{"tiddlers":{"$:/plugins/linonetwo/flowtiwi-sidebar/flowtiwi-sidebar.css":{"title":"$:/plugins/linonetwo/flowtiwi-sidebar/flowtiwi-sidebar.css","text":".react-grid-layout{position:relative;transition:height .2s}.react-grid-item{transition:left .2s,top .2s}.react-grid-item img{pointer-events:none;user-select:none}.react-grid-item.cssTransforms{transition-property:transform}.react-grid-item.resizing{z-index:1;will-change:width,height}.react-grid-item.react-draggable-dragging{transition:none;z-index:3;will-change:transform}.react-grid-item.dropping{visibility:hidden}.react-grid-item.react-grid-placeholder{background:red;opacity:.2;transition-duration:.1s;z-index:2;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none}.react-grid-item>.react-resizable-handle{position:absolute;width:20px;height:20px}.react-grid-item>.react-resizable-handle::after{content:\"\";position:absolute;right:3px;bottom:3px;width:5px;height:5px;border-right:2px solid rgba(0,0,0,.4);border-bottom:2px solid rgba(0,0,0,.4)}.react-resizable-hide>.react-resizable-handle{display:none}.react-grid-item>.react-resizable-handle.react-resizable-handle-sw{bottom:0;left:0;cursor:sw-resize;transform:rotate(90deg)}.react-grid-item>.react-resizable-handle.react-resizable-handle-se{bottom:0;right:0;cursor:se-resize}.react-grid-item>.react-resizable-handle.react-resizable-handle-nw{top:0;left:0;cursor:nw-resize;transform:rotate(180deg)}.react-grid-item>.react-resizable-handle.react-resizable-handle-ne{top:0;right:0;cursor:ne-resize;transform:rotate(270deg)}.react-grid-item>.react-resizable-handle.react-resizable-handle-e,.react-grid-item>.react-resizable-handle.react-resizable-handle-w{top:50%;margin-top:-10px;cursor:ew-resize}.react-grid-item>.react-resizable-handle.react-resizable-handle-w{left:0;transform:rotate(135deg)}.react-grid-item>.react-resizable-handle.react-resizable-handle-e{right:0;transform:rotate(315deg)}.react-grid-item>.react-resizable-handle.react-resizable-handle-n,.react-grid-item>.react-resizable-handle.react-resizable-handle-s{left:50%;margin-left:-10px;cursor:ns-resize}.react-grid-item>.react-resizable-handle.react-resizable-handle-n{top:0;transform:rotate(225deg)}.react-grid-item>.react-resizable-handle.react-resizable-handle-s{bottom:0;transform:rotate(45deg)}.react-resizable{position:relative}.react-resizable-handle{position:absolute;width:20px;height:20px;background-repeat:no-repeat;background-origin:content-box;box-sizing:border-box;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2IDYiIHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOiNmZmZmZmYwMCIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSI2cHgiIGhlaWdodD0iNnB4Ij48ZyBvcGFjaXR5PSIwLjMwMiI+PHBhdGggZD0iTSA2IDYgTCAwIDYgTCAwIDQuMiBMIDQgNC4yIEwgNC4yIDQuMiBMIDQuMiAwIEwgNiAwIEwgNiA2IEwgNiA2IFoiIGZpbGw9IiMwMDAwMDAiLz48L2c+PC9zdmc+);background-position:bottom right;padding:0 3px 3px 0}.react-resizable-handle-sw{bottom:0;left:0;cursor:sw-resize;transform:rotate(90deg)}.react-resizable-handle-se{bottom:0;right:0;cursor:se-resize}.react-resizable-handle-nw{top:0;left:0;cursor:nw-resize;transform:rotate(180deg)}.react-resizable-handle-ne{top:0;right:0;cursor:ne-resize;transform:rotate(270deg)}.react-resizable-handle-e,.react-resizable-handle-w{top:50%;margin-top:-10px;cursor:ew-resize}.react-resizable-handle-w{left:0;transform:rotate(135deg)}.react-resizable-handle-e{right:0;transform:rotate(315deg)}.react-resizable-handle-n,.react-resizable-handle-s{left:50%;margin-left:-10px;cursor:ns-resize}.react-resizable-handle-n{top:0;transform:rotate(225deg)}.react-resizable-handle-s{bottom:0;transform:rotate(45deg)}.flowtiwi-sidebar-tab-content{height:calc(100% - 1.5em);overflow:hidden;padding-left:5px}.flowtiwi-sidebar-tab-content:hover{overflow:auto;overflow:overlay}.tc-sidebar-header .tc-sidebar-lists p{margin:0}.flowtiwi-sidebar-tab-content>div,.flowtiwi-sidebar-tab-content>div>div,.flowtiwi-sidebar-tab-content>div>div>p{height:100%;margin:0;padding:0}.flowtiwi-sidebar-tab-handle{user-select:none;cursor:grabbing;text-overflow:ellipsis;height:1.5em;white-space:nowrap;overflow:hidden;padding-left:5px}.flowtiwi-sidebar-tab-handle-title{cursor:pointer}","tags":"$:/tags/Stylesheet","type":"text/css"},"$:/plugins/linonetwo/flowtiwi-sidebar/flowtiwi-sidebar.js":{"title":"$:/plugins/linonetwo/flowtiwi-sidebar/flowtiwi-sidebar.js","text":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target, mod));\n\n// node_modules/lodash/isObject.js\nvar require_isObject = __commonJS({\n  \"node_modules/lodash/isObject.js\"(exports2, module2) {\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == \"object\" || type == \"function\");\n    }\n    module2.exports = isObject;\n  }\n});\n\n// node_modules/lodash/_freeGlobal.js\nvar require_freeGlobal = __commonJS({\n  \"node_modules/lodash/_freeGlobal.js\"(exports2, module2) {\n    var freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\n    module2.exports = freeGlobal;\n  }\n});\n\n// node_modules/lodash/_root.js\nvar require_root = __commonJS({\n  \"node_modules/lodash/_root.js\"(exports2, module2) {\n    var freeGlobal = require_freeGlobal();\n    var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n    var root = freeGlobal || freeSelf || Function(\"return this\")();\n    module2.exports = root;\n  }\n});\n\n// node_modules/lodash/now.js\nvar require_now = __commonJS({\n  \"node_modules/lodash/now.js\"(exports2, module2) {\n    var root = require_root();\n    var now = function() {\n      return root.Date.now();\n    };\n    module2.exports = now;\n  }\n});\n\n// node_modules/lodash/_trimmedEndIndex.js\nvar require_trimmedEndIndex = __commonJS({\n  \"node_modules/lodash/_trimmedEndIndex.js\"(exports2, module2) {\n    var reWhitespace = /\\s/;\n    function trimmedEndIndex(string) {\n      var index = string.length;\n      while (index-- && reWhitespace.test(string.charAt(index))) {\n      }\n      return index;\n    }\n    module2.exports = trimmedEndIndex;\n  }\n});\n\n// node_modules/lodash/_baseTrim.js\nvar require_baseTrim = __commonJS({\n  \"node_modules/lodash/_baseTrim.js\"(exports2, module2) {\n    var trimmedEndIndex = require_trimmedEndIndex();\n    var reTrimStart = /^\\s+/;\n    function baseTrim(string) {\n      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, \"\") : string;\n    }\n    module2.exports = baseTrim;\n  }\n});\n\n// node_modules/lodash/_Symbol.js\nvar require_Symbol = __commonJS({\n  \"node_modules/lodash/_Symbol.js\"(exports2, module2) {\n    var root = require_root();\n    var Symbol2 = root.Symbol;\n    module2.exports = Symbol2;\n  }\n});\n\n// node_modules/lodash/_getRawTag.js\nvar require_getRawTag = __commonJS({\n  \"node_modules/lodash/_getRawTag.js\"(exports2, module2) {\n    var Symbol2 = require_Symbol();\n    var objectProto = Object.prototype;\n    var hasOwnProperty = objectProto.hasOwnProperty;\n    var nativeObjectToString = objectProto.toString;\n    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];\n      try {\n        value[symToStringTag] = void 0;\n        var unmasked = true;\n      } catch (e) {\n      }\n      var result = nativeObjectToString.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag] = tag;\n        } else {\n          delete value[symToStringTag];\n        }\n      }\n      return result;\n    }\n    module2.exports = getRawTag;\n  }\n});\n\n// node_modules/lodash/_objectToString.js\nvar require_objectToString = __commonJS({\n  \"node_modules/lodash/_objectToString.js\"(exports2, module2) {\n    var objectProto = Object.prototype;\n    var nativeObjectToString = objectProto.toString;\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n    module2.exports = objectToString;\n  }\n});\n\n// node_modules/lodash/_baseGetTag.js\nvar require_baseGetTag = __commonJS({\n  \"node_modules/lodash/_baseGetTag.js\"(exports2, module2) {\n    var Symbol2 = require_Symbol();\n    var getRawTag = require_getRawTag();\n    var objectToString = require_objectToString();\n    var nullTag = \"[object Null]\";\n    var undefinedTag = \"[object Undefined]\";\n    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === void 0 ? undefinedTag : nullTag;\n      }\n      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n    }\n    module2.exports = baseGetTag;\n  }\n});\n\n// node_modules/lodash/isObjectLike.js\nvar require_isObjectLike = __commonJS({\n  \"node_modules/lodash/isObjectLike.js\"(exports2, module2) {\n    function isObjectLike(value) {\n      return value != null && typeof value == \"object\";\n    }\n    module2.exports = isObjectLike;\n  }\n});\n\n// node_modules/lodash/isSymbol.js\nvar require_isSymbol = __commonJS({\n  \"node_modules/lodash/isSymbol.js\"(exports2, module2) {\n    var baseGetTag = require_baseGetTag();\n    var isObjectLike = require_isObjectLike();\n    var symbolTag = \"[object Symbol]\";\n    function isSymbol(value) {\n      return typeof value == \"symbol\" || isObjectLike(value) && baseGetTag(value) == symbolTag;\n    }\n    module2.exports = isSymbol;\n  }\n});\n\n// node_modules/lodash/toNumber.js\nvar require_toNumber = __commonJS({\n  \"node_modules/lodash/toNumber.js\"(exports2, module2) {\n    var baseTrim = require_baseTrim();\n    var isObject = require_isObject();\n    var isSymbol = require_isSymbol();\n    var NAN = 0 / 0;\n    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n    var reIsBinary = /^0b[01]+$/i;\n    var reIsOctal = /^0o[0-7]+$/i;\n    var freeParseInt = parseInt;\n    function toNumber(value) {\n      if (typeof value == \"number\") {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n        value = isObject(other) ? other + \"\" : other;\n      }\n      if (typeof value != \"string\") {\n        return value === 0 ? value : +value;\n      }\n      value = baseTrim(value);\n      var isBinary = reIsBinary.test(value);\n      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n    }\n    module2.exports = toNumber;\n  }\n});\n\n// node_modules/lodash/debounce.js\nvar require_debounce = __commonJS({\n  \"node_modules/lodash/debounce.js\"(exports2, module2) {\n    var isObject = require_isObject();\n    var now = require_now();\n    var toNumber = require_toNumber();\n    var FUNC_ERROR_TEXT = \"Expected a function\";\n    var nativeMax = Math.max;\n    var nativeMin = Math.min;\n    function debounce4(func, wait, options) {\n      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n      if (typeof func != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = \"maxWait\" in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n      }\n      function invokeFunc(time) {\n        var args = lastArgs, thisArg = lastThis;\n        lastArgs = lastThis = void 0;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n      function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = setTimeout(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n      }\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;\n        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n      }\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n      }\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n      function trailingEdge(time) {\n        timerId = void 0;\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = void 0;\n        return result;\n      }\n      function cancel() {\n        if (timerId !== void 0) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = void 0;\n      }\n      function flush() {\n        return timerId === void 0 ? result : trailingEdge(now());\n      }\n      function debounced() {\n        var time = now(), isInvoking = shouldInvoke(time);\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n          if (timerId === void 0) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            clearTimeout(timerId);\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === void 0) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n    module2.exports = debounce4;\n  }\n});\n\n// node_modules/tw-react/dist/plugins/linonetwo/tw-react/index.js\nvar require_tw_react = __commonJS({\n  \"node_modules/tw-react/dist/plugins/linonetwo/tw-react/index.js\"(exports2, module2) {\n    var __defProp2 = Object.defineProperty;\n    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;\n    var __getOwnPropNames2 = Object.getOwnPropertyNames;\n    var __hasOwnProp2 = Object.prototype.hasOwnProperty;\n    var __export = (target, all) => {\n      for (var name in all)\n        __defProp2(target, name, { get: all[name], enumerable: true });\n    };\n    var __copyProps2 = (to, from, except, desc) => {\n      if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames2(from))\n          if (!__hasOwnProp2.call(to, key) && key !== except)\n            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });\n      }\n      return to;\n    };\n    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, \"__esModule\", { value: true }), mod);\n    var src_exports = {};\n    __export(src_exports, {\n      ParentWidgetContext: () => ParentWidgetContext2,\n      useFilter: () => useFilter2,\n      useRenderTiddler: () => useRenderTiddler2,\n      useWidget: () => useWidget\n    });\n    module2.exports = __toCommonJS(src_exports);\n    var import_react35 = require(\"react\");\n    function useFilter2(twFilter, dependencies = []) {\n      const [filterResult, setFilterResult] = (0, import_react35.useState)([]);\n      const compiledFilter = (0, import_react35.useMemo)(() => $tw.wiki.compileFilter(twFilter), [twFilter]);\n      (0, import_react35.useEffect)(() => {\n        setFilterResult(compiledFilter());\n      }, [compiledFilter, ...dependencies]);\n      return filterResult;\n    }\n    var import_react36 = require(\"react\");\n    var import_react210 = require(\"react\");\n    var ParentWidgetContext2 = (0, import_react210.createContext)(void 0);\n    function useRenderTiddler2(tiddlerTitle, containerRef) {\n      const parentWidget = (0, import_react36.useContext)(ParentWidgetContext2);\n      (0, import_react36.useEffect)(() => {\n        if (containerRef.current === null || parentWidget === void 0) {\n          return;\n        }\n        const transcludeWidgetNode = $tw.wiki.makeTranscludeWidget(tiddlerTitle, {\n          document,\n          parentWidget,\n          recursionMarker: \"yes\",\n          mode: \"block\",\n          importPageMacros: true\n        });\n        const tiddlerContainer = document.createElement(\"div\");\n        containerRef.current.append(tiddlerContainer);\n        transcludeWidgetNode.render(tiddlerContainer, null);\n        parentWidget.children.push(transcludeWidgetNode);\n      }, [tiddlerTitle, containerRef.current]);\n    }\n    var import_react42 = require(\"react\");\n    function useWidget(parseTreeNode, containerRef) {\n      const parentWidget = (0, import_react42.useContext)(ParentWidgetContext2);\n      (0, import_react42.useEffect)(() => {\n        if (containerRef.current === null) {\n          return;\n        }\n        if (parentWidget === void 0) {\n          throw new Error(\"Your plugin have a bug: `parentWidget` is undefined, you should use `<ParentWidgetContext.Provider value={props.parentWidget}>`, see tw-react for document.\");\n        }\n        const newWidgetNode = parentWidget.makeChildWidget(parseTreeNode, {});\n        newWidgetNode.render(containerRef.current, null);\n        parentWidget.children.push(newWidgetNode);\n      }, [parseTreeNode, containerRef.current]);\n    }\n  }\n});\n\n// node_modules/invariant/browser.js\nvar require_browser = __commonJS({\n  \"node_modules/invariant/browser.js\"(exports2, module2) {\n    \"use strict\";\n    var invariant = function(condition, format, a, b, c, d, e, f) {\n      if (true) {\n        if (format === void 0) {\n          throw new Error(\"invariant requires an error message argument\");\n        }\n      }\n      if (!condition) {\n        var error;\n        if (format === void 0) {\n          error = new Error(\"Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.\");\n        } else {\n          var args = [a, b, c, d, e, f];\n          var argIndex = 0;\n          error = new Error(format.replace(/%s/g, function() {\n            return args[argIndex++];\n          }));\n          error.name = \"Invariant Violation\";\n        }\n        error.framesToPop = 1;\n        throw error;\n      }\n    };\n    module2.exports = invariant;\n  }\n});\n\n// node_modules/throttle-debounce/cjs/index.js\nvar require_cjs = __commonJS({\n  \"node_modules/throttle-debounce/cjs/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    function throttle2(delay, noTrailing, callback, debounceMode) {\n      var timeoutID;\n      var cancelled = false;\n      var lastExec = 0;\n      function clearExistingTimeout() {\n        if (timeoutID) {\n          clearTimeout(timeoutID);\n        }\n      }\n      function cancel() {\n        clearExistingTimeout();\n        cancelled = true;\n      }\n      if (typeof noTrailing !== \"boolean\") {\n        debounceMode = callback;\n        callback = noTrailing;\n        noTrailing = void 0;\n      }\n      function wrapper() {\n        for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\n          arguments_[_key] = arguments[_key];\n        }\n        var self2 = this;\n        var elapsed = Date.now() - lastExec;\n        if (cancelled) {\n          return;\n        }\n        function exec() {\n          lastExec = Date.now();\n          callback.apply(self2, arguments_);\n        }\n        function clear() {\n          timeoutID = void 0;\n        }\n        if (debounceMode && !timeoutID) {\n          exec();\n        }\n        clearExistingTimeout();\n        if (debounceMode === void 0 && elapsed > delay) {\n          exec();\n        } else if (noTrailing !== true) {\n          timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);\n        }\n      }\n      wrapper.cancel = cancel;\n      return wrapper;\n    }\n    function debounce4(delay, atBegin, callback) {\n      return callback === void 0 ? throttle2(delay, atBegin, false) : throttle2(delay, callback, atBegin !== false);\n    }\n    exports2.debounce = debounce4;\n    exports2.throttle = throttle2;\n  }\n});\n\n// node_modules/element-resize-detector/src/collection-utils.js\nvar require_collection_utils = __commonJS({\n  \"node_modules/element-resize-detector/src/collection-utils.js\"(exports2, module2) {\n    \"use strict\";\n    var utils = module2.exports = {};\n    utils.forEach = function(collection, callback) {\n      for (var i = 0; i < collection.length; i++) {\n        var result = callback(collection[i]);\n        if (result) {\n          return result;\n        }\n      }\n    };\n  }\n});\n\n// node_modules/element-resize-detector/src/element-utils.js\nvar require_element_utils = __commonJS({\n  \"node_modules/element-resize-detector/src/element-utils.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = function(options) {\n      var getState = options.stateHandler.getState;\n      function isDetectable(element) {\n        var state = getState(element);\n        return state && !!state.isDetectable;\n      }\n      function markAsDetectable(element) {\n        getState(element).isDetectable = true;\n      }\n      function isBusy(element) {\n        return !!getState(element).busy;\n      }\n      function markBusy(element, busy) {\n        getState(element).busy = !!busy;\n      }\n      return {\n        isDetectable,\n        markAsDetectable,\n        isBusy,\n        markBusy\n      };\n    };\n  }\n});\n\n// node_modules/element-resize-detector/src/listener-handler.js\nvar require_listener_handler = __commonJS({\n  \"node_modules/element-resize-detector/src/listener-handler.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = function(idHandler) {\n      var eventListeners = {};\n      function getListeners(element) {\n        var id = idHandler.get(element);\n        if (id === void 0) {\n          return [];\n        }\n        return eventListeners[id] || [];\n      }\n      function addListener(element, listener) {\n        var id = idHandler.get(element);\n        if (!eventListeners[id]) {\n          eventListeners[id] = [];\n        }\n        eventListeners[id].push(listener);\n      }\n      function removeListener(element, listener) {\n        var listeners = getListeners(element);\n        for (var i = 0, len = listeners.length; i < len; ++i) {\n          if (listeners[i] === listener) {\n            listeners.splice(i, 1);\n            break;\n          }\n        }\n      }\n      function removeAllListeners(element) {\n        var listeners = getListeners(element);\n        if (!listeners) {\n          return;\n        }\n        listeners.length = 0;\n      }\n      return {\n        get: getListeners,\n        add: addListener,\n        removeListener,\n        removeAllListeners\n      };\n    };\n  }\n});\n\n// node_modules/element-resize-detector/src/id-generator.js\nvar require_id_generator = __commonJS({\n  \"node_modules/element-resize-detector/src/id-generator.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = function() {\n      var idCount = 1;\n      function generate() {\n        return idCount++;\n      }\n      return {\n        generate\n      };\n    };\n  }\n});\n\n// node_modules/element-resize-detector/src/id-handler.js\nvar require_id_handler = __commonJS({\n  \"node_modules/element-resize-detector/src/id-handler.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = function(options) {\n      var idGenerator = options.idGenerator;\n      var getState = options.stateHandler.getState;\n      function getId(element) {\n        var state = getState(element);\n        if (state && state.id !== void 0) {\n          return state.id;\n        }\n        return null;\n      }\n      function setId(element) {\n        var state = getState(element);\n        if (!state) {\n          throw new Error(\"setId required the element to have a resize detection state.\");\n        }\n        var id = idGenerator.generate();\n        state.id = id;\n        return id;\n      }\n      return {\n        get: getId,\n        set: setId\n      };\n    };\n  }\n});\n\n// node_modules/element-resize-detector/src/reporter.js\nvar require_reporter = __commonJS({\n  \"node_modules/element-resize-detector/src/reporter.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = function(quiet) {\n      function noop() {\n      }\n      var reporter = {\n        log: noop,\n        warn: noop,\n        error: noop\n      };\n      if (!quiet && window.console) {\n        var attachFunction = function(reporter2, name) {\n          reporter2[name] = function reporterProxy() {\n            var f = console[name];\n            if (f.apply) {\n              f.apply(console, arguments);\n            } else {\n              for (var i = 0; i < arguments.length; i++) {\n                f(arguments[i]);\n              }\n            }\n          };\n        };\n        attachFunction(reporter, \"log\");\n        attachFunction(reporter, \"warn\");\n        attachFunction(reporter, \"error\");\n      }\n      return reporter;\n    };\n  }\n});\n\n// node_modules/element-resize-detector/src/browser-detector.js\nvar require_browser_detector = __commonJS({\n  \"node_modules/element-resize-detector/src/browser-detector.js\"(exports2, module2) {\n    \"use strict\";\n    var detector = module2.exports = {};\n    detector.isIE = function(version) {\n      function isAnyIeVersion() {\n        var agent = navigator.userAgent.toLowerCase();\n        return agent.indexOf(\"msie\") !== -1 || agent.indexOf(\"trident\") !== -1 || agent.indexOf(\" edge/\") !== -1;\n      }\n      if (!isAnyIeVersion()) {\n        return false;\n      }\n      if (!version) {\n        return true;\n      }\n      var ieVersion = function() {\n        var undef, v = 3, div = document.createElement(\"div\"), all = div.getElementsByTagName(\"i\");\n        do {\n          div.innerHTML = \"<!--[if gt IE \" + ++v + \"]><i></i><![endif]-->\";\n        } while (all[0]);\n        return v > 4 ? v : undef;\n      }();\n      return version === ieVersion;\n    };\n    detector.isLegacyOpera = function() {\n      return !!window.opera;\n    };\n  }\n});\n\n// node_modules/batch-processor/src/utils.js\nvar require_utils = __commonJS({\n  \"node_modules/batch-processor/src/utils.js\"(exports2, module2) {\n    \"use strict\";\n    var utils = module2.exports = {};\n    utils.getOption = getOption;\n    function getOption(options, name, defaultValue) {\n      var value = options[name];\n      if ((value === void 0 || value === null) && defaultValue !== void 0) {\n        return defaultValue;\n      }\n      return value;\n    }\n  }\n});\n\n// node_modules/batch-processor/src/batch-processor.js\nvar require_batch_processor = __commonJS({\n  \"node_modules/batch-processor/src/batch-processor.js\"(exports2, module2) {\n    \"use strict\";\n    var utils = require_utils();\n    module2.exports = function batchProcessorMaker(options) {\n      options = options || {};\n      var reporter = options.reporter;\n      var asyncProcess = utils.getOption(options, \"async\", true);\n      var autoProcess = utils.getOption(options, \"auto\", true);\n      if (autoProcess && !asyncProcess) {\n        reporter && reporter.warn(\"Invalid options combination. auto=true and async=false is invalid. Setting async=true.\");\n        asyncProcess = true;\n      }\n      var batch = Batch();\n      var asyncFrameHandler;\n      var isProcessing = false;\n      function addFunction(level, fn) {\n        if (!isProcessing && autoProcess && asyncProcess && batch.size() === 0) {\n          processBatchAsync();\n        }\n        batch.add(level, fn);\n      }\n      function processBatch() {\n        isProcessing = true;\n        while (batch.size()) {\n          var processingBatch = batch;\n          batch = Batch();\n          processingBatch.process();\n        }\n        isProcessing = false;\n      }\n      function forceProcessBatch(localAsyncProcess) {\n        if (isProcessing) {\n          return;\n        }\n        if (localAsyncProcess === void 0) {\n          localAsyncProcess = asyncProcess;\n        }\n        if (asyncFrameHandler) {\n          cancelFrame(asyncFrameHandler);\n          asyncFrameHandler = null;\n        }\n        if (localAsyncProcess) {\n          processBatchAsync();\n        } else {\n          processBatch();\n        }\n      }\n      function processBatchAsync() {\n        asyncFrameHandler = requestFrame(processBatch);\n      }\n      function clearBatch() {\n        batch = {};\n        batchSize = 0;\n        topLevel = 0;\n        bottomLevel = 0;\n      }\n      function cancelFrame(listener) {\n        var cancel = clearTimeout;\n        return cancel(listener);\n      }\n      function requestFrame(callback) {\n        var raf = function(fn) {\n          return setTimeout(fn, 0);\n        };\n        return raf(callback);\n      }\n      return {\n        add: addFunction,\n        force: forceProcessBatch\n      };\n    };\n    function Batch() {\n      var batch = {};\n      var size = 0;\n      var topLevel2 = 0;\n      var bottomLevel2 = 0;\n      function add(level, fn) {\n        if (!fn) {\n          fn = level;\n          level = 0;\n        }\n        if (level > topLevel2) {\n          topLevel2 = level;\n        } else if (level < bottomLevel2) {\n          bottomLevel2 = level;\n        }\n        if (!batch[level]) {\n          batch[level] = [];\n        }\n        batch[level].push(fn);\n        size++;\n      }\n      function process2() {\n        for (var level = bottomLevel2; level <= topLevel2; level++) {\n          var fns = batch[level];\n          for (var i = 0; i < fns.length; i++) {\n            var fn = fns[i];\n            fn();\n          }\n        }\n      }\n      function getSize() {\n        return size;\n      }\n      return {\n        add,\n        process: process2,\n        size: getSize\n      };\n    }\n  }\n});\n\n// node_modules/element-resize-detector/src/state-handler.js\nvar require_state_handler = __commonJS({\n  \"node_modules/element-resize-detector/src/state-handler.js\"(exports2, module2) {\n    \"use strict\";\n    var prop = \"_erd\";\n    function initState(element) {\n      element[prop] = {};\n      return getState(element);\n    }\n    function getState(element) {\n      return element[prop];\n    }\n    function cleanState(element) {\n      delete element[prop];\n    }\n    module2.exports = {\n      initState,\n      getState,\n      cleanState\n    };\n  }\n});\n\n// node_modules/element-resize-detector/src/detection-strategy/object.js\nvar require_object = __commonJS({\n  \"node_modules/element-resize-detector/src/detection-strategy/object.js\"(exports2, module2) {\n    \"use strict\";\n    var browserDetector = require_browser_detector();\n    module2.exports = function(options) {\n      options = options || {};\n      var reporter = options.reporter;\n      var batchProcessor = options.batchProcessor;\n      var getState = options.stateHandler.getState;\n      if (!reporter) {\n        throw new Error(\"Missing required dependency: reporter.\");\n      }\n      function addListener(element, listener) {\n        function listenerProxy() {\n          listener(element);\n        }\n        if (browserDetector.isIE(8)) {\n          getState(element).object = {\n            proxy: listenerProxy\n          };\n          element.attachEvent(\"onresize\", listenerProxy);\n        } else {\n          var object = getObject(element);\n          if (!object) {\n            throw new Error(\"Element is not detectable by this strategy.\");\n          }\n          object.contentDocument.defaultView.addEventListener(\"resize\", listenerProxy);\n        }\n      }\n      function buildCssTextString(rules) {\n        var seperator = options.important ? \" !important; \" : \"; \";\n        return (rules.join(seperator) + seperator).trim();\n      }\n      function makeDetectable(options2, element, callback) {\n        if (!callback) {\n          callback = element;\n          element = options2;\n          options2 = null;\n        }\n        options2 = options2 || {};\n        var debug = options2.debug;\n        function injectObject(element2, callback2) {\n          var OBJECT_STYLE = buildCssTextString([\"display: block\", \"position: absolute\", \"top: 0\", \"left: 0\", \"width: 100%\", \"height: 100%\", \"border: none\", \"padding: 0\", \"margin: 0\", \"opacity: 0\", \"z-index: -1000\", \"pointer-events: none\"]);\n          var positionCheckPerformed = false;\n          var style = window.getComputedStyle(element2);\n          var width = element2.offsetWidth;\n          var height = element2.offsetHeight;\n          getState(element2).startSize = {\n            width,\n            height\n          };\n          function mutateDom() {\n            function alterPositionStyles() {\n              if (style.position === \"static\") {\n                element2.style.setProperty(\"position\", \"relative\", options2.important ? \"important\" : \"\");\n                var removeRelativeStyles = function(reporter2, element3, style2, property) {\n                  function getNumericalValue(value2) {\n                    return value2.replace(/[^-\\d\\.]/g, \"\");\n                  }\n                  var value = style2[property];\n                  if (value !== \"auto\" && getNumericalValue(value) !== \"0\") {\n                    reporter2.warn(\"An element that is positioned static has style.\" + property + \"=\" + value + \" which is ignored due to the static positioning. The element will need to be positioned relative, so the style.\" + property + \" will be set to 0. Element: \", element3);\n                    element3.style.setProperty(property, \"0\", options2.important ? \"important\" : \"\");\n                  }\n                };\n                removeRelativeStyles(reporter, element2, style, \"top\");\n                removeRelativeStyles(reporter, element2, style, \"right\");\n                removeRelativeStyles(reporter, element2, style, \"bottom\");\n                removeRelativeStyles(reporter, element2, style, \"left\");\n              }\n            }\n            function onObjectLoad() {\n              if (!positionCheckPerformed) {\n                alterPositionStyles();\n              }\n              function getDocument(element3, callback3) {\n                if (!element3.contentDocument) {\n                  var state = getState(element3);\n                  if (state.checkForObjectDocumentTimeoutId) {\n                    window.clearTimeout(state.checkForObjectDocumentTimeoutId);\n                  }\n                  state.checkForObjectDocumentTimeoutId = setTimeout(function checkForObjectDocument() {\n                    state.checkForObjectDocumentTimeoutId = 0;\n                    getDocument(element3, callback3);\n                  }, 100);\n                  return;\n                }\n                callback3(element3.contentDocument);\n              }\n              var objectElement = this;\n              getDocument(objectElement, function onObjectDocumentReady(objectDocument) {\n                callback2(element2);\n              });\n            }\n            if (style.position !== \"\") {\n              alterPositionStyles(style);\n              positionCheckPerformed = true;\n            }\n            var object = document.createElement(\"object\");\n            object.style.cssText = OBJECT_STYLE;\n            object.tabIndex = -1;\n            object.type = \"text/html\";\n            object.setAttribute(\"aria-hidden\", \"true\");\n            object.onload = onObjectLoad;\n            if (!browserDetector.isIE()) {\n              object.data = \"about:blank\";\n            }\n            if (!getState(element2)) {\n              return;\n            }\n            element2.appendChild(object);\n            getState(element2).object = object;\n            if (browserDetector.isIE()) {\n              object.data = \"about:blank\";\n            }\n          }\n          if (batchProcessor) {\n            batchProcessor.add(mutateDom);\n          } else {\n            mutateDom();\n          }\n        }\n        if (browserDetector.isIE(8)) {\n          callback(element);\n        } else {\n          injectObject(element, callback);\n        }\n      }\n      function getObject(element) {\n        return getState(element).object;\n      }\n      function uninstall(element) {\n        if (!getState(element)) {\n          return;\n        }\n        var object = getObject(element);\n        if (!object) {\n          return;\n        }\n        if (browserDetector.isIE(8)) {\n          element.detachEvent(\"onresize\", object.proxy);\n        } else {\n          element.removeChild(object);\n        }\n        if (getState(element).checkForObjectDocumentTimeoutId) {\n          window.clearTimeout(getState(element).checkForObjectDocumentTimeoutId);\n        }\n        delete getState(element).object;\n      }\n      return {\n        makeDetectable,\n        addListener,\n        uninstall\n      };\n    };\n  }\n});\n\n// node_modules/element-resize-detector/src/detection-strategy/scroll.js\nvar require_scroll = __commonJS({\n  \"node_modules/element-resize-detector/src/detection-strategy/scroll.js\"(exports2, module2) {\n    \"use strict\";\n    var forEach = require_collection_utils().forEach;\n    module2.exports = function(options) {\n      options = options || {};\n      var reporter = options.reporter;\n      var batchProcessor = options.batchProcessor;\n      var getState = options.stateHandler.getState;\n      var hasState = options.stateHandler.hasState;\n      var idHandler = options.idHandler;\n      if (!batchProcessor) {\n        throw new Error(\"Missing required dependency: batchProcessor\");\n      }\n      if (!reporter) {\n        throw new Error(\"Missing required dependency: reporter.\");\n      }\n      var scrollbarSizes = getScrollbarSizes();\n      var styleId = \"erd_scroll_detection_scrollbar_style\";\n      var detectionContainerClass = \"erd_scroll_detection_container\";\n      function initDocument(targetDocument) {\n        injectScrollStyle(targetDocument, styleId, detectionContainerClass);\n      }\n      initDocument(window.document);\n      function buildCssTextString(rules) {\n        var seperator = options.important ? \" !important; \" : \"; \";\n        return (rules.join(seperator) + seperator).trim();\n      }\n      function getScrollbarSizes() {\n        var width = 500;\n        var height = 500;\n        var child = document.createElement(\"div\");\n        child.style.cssText = buildCssTextString([\"position: absolute\", \"width: \" + width * 2 + \"px\", \"height: \" + height * 2 + \"px\", \"visibility: hidden\", \"margin: 0\", \"padding: 0\"]);\n        var container = document.createElement(\"div\");\n        container.style.cssText = buildCssTextString([\"position: absolute\", \"width: \" + width + \"px\", \"height: \" + height + \"px\", \"overflow: scroll\", \"visibility: none\", \"top: \" + -width * 3 + \"px\", \"left: \" + -height * 3 + \"px\", \"visibility: hidden\", \"margin: 0\", \"padding: 0\"]);\n        container.appendChild(child);\n        document.body.insertBefore(container, document.body.firstChild);\n        var widthSize = width - container.clientWidth;\n        var heightSize = height - container.clientHeight;\n        document.body.removeChild(container);\n        return {\n          width: widthSize,\n          height: heightSize\n        };\n      }\n      function injectScrollStyle(targetDocument, styleId2, containerClass) {\n        function injectStyle(style2, method) {\n          method = method || function(element) {\n            targetDocument.head.appendChild(element);\n          };\n          var styleElement = targetDocument.createElement(\"style\");\n          styleElement.innerHTML = style2;\n          styleElement.id = styleId2;\n          method(styleElement);\n          return styleElement;\n        }\n        if (!targetDocument.getElementById(styleId2)) {\n          var containerAnimationClass = containerClass + \"_animation\";\n          var containerAnimationActiveClass = containerClass + \"_animation_active\";\n          var style = \"/* Created by the element-resize-detector library. */\\n\";\n          style += \".\" + containerClass + \" > div::-webkit-scrollbar { \" + buildCssTextString([\"display: none\"]) + \" }\\n\\n\";\n          style += \".\" + containerAnimationActiveClass + \" { \" + buildCssTextString([\"-webkit-animation-duration: 0.1s\", \"animation-duration: 0.1s\", \"-webkit-animation-name: \" + containerAnimationClass, \"animation-name: \" + containerAnimationClass]) + \" }\\n\";\n          style += \"@-webkit-keyframes \" + containerAnimationClass + \" { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }\\n\";\n          style += \"@keyframes \" + containerAnimationClass + \" { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }\";\n          injectStyle(style);\n        }\n      }\n      function addAnimationClass(element) {\n        element.className += \" \" + detectionContainerClass + \"_animation_active\";\n      }\n      function addEvent(el, name, cb) {\n        if (el.addEventListener) {\n          el.addEventListener(name, cb);\n        } else if (el.attachEvent) {\n          el.attachEvent(\"on\" + name, cb);\n        } else {\n          return reporter.error(\"[scroll] Don't know how to add event listeners.\");\n        }\n      }\n      function removeEvent(el, name, cb) {\n        if (el.removeEventListener) {\n          el.removeEventListener(name, cb);\n        } else if (el.detachEvent) {\n          el.detachEvent(\"on\" + name, cb);\n        } else {\n          return reporter.error(\"[scroll] Don't know how to remove event listeners.\");\n        }\n      }\n      function getExpandElement(element) {\n        return getState(element).container.childNodes[0].childNodes[0].childNodes[0];\n      }\n      function getShrinkElement(element) {\n        return getState(element).container.childNodes[0].childNodes[0].childNodes[1];\n      }\n      function addListener(element, listener) {\n        var listeners = getState(element).listeners;\n        if (!listeners.push) {\n          throw new Error(\"Cannot add listener to an element that is not detectable.\");\n        }\n        getState(element).listeners.push(listener);\n      }\n      function makeDetectable(options2, element, callback) {\n        if (!callback) {\n          callback = element;\n          element = options2;\n          options2 = null;\n        }\n        options2 = options2 || {};\n        function debug() {\n          if (options2.debug) {\n            var args = Array.prototype.slice.call(arguments);\n            args.unshift(idHandler.get(element), \"Scroll: \");\n            if (reporter.log.apply) {\n              reporter.log.apply(null, args);\n            } else {\n              for (var i = 0; i < args.length; i++) {\n                reporter.log(args[i]);\n              }\n            }\n          }\n        }\n        function isDetached(element2) {\n          function isInDocument(element3) {\n            var isInShadowRoot = element3.getRootNode && element3.getRootNode().contains(element3);\n            return element3 === element3.ownerDocument.body || element3.ownerDocument.body.contains(element3) || isInShadowRoot;\n          }\n          if (!isInDocument(element2)) {\n            return true;\n          }\n          if (window.getComputedStyle(element2) === null) {\n            return true;\n          }\n          return false;\n        }\n        function isUnrendered(element2) {\n          var container = getState(element2).container.childNodes[0];\n          var style = window.getComputedStyle(container);\n          return !style.width || style.width.indexOf(\"px\") === -1;\n        }\n        function getStyle() {\n          var elementStyle = window.getComputedStyle(element);\n          var style = {};\n          style.position = elementStyle.position;\n          style.width = element.offsetWidth;\n          style.height = element.offsetHeight;\n          style.top = elementStyle.top;\n          style.right = elementStyle.right;\n          style.bottom = elementStyle.bottom;\n          style.left = elementStyle.left;\n          style.widthCSS = elementStyle.width;\n          style.heightCSS = elementStyle.height;\n          return style;\n        }\n        function storeStartSize() {\n          var style = getStyle();\n          getState(element).startSize = {\n            width: style.width,\n            height: style.height\n          };\n          debug(\"Element start size\", getState(element).startSize);\n        }\n        function initListeners() {\n          getState(element).listeners = [];\n        }\n        function storeStyle() {\n          debug(\"storeStyle invoked.\");\n          if (!getState(element)) {\n            debug(\"Aborting because element has been uninstalled\");\n            return;\n          }\n          var style = getStyle();\n          getState(element).style = style;\n        }\n        function storeCurrentSize(element2, width, height) {\n          getState(element2).lastWidth = width;\n          getState(element2).lastHeight = height;\n        }\n        function getExpandChildElement(element2) {\n          return getExpandElement(element2).childNodes[0];\n        }\n        function getWidthOffset() {\n          return 2 * scrollbarSizes.width + 1;\n        }\n        function getHeightOffset() {\n          return 2 * scrollbarSizes.height + 1;\n        }\n        function getExpandWidth(width) {\n          return width + 10 + getWidthOffset();\n        }\n        function getExpandHeight(height) {\n          return height + 10 + getHeightOffset();\n        }\n        function getShrinkWidth(width) {\n          return width * 2 + getWidthOffset();\n        }\n        function getShrinkHeight(height) {\n          return height * 2 + getHeightOffset();\n        }\n        function positionScrollbars(element2, width, height) {\n          var expand = getExpandElement(element2);\n          var shrink = getShrinkElement(element2);\n          var expandWidth = getExpandWidth(width);\n          var expandHeight = getExpandHeight(height);\n          var shrinkWidth = getShrinkWidth(width);\n          var shrinkHeight = getShrinkHeight(height);\n          expand.scrollLeft = expandWidth;\n          expand.scrollTop = expandHeight;\n          shrink.scrollLeft = shrinkWidth;\n          shrink.scrollTop = shrinkHeight;\n        }\n        function injectContainerElement() {\n          var container = getState(element).container;\n          if (!container) {\n            container = document.createElement(\"div\");\n            container.className = detectionContainerClass;\n            container.style.cssText = buildCssTextString([\"visibility: hidden\", \"display: inline\", \"width: 0px\", \"height: 0px\", \"z-index: -1\", \"overflow: hidden\", \"margin: 0\", \"padding: 0\"]);\n            getState(element).container = container;\n            addAnimationClass(container);\n            element.appendChild(container);\n            var onAnimationStart = function() {\n              getState(element).onRendered && getState(element).onRendered();\n            };\n            addEvent(container, \"animationstart\", onAnimationStart);\n            getState(element).onAnimationStart = onAnimationStart;\n          }\n          return container;\n        }\n        function injectScrollElements() {\n          function alterPositionStyles() {\n            var style = getState(element).style;\n            if (style.position === \"static\") {\n              element.style.setProperty(\"position\", \"relative\", options2.important ? \"important\" : \"\");\n              var removeRelativeStyles = function(reporter2, element2, style2, property) {\n                function getNumericalValue(value2) {\n                  return value2.replace(/[^-\\d\\.]/g, \"\");\n                }\n                var value = style2[property];\n                if (value !== \"auto\" && getNumericalValue(value) !== \"0\") {\n                  reporter2.warn(\"An element that is positioned static has style.\" + property + \"=\" + value + \" which is ignored due to the static positioning. The element will need to be positioned relative, so the style.\" + property + \" will be set to 0. Element: \", element2);\n                  element2.style[property] = 0;\n                }\n              };\n              removeRelativeStyles(reporter, element, style, \"top\");\n              removeRelativeStyles(reporter, element, style, \"right\");\n              removeRelativeStyles(reporter, element, style, \"bottom\");\n              removeRelativeStyles(reporter, element, style, \"left\");\n            }\n          }\n          function getLeftTopBottomRightCssText(left, top, bottom, right) {\n            left = !left ? \"0\" : left + \"px\";\n            top = !top ? \"0\" : top + \"px\";\n            bottom = !bottom ? \"0\" : bottom + \"px\";\n            right = !right ? \"0\" : right + \"px\";\n            return [\"left: \" + left, \"top: \" + top, \"right: \" + right, \"bottom: \" + bottom];\n          }\n          debug(\"Injecting elements\");\n          if (!getState(element)) {\n            debug(\"Aborting because element has been uninstalled\");\n            return;\n          }\n          alterPositionStyles();\n          var rootContainer = getState(element).container;\n          if (!rootContainer) {\n            rootContainer = injectContainerElement();\n          }\n          var scrollbarWidth = scrollbarSizes.width;\n          var scrollbarHeight = scrollbarSizes.height;\n          var containerContainerStyle = buildCssTextString([\"position: absolute\", \"flex: none\", \"overflow: hidden\", \"z-index: -1\", \"visibility: hidden\", \"width: 100%\", \"height: 100%\", \"left: 0px\", \"top: 0px\"]);\n          var containerStyle = buildCssTextString([\"position: absolute\", \"flex: none\", \"overflow: hidden\", \"z-index: -1\", \"visibility: hidden\"].concat(getLeftTopBottomRightCssText(-(1 + scrollbarWidth), -(1 + scrollbarHeight), -scrollbarHeight, -scrollbarWidth)));\n          var expandStyle = buildCssTextString([\"position: absolute\", \"flex: none\", \"overflow: scroll\", \"z-index: -1\", \"visibility: hidden\", \"width: 100%\", \"height: 100%\"]);\n          var shrinkStyle = buildCssTextString([\"position: absolute\", \"flex: none\", \"overflow: scroll\", \"z-index: -1\", \"visibility: hidden\", \"width: 100%\", \"height: 100%\"]);\n          var expandChildStyle = buildCssTextString([\"position: absolute\", \"left: 0\", \"top: 0\"]);\n          var shrinkChildStyle = buildCssTextString([\"position: absolute\", \"width: 200%\", \"height: 200%\"]);\n          var containerContainer = document.createElement(\"div\");\n          var container = document.createElement(\"div\");\n          var expand = document.createElement(\"div\");\n          var expandChild = document.createElement(\"div\");\n          var shrink = document.createElement(\"div\");\n          var shrinkChild = document.createElement(\"div\");\n          containerContainer.dir = \"ltr\";\n          containerContainer.style.cssText = containerContainerStyle;\n          containerContainer.className = detectionContainerClass;\n          container.className = detectionContainerClass;\n          container.style.cssText = containerStyle;\n          expand.style.cssText = expandStyle;\n          expandChild.style.cssText = expandChildStyle;\n          shrink.style.cssText = shrinkStyle;\n          shrinkChild.style.cssText = shrinkChildStyle;\n          expand.appendChild(expandChild);\n          shrink.appendChild(shrinkChild);\n          container.appendChild(expand);\n          container.appendChild(shrink);\n          containerContainer.appendChild(container);\n          rootContainer.appendChild(containerContainer);\n          function onExpandScroll() {\n            var state = getState(element);\n            if (state && state.onExpand) {\n              state.onExpand();\n            } else {\n              debug(\"Aborting expand scroll handler: element has been uninstalled\");\n            }\n          }\n          function onShrinkScroll() {\n            var state = getState(element);\n            if (state && state.onShrink) {\n              state.onShrink();\n            } else {\n              debug(\"Aborting shrink scroll handler: element has been uninstalled\");\n            }\n          }\n          addEvent(expand, \"scroll\", onExpandScroll);\n          addEvent(shrink, \"scroll\", onShrinkScroll);\n          getState(element).onExpandScroll = onExpandScroll;\n          getState(element).onShrinkScroll = onShrinkScroll;\n        }\n        function registerListenersAndPositionElements() {\n          function updateChildSizes(element2, width, height) {\n            var expandChild = getExpandChildElement(element2);\n            var expandWidth = getExpandWidth(width);\n            var expandHeight = getExpandHeight(height);\n            expandChild.style.setProperty(\"width\", expandWidth + \"px\", options2.important ? \"important\" : \"\");\n            expandChild.style.setProperty(\"height\", expandHeight + \"px\", options2.important ? \"important\" : \"\");\n          }\n          function updateDetectorElements(done) {\n            var width = element.offsetWidth;\n            var height = element.offsetHeight;\n            var sizeChanged = width !== getState(element).lastWidth || height !== getState(element).lastHeight;\n            debug(\"Storing current size\", width, height);\n            storeCurrentSize(element, width, height);\n            batchProcessor.add(0, function performUpdateChildSizes() {\n              if (!sizeChanged) {\n                return;\n              }\n              if (!getState(element)) {\n                debug(\"Aborting because element has been uninstalled\");\n                return;\n              }\n              if (!areElementsInjected()) {\n                debug(\"Aborting because element container has not been initialized\");\n                return;\n              }\n              if (options2.debug) {\n                var w = element.offsetWidth;\n                var h = element.offsetHeight;\n                if (w !== width || h !== height) {\n                  reporter.warn(idHandler.get(element), \"Scroll: Size changed before updating detector elements.\");\n                }\n              }\n              updateChildSizes(element, width, height);\n            });\n            batchProcessor.add(1, function updateScrollbars() {\n              if (!getState(element)) {\n                debug(\"Aborting because element has been uninstalled\");\n                return;\n              }\n              if (!areElementsInjected()) {\n                debug(\"Aborting because element container has not been initialized\");\n                return;\n              }\n              positionScrollbars(element, width, height);\n            });\n            if (sizeChanged && done) {\n              batchProcessor.add(2, function() {\n                if (!getState(element)) {\n                  debug(\"Aborting because element has been uninstalled\");\n                  return;\n                }\n                if (!areElementsInjected()) {\n                  debug(\"Aborting because element container has not been initialized\");\n                  return;\n                }\n                done();\n              });\n            }\n          }\n          function areElementsInjected() {\n            return !!getState(element).container;\n          }\n          function notifyListenersIfNeeded() {\n            function isFirstNotify() {\n              return getState(element).lastNotifiedWidth === void 0;\n            }\n            debug(\"notifyListenersIfNeeded invoked\");\n            var state = getState(element);\n            if (isFirstNotify() && state.lastWidth === state.startSize.width && state.lastHeight === state.startSize.height) {\n              return debug(\"Not notifying: Size is the same as the start size, and there has been no notification yet.\");\n            }\n            if (state.lastWidth === state.lastNotifiedWidth && state.lastHeight === state.lastNotifiedHeight) {\n              return debug(\"Not notifying: Size already notified\");\n            }\n            debug(\"Current size not notified, notifying...\");\n            state.lastNotifiedWidth = state.lastWidth;\n            state.lastNotifiedHeight = state.lastHeight;\n            forEach(getState(element).listeners, function(listener) {\n              listener(element);\n            });\n          }\n          function handleRender() {\n            debug(\"startanimation triggered.\");\n            if (isUnrendered(element)) {\n              debug(\"Ignoring since element is still unrendered...\");\n              return;\n            }\n            debug(\"Element rendered.\");\n            var expand = getExpandElement(element);\n            var shrink = getShrinkElement(element);\n            if (expand.scrollLeft === 0 || expand.scrollTop === 0 || shrink.scrollLeft === 0 || shrink.scrollTop === 0) {\n              debug(\"Scrollbars out of sync. Updating detector elements...\");\n              updateDetectorElements(notifyListenersIfNeeded);\n            }\n          }\n          function handleScroll() {\n            debug(\"Scroll detected.\");\n            if (isUnrendered(element)) {\n              debug(\"Scroll event fired while unrendered. Ignoring...\");\n              return;\n            }\n            updateDetectorElements(notifyListenersIfNeeded);\n          }\n          debug(\"registerListenersAndPositionElements invoked.\");\n          if (!getState(element)) {\n            debug(\"Aborting because element has been uninstalled\");\n            return;\n          }\n          getState(element).onRendered = handleRender;\n          getState(element).onExpand = handleScroll;\n          getState(element).onShrink = handleScroll;\n          var style = getState(element).style;\n          updateChildSizes(element, style.width, style.height);\n        }\n        function finalizeDomMutation() {\n          debug(\"finalizeDomMutation invoked.\");\n          if (!getState(element)) {\n            debug(\"Aborting because element has been uninstalled\");\n            return;\n          }\n          var style = getState(element).style;\n          storeCurrentSize(element, style.width, style.height);\n          positionScrollbars(element, style.width, style.height);\n        }\n        function ready() {\n          callback(element);\n        }\n        function install() {\n          debug(\"Installing...\");\n          initListeners();\n          storeStartSize();\n          batchProcessor.add(0, storeStyle);\n          batchProcessor.add(1, injectScrollElements);\n          batchProcessor.add(2, registerListenersAndPositionElements);\n          batchProcessor.add(3, finalizeDomMutation);\n          batchProcessor.add(4, ready);\n        }\n        debug(\"Making detectable...\");\n        if (isDetached(element)) {\n          debug(\"Element is detached\");\n          injectContainerElement();\n          debug(\"Waiting until element is attached...\");\n          getState(element).onRendered = function() {\n            debug(\"Element is now attached\");\n            install();\n          };\n        } else {\n          install();\n        }\n      }\n      function uninstall(element) {\n        var state = getState(element);\n        if (!state) {\n          return;\n        }\n        state.onExpandScroll && removeEvent(getExpandElement(element), \"scroll\", state.onExpandScroll);\n        state.onShrinkScroll && removeEvent(getShrinkElement(element), \"scroll\", state.onShrinkScroll);\n        state.onAnimationStart && removeEvent(state.container, \"animationstart\", state.onAnimationStart);\n        state.container && element.removeChild(state.container);\n      }\n      return {\n        makeDetectable,\n        addListener,\n        uninstall,\n        initDocument\n      };\n    };\n  }\n});\n\n// node_modules/element-resize-detector/src/element-resize-detector.js\nvar require_element_resize_detector = __commonJS({\n  \"node_modules/element-resize-detector/src/element-resize-detector.js\"(exports2, module2) {\n    \"use strict\";\n    var forEach = require_collection_utils().forEach;\n    var elementUtilsMaker = require_element_utils();\n    var listenerHandlerMaker = require_listener_handler();\n    var idGeneratorMaker = require_id_generator();\n    var idHandlerMaker = require_id_handler();\n    var reporterMaker = require_reporter();\n    var browserDetector = require_browser_detector();\n    var batchProcessorMaker = require_batch_processor();\n    var stateHandler = require_state_handler();\n    var objectStrategyMaker = require_object();\n    var scrollStrategyMaker = require_scroll();\n    function isCollection(obj) {\n      return Array.isArray(obj) || obj.length !== void 0;\n    }\n    function toArray(collection) {\n      if (!Array.isArray(collection)) {\n        var array = [];\n        forEach(collection, function(obj) {\n          array.push(obj);\n        });\n        return array;\n      } else {\n        return collection;\n      }\n    }\n    function isElement(obj) {\n      return obj && obj.nodeType === 1;\n    }\n    module2.exports = function(options) {\n      options = options || {};\n      var idHandler;\n      if (options.idHandler) {\n        idHandler = {\n          get: function(element) {\n            return options.idHandler.get(element, true);\n          },\n          set: options.idHandler.set\n        };\n      } else {\n        var idGenerator = idGeneratorMaker();\n        var defaultIdHandler = idHandlerMaker({\n          idGenerator,\n          stateHandler\n        });\n        idHandler = defaultIdHandler;\n      }\n      var reporter = options.reporter;\n      if (!reporter) {\n        var quiet = reporter === false;\n        reporter = reporterMaker(quiet);\n      }\n      var batchProcessor = getOption(options, \"batchProcessor\", batchProcessorMaker({ reporter }));\n      var globalOptions = {};\n      globalOptions.callOnAdd = !!getOption(options, \"callOnAdd\", true);\n      globalOptions.debug = !!getOption(options, \"debug\", false);\n      var eventListenerHandler = listenerHandlerMaker(idHandler);\n      var elementUtils = elementUtilsMaker({\n        stateHandler\n      });\n      var detectionStrategy;\n      var desiredStrategy = getOption(options, \"strategy\", \"object\");\n      var importantCssRules = getOption(options, \"important\", false);\n      var strategyOptions = {\n        reporter,\n        batchProcessor,\n        stateHandler,\n        idHandler,\n        important: importantCssRules\n      };\n      if (desiredStrategy === \"scroll\") {\n        if (browserDetector.isLegacyOpera()) {\n          reporter.warn(\"Scroll strategy is not supported on legacy Opera. Changing to object strategy.\");\n          desiredStrategy = \"object\";\n        } else if (browserDetector.isIE(9)) {\n          reporter.warn(\"Scroll strategy is not supported on IE9. Changing to object strategy.\");\n          desiredStrategy = \"object\";\n        }\n      }\n      if (desiredStrategy === \"scroll\") {\n        detectionStrategy = scrollStrategyMaker(strategyOptions);\n      } else if (desiredStrategy === \"object\") {\n        detectionStrategy = objectStrategyMaker(strategyOptions);\n      } else {\n        throw new Error(\"Invalid strategy name: \" + desiredStrategy);\n      }\n      var onReadyCallbacks = {};\n      function listenTo(options2, elements, listener) {\n        function onResizeCallback(element) {\n          var listeners = eventListenerHandler.get(element);\n          forEach(listeners, function callListenerProxy(listener2) {\n            listener2(element);\n          });\n        }\n        function addListener(callOnAdd2, element, listener2) {\n          eventListenerHandler.add(element, listener2);\n          if (callOnAdd2) {\n            listener2(element);\n          }\n        }\n        if (!listener) {\n          listener = elements;\n          elements = options2;\n          options2 = {};\n        }\n        if (!elements) {\n          throw new Error(\"At least one element required.\");\n        }\n        if (!listener) {\n          throw new Error(\"Listener required.\");\n        }\n        if (isElement(elements)) {\n          elements = [elements];\n        } else if (isCollection(elements)) {\n          elements = toArray(elements);\n        } else {\n          return reporter.error(\"Invalid arguments. Must be a DOM element or a collection of DOM elements.\");\n        }\n        var elementsReady = 0;\n        var callOnAdd = getOption(options2, \"callOnAdd\", globalOptions.callOnAdd);\n        var onReadyCallback = getOption(options2, \"onReady\", function noop() {\n        });\n        var debug = getOption(options2, \"debug\", globalOptions.debug);\n        forEach(elements, function attachListenerToElement(element) {\n          if (!stateHandler.getState(element)) {\n            stateHandler.initState(element);\n            idHandler.set(element);\n          }\n          var id = idHandler.get(element);\n          debug && reporter.log(\"Attaching listener to element\", id, element);\n          if (!elementUtils.isDetectable(element)) {\n            debug && reporter.log(id, \"Not detectable.\");\n            if (elementUtils.isBusy(element)) {\n              debug && reporter.log(id, \"System busy making it detectable\");\n              addListener(callOnAdd, element, listener);\n              onReadyCallbacks[id] = onReadyCallbacks[id] || [];\n              onReadyCallbacks[id].push(function onReady() {\n                elementsReady++;\n                if (elementsReady === elements.length) {\n                  onReadyCallback();\n                }\n              });\n              return;\n            }\n            debug && reporter.log(id, \"Making detectable...\");\n            elementUtils.markBusy(element, true);\n            return detectionStrategy.makeDetectable({ debug, important: importantCssRules }, element, function onElementDetectable(element2) {\n              debug && reporter.log(id, \"onElementDetectable\");\n              if (stateHandler.getState(element2)) {\n                elementUtils.markAsDetectable(element2);\n                elementUtils.markBusy(element2, false);\n                detectionStrategy.addListener(element2, onResizeCallback);\n                addListener(callOnAdd, element2, listener);\n                var state = stateHandler.getState(element2);\n                if (state && state.startSize) {\n                  var width = element2.offsetWidth;\n                  var height = element2.offsetHeight;\n                  if (state.startSize.width !== width || state.startSize.height !== height) {\n                    onResizeCallback(element2);\n                  }\n                }\n                if (onReadyCallbacks[id]) {\n                  forEach(onReadyCallbacks[id], function(callback) {\n                    callback();\n                  });\n                }\n              } else {\n                debug && reporter.log(id, \"Element uninstalled before being detectable.\");\n              }\n              delete onReadyCallbacks[id];\n              elementsReady++;\n              if (elementsReady === elements.length) {\n                onReadyCallback();\n              }\n            });\n          }\n          debug && reporter.log(id, \"Already detecable, adding listener.\");\n          addListener(callOnAdd, element, listener);\n          elementsReady++;\n        });\n        if (elementsReady === elements.length) {\n          onReadyCallback();\n        }\n      }\n      function uninstall(elements) {\n        if (!elements) {\n          return reporter.error(\"At least one element is required.\");\n        }\n        if (isElement(elements)) {\n          elements = [elements];\n        } else if (isCollection(elements)) {\n          elements = toArray(elements);\n        } else {\n          return reporter.error(\"Invalid arguments. Must be a DOM element or a collection of DOM elements.\");\n        }\n        forEach(elements, function(element) {\n          eventListenerHandler.removeAllListeners(element);\n          detectionStrategy.uninstall(element);\n          stateHandler.cleanState(element);\n        });\n      }\n      function initDocument(targetDocument) {\n        detectionStrategy.initDocument && detectionStrategy.initDocument(targetDocument);\n      }\n      return {\n        listenTo,\n        removeListener: eventListenerHandler.removeListener,\n        removeAllListeners: eventListenerHandler.removeAllListeners,\n        uninstall,\n        initDocument\n      };\n    };\n    function getOption(options, name, defaultValue) {\n      var value = options[name];\n      if ((value === void 0 || value === null) && defaultValue !== void 0) {\n        return defaultValue;\n      }\n      return value;\n    }\n  }\n});\n\n// node_modules/shallowequal/index.js\nvar require_shallowequal = __commonJS({\n  \"node_modules/shallowequal/index.js\"(exports2, module2) {\n    module2.exports = function shallowEqual(objA, objB, compare, compareContext) {\n      var ret = compare ? compare.call(compareContext, objA, objB) : void 0;\n      if (ret !== void 0) {\n        return !!ret;\n      }\n      if (objA === objB) {\n        return true;\n      }\n      if (typeof objA !== \"object\" || !objA || typeof objB !== \"object\" || !objB) {\n        return false;\n      }\n      var keysA = Object.keys(objA);\n      var keysB = Object.keys(objB);\n      if (keysA.length !== keysB.length) {\n        return false;\n      }\n      var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);\n      for (var idx = 0; idx < keysA.length; idx++) {\n        var key = keysA[idx];\n        if (!bHasOwnProperty(key)) {\n          return false;\n        }\n        var valueA = objA[key];\n        var valueB = objB[key];\n        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;\n        if (ret === false || ret === void 0 && valueA !== valueB) {\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n});\n\n// node_modules/react-sizeme/dist/react-sizeme.js\nvar require_react_sizeme = __commonJS({\n  \"node_modules/react-sizeme/dist/react-sizeme.js\"(exports2, module2) {\n    \"use strict\";\n    var React3 = require(\"react\");\n    var ReactDOM = require(\"react-dom\");\n    var invariant = require_browser();\n    var throttleDebounce = require_cjs();\n    var createResizeDetector = require_element_resize_detector();\n    var isShallowEqual = require_shallowequal();\n    function _interopDefaultLegacy(e) {\n      return e && typeof e === \"object\" && \"default\" in e ? e : { \"default\": e };\n    }\n    var React__default = /* @__PURE__ */ _interopDefaultLegacy(React3);\n    var ReactDOM__default = /* @__PURE__ */ _interopDefaultLegacy(ReactDOM);\n    var invariant__default = /* @__PURE__ */ _interopDefaultLegacy(invariant);\n    var createResizeDetector__default = /* @__PURE__ */ _interopDefaultLegacy(createResizeDetector);\n    var isShallowEqual__default = /* @__PURE__ */ _interopDefaultLegacy(isShallowEqual);\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n          symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n          });\n        }\n        keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread2(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n          ownKeys(Object(source), true).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n          });\n        } else if (Object.getOwnPropertyDescriptors) {\n          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n          ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n          });\n        }\n      }\n      return target;\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n          descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps)\n        _defineProperties(Constructor, staticProps);\n      return Constructor;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, {\n          value,\n          enumerable: true,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function _extends() {\n      _extends = Object.assign || function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      };\n      return _extends.apply(this, arguments);\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n          value: subClass,\n          writable: true,\n          configurable: true\n        }\n      });\n      if (superClass)\n        _setPrototypeOf(subClass, superClass);\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      };\n      return _getPrototypeOf(o);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct)\n        return false;\n      if (Reflect.construct.sham)\n        return false;\n      if (typeof Proxy === \"function\")\n        return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _objectWithoutPropertiesLoose(source, excluded) {\n      if (source == null)\n        return {};\n      var target = {};\n      var sourceKeys = Object.keys(source);\n      var key, i;\n      for (i = 0; i < sourceKeys.length; i++) {\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0)\n          continue;\n        target[key] = source[key];\n      }\n      return target;\n    }\n    function _objectWithoutProperties(source, excluded) {\n      if (source == null)\n        return {};\n      var target = _objectWithoutPropertiesLoose(source, excluded);\n      var key, i;\n      if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for (i = 0; i < sourceSymbolKeys.length; i++) {\n          key = sourceSymbolKeys[i];\n          if (excluded.indexOf(key) >= 0)\n            continue;\n          if (!Object.prototype.propertyIsEnumerable.call(source, key))\n            continue;\n          target[key] = source[key];\n        }\n      }\n      return target;\n    }\n    function _assertThisInitialized(self2) {\n      if (self2 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self2;\n    }\n    function _possibleConstructorReturn(self2, call) {\n      if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n        return call;\n      } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n      }\n      return _assertThisInitialized(self2);\n    }\n    function _createSuper(Derived) {\n      var hasNativeReflectConstruct = _isNativeReflectConstruct();\n      return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n          var NewTarget = _getPrototypeOf(this).constructor;\n          result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n          result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n      };\n    }\n    var instances = {};\n    function resizeDetector() {\n      var strategy = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"scroll\";\n      if (!instances[strategy]) {\n        instances[strategy] = createResizeDetector__default[\"default\"]({\n          strategy\n        });\n      }\n      return instances[strategy];\n    }\n    var _excluded$1 = [\"explicitRef\", \"className\", \"style\", \"size\", \"disablePlaceholder\", \"onSize\"];\n    var errMsg = \"react-sizeme: an error occurred whilst stopping to listen to node size changes\";\n    var defaultConfig = {\n      monitorWidth: true,\n      monitorHeight: false,\n      refreshRate: 16,\n      refreshMode: \"throttle\",\n      noPlaceholder: false,\n      resizeDetectorStrategy: \"scroll\"\n    };\n    function getDisplayName(WrappedComponent) {\n      return WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n    }\n    var ReferenceWrapper = /* @__PURE__ */ function(_Component) {\n      _inherits(ReferenceWrapper2, _Component);\n      var _super = _createSuper(ReferenceWrapper2);\n      function ReferenceWrapper2() {\n        _classCallCheck(this, ReferenceWrapper2);\n        return _super.apply(this, arguments);\n      }\n      _createClass(ReferenceWrapper2, [{\n        key: \"render\",\n        value: function render() {\n          return React3.Children.only(this.props.children);\n        }\n      }]);\n      return ReferenceWrapper2;\n    }(React3.Component);\n    _defineProperty(ReferenceWrapper, \"displayName\", \"SizeMeReferenceWrapper\");\n    function Placeholder(_ref) {\n      var className = _ref.className, style = _ref.style;\n      var phProps = {};\n      if (!className && !style) {\n        phProps.style = {\n          width: \"100%\",\n          height: \"100%\"\n        };\n      } else {\n        if (className) {\n          phProps.className = className;\n        }\n        if (style) {\n          phProps.style = style;\n        }\n      }\n      return /* @__PURE__ */ React__default[\"default\"].createElement(\"div\", phProps);\n    }\n    Placeholder.displayName = \"SizeMePlaceholder\";\n    var renderWrapper = function renderWrapper2(WrappedComponent) {\n      function SizeMeRenderer(props) {\n        var explicitRef = props.explicitRef, className = props.className, style = props.style, size = props.size, disablePlaceholder = props.disablePlaceholder;\n        props.onSize;\n        var restProps = _objectWithoutProperties(props, _excluded$1);\n        var noSizeData = size == null || size.width == null && size.height == null;\n        var renderPlaceholder = noSizeData && !disablePlaceholder;\n        var renderProps = {\n          className,\n          style\n        };\n        if (size != null) {\n          renderProps.size = size;\n        }\n        var toRender = renderPlaceholder ? /* @__PURE__ */ React__default[\"default\"].createElement(Placeholder, {\n          className,\n          style\n        }) : /* @__PURE__ */ React__default[\"default\"].createElement(WrappedComponent, _extends({}, renderProps, restProps));\n        return /* @__PURE__ */ React__default[\"default\"].createElement(ReferenceWrapper, {\n          ref: explicitRef\n        }, toRender);\n      }\n      SizeMeRenderer.displayName = \"SizeMeRenderer(\".concat(getDisplayName(WrappedComponent), \")\");\n      return SizeMeRenderer;\n    };\n    function withSize() {\n      var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultConfig;\n      var _config$monitorWidth = config.monitorWidth, monitorWidth = _config$monitorWidth === void 0 ? defaultConfig.monitorWidth : _config$monitorWidth, _config$monitorHeight = config.monitorHeight, monitorHeight = _config$monitorHeight === void 0 ? defaultConfig.monitorHeight : _config$monitorHeight, _config$refreshRate = config.refreshRate, refreshRate = _config$refreshRate === void 0 ? defaultConfig.refreshRate : _config$refreshRate, _config$refreshMode = config.refreshMode, refreshMode = _config$refreshMode === void 0 ? defaultConfig.refreshMode : _config$refreshMode, _config$noPlaceholder = config.noPlaceholder, noPlaceholder = _config$noPlaceholder === void 0 ? defaultConfig.noPlaceholder : _config$noPlaceholder, _config$resizeDetecto = config.resizeDetectorStrategy, resizeDetectorStrategy = _config$resizeDetecto === void 0 ? defaultConfig.resizeDetectorStrategy : _config$resizeDetecto;\n      invariant__default[\"default\"](monitorWidth || monitorHeight, 'You have to monitor at least one of the width or height when using \"sizeMe\"');\n      invariant__default[\"default\"](refreshRate >= 16, \"It is highly recommended that you don't put your refreshRate lower than 16 as this may cause layout thrashing.\");\n      invariant__default[\"default\"](refreshMode === \"throttle\" || refreshMode === \"debounce\", 'The refreshMode should have a value of \"throttle\" or \"debounce\"');\n      var refreshDelayStrategy = refreshMode === \"throttle\" ? throttleDebounce.throttle : throttleDebounce.debounce;\n      return function WrapComponent(WrappedComponent) {\n        var SizeMeRenderWrapper = renderWrapper(WrappedComponent);\n        var SizeAwareComponent = /* @__PURE__ */ function(_React$Component) {\n          _inherits(SizeAwareComponent2, _React$Component);\n          var _super2 = _createSuper(SizeAwareComponent2);\n          function SizeAwareComponent2() {\n            var _this;\n            _classCallCheck(this, SizeAwareComponent2);\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n            _this = _super2.call.apply(_super2, [this].concat(args));\n            _defineProperty(_assertThisInitialized(_this), \"domEl\", null);\n            _defineProperty(_assertThisInitialized(_this), \"state\", {\n              width: void 0,\n              height: void 0\n            });\n            _defineProperty(_assertThisInitialized(_this), \"uninstall\", function() {\n              if (_this.domEl) {\n                try {\n                  _this.detector.uninstall(_this.domEl);\n                } catch (err) {\n                  console.warn(errMsg);\n                }\n                _this.domEl = null;\n              }\n            });\n            _defineProperty(_assertThisInitialized(_this), \"determineStrategy\", function(props) {\n              if (props.onSize) {\n                if (!_this.callbackState) {\n                  _this.callbackState = _objectSpread2({}, _this.state);\n                }\n                _this.strategy = \"callback\";\n              } else {\n                _this.strategy = \"render\";\n              }\n            });\n            _defineProperty(_assertThisInitialized(_this), \"strategisedSetState\", function(state) {\n              if (_this.strategy === \"callback\") {\n                _this.callbackState = state;\n                _this.props.onSize(state);\n              }\n              _this.setState(state);\n            });\n            _defineProperty(_assertThisInitialized(_this), \"strategisedGetState\", function() {\n              return _this.strategy === \"callback\" ? _this.callbackState : _this.state;\n            });\n            _defineProperty(_assertThisInitialized(_this), \"refCallback\", function(element) {\n              _this.element = element;\n            });\n            _defineProperty(_assertThisInitialized(_this), \"hasSizeChanged\", function(current, next) {\n              var c = current;\n              var n = next;\n              return monitorWidth && c.width !== n.width || monitorHeight && c.height !== n.height;\n            });\n            _defineProperty(_assertThisInitialized(_this), \"checkIfSizeChanged\", refreshDelayStrategy(refreshRate, function(el) {\n              var _el$getBoundingClient = el.getBoundingClientRect(), width = _el$getBoundingClient.width, height = _el$getBoundingClient.height;\n              var next = {\n                width: monitorWidth ? width : null,\n                height: monitorHeight ? height : null\n              };\n              if (_this.hasSizeChanged(_this.strategisedGetState(), next)) {\n                _this.strategisedSetState(next);\n              }\n            }));\n            return _this;\n          }\n          _createClass(SizeAwareComponent2, [{\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n              this.detector = resizeDetector(resizeDetectorStrategy);\n              this.determineStrategy(this.props);\n              this.handleDOMNode();\n            }\n          }, {\n            key: \"componentDidUpdate\",\n            value: function componentDidUpdate() {\n              this.determineStrategy(this.props);\n              this.handleDOMNode();\n            }\n          }, {\n            key: \"componentWillUnmount\",\n            value: function componentWillUnmount() {\n              this.hasSizeChanged = function() {\n                return void 0;\n              };\n              this.checkIfSizeChanged = function() {\n                return void 0;\n              };\n              this.uninstall();\n            }\n          }, {\n            key: \"handleDOMNode\",\n            value: function handleDOMNode() {\n              var found = this.element && ReactDOM__default[\"default\"].findDOMNode(this.element);\n              if (!found) {\n                this.uninstall();\n                return;\n              }\n              if (!this.domEl) {\n                this.domEl = found;\n                this.detector.listenTo(this.domEl, this.checkIfSizeChanged);\n              } else if (this.domEl.isSameNode && !this.domEl.isSameNode(found) || this.domEl !== found) {\n                this.uninstall();\n                this.domEl = found;\n                this.detector.listenTo(this.domEl, this.checkIfSizeChanged);\n              } else\n                ;\n            }\n          }, {\n            key: \"render\",\n            value: function render() {\n              var disablePlaceholder = withSize.enableSSRBehaviour || withSize.noPlaceholders || noPlaceholder || this.strategy === \"callback\";\n              var size = _objectSpread2({}, this.state);\n              return /* @__PURE__ */ React__default[\"default\"].createElement(SizeMeRenderWrapper, _extends({\n                explicitRef: this.refCallback,\n                size: this.strategy === \"callback\" ? null : size,\n                disablePlaceholder\n              }, this.props));\n            }\n          }]);\n          return SizeAwareComponent2;\n        }(React__default[\"default\"].Component);\n        _defineProperty(SizeAwareComponent, \"displayName\", \"SizeMe(\".concat(getDisplayName(WrappedComponent), \")\"));\n        SizeAwareComponent.WrappedComponent = WrappedComponent;\n        return SizeAwareComponent;\n      };\n    }\n    withSize.enableSSRBehaviour = false;\n    withSize.noPlaceholders = false;\n    var _excluded = [\"children\", \"render\"];\n    var _excluded2 = [\"children\", \"render\"];\n    var _excluded3 = [\"children\", \"render\"];\n    var SizeMe2 = /* @__PURE__ */ function(_Component) {\n      _inherits(SizeMe3, _Component);\n      var _super = _createSuper(SizeMe3);\n      function SizeMe3(props) {\n        var _this;\n        _classCallCheck(this, SizeMe3);\n        _this = _super.call(this, props);\n        _defineProperty(_assertThisInitialized(_this), \"createComponent\", function(config) {\n          _this.SizeAware = withSize(config)(function(_ref) {\n            var children = _ref.children;\n            return children;\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onSize\", function(size) {\n          return _this.setState({\n            size\n          });\n        });\n        props.children;\n        props.render;\n        var sizeMeConfig = _objectWithoutProperties(props, _excluded);\n        _this.createComponent(sizeMeConfig);\n        _this.state = {\n          size: {\n            width: void 0,\n            height: void 0\n          }\n        };\n        return _this;\n      }\n      _createClass(SizeMe3, [{\n        key: \"componentDidUpdate\",\n        value: function componentDidUpdate(prevProps) {\n          var _this$props = this.props;\n          _this$props.children;\n          _this$props.render;\n          var currentSizeMeConfig = _objectWithoutProperties(_this$props, _excluded2);\n          prevProps.children;\n          prevProps.render;\n          var prevSizeMeConfig = _objectWithoutProperties(prevProps, _excluded3);\n          if (!isShallowEqual__default[\"default\"](currentSizeMeConfig, prevSizeMeConfig)) {\n            this.createComponent(currentSizeMeConfig);\n          }\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var SizeAware = this.SizeAware;\n          var render2 = this.props.children || this.props.render;\n          return /* @__PURE__ */ React__default[\"default\"].createElement(SizeAware, {\n            onSize: this.onSize\n          }, render2({\n            size: this.state.size\n          }));\n        }\n      }]);\n      return SizeMe3;\n    }(React3.Component);\n    _defineProperty(SizeMe2, \"defaultProps\", {\n      children: void 0,\n      render: void 0\n    });\n    withSize.SizeMe = SizeMe2;\n    withSize.withSize = withSize;\n    module2.exports = withSize;\n  }\n});\n\n// node_modules/lodash.isequal/index.js\nvar require_lodash = __commonJS({\n  \"node_modules/lodash.isequal/index.js\"(exports2, module2) {\n    var LARGE_ARRAY_SIZE = 200;\n    var HASH_UNDEFINED = \"__lodash_hash_undefined__\";\n    var COMPARE_PARTIAL_FLAG = 1;\n    var COMPARE_UNORDERED_FLAG = 2;\n    var MAX_SAFE_INTEGER = 9007199254740991;\n    var argsTag = \"[object Arguments]\";\n    var arrayTag = \"[object Array]\";\n    var asyncTag = \"[object AsyncFunction]\";\n    var boolTag = \"[object Boolean]\";\n    var dateTag = \"[object Date]\";\n    var errorTag = \"[object Error]\";\n    var funcTag = \"[object Function]\";\n    var genTag = \"[object GeneratorFunction]\";\n    var mapTag = \"[object Map]\";\n    var numberTag = \"[object Number]\";\n    var nullTag = \"[object Null]\";\n    var objectTag = \"[object Object]\";\n    var promiseTag = \"[object Promise]\";\n    var proxyTag = \"[object Proxy]\";\n    var regexpTag = \"[object RegExp]\";\n    var setTag = \"[object Set]\";\n    var stringTag = \"[object String]\";\n    var symbolTag = \"[object Symbol]\";\n    var undefinedTag = \"[object Undefined]\";\n    var weakMapTag = \"[object WeakMap]\";\n    var arrayBufferTag = \"[object ArrayBuffer]\";\n    var dataViewTag = \"[object DataView]\";\n    var float32Tag = \"[object Float32Array]\";\n    var float64Tag = \"[object Float64Array]\";\n    var int8Tag = \"[object Int8Array]\";\n    var int16Tag = \"[object Int16Array]\";\n    var int32Tag = \"[object Int32Array]\";\n    var uint8Tag = \"[object Uint8Array]\";\n    var uint8ClampedTag = \"[object Uint8ClampedArray]\";\n    var uint16Tag = \"[object Uint16Array]\";\n    var uint32Tag = \"[object Uint32Array]\";\n    var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n    var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n    var reIsUint = /^(?:0|[1-9]\\d*)$/;\n    var typedArrayTags = {};\n    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\n    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n    var freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\n    var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n    var root = freeGlobal || freeSelf || Function(\"return this\")();\n    var freeExports = typeof exports2 == \"object\" && exports2 && !exports2.nodeType && exports2;\n    var freeModule = freeExports && typeof module2 == \"object\" && module2 && !module2.nodeType && module2;\n    var moduleExports = freeModule && freeModule.exports === freeExports;\n    var freeProcess = moduleExports && freeGlobal.process;\n    var nodeUtil = function() {\n      try {\n        return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n      } catch (e) {\n      }\n    }();\n    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n    function arrayFilter(array, predicate) {\n      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n    function arrayPush(array, values) {\n      var index = -1, length = values.length, offset = array.length;\n      while (++index < length) {\n        array[offset + index] = values[index];\n      }\n      return array;\n    }\n    function arraySome(array, predicate) {\n      var index = -1, length = array == null ? 0 : array.length;\n      while (++index < length) {\n        if (predicate(array[index], index, array)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function baseTimes(n, iteratee) {\n      var index = -1, result = Array(n);\n      while (++index < n) {\n        result[index] = iteratee(index);\n      }\n      return result;\n    }\n    function baseUnary(func) {\n      return function(value) {\n        return func(value);\n      };\n    }\n    function cacheHas(cache, key) {\n      return cache.has(key);\n    }\n    function getValue(object, key) {\n      return object == null ? void 0 : object[key];\n    }\n    function mapToArray(map) {\n      var index = -1, result = Array(map.size);\n      map.forEach(function(value, key) {\n        result[++index] = [key, value];\n      });\n      return result;\n    }\n    function overArg(func, transform) {\n      return function(arg) {\n        return func(transform(arg));\n      };\n    }\n    function setToArray(set) {\n      var index = -1, result = Array(set.size);\n      set.forEach(function(value) {\n        result[++index] = value;\n      });\n      return result;\n    }\n    var arrayProto = Array.prototype;\n    var funcProto = Function.prototype;\n    var objectProto = Object.prototype;\n    var coreJsData = root[\"__core-js_shared__\"];\n    var funcToString = funcProto.toString;\n    var hasOwnProperty = objectProto.hasOwnProperty;\n    var maskSrcKey = function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || \"\");\n      return uid ? \"Symbol(src)_1.\" + uid : \"\";\n    }();\n    var nativeObjectToString = objectProto.toString;\n    var reIsNative = RegExp(\"^\" + funcToString.call(hasOwnProperty).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\n    var Buffer2 = moduleExports ? root.Buffer : void 0;\n    var Symbol2 = root.Symbol;\n    var Uint8Array2 = root.Uint8Array;\n    var propertyIsEnumerable = objectProto.propertyIsEnumerable;\n    var splice = arrayProto.splice;\n    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;\n    var nativeGetSymbols = Object.getOwnPropertySymbols;\n    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;\n    var nativeKeys = overArg(Object.keys, Object);\n    var DataView = getNative(root, \"DataView\");\n    var Map = getNative(root, \"Map\");\n    var Promise2 = getNative(root, \"Promise\");\n    var Set = getNative(root, \"Set\");\n    var WeakMap2 = getNative(root, \"WeakMap\");\n    var nativeCreate = getNative(Object, \"create\");\n    var dataViewCtorString = toSource(DataView);\n    var mapCtorString = toSource(Map);\n    var promiseCtorString = toSource(Promise2);\n    var setCtorString = toSource(Set);\n    var weakMapCtorString = toSource(WeakMap2);\n    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;\n    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;\n    function Hash(entries) {\n      var index = -1, length = entries == null ? 0 : entries.length;\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n      this.size = 0;\n    }\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? void 0 : result;\n      }\n      return hasOwnProperty.call(data, key) ? data[key] : void 0;\n    }\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);\n    }\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;\n      return this;\n    }\n    Hash.prototype.clear = hashClear;\n    Hash.prototype[\"delete\"] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n    function ListCache(entries) {\n      var index = -1, length = entries == null ? 0 : entries.length;\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n    function listCacheDelete(key) {\n      var data = this.__data__, index = assocIndexOf(data, key);\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n    function listCacheGet(key) {\n      var data = this.__data__, index = assocIndexOf(data, key);\n      return index < 0 ? void 0 : data[index][1];\n    }\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n    function listCacheSet(key, value) {\n      var data = this.__data__, index = assocIndexOf(data, key);\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype[\"delete\"] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n    function MapCache(entries) {\n      var index = -1, length = entries == null ? 0 : entries.length;\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        \"hash\": new Hash(),\n        \"map\": new (Map || ListCache)(),\n        \"string\": new Hash()\n      };\n    }\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)[\"delete\"](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key), size = data.size;\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype[\"delete\"] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n    function SetCache(values) {\n      var index = -1, length = values == null ? 0 : values.length;\n      this.__data__ = new MapCache();\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n    function stackClear() {\n      this.__data__ = new ListCache();\n      this.size = 0;\n    }\n    function stackDelete(key) {\n      var data = this.__data__, result = data[\"delete\"](key);\n      this.size = data.size;\n      return result;\n    }\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n    Stack.prototype.clear = stackClear;\n    Stack.prototype[\"delete\"] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == \"length\" || isBuff && (key == \"offset\" || key == \"parent\") || isType && (key == \"buffer\" || key == \"byteLength\" || key == \"byteOffset\") || isIndex(key, length)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === void 0 ? undefinedTag : nullTag;\n      }\n      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n    }\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\n    }\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);\n      objTag = objTag == argsTag ? objectTag : objTag;\n      othTag = othTag == argsTag ? objectTag : othTag;\n      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack());\n        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, \"__wrapped__\"), othIsWrapped = othIsObj && hasOwnProperty.call(other, \"__wrapped__\");\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;\n          stack || (stack = new Stack());\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack());\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != \"constructor\") {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      var stacked = stack.get(array);\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;\n      stack.set(array, other);\n      stack.set(other, array);\n      while (++index < arrLength) {\n        var arrValue = array[index], othValue = other[index];\n        if (customizer) {\n          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== void 0) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        if (seen) {\n          if (!arraySome(other, function(othValue2, othIndex) {\n            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n            result = false;\n            break;\n          }\n        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n          result = false;\n          break;\n        }\n      }\n      stack[\"delete\"](array);\n      stack[\"delete\"](other);\n      return result;\n    }\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n        case arrayBufferTag:\n          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {\n            return false;\n          }\n          return true;\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          return eq(+object, +other);\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n        case regexpTag:\n        case stringTag:\n          return object == other + \"\";\n        case mapTag:\n          var convert = mapToArray;\n        case setTag:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n          convert || (convert = setToArray);\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG;\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack[\"delete\"](object);\n          return result;\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      var stacked = stack.get(object);\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key], othValue = other[key];\n        if (customizer) {\n          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n        }\n        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == \"constructor\");\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor, othCtor = other.constructor;\n        if (objCtor != othCtor && (\"constructor\" in object && \"constructor\" in other) && !(typeof objCtor == \"function\" && objCtor instanceof objCtor && typeof othCtor == \"function\" && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack[\"delete\"](object);\n      stack[\"delete\"](other);\n      return result;\n    }\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols);\n    }\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n    }\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : void 0;\n    }\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];\n      try {\n        value[symToStringTag] = void 0;\n        var unmasked = true;\n      } catch (e) {\n      }\n      var result = nativeObjectToString.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag] = tag;\n        } else {\n          delete value[symToStringTag];\n        }\n      }\n      return result;\n    }\n    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter(nativeGetSymbols(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n      });\n    };\n    var getTag = baseGetTag;\n    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {\n      getTag = function(value) {\n        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : \"\";\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString:\n              return dataViewTag;\n            case mapCtorString:\n              return mapTag;\n            case promiseCtorString:\n              return promiseTag;\n            case setCtorString:\n              return setTag;\n            case weakMapCtorString:\n              return weakMapTag;\n          }\n        }\n        return result;\n      };\n    }\n    function isIndex(value, length) {\n      length = length == null ? MAX_SAFE_INTEGER : length;\n      return !!length && (typeof value == \"number\" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);\n    }\n    function isKeyable(value) {\n      var type = typeof value;\n      return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n    }\n    function isMasked(func) {\n      return !!maskSrcKey && maskSrcKey in func;\n    }\n    function isPrototype(value) {\n      var Ctor = value && value.constructor, proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto;\n      return value === proto;\n    }\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {\n        }\n        try {\n          return func + \"\";\n        } catch (e) {\n        }\n      }\n      return \"\";\n    }\n    function eq(value, other) {\n      return value === other || value !== value && other !== other;\n    }\n    var isArguments = baseIsArguments(function() {\n      return arguments;\n    }()) ? baseIsArguments : function(value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, \"callee\") && !propertyIsEnumerable.call(value, \"callee\");\n    };\n    var isArray = Array.isArray;\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n    var isBuffer = nativeIsBuffer || stubFalse;\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n    function isLength(value) {\n      return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == \"object\" || type == \"function\");\n    }\n    function isObjectLike(value) {\n      return value != null && typeof value == \"object\";\n    }\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n    function stubArray() {\n      return [];\n    }\n    function stubFalse() {\n      return false;\n    }\n    module2.exports = isEqual;\n  }\n});\n\n// node_modules/clsx/dist/clsx.js\nvar require_clsx = __commonJS({\n  \"node_modules/clsx/dist/clsx.js\"(exports2, module2) {\n    function toVal(mix) {\n      var k, y, str = \"\";\n      if (typeof mix === \"string\" || typeof mix === \"number\") {\n        str += mix;\n      } else if (typeof mix === \"object\") {\n        if (Array.isArray(mix)) {\n          for (k = 0; k < mix.length; k++) {\n            if (mix[k]) {\n              if (y = toVal(mix[k])) {\n                str && (str += \" \");\n                str += y;\n              }\n            }\n          }\n        } else {\n          for (k in mix) {\n            if (mix[k]) {\n              str && (str += \" \");\n              str += k;\n            }\n          }\n        }\n      }\n      return str;\n    }\n    module2.exports = function() {\n      var i = 0, tmp, x, str = \"\";\n      while (i < arguments.length) {\n        if (tmp = arguments[i++]) {\n          if (x = toVal(tmp)) {\n            str && (str += \" \");\n            str += x;\n          }\n        }\n      }\n      return str;\n    };\n  }\n});\n\n// node_modules/react-grid-layout/build/fastRGLPropsEqual.js\nvar require_fastRGLPropsEqual = __commonJS({\n  \"node_modules/react-grid-layout/build/fastRGLPropsEqual.js\"(exports2, module2) {\n    module2.exports = function fastRGLPropsEqual(a, b, isEqualImpl) {\n      if (a === b)\n        return true;\n      return a.className === b.className && isEqualImpl(a.style, b.style) && a.width === b.width && a.autoSize === b.autoSize && a.cols === b.cols && a.draggableCancel === b.draggableCancel && a.draggableHandle === b.draggableHandle && isEqualImpl(a.verticalCompact, b.verticalCompact) && isEqualImpl(a.compactType, b.compactType) && isEqualImpl(a.layout, b.layout) && isEqualImpl(a.margin, b.margin) && isEqualImpl(a.containerPadding, b.containerPadding) && a.rowHeight === b.rowHeight && a.maxRows === b.maxRows && a.isBounded === b.isBounded && a.isDraggable === b.isDraggable && a.isResizable === b.isResizable && a.allowOverlap === b.allowOverlap && a.preventCollision === b.preventCollision && a.useCSSTransforms === b.useCSSTransforms && a.transformScale === b.transformScale && a.isDroppable === b.isDroppable && isEqualImpl(a.resizeHandles, b.resizeHandles) && isEqualImpl(a.resizeHandle, b.resizeHandle) && a.onLayoutChange === b.onLayoutChange && a.onDragStart === b.onDragStart && a.onDrag === b.onDrag && a.onDragStop === b.onDragStop && a.onResizeStart === b.onResizeStart && a.onResize === b.onResize && a.onResizeStop === b.onResizeStop && a.onDrop === b.onDrop && isEqualImpl(a.droppingItem, b.droppingItem) && isEqualImpl(a.innerRef, b.innerRef);\n    };\n  }\n});\n\n// node_modules/react-grid-layout/build/utils.js\nvar require_utils2 = __commonJS({\n  \"node_modules/react-grid-layout/build/utils.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.bottom = bottom;\n    exports2.childrenEqual = childrenEqual;\n    exports2.cloneLayout = cloneLayout;\n    exports2.cloneLayoutItem = cloneLayoutItem;\n    exports2.collides = collides;\n    exports2.compact = compact;\n    exports2.compactItem = compactItem;\n    exports2.compactType = compactType;\n    exports2.correctBounds = correctBounds;\n    exports2.fastPositionEqual = fastPositionEqual;\n    exports2.fastRGLPropsEqual = void 0;\n    exports2.getAllCollisions = getAllCollisions;\n    exports2.getFirstCollision = getFirstCollision;\n    exports2.getLayoutItem = getLayoutItem;\n    exports2.getStatics = getStatics;\n    exports2.modifyLayout = modifyLayout;\n    exports2.moveElement = moveElement;\n    exports2.moveElementAwayFromCollision = moveElementAwayFromCollision;\n    exports2.noop = void 0;\n    exports2.perc = perc;\n    exports2.setTopLeft = setTopLeft;\n    exports2.setTransform = setTransform;\n    exports2.sortLayoutItems = sortLayoutItems;\n    exports2.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\n    exports2.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\n    exports2.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\n    exports2.validateLayout = validateLayout;\n    exports2.withLayoutItem = withLayoutItem;\n    var _lodash = _interopRequireDefault(require_lodash());\n    var _react = _interopRequireDefault(require(\"react\"));\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    var isProduction = false;\n    var DEBUG = false;\n    function bottom(layout) {\n      var max = 0, bottomY;\n      for (var i = 0, len = layout.length; i < len; i++) {\n        bottomY = layout[i].y + layout[i].h;\n        if (bottomY > max)\n          max = bottomY;\n      }\n      return max;\n    }\n    function cloneLayout(layout) {\n      var newLayout = Array(layout.length);\n      for (var i = 0, len = layout.length; i < len; i++) {\n        newLayout[i] = cloneLayoutItem(layout[i]);\n      }\n      return newLayout;\n    }\n    function modifyLayout(layout, layoutItem) {\n      var newLayout = Array(layout.length);\n      for (var i = 0, len = layout.length; i < len; i++) {\n        if (layoutItem.i === layout[i].i) {\n          newLayout[i] = layoutItem;\n        } else {\n          newLayout[i] = layout[i];\n        }\n      }\n      return newLayout;\n    }\n    function withLayoutItem(layout, itemKey, cb) {\n      var item = getLayoutItem(layout, itemKey);\n      if (!item)\n        return [layout, null];\n      item = cb(cloneLayoutItem(item));\n      layout = modifyLayout(layout, item);\n      return [layout, item];\n    }\n    function cloneLayoutItem(layoutItem) {\n      return {\n        w: layoutItem.w,\n        h: layoutItem.h,\n        x: layoutItem.x,\n        y: layoutItem.y,\n        i: layoutItem.i,\n        minW: layoutItem.minW,\n        maxW: layoutItem.maxW,\n        minH: layoutItem.minH,\n        maxH: layoutItem.maxH,\n        moved: Boolean(layoutItem.moved),\n        static: Boolean(layoutItem.static),\n        isDraggable: layoutItem.isDraggable,\n        isResizable: layoutItem.isResizable,\n        resizeHandles: layoutItem.resizeHandles,\n        isBounded: layoutItem.isBounded\n      };\n    }\n    function childrenEqual(a, b) {\n      return (0, _lodash.default)(_react.default.Children.map(a, function(c) {\n        return c === null || c === void 0 ? void 0 : c.key;\n      }), _react.default.Children.map(b, function(c) {\n        return c === null || c === void 0 ? void 0 : c.key;\n      }));\n    }\n    var fastRGLPropsEqual = require_fastRGLPropsEqual();\n    exports2.fastRGLPropsEqual = fastRGLPropsEqual;\n    function fastPositionEqual(a, b) {\n      return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n    }\n    function collides(l1, l2) {\n      if (l1.i === l2.i)\n        return false;\n      if (l1.x + l1.w <= l2.x)\n        return false;\n      if (l1.x >= l2.x + l2.w)\n        return false;\n      if (l1.y + l1.h <= l2.y)\n        return false;\n      if (l1.y >= l2.y + l2.h)\n        return false;\n      return true;\n    }\n    function compact(layout, compactType2, cols) {\n      var compareWith = getStatics(layout);\n      var sorted = sortLayoutItems(layout, compactType2);\n      var out = Array(layout.length);\n      for (var i = 0, len = sorted.length; i < len; i++) {\n        var l = cloneLayoutItem(sorted[i]);\n        if (!l.static) {\n          l = compactItem(compareWith, l, compactType2, cols, sorted);\n          compareWith.push(l);\n        }\n        out[layout.indexOf(sorted[i])] = l;\n        l.moved = false;\n      }\n      return out;\n    }\n    var heightWidth = {\n      x: \"w\",\n      y: \"h\"\n    };\n    function resolveCompactionCollision(layout, item, moveToCoord, axis) {\n      var sizeProp = heightWidth[axis];\n      item[axis] += 1;\n      var itemIndex = layout.map(function(layoutItem) {\n        return layoutItem.i;\n      }).indexOf(item.i);\n      for (var i = itemIndex + 1; i < layout.length; i++) {\n        var otherItem = layout[i];\n        if (otherItem.static)\n          continue;\n        if (otherItem.y > item.y + item.h)\n          break;\n        if (collides(item, otherItem)) {\n          resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n        }\n      }\n      item[axis] = moveToCoord;\n    }\n    function compactItem(compareWith, l, compactType2, cols, fullLayout) {\n      var compactV = compactType2 === \"vertical\";\n      var compactH = compactType2 === \"horizontal\";\n      if (compactV) {\n        l.y = Math.min(bottom(compareWith), l.y);\n        while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n          l.y--;\n        }\n      } else if (compactH) {\n        while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n          l.x--;\n        }\n      }\n      var collides2;\n      while (collides2 = getFirstCollision(compareWith, l)) {\n        if (compactH) {\n          resolveCompactionCollision(fullLayout, l, collides2.x + collides2.w, \"x\");\n        } else {\n          resolveCompactionCollision(fullLayout, l, collides2.y + collides2.h, \"y\");\n        }\n        if (compactH && l.x + l.w > cols) {\n          l.x = cols - l.w;\n          l.y++;\n        }\n      }\n      l.y = Math.max(l.y, 0);\n      l.x = Math.max(l.x, 0);\n      return l;\n    }\n    function correctBounds(layout, bounds) {\n      var collidesWith = getStatics(layout);\n      for (var i = 0, len = layout.length; i < len; i++) {\n        var l = layout[i];\n        if (l.x + l.w > bounds.cols)\n          l.x = bounds.cols - l.w;\n        if (l.x < 0) {\n          l.x = 0;\n          l.w = bounds.cols;\n        }\n        if (!l.static)\n          collidesWith.push(l);\n        else {\n          while (getFirstCollision(collidesWith, l)) {\n            l.y++;\n          }\n        }\n      }\n      return layout;\n    }\n    function getLayoutItem(layout, id) {\n      for (var i = 0, len = layout.length; i < len; i++) {\n        if (layout[i].i === id)\n          return layout[i];\n      }\n    }\n    function getFirstCollision(layout, layoutItem) {\n      for (var i = 0, len = layout.length; i < len; i++) {\n        if (collides(layout[i], layoutItem))\n          return layout[i];\n      }\n    }\n    function getAllCollisions(layout, layoutItem) {\n      return layout.filter(function(l) {\n        return collides(l, layoutItem);\n      });\n    }\n    function getStatics(layout) {\n      return layout.filter(function(l) {\n        return l.static;\n      });\n    }\n    function moveElement(layout, l, x, y, isUserAction, preventCollision, compactType2, cols, allowOverlap) {\n      if (l.static && l.isDraggable !== true)\n        return layout;\n      if (l.y === y && l.x === x)\n        return layout;\n      log(\"Moving element \".concat(l.i, \" to [\").concat(String(x), \",\").concat(String(y), \"] from [\").concat(l.x, \",\").concat(l.y, \"]\"));\n      var oldX = l.x;\n      var oldY = l.y;\n      if (typeof x === \"number\")\n        l.x = x;\n      if (typeof y === \"number\")\n        l.y = y;\n      l.moved = true;\n      var sorted = sortLayoutItems(layout, compactType2);\n      var movingUp = compactType2 === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType2 === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false;\n      if (movingUp)\n        sorted = sorted.reverse();\n      var collisions = getAllCollisions(sorted, l);\n      var hasCollisions = collisions.length > 0;\n      if (hasCollisions && allowOverlap) {\n        return cloneLayout(layout);\n      } else if (hasCollisions && preventCollision) {\n        log(\"Collision prevented on \".concat(l.i, \", reverting.\"));\n        l.x = oldX;\n        l.y = oldY;\n        l.moved = false;\n        return layout;\n      }\n      for (var i = 0, len = collisions.length; i < len; i++) {\n        var collision = collisions[i];\n        log(\"Resolving collision between \".concat(l.i, \" at [\").concat(l.x, \",\").concat(l.y, \"] and \").concat(collision.i, \" at [\").concat(collision.x, \",\").concat(collision.y, \"]\"));\n        if (collision.moved)\n          continue;\n        if (collision.static) {\n          layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType2, cols);\n        } else {\n          layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType2, cols);\n        }\n      }\n      return layout;\n    }\n    function moveElementAwayFromCollision(layout, collidesWith, itemToMove, isUserAction, compactType2, cols) {\n      var compactH = compactType2 === \"horizontal\";\n      var compactV = compactType2 !== \"horizontal\";\n      var preventCollision = collidesWith.static;\n      if (isUserAction) {\n        isUserAction = false;\n        var fakeItem = {\n          x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n          y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n          w: itemToMove.w,\n          h: itemToMove.h,\n          i: \"-1\"\n        };\n        if (!getFirstCollision(layout, fakeItem)) {\n          log(\"Doing reverse collision on \".concat(itemToMove.i, \" up to [\").concat(fakeItem.x, \",\").concat(fakeItem.y, \"].\"));\n          return moveElement(layout, itemToMove, compactH ? fakeItem.x : void 0, compactV ? fakeItem.y : void 0, isUserAction, preventCollision, compactType2, cols);\n        }\n      }\n      return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : void 0, compactV ? itemToMove.y + 1 : void 0, isUserAction, preventCollision, compactType2, cols);\n    }\n    function perc(num) {\n      return num * 100 + \"%\";\n    }\n    function setTransform(_ref) {\n      var top = _ref.top, left = _ref.left, width = _ref.width, height = _ref.height;\n      var translate = \"translate(\".concat(left, \"px,\").concat(top, \"px)\");\n      return {\n        transform: translate,\n        WebkitTransform: translate,\n        MozTransform: translate,\n        msTransform: translate,\n        OTransform: translate,\n        width: \"\".concat(width, \"px\"),\n        height: \"\".concat(height, \"px\"),\n        position: \"absolute\"\n      };\n    }\n    function setTopLeft(_ref2) {\n      var top = _ref2.top, left = _ref2.left, width = _ref2.width, height = _ref2.height;\n      return {\n        top: \"\".concat(top, \"px\"),\n        left: \"\".concat(left, \"px\"),\n        width: \"\".concat(width, \"px\"),\n        height: \"\".concat(height, \"px\"),\n        position: \"absolute\"\n      };\n    }\n    function sortLayoutItems(layout, compactType2) {\n      if (compactType2 === \"horizontal\")\n        return sortLayoutItemsByColRow(layout);\n      if (compactType2 === \"vertical\")\n        return sortLayoutItemsByRowCol(layout);\n      else\n        return layout;\n    }\n    function sortLayoutItemsByRowCol(layout) {\n      return layout.slice(0).sort(function(a, b) {\n        if (a.y > b.y || a.y === b.y && a.x > b.x) {\n          return 1;\n        } else if (a.y === b.y && a.x === b.x) {\n          return 0;\n        }\n        return -1;\n      });\n    }\n    function sortLayoutItemsByColRow(layout) {\n      return layout.slice(0).sort(function(a, b) {\n        if (a.x > b.x || a.x === b.x && a.y > b.y) {\n          return 1;\n        }\n        return -1;\n      });\n    }\n    function synchronizeLayoutWithChildren(initialLayout, children, cols, compactType2, allowOverlap) {\n      initialLayout = initialLayout || [];\n      var layout = [];\n      _react.default.Children.forEach(children, function(child) {\n        if ((child === null || child === void 0 ? void 0 : child.key) == null)\n          return;\n        var exists = getLayoutItem(initialLayout, String(child.key));\n        if (exists) {\n          layout.push(cloneLayoutItem(exists));\n        } else {\n          if (!isProduction && child.props._grid) {\n            console.warn(\"`_grid` properties on children have been deprecated as of React 15.2. Please use `data-grid` or add your properties directly to the `layout`.\");\n          }\n          var g = child.props[\"data-grid\"] || child.props._grid;\n          if (g) {\n            if (!isProduction) {\n              validateLayout([g], \"ReactGridLayout.children\");\n            }\n            layout.push(cloneLayoutItem(_objectSpread(_objectSpread({}, g), {}, {\n              i: child.key\n            })));\n          } else {\n            layout.push(cloneLayoutItem({\n              w: 1,\n              h: 1,\n              x: 0,\n              y: bottom(layout),\n              i: String(child.key)\n            }));\n          }\n        }\n      });\n      var correctedLayout = correctBounds(layout, {\n        cols\n      });\n      return allowOverlap ? correctedLayout : compact(correctedLayout, compactType2, cols);\n    }\n    function validateLayout(layout) {\n      var contextName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"Layout\";\n      var subProps = [\"x\", \"y\", \"w\", \"h\"];\n      if (!Array.isArray(layout))\n        throw new Error(contextName + \" must be an array!\");\n      for (var i = 0, len = layout.length; i < len; i++) {\n        var item = layout[i];\n        for (var j = 0; j < subProps.length; j++) {\n          if (typeof item[subProps[j]] !== \"number\") {\n            throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].\" + subProps[j] + \" must be a number!\");\n          }\n        }\n      }\n    }\n    function compactType(props) {\n      var _ref3 = props || {}, verticalCompact = _ref3.verticalCompact, compactType2 = _ref3.compactType;\n      return verticalCompact === false ? null : compactType2;\n    }\n    function log() {\n      var _console;\n      if (!DEBUG)\n        return;\n      (_console = console).log.apply(_console, arguments);\n    }\n    var noop = function noop2() {\n    };\n    exports2.noop = noop;\n  }\n});\n\n// node_modules/react-grid-layout/build/calculateUtils.js\nvar require_calculateUtils = __commonJS({\n  \"node_modules/react-grid-layout/build/calculateUtils.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.calcGridColWidth = calcGridColWidth;\n    exports2.calcGridItemPosition = calcGridItemPosition;\n    exports2.calcGridItemWHPx = calcGridItemWHPx;\n    exports2.calcWH = calcWH;\n    exports2.calcXY = calcXY;\n    exports2.clamp = clamp;\n    function calcGridColWidth(positionParams) {\n      var margin = positionParams.margin, containerPadding = positionParams.containerPadding, containerWidth = positionParams.containerWidth, cols = positionParams.cols;\n      return (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols;\n    }\n    function calcGridItemWHPx(gridUnits, colOrRowSize, marginPx) {\n      if (!Number.isFinite(gridUnits))\n        return gridUnits;\n      return Math.round(colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx);\n    }\n    function calcGridItemPosition(positionParams, x, y, w, h, state) {\n      var margin = positionParams.margin, containerPadding = positionParams.containerPadding, rowHeight = positionParams.rowHeight;\n      var colWidth = calcGridColWidth(positionParams);\n      var out = {};\n      if (state && state.resizing) {\n        out.width = Math.round(state.resizing.width);\n        out.height = Math.round(state.resizing.height);\n      } else {\n        out.width = calcGridItemWHPx(w, colWidth, margin[0]);\n        out.height = calcGridItemWHPx(h, rowHeight, margin[1]);\n      }\n      if (state && state.dragging) {\n        out.top = Math.round(state.dragging.top);\n        out.left = Math.round(state.dragging.left);\n      } else {\n        out.top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);\n        out.left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);\n      }\n      return out;\n    }\n    function calcXY(positionParams, top, left, w, h) {\n      var margin = positionParams.margin, cols = positionParams.cols, rowHeight = positionParams.rowHeight, maxRows = positionParams.maxRows;\n      var colWidth = calcGridColWidth(positionParams);\n      var x = Math.round((left - margin[0]) / (colWidth + margin[0]));\n      var y = Math.round((top - margin[1]) / (rowHeight + margin[1]));\n      x = clamp(x, 0, cols - w);\n      y = clamp(y, 0, maxRows - h);\n      return {\n        x,\n        y\n      };\n    }\n    function calcWH(positionParams, width, height, x, y) {\n      var margin = positionParams.margin, maxRows = positionParams.maxRows, cols = positionParams.cols, rowHeight = positionParams.rowHeight;\n      var colWidth = calcGridColWidth(positionParams);\n      var w = Math.round((width + margin[0]) / (colWidth + margin[0]));\n      var h = Math.round((height + margin[1]) / (rowHeight + margin[1]));\n      w = clamp(w, 0, cols - x);\n      h = clamp(h, 0, maxRows - y);\n      return {\n        w,\n        h\n      };\n    }\n    function clamp(num, lowerBound, upperBound) {\n      return Math.max(Math.min(num, upperBound), lowerBound);\n    }\n  }\n});\n\n// node_modules/react-is/cjs/react-is.development.js\nvar require_react_is_development = __commonJS({\n  \"node_modules/react-is/cjs/react-is.development.js\"(exports2) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        var hasSymbol = typeof Symbol === \"function\" && Symbol.for;\n        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for(\"react.element\") : 60103;\n        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for(\"react.portal\") : 60106;\n        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for(\"react.fragment\") : 60107;\n        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for(\"react.strict_mode\") : 60108;\n        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for(\"react.profiler\") : 60114;\n        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for(\"react.provider\") : 60109;\n        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for(\"react.context\") : 60110;\n        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for(\"react.async_mode\") : 60111;\n        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for(\"react.concurrent_mode\") : 60111;\n        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for(\"react.forward_ref\") : 60112;\n        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for(\"react.suspense\") : 60113;\n        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for(\"react.suspense_list\") : 60120;\n        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for(\"react.memo\") : 60115;\n        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for(\"react.lazy\") : 60116;\n        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for(\"react.block\") : 60121;\n        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for(\"react.fundamental\") : 60117;\n        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for(\"react.responder\") : 60118;\n        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for(\"react.scope\") : 60119;\n        function isValidElementType(type) {\n          return typeof type === \"string\" || typeof type === \"function\" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === \"object\" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n        }\n        function typeOf(object) {\n          if (typeof object === \"object\" && object !== null) {\n            var $$typeof = object.$$typeof;\n            switch ($$typeof) {\n              case REACT_ELEMENT_TYPE:\n                var type = object.type;\n                switch (type) {\n                  case REACT_ASYNC_MODE_TYPE:\n                  case REACT_CONCURRENT_MODE_TYPE:\n                  case REACT_FRAGMENT_TYPE:\n                  case REACT_PROFILER_TYPE:\n                  case REACT_STRICT_MODE_TYPE:\n                  case REACT_SUSPENSE_TYPE:\n                    return type;\n                  default:\n                    var $$typeofType = type && type.$$typeof;\n                    switch ($$typeofType) {\n                      case REACT_CONTEXT_TYPE:\n                      case REACT_FORWARD_REF_TYPE:\n                      case REACT_LAZY_TYPE:\n                      case REACT_MEMO_TYPE:\n                      case REACT_PROVIDER_TYPE:\n                        return $$typeofType;\n                      default:\n                        return $$typeof;\n                    }\n                }\n              case REACT_PORTAL_TYPE:\n                return $$typeof;\n            }\n          }\n          return void 0;\n        }\n        var AsyncMode = REACT_ASYNC_MODE_TYPE;\n        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\n        var ContextConsumer = REACT_CONTEXT_TYPE;\n        var ContextProvider = REACT_PROVIDER_TYPE;\n        var Element = REACT_ELEMENT_TYPE;\n        var ForwardRef = REACT_FORWARD_REF_TYPE;\n        var Fragment = REACT_FRAGMENT_TYPE;\n        var Lazy = REACT_LAZY_TYPE;\n        var Memo = REACT_MEMO_TYPE;\n        var Portal = REACT_PORTAL_TYPE;\n        var Profiler = REACT_PROFILER_TYPE;\n        var StrictMode = REACT_STRICT_MODE_TYPE;\n        var Suspense = REACT_SUSPENSE_TYPE;\n        var hasWarnedAboutDeprecatedIsAsyncMode = false;\n        function isAsyncMode(object) {\n          {\n            if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n              hasWarnedAboutDeprecatedIsAsyncMode = true;\n              console[\"warn\"](\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.\");\n            }\n          }\n          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n        }\n        function isConcurrentMode(object) {\n          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n        }\n        function isContextConsumer(object) {\n          return typeOf(object) === REACT_CONTEXT_TYPE;\n        }\n        function isContextProvider(object) {\n          return typeOf(object) === REACT_PROVIDER_TYPE;\n        }\n        function isElement(object) {\n          return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n        }\n        function isForwardRef(object) {\n          return typeOf(object) === REACT_FORWARD_REF_TYPE;\n        }\n        function isFragment(object) {\n          return typeOf(object) === REACT_FRAGMENT_TYPE;\n        }\n        function isLazy(object) {\n          return typeOf(object) === REACT_LAZY_TYPE;\n        }\n        function isMemo(object) {\n          return typeOf(object) === REACT_MEMO_TYPE;\n        }\n        function isPortal(object) {\n          return typeOf(object) === REACT_PORTAL_TYPE;\n        }\n        function isProfiler(object) {\n          return typeOf(object) === REACT_PROFILER_TYPE;\n        }\n        function isStrictMode(object) {\n          return typeOf(object) === REACT_STRICT_MODE_TYPE;\n        }\n        function isSuspense(object) {\n          return typeOf(object) === REACT_SUSPENSE_TYPE;\n        }\n        exports2.AsyncMode = AsyncMode;\n        exports2.ConcurrentMode = ConcurrentMode;\n        exports2.ContextConsumer = ContextConsumer;\n        exports2.ContextProvider = ContextProvider;\n        exports2.Element = Element;\n        exports2.ForwardRef = ForwardRef;\n        exports2.Fragment = Fragment;\n        exports2.Lazy = Lazy;\n        exports2.Memo = Memo;\n        exports2.Portal = Portal;\n        exports2.Profiler = Profiler;\n        exports2.StrictMode = StrictMode;\n        exports2.Suspense = Suspense;\n        exports2.isAsyncMode = isAsyncMode;\n        exports2.isConcurrentMode = isConcurrentMode;\n        exports2.isContextConsumer = isContextConsumer;\n        exports2.isContextProvider = isContextProvider;\n        exports2.isElement = isElement;\n        exports2.isForwardRef = isForwardRef;\n        exports2.isFragment = isFragment;\n        exports2.isLazy = isLazy;\n        exports2.isMemo = isMemo;\n        exports2.isPortal = isPortal;\n        exports2.isProfiler = isProfiler;\n        exports2.isStrictMode = isStrictMode;\n        exports2.isSuspense = isSuspense;\n        exports2.isValidElementType = isValidElementType;\n        exports2.typeOf = typeOf;\n      })();\n    }\n  }\n});\n\n// node_modules/react-is/index.js\nvar require_react_is = __commonJS({\n  \"node_modules/react-is/index.js\"(exports2, module2) {\n    \"use strict\";\n    if (false) {\n      module2.exports = null;\n    } else {\n      module2.exports = require_react_is_development();\n    }\n  }\n});\n\n// node_modules/object-assign/index.js\nvar require_object_assign = __commonJS({\n  \"node_modules/object-assign/index.js\"(exports2, module2) {\n    \"use strict\";\n    var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n    function toObject(val) {\n      if (val === null || val === void 0) {\n        throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n      }\n      return Object(val);\n    }\n    function shouldUseNative() {\n      try {\n        if (!Object.assign) {\n          return false;\n        }\n        var test1 = new String(\"abc\");\n        test1[5] = \"de\";\n        if (Object.getOwnPropertyNames(test1)[0] === \"5\") {\n          return false;\n        }\n        var test2 = {};\n        for (var i = 0; i < 10; i++) {\n          test2[\"_\" + String.fromCharCode(i)] = i;\n        }\n        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {\n          return test2[n];\n        });\n        if (order2.join(\"\") !== \"0123456789\") {\n          return false;\n        }\n        var test3 = {};\n        \"abcdefghijklmnopqrst\".split(\"\").forEach(function(letter) {\n          test3[letter] = letter;\n        });\n        if (Object.keys(Object.assign({}, test3)).join(\"\") !== \"abcdefghijklmnopqrst\") {\n          return false;\n        }\n        return true;\n      } catch (err) {\n        return false;\n      }\n    }\n    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {\n      var from;\n      var to = toObject(target);\n      var symbols;\n      for (var s = 1; s < arguments.length; s++) {\n        from = Object(arguments[s]);\n        for (var key in from) {\n          if (hasOwnProperty.call(from, key)) {\n            to[key] = from[key];\n          }\n        }\n        if (getOwnPropertySymbols) {\n          symbols = getOwnPropertySymbols(from);\n          for (var i = 0; i < symbols.length; i++) {\n            if (propIsEnumerable.call(from, symbols[i])) {\n              to[symbols[i]] = from[symbols[i]];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n});\n\n// node_modules/prop-types/lib/ReactPropTypesSecret.js\nvar require_ReactPropTypesSecret = __commonJS({\n  \"node_modules/prop-types/lib/ReactPropTypesSecret.js\"(exports2, module2) {\n    \"use strict\";\n    var ReactPropTypesSecret = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n    module2.exports = ReactPropTypesSecret;\n  }\n});\n\n// node_modules/prop-types/lib/has.js\nvar require_has = __commonJS({\n  \"node_modules/prop-types/lib/has.js\"(exports2, module2) {\n    module2.exports = Function.call.bind(Object.prototype.hasOwnProperty);\n  }\n});\n\n// node_modules/prop-types/checkPropTypes.js\nvar require_checkPropTypes = __commonJS({\n  \"node_modules/prop-types/checkPropTypes.js\"(exports2, module2) {\n    \"use strict\";\n    var printWarning = function() {\n    };\n    if (true) {\n      ReactPropTypesSecret = require_ReactPropTypesSecret();\n      loggedTypeFailures = {};\n      has = require_has();\n      printWarning = function(text) {\n        var message = \"Warning: \" + text;\n        if (typeof console !== \"undefined\") {\n          console.error(message);\n        }\n        try {\n          throw new Error(message);\n        } catch (x) {\n        }\n      };\n    }\n    var ReactPropTypesSecret;\n    var loggedTypeFailures;\n    var has;\n    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n      if (true) {\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error;\n            try {\n              if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                err.name = \"Invariant Violation\";\n                throw err;\n              }\n              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n            } catch (ex) {\n              error = ex;\n            }\n            if (error && !(error instanceof Error)) {\n              printWarning((componentName || \"React class\") + \": type specification of \" + location + \" `\" + typeSpecName + \"` is invalid; the type checker function must return `null` or an `Error` but returned a \" + typeof error + \". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\");\n            }\n            if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n              loggedTypeFailures[error.message] = true;\n              var stack = getStack ? getStack() : \"\";\n              printWarning(\"Failed \" + location + \" type: \" + error.message + (stack != null ? stack : \"\"));\n            }\n          }\n        }\n      }\n    }\n    checkPropTypes.resetWarningCache = function() {\n      if (true) {\n        loggedTypeFailures = {};\n      }\n    };\n    module2.exports = checkPropTypes;\n  }\n});\n\n// node_modules/prop-types/factoryWithTypeCheckers.js\nvar require_factoryWithTypeCheckers = __commonJS({\n  \"node_modules/prop-types/factoryWithTypeCheckers.js\"(exports2, module2) {\n    \"use strict\";\n    var ReactIs = require_react_is();\n    var assign = require_object_assign();\n    var ReactPropTypesSecret = require_ReactPropTypesSecret();\n    var has = require_has();\n    var checkPropTypes = require_checkPropTypes();\n    var printWarning = function() {\n    };\n    if (true) {\n      printWarning = function(text) {\n        var message = \"Warning: \" + text;\n        if (typeof console !== \"undefined\") {\n          console.error(message);\n        }\n        try {\n          throw new Error(message);\n        } catch (x) {\n        }\n      };\n    }\n    function emptyFunctionThatReturnsNull() {\n      return null;\n    }\n    module2.exports = function(isValidElement, throwOnDirectAccess) {\n      var ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\n      var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n      function getIteratorFn(maybeIterable) {\n        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n        if (typeof iteratorFn === \"function\") {\n          return iteratorFn;\n        }\n      }\n      var ANONYMOUS = \"<<anonymous>>\";\n      var ReactPropTypes = {\n        array: createPrimitiveTypeChecker(\"array\"),\n        bigint: createPrimitiveTypeChecker(\"bigint\"),\n        bool: createPrimitiveTypeChecker(\"boolean\"),\n        func: createPrimitiveTypeChecker(\"function\"),\n        number: createPrimitiveTypeChecker(\"number\"),\n        object: createPrimitiveTypeChecker(\"object\"),\n        string: createPrimitiveTypeChecker(\"string\"),\n        symbol: createPrimitiveTypeChecker(\"symbol\"),\n        any: createAnyTypeChecker(),\n        arrayOf: createArrayOfTypeChecker,\n        element: createElementTypeChecker(),\n        elementType: createElementTypeTypeChecker(),\n        instanceOf: createInstanceTypeChecker,\n        node: createNodeChecker(),\n        objectOf: createObjectOfTypeChecker,\n        oneOf: createEnumTypeChecker,\n        oneOfType: createUnionTypeChecker,\n        shape: createShapeTypeChecker,\n        exact: createStrictShapeTypeChecker\n      };\n      function is(x, y) {\n        if (x === y) {\n          return x !== 0 || 1 / x === 1 / y;\n        } else {\n          return x !== x && y !== y;\n        }\n      }\n      function PropTypeError(message, data) {\n        this.message = message;\n        this.data = data && typeof data === \"object\" ? data : {};\n        this.stack = \"\";\n      }\n      PropTypeError.prototype = Error.prototype;\n      function createChainableTypeChecker(validate) {\n        if (true) {\n          var manualPropTypeCallCache = {};\n          var manualPropTypeWarningCount = 0;\n        }\n        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n          componentName = componentName || ANONYMOUS;\n          propFullName = propFullName || propName;\n          if (secret !== ReactPropTypesSecret) {\n            if (throwOnDirectAccess) {\n              var err = new Error(\"Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types\");\n              err.name = \"Invariant Violation\";\n              throw err;\n            } else if (typeof console !== \"undefined\") {\n              var cacheKey = componentName + \":\" + propName;\n              if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {\n                printWarning(\"You are manually calling a React.PropTypes validation function for the `\" + propFullName + \"` prop on `\" + componentName + \"`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.\");\n                manualPropTypeCallCache[cacheKey] = true;\n                manualPropTypeWarningCount++;\n              }\n            }\n          }\n          if (props[propName] == null) {\n            if (isRequired) {\n              if (props[propName] === null) {\n                return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + (\"in `\" + componentName + \"`, but its value is `null`.\"));\n              }\n              return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required in \" + (\"`\" + componentName + \"`, but its value is `undefined`.\"));\n            }\n            return null;\n          } else {\n            return validate(props, propName, componentName, location, propFullName);\n          }\n        }\n        var chainedCheckType = checkType.bind(null, false);\n        chainedCheckType.isRequired = checkType.bind(null, true);\n        return chainedCheckType;\n      }\n      function createPrimitiveTypeChecker(expectedType) {\n        function validate(props, propName, componentName, location, propFullName, secret) {\n          var propValue = props[propName];\n          var propType = getPropType(propValue);\n          if (propType !== expectedType) {\n            var preciseType = getPreciseType(propValue);\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + preciseType + \"` supplied to `\" + componentName + \"`, expected \") + (\"`\" + expectedType + \"`.\"), { expectedType });\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createAnyTypeChecker() {\n        return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n      }\n      function createArrayOfTypeChecker(typeChecker) {\n        function validate(props, propName, componentName, location, propFullName) {\n          if (typeof typeChecker !== \"function\") {\n            return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside arrayOf.\");\n          }\n          var propValue = props[propName];\n          if (!Array.isArray(propValue)) {\n            var propType = getPropType(propValue);\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an array.\"));\n          }\n          for (var i = 0; i < propValue.length; i++) {\n            var error = typeChecker(propValue, i, componentName, location, propFullName + \"[\" + i + \"]\", ReactPropTypesSecret);\n            if (error instanceof Error) {\n              return error;\n            }\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createElementTypeChecker() {\n        function validate(props, propName, componentName, location, propFullName) {\n          var propValue = props[propName];\n          if (!isValidElement(propValue)) {\n            var propType = getPropType(propValue);\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement.\"));\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createElementTypeTypeChecker() {\n        function validate(props, propName, componentName, location, propFullName) {\n          var propValue = props[propName];\n          if (!ReactIs.isValidElementType(propValue)) {\n            var propType = getPropType(propValue);\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement type.\"));\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createInstanceTypeChecker(expectedClass) {\n        function validate(props, propName, componentName, location, propFullName) {\n          if (!(props[propName] instanceof expectedClass)) {\n            var expectedClassName = expectedClass.name || ANONYMOUS;\n            var actualClassName = getClassName(props[propName]);\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + actualClassName + \"` supplied to `\" + componentName + \"`, expected \") + (\"instance of `\" + expectedClassName + \"`.\"));\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createEnumTypeChecker(expectedValues) {\n        if (!Array.isArray(expectedValues)) {\n          if (true) {\n            if (arguments.length > 1) {\n              printWarning(\"Invalid arguments supplied to oneOf, expected an array, got \" + arguments.length + \" arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\");\n            } else {\n              printWarning(\"Invalid argument supplied to oneOf, expected an array.\");\n            }\n          }\n          return emptyFunctionThatReturnsNull;\n        }\n        function validate(props, propName, componentName, location, propFullName) {\n          var propValue = props[propName];\n          for (var i = 0; i < expectedValues.length; i++) {\n            if (is(propValue, expectedValues[i])) {\n              return null;\n            }\n          }\n          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n            var type = getPreciseType(value);\n            if (type === \"symbol\") {\n              return String(value);\n            }\n            return value;\n          });\n          return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of value `\" + String(propValue) + \"` \" + (\"supplied to `\" + componentName + \"`, expected one of \" + valuesString + \".\"));\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createObjectOfTypeChecker(typeChecker) {\n        function validate(props, propName, componentName, location, propFullName) {\n          if (typeof typeChecker !== \"function\") {\n            return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside objectOf.\");\n          }\n          var propValue = props[propName];\n          var propType = getPropType(propValue);\n          if (propType !== \"object\") {\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an object.\"));\n          }\n          for (var key in propValue) {\n            if (has(propValue, key)) {\n              var error = typeChecker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n              if (error instanceof Error) {\n                return error;\n              }\n            }\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createUnionTypeChecker(arrayOfTypeCheckers) {\n        if (!Array.isArray(arrayOfTypeCheckers)) {\n          true ? printWarning(\"Invalid argument supplied to oneOfType, expected an instance of array.\") : void 0;\n          return emptyFunctionThatReturnsNull;\n        }\n        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n          var checker = arrayOfTypeCheckers[i];\n          if (typeof checker !== \"function\") {\n            printWarning(\"Invalid argument supplied to oneOfType. Expected an array of check functions, but received \" + getPostfixForTypeWarning(checker) + \" at index \" + i + \".\");\n            return emptyFunctionThatReturnsNull;\n          }\n        }\n        function validate(props, propName, componentName, location, propFullName) {\n          var expectedTypes = [];\n          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {\n            var checker2 = arrayOfTypeCheckers[i2];\n            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n            if (checkerResult == null) {\n              return null;\n            }\n            if (checkerResult.data && has(checkerResult.data, \"expectedType\")) {\n              expectedTypes.push(checkerResult.data.expectedType);\n            }\n          }\n          var expectedTypesMessage = expectedTypes.length > 0 ? \", expected one of type [\" + expectedTypes.join(\", \") + \"]\" : \"\";\n          return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`\" + expectedTypesMessage + \".\"));\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createNodeChecker() {\n        function validate(props, propName, componentName, location, propFullName) {\n          if (!isNode(props[propName])) {\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`, expected a ReactNode.\"));\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function invalidValidatorError(componentName, location, propFullName, key, type) {\n        return new PropTypeError((componentName || \"React class\") + \": \" + location + \" type `\" + propFullName + \".\" + key + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + type + \"`.\");\n      }\n      function createShapeTypeChecker(shapeTypes) {\n        function validate(props, propName, componentName, location, propFullName) {\n          var propValue = props[propName];\n          var propType = getPropType(propValue);\n          if (propType !== \"object\") {\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n          }\n          for (var key in shapeTypes) {\n            var checker = shapeTypes[key];\n            if (typeof checker !== \"function\") {\n              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n            }\n            var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n            if (error) {\n              return error;\n            }\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createStrictShapeTypeChecker(shapeTypes) {\n        function validate(props, propName, componentName, location, propFullName) {\n          var propValue = props[propName];\n          var propType = getPropType(propValue);\n          if (propType !== \"object\") {\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n          }\n          var allKeys = assign({}, props[propName], shapeTypes);\n          for (var key in allKeys) {\n            var checker = shapeTypes[key];\n            if (has(shapeTypes, key) && typeof checker !== \"function\") {\n              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n            }\n            if (!checker) {\n              return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` key `\" + key + \"` supplied to `\" + componentName + \"`.\\nBad object: \" + JSON.stringify(props[propName], null, \"  \") + \"\\nValid keys: \" + JSON.stringify(Object.keys(shapeTypes), null, \"  \"));\n            }\n            var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n            if (error) {\n              return error;\n            }\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function isNode(propValue) {\n        switch (typeof propValue) {\n          case \"number\":\n          case \"string\":\n          case \"undefined\":\n            return true;\n          case \"boolean\":\n            return !propValue;\n          case \"object\":\n            if (Array.isArray(propValue)) {\n              return propValue.every(isNode);\n            }\n            if (propValue === null || isValidElement(propValue)) {\n              return true;\n            }\n            var iteratorFn = getIteratorFn(propValue);\n            if (iteratorFn) {\n              var iterator = iteratorFn.call(propValue);\n              var step;\n              if (iteratorFn !== propValue.entries) {\n                while (!(step = iterator.next()).done) {\n                  if (!isNode(step.value)) {\n                    return false;\n                  }\n                }\n              } else {\n                while (!(step = iterator.next()).done) {\n                  var entry = step.value;\n                  if (entry) {\n                    if (!isNode(entry[1])) {\n                      return false;\n                    }\n                  }\n                }\n              }\n            } else {\n              return false;\n            }\n            return true;\n          default:\n            return false;\n        }\n      }\n      function isSymbol(propType, propValue) {\n        if (propType === \"symbol\") {\n          return true;\n        }\n        if (!propValue) {\n          return false;\n        }\n        if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n          return true;\n        }\n        if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n          return true;\n        }\n        return false;\n      }\n      function getPropType(propValue) {\n        var propType = typeof propValue;\n        if (Array.isArray(propValue)) {\n          return \"array\";\n        }\n        if (propValue instanceof RegExp) {\n          return \"object\";\n        }\n        if (isSymbol(propType, propValue)) {\n          return \"symbol\";\n        }\n        return propType;\n      }\n      function getPreciseType(propValue) {\n        if (typeof propValue === \"undefined\" || propValue === null) {\n          return \"\" + propValue;\n        }\n        var propType = getPropType(propValue);\n        if (propType === \"object\") {\n          if (propValue instanceof Date) {\n            return \"date\";\n          } else if (propValue instanceof RegExp) {\n            return \"regexp\";\n          }\n        }\n        return propType;\n      }\n      function getPostfixForTypeWarning(value) {\n        var type = getPreciseType(value);\n        switch (type) {\n          case \"array\":\n          case \"object\":\n            return \"an \" + type;\n          case \"boolean\":\n          case \"date\":\n          case \"regexp\":\n            return \"a \" + type;\n          default:\n            return type;\n        }\n      }\n      function getClassName(propValue) {\n        if (!propValue.constructor || !propValue.constructor.name) {\n          return ANONYMOUS;\n        }\n        return propValue.constructor.name;\n      }\n      ReactPropTypes.checkPropTypes = checkPropTypes;\n      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n      ReactPropTypes.PropTypes = ReactPropTypes;\n      return ReactPropTypes;\n    };\n  }\n});\n\n// node_modules/prop-types/index.js\nvar require_prop_types = __commonJS({\n  \"node_modules/prop-types/index.js\"(exports2, module2) {\n    if (true) {\n      ReactIs = require_react_is();\n      throwOnDirectAccess = true;\n      module2.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);\n    } else {\n      module2.exports = null();\n    }\n    var ReactIs;\n    var throwOnDirectAccess;\n  }\n});\n\n// node_modules/react-draggable/build/cjs/utils/shims.js\nvar require_shims = __commonJS({\n  \"node_modules/react-draggable/build/cjs/utils/shims.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.findInArray = findInArray;\n    exports2.isFunction = isFunction;\n    exports2.isNum = isNum;\n    exports2.int = int;\n    exports2.dontSetMe = dontSetMe;\n    function findInArray(array, callback) {\n      for (var i = 0, length = array.length; i < length; i++) {\n        if (callback.apply(callback, [array[i], i, array]))\n          return array[i];\n      }\n    }\n    function isFunction(func) {\n      return typeof func === \"function\" || Object.prototype.toString.call(func) === \"[object Function]\";\n    }\n    function isNum(num) {\n      return typeof num === \"number\" && !isNaN(num);\n    }\n    function int(a) {\n      return parseInt(a, 10);\n    }\n    function dontSetMe(props, propName, componentName) {\n      if (props[propName]) {\n        return new Error(\"Invalid prop \".concat(propName, \" passed to \").concat(componentName, \" - do not set this, set it on the child.\"));\n      }\n    }\n  }\n});\n\n// node_modules/react-draggable/build/cjs/utils/getPrefix.js\nvar require_getPrefix = __commonJS({\n  \"node_modules/react-draggable/build/cjs/utils/getPrefix.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.getPrefix = getPrefix;\n    exports2.browserPrefixToKey = browserPrefixToKey;\n    exports2.browserPrefixToStyle = browserPrefixToStyle;\n    exports2.default = void 0;\n    var prefixes = [\"Moz\", \"Webkit\", \"O\", \"ms\"];\n    function getPrefix() {\n      var _window$document, _window$document$docu;\n      var prop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"transform\";\n      if (typeof window === \"undefined\")\n        return \"\";\n      var style = (_window$document = window.document) === null || _window$document === void 0 ? void 0 : (_window$document$docu = _window$document.documentElement) === null || _window$document$docu === void 0 ? void 0 : _window$document$docu.style;\n      if (!style)\n        return \"\";\n      if (prop in style)\n        return \"\";\n      for (var i = 0; i < prefixes.length; i++) {\n        if (browserPrefixToKey(prop, prefixes[i]) in style)\n          return prefixes[i];\n      }\n      return \"\";\n    }\n    function browserPrefixToKey(prop, prefix) {\n      return prefix ? \"\".concat(prefix).concat(kebabToTitleCase(prop)) : prop;\n    }\n    function browserPrefixToStyle(prop, prefix) {\n      return prefix ? \"-\".concat(prefix.toLowerCase(), \"-\").concat(prop) : prop;\n    }\n    function kebabToTitleCase(str) {\n      var out = \"\";\n      var shouldCapitalize = true;\n      for (var i = 0; i < str.length; i++) {\n        if (shouldCapitalize) {\n          out += str[i].toUpperCase();\n          shouldCapitalize = false;\n        } else if (str[i] === \"-\") {\n          shouldCapitalize = true;\n        } else {\n          out += str[i];\n        }\n      }\n      return out;\n    }\n    var _default = getPrefix();\n    exports2.default = _default;\n  }\n});\n\n// node_modules/react-draggable/build/cjs/utils/domFns.js\nvar require_domFns = __commonJS({\n  \"node_modules/react-draggable/build/cjs/utils/domFns.js\"(exports2) {\n    \"use strict\";\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof2(obj2) {\n          return typeof obj2;\n        };\n      } else {\n        _typeof = function _typeof2(obj2) {\n          return obj2 && typeof Symbol === \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n        };\n      }\n      return _typeof(obj);\n    }\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.matchesSelector = matchesSelector;\n    exports2.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;\n    exports2.addEvent = addEvent;\n    exports2.removeEvent = removeEvent;\n    exports2.outerHeight = outerHeight;\n    exports2.outerWidth = outerWidth;\n    exports2.innerHeight = innerHeight;\n    exports2.innerWidth = innerWidth;\n    exports2.offsetXYFromParent = offsetXYFromParent;\n    exports2.createCSSTransform = createCSSTransform;\n    exports2.createSVGTransform = createSVGTransform;\n    exports2.getTranslation = getTranslation;\n    exports2.getTouch = getTouch;\n    exports2.getTouchIdentifier = getTouchIdentifier;\n    exports2.addUserSelectStyles = addUserSelectStyles;\n    exports2.removeUserSelectStyles = removeUserSelectStyles;\n    exports2.addClassName = addClassName;\n    exports2.removeClassName = removeClassName;\n    var _shims = require_shims();\n    var _getPrefix = _interopRequireWildcard(require_getPrefix());\n    function _getRequireWildcardCache(nodeInterop) {\n      if (typeof WeakMap !== \"function\")\n        return null;\n      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();\n      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();\n      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {\n        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;\n      })(nodeInterop);\n    }\n    function _interopRequireWildcard(obj, nodeInterop) {\n      if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n      }\n      if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n        return { default: obj };\n      }\n      var cache = _getRequireWildcardCache(nodeInterop);\n      if (cache && cache.has(obj)) {\n        return cache.get(obj);\n      }\n      var newObj = {};\n      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var key in obj) {\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n          if (desc && (desc.get || desc.set)) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n      newObj.default = obj;\n      if (cache) {\n        cache.set(obj, newObj);\n      }\n      return newObj;\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n          symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n          });\n        }\n        keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n          ownKeys(Object(source), true).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n          });\n        } else if (Object.getOwnPropertyDescriptors) {\n          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n          ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n          });\n        }\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    var matchesSelectorFunc = \"\";\n    function matchesSelector(el, selector) {\n      if (!matchesSelectorFunc) {\n        matchesSelectorFunc = (0, _shims.findInArray)([\"matches\", \"webkitMatchesSelector\", \"mozMatchesSelector\", \"msMatchesSelector\", \"oMatchesSelector\"], function(method) {\n          return (0, _shims.isFunction)(el[method]);\n        });\n      }\n      if (!(0, _shims.isFunction)(el[matchesSelectorFunc]))\n        return false;\n      return el[matchesSelectorFunc](selector);\n    }\n    function matchesSelectorAndParentsTo(el, selector, baseNode) {\n      var node = el;\n      do {\n        if (matchesSelector(node, selector))\n          return true;\n        if (node === baseNode)\n          return false;\n        node = node.parentNode;\n      } while (node);\n      return false;\n    }\n    function addEvent(el, event, handler, inputOptions) {\n      if (!el)\n        return;\n      var options = _objectSpread({\n        capture: true\n      }, inputOptions);\n      if (el.addEventListener) {\n        el.addEventListener(event, handler, options);\n      } else if (el.attachEvent) {\n        el.attachEvent(\"on\" + event, handler);\n      } else {\n        el[\"on\" + event] = handler;\n      }\n    }\n    function removeEvent(el, event, handler, inputOptions) {\n      if (!el)\n        return;\n      var options = _objectSpread({\n        capture: true\n      }, inputOptions);\n      if (el.removeEventListener) {\n        el.removeEventListener(event, handler, options);\n      } else if (el.detachEvent) {\n        el.detachEvent(\"on\" + event, handler);\n      } else {\n        el[\"on\" + event] = null;\n      }\n    }\n    function outerHeight(node) {\n      var height = node.clientHeight;\n      var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n      height += (0, _shims.int)(computedStyle.borderTopWidth);\n      height += (0, _shims.int)(computedStyle.borderBottomWidth);\n      return height;\n    }\n    function outerWidth(node) {\n      var width = node.clientWidth;\n      var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n      width += (0, _shims.int)(computedStyle.borderLeftWidth);\n      width += (0, _shims.int)(computedStyle.borderRightWidth);\n      return width;\n    }\n    function innerHeight(node) {\n      var height = node.clientHeight;\n      var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n      height -= (0, _shims.int)(computedStyle.paddingTop);\n      height -= (0, _shims.int)(computedStyle.paddingBottom);\n      return height;\n    }\n    function innerWidth(node) {\n      var width = node.clientWidth;\n      var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n      width -= (0, _shims.int)(computedStyle.paddingLeft);\n      width -= (0, _shims.int)(computedStyle.paddingRight);\n      return width;\n    }\n    function offsetXYFromParent(evt, offsetParent, scale) {\n      var isBody = offsetParent === offsetParent.ownerDocument.body;\n      var offsetParentRect = isBody ? {\n        left: 0,\n        top: 0\n      } : offsetParent.getBoundingClientRect();\n      var x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;\n      var y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;\n      return {\n        x,\n        y\n      };\n    }\n    function createCSSTransform(controlPos, positionOffset) {\n      var translation = getTranslation(controlPos, positionOffset, \"px\");\n      return _defineProperty({}, (0, _getPrefix.browserPrefixToKey)(\"transform\", _getPrefix.default), translation);\n    }\n    function createSVGTransform(controlPos, positionOffset) {\n      var translation = getTranslation(controlPos, positionOffset, \"\");\n      return translation;\n    }\n    function getTranslation(_ref2, positionOffset, unitSuffix) {\n      var x = _ref2.x, y = _ref2.y;\n      var translation = \"translate(\".concat(x).concat(unitSuffix, \",\").concat(y).concat(unitSuffix, \")\");\n      if (positionOffset) {\n        var defaultX = \"\".concat(typeof positionOffset.x === \"string\" ? positionOffset.x : positionOffset.x + unitSuffix);\n        var defaultY = \"\".concat(typeof positionOffset.y === \"string\" ? positionOffset.y : positionOffset.y + unitSuffix);\n        translation = \"translate(\".concat(defaultX, \", \").concat(defaultY, \")\") + translation;\n      }\n      return translation;\n    }\n    function getTouch(e, identifier) {\n      return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, function(t) {\n        return identifier === t.identifier;\n      }) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, function(t) {\n        return identifier === t.identifier;\n      });\n    }\n    function getTouchIdentifier(e) {\n      if (e.targetTouches && e.targetTouches[0])\n        return e.targetTouches[0].identifier;\n      if (e.changedTouches && e.changedTouches[0])\n        return e.changedTouches[0].identifier;\n    }\n    function addUserSelectStyles(doc) {\n      if (!doc)\n        return;\n      var styleEl = doc.getElementById(\"react-draggable-style-el\");\n      if (!styleEl) {\n        styleEl = doc.createElement(\"style\");\n        styleEl.type = \"text/css\";\n        styleEl.id = \"react-draggable-style-el\";\n        styleEl.innerHTML = \".react-draggable-transparent-selection *::-moz-selection {all: inherit;}\\n\";\n        styleEl.innerHTML += \".react-draggable-transparent-selection *::selection {all: inherit;}\\n\";\n        doc.getElementsByTagName(\"head\")[0].appendChild(styleEl);\n      }\n      if (doc.body)\n        addClassName(doc.body, \"react-draggable-transparent-selection\");\n    }\n    function removeUserSelectStyles(doc) {\n      if (!doc)\n        return;\n      try {\n        if (doc.body)\n          removeClassName(doc.body, \"react-draggable-transparent-selection\");\n        if (doc.selection) {\n          doc.selection.empty();\n        } else {\n          var selection = (doc.defaultView || window).getSelection();\n          if (selection && selection.type !== \"Caret\") {\n            selection.removeAllRanges();\n          }\n        }\n      } catch (e) {\n      }\n    }\n    function addClassName(el, className) {\n      if (el.classList) {\n        el.classList.add(className);\n      } else {\n        if (!el.className.match(new RegExp(\"(?:^|\\\\s)\".concat(className, \"(?!\\\\S)\")))) {\n          el.className += \" \".concat(className);\n        }\n      }\n    }\n    function removeClassName(el, className) {\n      if (el.classList) {\n        el.classList.remove(className);\n      } else {\n        el.className = el.className.replace(new RegExp(\"(?:^|\\\\s)\".concat(className, \"(?!\\\\S)\"), \"g\"), \"\");\n      }\n    }\n  }\n});\n\n// node_modules/react-draggable/build/cjs/utils/positionFns.js\nvar require_positionFns = __commonJS({\n  \"node_modules/react-draggable/build/cjs/utils/positionFns.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.getBoundPosition = getBoundPosition;\n    exports2.snapToGrid = snapToGrid;\n    exports2.canDragX = canDragX;\n    exports2.canDragY = canDragY;\n    exports2.getControlPosition = getControlPosition;\n    exports2.createCoreData = createCoreData;\n    exports2.createDraggableData = createDraggableData;\n    var _shims = require_shims();\n    var _domFns = require_domFns();\n    function getBoundPosition(draggable, x, y) {\n      if (!draggable.props.bounds)\n        return [x, y];\n      var bounds = draggable.props.bounds;\n      bounds = typeof bounds === \"string\" ? bounds : cloneBounds(bounds);\n      var node = findDOMNode(draggable);\n      if (typeof bounds === \"string\") {\n        var ownerDocument = node.ownerDocument;\n        var ownerWindow = ownerDocument.defaultView;\n        var boundNode;\n        if (bounds === \"parent\") {\n          boundNode = node.parentNode;\n        } else {\n          boundNode = ownerDocument.querySelector(bounds);\n        }\n        if (!(boundNode instanceof ownerWindow.HTMLElement)) {\n          throw new Error('Bounds selector \"' + bounds + '\" could not find an element.');\n        }\n        var boundNodeEl = boundNode;\n        var nodeStyle = ownerWindow.getComputedStyle(node);\n        var boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);\n        bounds = {\n          left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),\n          top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),\n          right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),\n          bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)\n        };\n      }\n      if ((0, _shims.isNum)(bounds.right))\n        x = Math.min(x, bounds.right);\n      if ((0, _shims.isNum)(bounds.bottom))\n        y = Math.min(y, bounds.bottom);\n      if ((0, _shims.isNum)(bounds.left))\n        x = Math.max(x, bounds.left);\n      if ((0, _shims.isNum)(bounds.top))\n        y = Math.max(y, bounds.top);\n      return [x, y];\n    }\n    function snapToGrid(grid, pendingX, pendingY) {\n      var x = Math.round(pendingX / grid[0]) * grid[0];\n      var y = Math.round(pendingY / grid[1]) * grid[1];\n      return [x, y];\n    }\n    function canDragX(draggable) {\n      return draggable.props.axis === \"both\" || draggable.props.axis === \"x\";\n    }\n    function canDragY(draggable) {\n      return draggable.props.axis === \"both\" || draggable.props.axis === \"y\";\n    }\n    function getControlPosition(e, touchIdentifier, draggableCore) {\n      var touchObj = typeof touchIdentifier === \"number\" ? (0, _domFns.getTouch)(e, touchIdentifier) : null;\n      if (typeof touchIdentifier === \"number\" && !touchObj)\n        return null;\n      var node = findDOMNode(draggableCore);\n      var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;\n      return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);\n    }\n    function createCoreData(draggable, x, y) {\n      var state = draggable.state;\n      var isStart = !(0, _shims.isNum)(state.lastX);\n      var node = findDOMNode(draggable);\n      if (isStart) {\n        return {\n          node,\n          deltaX: 0,\n          deltaY: 0,\n          lastX: x,\n          lastY: y,\n          x,\n          y\n        };\n      } else {\n        return {\n          node,\n          deltaX: x - state.lastX,\n          deltaY: y - state.lastY,\n          lastX: state.lastX,\n          lastY: state.lastY,\n          x,\n          y\n        };\n      }\n    }\n    function createDraggableData(draggable, coreData) {\n      var scale = draggable.props.scale;\n      return {\n        node: coreData.node,\n        x: draggable.state.x + coreData.deltaX / scale,\n        y: draggable.state.y + coreData.deltaY / scale,\n        deltaX: coreData.deltaX / scale,\n        deltaY: coreData.deltaY / scale,\n        lastX: draggable.state.x,\n        lastY: draggable.state.y\n      };\n    }\n    function cloneBounds(bounds) {\n      return {\n        left: bounds.left,\n        top: bounds.top,\n        right: bounds.right,\n        bottom: bounds.bottom\n      };\n    }\n    function findDOMNode(draggable) {\n      var node = draggable.findDOMNode();\n      if (!node) {\n        throw new Error(\"<DraggableCore>: Unmounted during event!\");\n      }\n      return node;\n    }\n  }\n});\n\n// node_modules/react-draggable/build/cjs/utils/log.js\nvar require_log = __commonJS({\n  \"node_modules/react-draggable/build/cjs/utils/log.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.default = log;\n    function log() {\n      var _console;\n      if (void 0)\n        (_console = console).log.apply(_console, arguments);\n    }\n  }\n});\n\n// node_modules/react-draggable/build/cjs/DraggableCore.js\nvar require_DraggableCore = __commonJS({\n  \"node_modules/react-draggable/build/cjs/DraggableCore.js\"(exports2) {\n    \"use strict\";\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof2(obj2) {\n          return typeof obj2;\n        };\n      } else {\n        _typeof = function _typeof2(obj2) {\n          return obj2 && typeof Symbol === \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n        };\n      }\n      return _typeof(obj);\n    }\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.default = void 0;\n    var React3 = _interopRequireWildcard(require(\"react\"));\n    var _propTypes = _interopRequireDefault(require_prop_types());\n    var _reactDom = _interopRequireDefault(require(\"react-dom\"));\n    var _domFns = require_domFns();\n    var _positionFns = require_positionFns();\n    var _shims = require_shims();\n    var _log = _interopRequireDefault(require_log());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n    function _getRequireWildcardCache(nodeInterop) {\n      if (typeof WeakMap !== \"function\")\n        return null;\n      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();\n      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();\n      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {\n        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;\n      })(nodeInterop);\n    }\n    function _interopRequireWildcard(obj, nodeInterop) {\n      if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n      }\n      if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n        return { default: obj };\n      }\n      var cache = _getRequireWildcardCache(nodeInterop);\n      if (cache && cache.has(obj)) {\n        return cache.get(obj);\n      }\n      var newObj = {};\n      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var key in obj) {\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n          if (desc && (desc.get || desc.set)) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n      newObj.default = obj;\n      if (cache) {\n        cache.set(obj, newObj);\n      }\n      return newObj;\n    }\n    function _slicedToArray(arr, i) {\n      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n    }\n    function _nonIterableRest() {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    function _unsupportedIterableToArray(o, minLen) {\n      if (!o)\n        return;\n      if (typeof o === \"string\")\n        return _arrayLikeToArray(o, minLen);\n      var n = Object.prototype.toString.call(o).slice(8, -1);\n      if (n === \"Object\" && o.constructor)\n        n = o.constructor.name;\n      if (n === \"Map\" || n === \"Set\")\n        return Array.from(o);\n      if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n        return _arrayLikeToArray(o, minLen);\n    }\n    function _arrayLikeToArray(arr, len) {\n      if (len == null || len > arr.length)\n        len = arr.length;\n      for (var i = 0, arr2 = new Array(len); i < len; i++) {\n        arr2[i] = arr[i];\n      }\n      return arr2;\n    }\n    function _iterableToArrayLimit(arr, i) {\n      var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n      if (_i == null)\n        return;\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _s, _e;\n      try {\n        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n          if (i && _arr.length === i)\n            break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i[\"return\"] != null)\n            _i[\"return\"]();\n        } finally {\n          if (_d)\n            throw _e;\n        }\n      }\n      return _arr;\n    }\n    function _arrayWithHoles(arr) {\n      if (Array.isArray(arr))\n        return arr;\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n          descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps)\n        _defineProperties(Constructor, staticProps);\n      return Constructor;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });\n      if (superClass)\n        _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _createSuper(Derived) {\n      var hasNativeReflectConstruct = _isNativeReflectConstruct();\n      return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n          var NewTarget = _getPrototypeOf(this).constructor;\n          result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n          result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n      };\n    }\n    function _possibleConstructorReturn(self2, call) {\n      if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n      } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n      }\n      return _assertThisInitialized(self2);\n    }\n    function _assertThisInitialized(self2) {\n      if (self2 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self2;\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct)\n        return false;\n      if (Reflect.construct.sham)\n        return false;\n      if (typeof Proxy === \"function\")\n        return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      };\n      return _getPrototypeOf(o);\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    var eventsFor = {\n      touch: {\n        start: \"touchstart\",\n        move: \"touchmove\",\n        stop: \"touchend\"\n      },\n      mouse: {\n        start: \"mousedown\",\n        move: \"mousemove\",\n        stop: \"mouseup\"\n      }\n    };\n    var dragEventFor = eventsFor.mouse;\n    var DraggableCore = /* @__PURE__ */ function(_React$Component) {\n      _inherits(DraggableCore2, _React$Component);\n      var _super = _createSuper(DraggableCore2);\n      function DraggableCore2() {\n        var _this;\n        _classCallCheck(this, DraggableCore2);\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        _this = _super.call.apply(_super, [this].concat(args));\n        _defineProperty(_assertThisInitialized(_this), \"state\", {\n          dragging: false,\n          lastX: NaN,\n          lastY: NaN,\n          touchIdentifier: null\n        });\n        _defineProperty(_assertThisInitialized(_this), \"mounted\", false);\n        _defineProperty(_assertThisInitialized(_this), \"handleDragStart\", function(e) {\n          _this.props.onMouseDown(e);\n          if (!_this.props.allowAnyClick && typeof e.button === \"number\" && e.button !== 0)\n            return false;\n          var thisNode = _this.findDOMNode();\n          if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {\n            throw new Error(\"<DraggableCore> not mounted on DragStart!\");\n          }\n          var ownerDocument = thisNode.ownerDocument;\n          if (_this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || _this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.handle, thisNode) || _this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.cancel, thisNode)) {\n            return;\n          }\n          if (e.type === \"touchstart\")\n            e.preventDefault();\n          var touchIdentifier = (0, _domFns.getTouchIdentifier)(e);\n          _this.setState({\n            touchIdentifier\n          });\n          var position = (0, _positionFns.getControlPosition)(e, touchIdentifier, _assertThisInitialized(_this));\n          if (position == null)\n            return;\n          var x = position.x, y = position.y;\n          var coreEvent = (0, _positionFns.createCoreData)(_assertThisInitialized(_this), x, y);\n          (0, _log.default)(\"DraggableCore: handleDragStart: %j\", coreEvent);\n          (0, _log.default)(\"calling\", _this.props.onStart);\n          var shouldUpdate = _this.props.onStart(e, coreEvent);\n          if (shouldUpdate === false || _this.mounted === false)\n            return;\n          if (_this.props.enableUserSelectHack)\n            (0, _domFns.addUserSelectStyles)(ownerDocument);\n          _this.setState({\n            dragging: true,\n            lastX: x,\n            lastY: y\n          });\n          (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, _this.handleDrag);\n          (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, _this.handleDragStop);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"handleDrag\", function(e) {\n          var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _assertThisInitialized(_this));\n          if (position == null)\n            return;\n          var x = position.x, y = position.y;\n          if (Array.isArray(_this.props.grid)) {\n            var deltaX = x - _this.state.lastX, deltaY = y - _this.state.lastY;\n            var _snapToGrid = (0, _positionFns.snapToGrid)(_this.props.grid, deltaX, deltaY);\n            var _snapToGrid2 = _slicedToArray(_snapToGrid, 2);\n            deltaX = _snapToGrid2[0];\n            deltaY = _snapToGrid2[1];\n            if (!deltaX && !deltaY)\n              return;\n            x = _this.state.lastX + deltaX, y = _this.state.lastY + deltaY;\n          }\n          var coreEvent = (0, _positionFns.createCoreData)(_assertThisInitialized(_this), x, y);\n          (0, _log.default)(\"DraggableCore: handleDrag: %j\", coreEvent);\n          var shouldUpdate = _this.props.onDrag(e, coreEvent);\n          if (shouldUpdate === false || _this.mounted === false) {\n            try {\n              _this.handleDragStop(new MouseEvent(\"mouseup\"));\n            } catch (err) {\n              var event = document.createEvent(\"MouseEvents\");\n              event.initMouseEvent(\"mouseup\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n              _this.handleDragStop(event);\n            }\n            return;\n          }\n          _this.setState({\n            lastX: x,\n            lastY: y\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"handleDragStop\", function(e) {\n          if (!_this.state.dragging)\n            return;\n          var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _assertThisInitialized(_this));\n          if (position == null)\n            return;\n          var x = position.x, y = position.y;\n          var coreEvent = (0, _positionFns.createCoreData)(_assertThisInitialized(_this), x, y);\n          var shouldContinue = _this.props.onStop(e, coreEvent);\n          if (shouldContinue === false || _this.mounted === false)\n            return false;\n          var thisNode = _this.findDOMNode();\n          if (thisNode) {\n            if (_this.props.enableUserSelectHack)\n              (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);\n          }\n          (0, _log.default)(\"DraggableCore: handleDragStop: %j\", coreEvent);\n          _this.setState({\n            dragging: false,\n            lastX: NaN,\n            lastY: NaN\n          });\n          if (thisNode) {\n            (0, _log.default)(\"DraggableCore: Removing handlers\");\n            (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, _this.handleDrag);\n            (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, _this.handleDragStop);\n          }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onMouseDown\", function(e) {\n          dragEventFor = eventsFor.mouse;\n          return _this.handleDragStart(e);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onMouseUp\", function(e) {\n          dragEventFor = eventsFor.mouse;\n          return _this.handleDragStop(e);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onTouchStart\", function(e) {\n          dragEventFor = eventsFor.touch;\n          return _this.handleDragStart(e);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onTouchEnd\", function(e) {\n          dragEventFor = eventsFor.touch;\n          return _this.handleDragStop(e);\n        });\n        return _this;\n      }\n      _createClass(DraggableCore2, [{\n        key: \"componentDidMount\",\n        value: function componentDidMount() {\n          this.mounted = true;\n          var thisNode = this.findDOMNode();\n          if (thisNode) {\n            (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n              passive: false\n            });\n          }\n        }\n      }, {\n        key: \"componentWillUnmount\",\n        value: function componentWillUnmount() {\n          this.mounted = false;\n          var thisNode = this.findDOMNode();\n          if (thisNode) {\n            var ownerDocument = thisNode.ownerDocument;\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);\n            (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n              passive: false\n            });\n            if (this.props.enableUserSelectHack)\n              (0, _domFns.removeUserSelectStyles)(ownerDocument);\n          }\n        }\n      }, {\n        key: \"findDOMNode\",\n        value: function findDOMNode() {\n          var _this$props$nodeRef$c, _this$props, _this$props$nodeRef;\n          return (_this$props$nodeRef$c = (_this$props = this.props) === null || _this$props === void 0 ? void 0 : (_this$props$nodeRef = _this$props.nodeRef) === null || _this$props$nodeRef === void 0 ? void 0 : _this$props$nodeRef.current) !== null && _this$props$nodeRef$c !== void 0 ? _this$props$nodeRef$c : _reactDom.default.findDOMNode(this);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          return /* @__PURE__ */ React3.cloneElement(React3.Children.only(this.props.children), {\n            onMouseDown: this.onMouseDown,\n            onMouseUp: this.onMouseUp,\n            onTouchEnd: this.onTouchEnd\n          });\n        }\n      }]);\n      return DraggableCore2;\n    }(React3.Component);\n    exports2.default = DraggableCore;\n    _defineProperty(DraggableCore, \"displayName\", \"DraggableCore\");\n    _defineProperty(DraggableCore, \"propTypes\", {\n      allowAnyClick: _propTypes.default.bool,\n      disabled: _propTypes.default.bool,\n      enableUserSelectHack: _propTypes.default.bool,\n      offsetParent: function offsetParent(props, propName) {\n        if (props[propName] && props[propName].nodeType !== 1) {\n          throw new Error(\"Draggable's offsetParent must be a DOM Node.\");\n        }\n      },\n      grid: _propTypes.default.arrayOf(_propTypes.default.number),\n      handle: _propTypes.default.string,\n      cancel: _propTypes.default.string,\n      nodeRef: _propTypes.default.object,\n      onStart: _propTypes.default.func,\n      onDrag: _propTypes.default.func,\n      onStop: _propTypes.default.func,\n      onMouseDown: _propTypes.default.func,\n      scale: _propTypes.default.number,\n      className: _shims.dontSetMe,\n      style: _shims.dontSetMe,\n      transform: _shims.dontSetMe\n    });\n    _defineProperty(DraggableCore, \"defaultProps\", {\n      allowAnyClick: false,\n      disabled: false,\n      enableUserSelectHack: true,\n      onStart: function onStart() {\n      },\n      onDrag: function onDrag() {\n      },\n      onStop: function onStop() {\n      },\n      onMouseDown: function onMouseDown() {\n      },\n      scale: 1\n    });\n  }\n});\n\n// node_modules/react-draggable/build/cjs/Draggable.js\nvar require_Draggable = __commonJS({\n  \"node_modules/react-draggable/build/cjs/Draggable.js\"(exports2) {\n    \"use strict\";\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof2(obj2) {\n          return typeof obj2;\n        };\n      } else {\n        _typeof = function _typeof2(obj2) {\n          return obj2 && typeof Symbol === \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n        };\n      }\n      return _typeof(obj);\n    }\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    Object.defineProperty(exports2, \"DraggableCore\", {\n      enumerable: true,\n      get: function get() {\n        return _DraggableCore.default;\n      }\n    });\n    exports2.default = void 0;\n    var React3 = _interopRequireWildcard(require(\"react\"));\n    var _propTypes = _interopRequireDefault(require_prop_types());\n    var _reactDom = _interopRequireDefault(require(\"react-dom\"));\n    var _clsx2 = _interopRequireDefault(require_clsx());\n    var _domFns = require_domFns();\n    var _positionFns = require_positionFns();\n    var _shims = require_shims();\n    var _DraggableCore = _interopRequireDefault(require_DraggableCore());\n    var _log = _interopRequireDefault(require_log());\n    var _excluded = [\"axis\", \"bounds\", \"children\", \"defaultPosition\", \"defaultClassName\", \"defaultClassNameDragging\", \"defaultClassNameDragged\", \"position\", \"positionOffset\", \"scale\"];\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n    function _getRequireWildcardCache(nodeInterop) {\n      if (typeof WeakMap !== \"function\")\n        return null;\n      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();\n      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();\n      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {\n        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;\n      })(nodeInterop);\n    }\n    function _interopRequireWildcard(obj, nodeInterop) {\n      if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n      }\n      if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n        return { default: obj };\n      }\n      var cache = _getRequireWildcardCache(nodeInterop);\n      if (cache && cache.has(obj)) {\n        return cache.get(obj);\n      }\n      var newObj = {};\n      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var key in obj) {\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n          if (desc && (desc.get || desc.set)) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n      newObj.default = obj;\n      if (cache) {\n        cache.set(obj, newObj);\n      }\n      return newObj;\n    }\n    function _extends() {\n      _extends = Object.assign || function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      };\n      return _extends.apply(this, arguments);\n    }\n    function _objectWithoutProperties(source, excluded) {\n      if (source == null)\n        return {};\n      var target = _objectWithoutPropertiesLoose(source, excluded);\n      var key, i;\n      if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for (i = 0; i < sourceSymbolKeys.length; i++) {\n          key = sourceSymbolKeys[i];\n          if (excluded.indexOf(key) >= 0)\n            continue;\n          if (!Object.prototype.propertyIsEnumerable.call(source, key))\n            continue;\n          target[key] = source[key];\n        }\n      }\n      return target;\n    }\n    function _objectWithoutPropertiesLoose(source, excluded) {\n      if (source == null)\n        return {};\n      var target = {};\n      var sourceKeys = Object.keys(source);\n      var key, i;\n      for (i = 0; i < sourceKeys.length; i++) {\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0)\n          continue;\n        target[key] = source[key];\n      }\n      return target;\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n          symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n          });\n        }\n        keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n          ownKeys(Object(source), true).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n          });\n        } else if (Object.getOwnPropertyDescriptors) {\n          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n          ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n          });\n        }\n      }\n      return target;\n    }\n    function _slicedToArray(arr, i) {\n      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n    }\n    function _nonIterableRest() {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    function _unsupportedIterableToArray(o, minLen) {\n      if (!o)\n        return;\n      if (typeof o === \"string\")\n        return _arrayLikeToArray(o, minLen);\n      var n = Object.prototype.toString.call(o).slice(8, -1);\n      if (n === \"Object\" && o.constructor)\n        n = o.constructor.name;\n      if (n === \"Map\" || n === \"Set\")\n        return Array.from(o);\n      if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n        return _arrayLikeToArray(o, minLen);\n    }\n    function _arrayLikeToArray(arr, len) {\n      if (len == null || len > arr.length)\n        len = arr.length;\n      for (var i = 0, arr2 = new Array(len); i < len; i++) {\n        arr2[i] = arr[i];\n      }\n      return arr2;\n    }\n    function _iterableToArrayLimit(arr, i) {\n      var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n      if (_i == null)\n        return;\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _s, _e;\n      try {\n        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n          if (i && _arr.length === i)\n            break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i[\"return\"] != null)\n            _i[\"return\"]();\n        } finally {\n          if (_d)\n            throw _e;\n        }\n      }\n      return _arr;\n    }\n    function _arrayWithHoles(arr) {\n      if (Array.isArray(arr))\n        return arr;\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n          descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps)\n        _defineProperties(Constructor, staticProps);\n      return Constructor;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });\n      if (superClass)\n        _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _createSuper(Derived) {\n      var hasNativeReflectConstruct = _isNativeReflectConstruct();\n      return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n          var NewTarget = _getPrototypeOf(this).constructor;\n          result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n          result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n      };\n    }\n    function _possibleConstructorReturn(self2, call) {\n      if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n      } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n      }\n      return _assertThisInitialized(self2);\n    }\n    function _assertThisInitialized(self2) {\n      if (self2 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self2;\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct)\n        return false;\n      if (Reflect.construct.sham)\n        return false;\n      if (typeof Proxy === \"function\")\n        return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      };\n      return _getPrototypeOf(o);\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    var Draggable = /* @__PURE__ */ function(_React$Component) {\n      _inherits(Draggable2, _React$Component);\n      var _super = _createSuper(Draggable2);\n      function Draggable2(props) {\n        var _this;\n        _classCallCheck(this, Draggable2);\n        _this = _super.call(this, props);\n        _defineProperty(_assertThisInitialized(_this), \"onDragStart\", function(e, coreData) {\n          (0, _log.default)(\"Draggable: onDragStart: %j\", coreData);\n          var shouldStart = _this.props.onStart(e, (0, _positionFns.createDraggableData)(_assertThisInitialized(_this), coreData));\n          if (shouldStart === false)\n            return false;\n          _this.setState({\n            dragging: true,\n            dragged: true\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onDrag\", function(e, coreData) {\n          if (!_this.state.dragging)\n            return false;\n          (0, _log.default)(\"Draggable: onDrag: %j\", coreData);\n          var uiData = (0, _positionFns.createDraggableData)(_assertThisInitialized(_this), coreData);\n          var newState = {\n            x: uiData.x,\n            y: uiData.y\n          };\n          if (_this.props.bounds) {\n            var x = newState.x, y = newState.y;\n            newState.x += _this.state.slackX;\n            newState.y += _this.state.slackY;\n            var _getBoundPosition = (0, _positionFns.getBoundPosition)(_assertThisInitialized(_this), newState.x, newState.y), _getBoundPosition2 = _slicedToArray(_getBoundPosition, 2), newStateX = _getBoundPosition2[0], newStateY = _getBoundPosition2[1];\n            newState.x = newStateX;\n            newState.y = newStateY;\n            newState.slackX = _this.state.slackX + (x - newState.x);\n            newState.slackY = _this.state.slackY + (y - newState.y);\n            uiData.x = newState.x;\n            uiData.y = newState.y;\n            uiData.deltaX = newState.x - _this.state.x;\n            uiData.deltaY = newState.y - _this.state.y;\n          }\n          var shouldUpdate = _this.props.onDrag(e, uiData);\n          if (shouldUpdate === false)\n            return false;\n          _this.setState(newState);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onDragStop\", function(e, coreData) {\n          if (!_this.state.dragging)\n            return false;\n          var shouldContinue = _this.props.onStop(e, (0, _positionFns.createDraggableData)(_assertThisInitialized(_this), coreData));\n          if (shouldContinue === false)\n            return false;\n          (0, _log.default)(\"Draggable: onDragStop: %j\", coreData);\n          var newState = {\n            dragging: false,\n            slackX: 0,\n            slackY: 0\n          };\n          var controlled = Boolean(_this.props.position);\n          if (controlled) {\n            var _this$props$position = _this.props.position, x = _this$props$position.x, y = _this$props$position.y;\n            newState.x = x;\n            newState.y = y;\n          }\n          _this.setState(newState);\n        });\n        _this.state = {\n          dragging: false,\n          dragged: false,\n          x: props.position ? props.position.x : props.defaultPosition.x,\n          y: props.position ? props.position.y : props.defaultPosition.y,\n          prevPropsPosition: _objectSpread({}, props.position),\n          slackX: 0,\n          slackY: 0,\n          isElementSVG: false\n        };\n        if (props.position && !(props.onDrag || props.onStop)) {\n          console.warn(\"A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.\");\n        }\n        return _this;\n      }\n      _createClass(Draggable2, [{\n        key: \"componentDidMount\",\n        value: function componentDidMount() {\n          if (typeof window.SVGElement !== \"undefined\" && this.findDOMNode() instanceof window.SVGElement) {\n            this.setState({\n              isElementSVG: true\n            });\n          }\n        }\n      }, {\n        key: \"componentWillUnmount\",\n        value: function componentWillUnmount() {\n          this.setState({\n            dragging: false\n          });\n        }\n      }, {\n        key: \"findDOMNode\",\n        value: function findDOMNode() {\n          var _this$props$nodeRef$c, _this$props, _this$props$nodeRef;\n          return (_this$props$nodeRef$c = (_this$props = this.props) === null || _this$props === void 0 ? void 0 : (_this$props$nodeRef = _this$props.nodeRef) === null || _this$props$nodeRef === void 0 ? void 0 : _this$props$nodeRef.current) !== null && _this$props$nodeRef$c !== void 0 ? _this$props$nodeRef$c : _reactDom.default.findDOMNode(this);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var _clsx;\n          var _this$props2 = this.props, axis = _this$props2.axis, bounds = _this$props2.bounds, children = _this$props2.children, defaultPosition = _this$props2.defaultPosition, defaultClassName = _this$props2.defaultClassName, defaultClassNameDragging = _this$props2.defaultClassNameDragging, defaultClassNameDragged = _this$props2.defaultClassNameDragged, position = _this$props2.position, positionOffset = _this$props2.positionOffset, scale = _this$props2.scale, draggableCoreProps = _objectWithoutProperties(_this$props2, _excluded);\n          var style = {};\n          var svgTransform = null;\n          var controlled = Boolean(position);\n          var draggable = !controlled || this.state.dragging;\n          var validPosition = position || defaultPosition;\n          var transformOpts = {\n            x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,\n            y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y\n          };\n          if (this.state.isElementSVG) {\n            svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);\n          } else {\n            style = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);\n          }\n          var className = (0, _clsx2.default)(children.props.className || \"\", defaultClassName, (_clsx = {}, _defineProperty(_clsx, defaultClassNameDragging, this.state.dragging), _defineProperty(_clsx, defaultClassNameDragged, this.state.dragged), _clsx));\n          return /* @__PURE__ */ React3.createElement(_DraggableCore.default, _extends({}, draggableCoreProps, {\n            onStart: this.onDragStart,\n            onDrag: this.onDrag,\n            onStop: this.onDragStop\n          }), /* @__PURE__ */ React3.cloneElement(React3.Children.only(children), {\n            className,\n            style: _objectSpread(_objectSpread({}, children.props.style), style),\n            transform: svgTransform\n          }));\n        }\n      }], [{\n        key: \"getDerivedStateFromProps\",\n        value: function getDerivedStateFromProps(_ref, _ref2) {\n          var position = _ref.position;\n          var prevPropsPosition = _ref2.prevPropsPosition;\n          if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {\n            (0, _log.default)(\"Draggable: getDerivedStateFromProps %j\", {\n              position,\n              prevPropsPosition\n            });\n            return {\n              x: position.x,\n              y: position.y,\n              prevPropsPosition: _objectSpread({}, position)\n            };\n          }\n          return null;\n        }\n      }]);\n      return Draggable2;\n    }(React3.Component);\n    exports2.default = Draggable;\n    _defineProperty(Draggable, \"displayName\", \"Draggable\");\n    _defineProperty(Draggable, \"propTypes\", _objectSpread(_objectSpread({}, _DraggableCore.default.propTypes), {}, {\n      axis: _propTypes.default.oneOf([\"both\", \"x\", \"y\", \"none\"]),\n      bounds: _propTypes.default.oneOfType([_propTypes.default.shape({\n        left: _propTypes.default.number,\n        right: _propTypes.default.number,\n        top: _propTypes.default.number,\n        bottom: _propTypes.default.number\n      }), _propTypes.default.string, _propTypes.default.oneOf([false])]),\n      defaultClassName: _propTypes.default.string,\n      defaultClassNameDragging: _propTypes.default.string,\n      defaultClassNameDragged: _propTypes.default.string,\n      defaultPosition: _propTypes.default.shape({\n        x: _propTypes.default.number,\n        y: _propTypes.default.number\n      }),\n      positionOffset: _propTypes.default.shape({\n        x: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),\n        y: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])\n      }),\n      position: _propTypes.default.shape({\n        x: _propTypes.default.number,\n        y: _propTypes.default.number\n      }),\n      className: _shims.dontSetMe,\n      style: _shims.dontSetMe,\n      transform: _shims.dontSetMe\n    }));\n    _defineProperty(Draggable, \"defaultProps\", _objectSpread(_objectSpread({}, _DraggableCore.default.defaultProps), {}, {\n      axis: \"both\",\n      bounds: false,\n      defaultClassName: \"react-draggable\",\n      defaultClassNameDragging: \"react-draggable-dragging\",\n      defaultClassNameDragged: \"react-draggable-dragged\",\n      defaultPosition: {\n        x: 0,\n        y: 0\n      },\n      scale: 1\n    }));\n  }\n});\n\n// node_modules/react-draggable/build/cjs/cjs.js\nvar require_cjs2 = __commonJS({\n  \"node_modules/react-draggable/build/cjs/cjs.js\"(exports2, module2) {\n    \"use strict\";\n    var _require = require_Draggable();\n    var Draggable = _require.default;\n    var DraggableCore = _require.DraggableCore;\n    module2.exports = Draggable;\n    module2.exports.default = Draggable;\n    module2.exports.DraggableCore = DraggableCore;\n  }\n});\n\n// node_modules/react-resizable/build/utils.js\nvar require_utils3 = __commonJS({\n  \"node_modules/react-resizable/build/utils.js\"(exports2) {\n    \"use strict\";\n    exports2.__esModule = true;\n    exports2.cloneElement = cloneElement;\n    var _react = _interopRequireDefault(require(\"react\"));\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n          symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n          });\n        }\n        keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n          ownKeys(Object(source), true).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n          });\n        } else if (Object.getOwnPropertyDescriptors) {\n          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n          ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n          });\n        }\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function cloneElement(element, props) {\n      if (props.style && element.props.style) {\n        props.style = _objectSpread(_objectSpread({}, element.props.style), props.style);\n      }\n      if (props.className && element.props.className) {\n        props.className = element.props.className + \" \" + props.className;\n      }\n      return /* @__PURE__ */ _react.default.cloneElement(element, props);\n    }\n  }\n});\n\n// node_modules/react-resizable/build/propTypes.js\nvar require_propTypes = __commonJS({\n  \"node_modules/react-resizable/build/propTypes.js\"(exports2) {\n    \"use strict\";\n    exports2.__esModule = true;\n    exports2.resizableProps = void 0;\n    var _propTypes = _interopRequireDefault(require_prop_types());\n    var _reactDraggable = require_cjs2();\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n    var resizableProps = {\n      axis: _propTypes.default.oneOf([\"both\", \"x\", \"y\", \"none\"]),\n      className: _propTypes.default.string,\n      children: _propTypes.default.element.isRequired,\n      draggableOpts: _propTypes.default.shape({\n        allowAnyClick: _propTypes.default.bool,\n        cancel: _propTypes.default.string,\n        children: _propTypes.default.node,\n        disabled: _propTypes.default.bool,\n        enableUserSelectHack: _propTypes.default.bool,\n        offsetParent: _propTypes.default.node,\n        grid: _propTypes.default.arrayOf(_propTypes.default.number),\n        handle: _propTypes.default.string,\n        nodeRef: _propTypes.default.object,\n        onStart: _propTypes.default.func,\n        onDrag: _propTypes.default.func,\n        onStop: _propTypes.default.func,\n        onMouseDown: _propTypes.default.func,\n        scale: _propTypes.default.number\n      }),\n      height: _propTypes.default.number.isRequired,\n      handle: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),\n      handleSize: _propTypes.default.arrayOf(_propTypes.default.number),\n      lockAspectRatio: _propTypes.default.bool,\n      maxConstraints: _propTypes.default.arrayOf(_propTypes.default.number),\n      minConstraints: _propTypes.default.arrayOf(_propTypes.default.number),\n      onResizeStop: _propTypes.default.func,\n      onResizeStart: _propTypes.default.func,\n      onResize: _propTypes.default.func,\n      resizeHandles: _propTypes.default.arrayOf(_propTypes.default.oneOf([\"s\", \"w\", \"e\", \"n\", \"sw\", \"nw\", \"se\", \"ne\"])),\n      transformScale: _propTypes.default.number,\n      width: _propTypes.default.number.isRequired\n    };\n    exports2.resizableProps = resizableProps;\n  }\n});\n\n// node_modules/react-resizable/build/Resizable.js\nvar require_Resizable = __commonJS({\n  \"node_modules/react-resizable/build/Resizable.js\"(exports2) {\n    \"use strict\";\n    exports2.__esModule = true;\n    exports2.default = void 0;\n    var React3 = _interopRequireWildcard(require(\"react\"));\n    var _reactDraggable = require_cjs2();\n    var _utils = require_utils3();\n    var _propTypes = require_propTypes();\n    var _excluded = [\"children\", \"className\", \"draggableOpts\", \"width\", \"height\", \"handle\", \"handleSize\", \"lockAspectRatio\", \"axis\", \"minConstraints\", \"maxConstraints\", \"onResize\", \"onResizeStop\", \"onResizeStart\", \"resizeHandles\", \"transformScale\"];\n    function _getRequireWildcardCache(nodeInterop) {\n      if (typeof WeakMap !== \"function\")\n        return null;\n      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();\n      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();\n      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {\n        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;\n      })(nodeInterop);\n    }\n    function _interopRequireWildcard(obj, nodeInterop) {\n      if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n      }\n      if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return { default: obj };\n      }\n      var cache = _getRequireWildcardCache(nodeInterop);\n      if (cache && cache.has(obj)) {\n        return cache.get(obj);\n      }\n      var newObj = {};\n      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var key in obj) {\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n          if (desc && (desc.get || desc.set)) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n      newObj.default = obj;\n      if (cache) {\n        cache.set(obj, newObj);\n      }\n      return newObj;\n    }\n    function _extends() {\n      _extends = Object.assign || function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      };\n      return _extends.apply(this, arguments);\n    }\n    function _objectWithoutPropertiesLoose(source, excluded) {\n      if (source == null)\n        return {};\n      var target = {};\n      var sourceKeys = Object.keys(source);\n      var key, i;\n      for (i = 0; i < sourceKeys.length; i++) {\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0)\n          continue;\n        target[key] = source[key];\n      }\n      return target;\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n          symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n          });\n        }\n        keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n          ownKeys(Object(source), true).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n          });\n        } else if (Object.getOwnPropertyDescriptors) {\n          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n          ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n          });\n        }\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function _inheritsLoose(subClass, superClass) {\n      subClass.prototype = Object.create(superClass.prototype);\n      subClass.prototype.constructor = subClass;\n      _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    var Resizable = /* @__PURE__ */ function(_React$Component) {\n      _inheritsLoose(Resizable2, _React$Component);\n      function Resizable2() {\n        var _this;\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n        _this.handleRefs = {};\n        _this.lastHandleRect = null;\n        _this.slack = null;\n        return _this;\n      }\n      var _proto = Resizable2.prototype;\n      _proto.componentWillUnmount = function componentWillUnmount() {\n        this.resetData();\n      };\n      _proto.resetData = function resetData() {\n        this.lastHandleRect = this.slack = null;\n      };\n      _proto.runConstraints = function runConstraints(width, height) {\n        var _this$props = this.props, minConstraints = _this$props.minConstraints, maxConstraints = _this$props.maxConstraints, lockAspectRatio = _this$props.lockAspectRatio;\n        if (!minConstraints && !maxConstraints && !lockAspectRatio)\n          return [width, height];\n        if (lockAspectRatio) {\n          var ratio = this.props.width / this.props.height;\n          var deltaW = width - this.props.width;\n          var deltaH = height - this.props.height;\n          if (Math.abs(deltaW) > Math.abs(deltaH * ratio)) {\n            height = width / ratio;\n          } else {\n            width = height * ratio;\n          }\n        }\n        var oldW = width, oldH = height;\n        var _ref = this.slack || [0, 0], slackW = _ref[0], slackH = _ref[1];\n        width += slackW;\n        height += slackH;\n        if (minConstraints) {\n          width = Math.max(minConstraints[0], width);\n          height = Math.max(minConstraints[1], height);\n        }\n        if (maxConstraints) {\n          width = Math.min(maxConstraints[0], width);\n          height = Math.min(maxConstraints[1], height);\n        }\n        this.slack = [slackW + (oldW - width), slackH + (oldH - height)];\n        return [width, height];\n      };\n      _proto.resizeHandler = function resizeHandler(handlerName, axis) {\n        var _this2 = this;\n        return function(e, _ref2) {\n          var node = _ref2.node, deltaX = _ref2.deltaX, deltaY = _ref2.deltaY;\n          if (handlerName === \"onResizeStart\")\n            _this2.resetData();\n          var canDragX = (_this2.props.axis === \"both\" || _this2.props.axis === \"x\") && axis !== \"n\" && axis !== \"s\";\n          var canDragY = (_this2.props.axis === \"both\" || _this2.props.axis === \"y\") && axis !== \"e\" && axis !== \"w\";\n          if (!canDragX && !canDragY)\n            return;\n          var axisV = axis[0];\n          var axisH = axis[axis.length - 1];\n          var handleRect = node.getBoundingClientRect();\n          if (_this2.lastHandleRect != null) {\n            if (axisH === \"w\") {\n              var deltaLeftSinceLast = handleRect.left - _this2.lastHandleRect.left;\n              deltaX += deltaLeftSinceLast;\n            }\n            if (axisV === \"n\") {\n              var deltaTopSinceLast = handleRect.top - _this2.lastHandleRect.top;\n              deltaY += deltaTopSinceLast;\n            }\n          }\n          _this2.lastHandleRect = handleRect;\n          if (axisH === \"w\")\n            deltaX = -deltaX;\n          if (axisV === \"n\")\n            deltaY = -deltaY;\n          var width = _this2.props.width + (canDragX ? deltaX / _this2.props.transformScale : 0);\n          var height = _this2.props.height + (canDragY ? deltaY / _this2.props.transformScale : 0);\n          var _this2$runConstraints = _this2.runConstraints(width, height);\n          width = _this2$runConstraints[0];\n          height = _this2$runConstraints[1];\n          var dimensionsChanged = width !== _this2.props.width || height !== _this2.props.height;\n          var cb = typeof _this2.props[handlerName] === \"function\" ? _this2.props[handlerName] : null;\n          var shouldSkipCb = handlerName === \"onResize\" && !dimensionsChanged;\n          if (cb && !shouldSkipCb) {\n            e.persist == null ? void 0 : e.persist();\n            cb(e, {\n              node,\n              size: {\n                width,\n                height\n              },\n              handle: axis\n            });\n          }\n          if (handlerName === \"onResizeStop\")\n            _this2.resetData();\n        };\n      };\n      _proto.renderResizeHandle = function renderResizeHandle(handleAxis, ref) {\n        var handle = this.props.handle;\n        if (!handle) {\n          return /* @__PURE__ */ React3.createElement(\"span\", {\n            className: \"react-resizable-handle react-resizable-handle-\" + handleAxis,\n            ref\n          });\n        }\n        if (typeof handle === \"function\") {\n          return handle(handleAxis, ref);\n        }\n        var isDOMElement = typeof handle.type === \"string\";\n        var props = _objectSpread({\n          ref\n        }, isDOMElement ? {} : {\n          handleAxis\n        });\n        return /* @__PURE__ */ React3.cloneElement(handle, props);\n      };\n      _proto.render = function render() {\n        var _this3 = this;\n        var _this$props2 = this.props, children = _this$props2.children, className = _this$props2.className, draggableOpts = _this$props2.draggableOpts, width = _this$props2.width, height = _this$props2.height, handle = _this$props2.handle, handleSize = _this$props2.handleSize, lockAspectRatio = _this$props2.lockAspectRatio, axis = _this$props2.axis, minConstraints = _this$props2.minConstraints, maxConstraints = _this$props2.maxConstraints, onResize = _this$props2.onResize, onResizeStop = _this$props2.onResizeStop, onResizeStart = _this$props2.onResizeStart, resizeHandles = _this$props2.resizeHandles, transformScale = _this$props2.transformScale, p = _objectWithoutPropertiesLoose(_this$props2, _excluded);\n        return (0, _utils.cloneElement)(children, _objectSpread(_objectSpread({}, p), {}, {\n          className: (className ? className + \" \" : \"\") + \"react-resizable\",\n          children: [].concat(children.props.children, resizeHandles.map(function(handleAxis) {\n            var _this3$handleRefs$han;\n            var ref = (_this3$handleRefs$han = _this3.handleRefs[handleAxis]) != null ? _this3$handleRefs$han : _this3.handleRefs[handleAxis] = /* @__PURE__ */ React3.createRef();\n            return /* @__PURE__ */ React3.createElement(_reactDraggable.DraggableCore, _extends({}, draggableOpts, {\n              nodeRef: ref,\n              key: \"resizableHandle-\" + handleAxis,\n              onStop: _this3.resizeHandler(\"onResizeStop\", handleAxis),\n              onStart: _this3.resizeHandler(\"onResizeStart\", handleAxis),\n              onDrag: _this3.resizeHandler(\"onResize\", handleAxis)\n            }), _this3.renderResizeHandle(handleAxis, ref));\n          }))\n        }));\n      };\n      return Resizable2;\n    }(React3.Component);\n    exports2.default = Resizable;\n    Resizable.propTypes = _propTypes.resizableProps;\n    Resizable.defaultProps = {\n      axis: \"both\",\n      handleSize: [20, 20],\n      lockAspectRatio: false,\n      minConstraints: [20, 20],\n      maxConstraints: [Infinity, Infinity],\n      resizeHandles: [\"se\"],\n      transformScale: 1\n    };\n  }\n});\n\n// node_modules/react-resizable/build/ResizableBox.js\nvar require_ResizableBox = __commonJS({\n  \"node_modules/react-resizable/build/ResizableBox.js\"(exports2) {\n    \"use strict\";\n    exports2.__esModule = true;\n    exports2.default = void 0;\n    var React3 = _interopRequireWildcard(require(\"react\"));\n    var _propTypes = _interopRequireDefault(require_prop_types());\n    var _Resizable = _interopRequireDefault(require_Resizable());\n    var _propTypes2 = require_propTypes();\n    var _excluded = [\"handle\", \"handleSize\", \"onResize\", \"onResizeStart\", \"onResizeStop\", \"draggableOpts\", \"minConstraints\", \"maxConstraints\", \"lockAspectRatio\", \"axis\", \"width\", \"height\", \"resizeHandles\", \"style\", \"transformScale\"];\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n    function _getRequireWildcardCache(nodeInterop) {\n      if (typeof WeakMap !== \"function\")\n        return null;\n      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();\n      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();\n      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {\n        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;\n      })(nodeInterop);\n    }\n    function _interopRequireWildcard(obj, nodeInterop) {\n      if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n      }\n      if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return { default: obj };\n      }\n      var cache = _getRequireWildcardCache(nodeInterop);\n      if (cache && cache.has(obj)) {\n        return cache.get(obj);\n      }\n      var newObj = {};\n      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var key in obj) {\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n          if (desc && (desc.get || desc.set)) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n      newObj.default = obj;\n      if (cache) {\n        cache.set(obj, newObj);\n      }\n      return newObj;\n    }\n    function _extends() {\n      _extends = Object.assign || function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      };\n      return _extends.apply(this, arguments);\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n          symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n          });\n        }\n        keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n          ownKeys(Object(source), true).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n          });\n        } else if (Object.getOwnPropertyDescriptors) {\n          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n          ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n          });\n        }\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function _objectWithoutPropertiesLoose(source, excluded) {\n      if (source == null)\n        return {};\n      var target = {};\n      var sourceKeys = Object.keys(source);\n      var key, i;\n      for (i = 0; i < sourceKeys.length; i++) {\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0)\n          continue;\n        target[key] = source[key];\n      }\n      return target;\n    }\n    function _inheritsLoose(subClass, superClass) {\n      subClass.prototype = Object.create(superClass.prototype);\n      subClass.prototype.constructor = subClass;\n      _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    var ResizableBox = /* @__PURE__ */ function(_React$Component) {\n      _inheritsLoose(ResizableBox2, _React$Component);\n      function ResizableBox2() {\n        var _this;\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n        _this.state = {\n          width: _this.props.width,\n          height: _this.props.height,\n          propsWidth: _this.props.width,\n          propsHeight: _this.props.height\n        };\n        _this.onResize = function(e, data) {\n          var size = data.size;\n          if (_this.props.onResize) {\n            e.persist == null ? void 0 : e.persist();\n            _this.setState(size, function() {\n              return _this.props.onResize && _this.props.onResize(e, data);\n            });\n          } else {\n            _this.setState(size);\n          }\n        };\n        return _this;\n      }\n      ResizableBox2.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n        if (state.propsWidth !== props.width || state.propsHeight !== props.height) {\n          return {\n            width: props.width,\n            height: props.height,\n            propsWidth: props.width,\n            propsHeight: props.height\n          };\n        }\n        return null;\n      };\n      var _proto = ResizableBox2.prototype;\n      _proto.render = function render() {\n        var _this$props = this.props, handle = _this$props.handle, handleSize = _this$props.handleSize, onResize = _this$props.onResize, onResizeStart = _this$props.onResizeStart, onResizeStop = _this$props.onResizeStop, draggableOpts = _this$props.draggableOpts, minConstraints = _this$props.minConstraints, maxConstraints = _this$props.maxConstraints, lockAspectRatio = _this$props.lockAspectRatio, axis = _this$props.axis, width = _this$props.width, height = _this$props.height, resizeHandles = _this$props.resizeHandles, style = _this$props.style, transformScale = _this$props.transformScale, props = _objectWithoutPropertiesLoose(_this$props, _excluded);\n        return /* @__PURE__ */ React3.createElement(_Resizable.default, {\n          axis,\n          draggableOpts,\n          handle,\n          handleSize,\n          height: this.state.height,\n          lockAspectRatio,\n          maxConstraints,\n          minConstraints,\n          onResizeStart,\n          onResize: this.onResize,\n          onResizeStop,\n          resizeHandles,\n          transformScale,\n          width: this.state.width\n        }, /* @__PURE__ */ React3.createElement(\"div\", _extends({}, props, {\n          style: _objectSpread(_objectSpread({}, style), {}, {\n            width: this.state.width + \"px\",\n            height: this.state.height + \"px\"\n          })\n        })));\n      };\n      return ResizableBox2;\n    }(React3.Component);\n    exports2.default = ResizableBox;\n    ResizableBox.propTypes = _objectSpread(_objectSpread({}, _propTypes2.resizableProps), {}, {\n      children: _propTypes.default.element\n    });\n  }\n});\n\n// node_modules/react-resizable/index.js\nvar require_react_resizable = __commonJS({\n  \"node_modules/react-resizable/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = function() {\n      throw new Error(\"Don't instantiate Resizable directly! Use require('react-resizable').Resizable\");\n    };\n    module2.exports.Resizable = require_Resizable().default;\n    module2.exports.ResizableBox = require_ResizableBox().default;\n  }\n});\n\n// node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js\nvar require_ReactGridLayoutPropTypes = __commonJS({\n  \"node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.resizeHandleType = exports2.resizeHandleAxesType = exports2.default = void 0;\n    var _propTypes = _interopRequireDefault(require_prop_types());\n    var _react = _interopRequireDefault(require(\"react\"));\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n    var resizeHandleAxesType = _propTypes.default.arrayOf(_propTypes.default.oneOf([\"s\", \"w\", \"e\", \"n\", \"sw\", \"nw\", \"se\", \"ne\"]));\n    exports2.resizeHandleAxesType = resizeHandleAxesType;\n    var resizeHandleType = _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]);\n    exports2.resizeHandleType = resizeHandleType;\n    var _default = {\n      className: _propTypes.default.string,\n      style: _propTypes.default.object,\n      width: _propTypes.default.number,\n      autoSize: _propTypes.default.bool,\n      cols: _propTypes.default.number,\n      draggableCancel: _propTypes.default.string,\n      draggableHandle: _propTypes.default.string,\n      verticalCompact: function verticalCompact(props) {\n        if (props.verticalCompact === false && true) {\n          console.warn('`verticalCompact` on <ReactGridLayout> is deprecated and will be removed soon. Use `compactType`: \"horizontal\" | \"vertical\" | null.');\n        }\n      },\n      compactType: _propTypes.default.oneOf([\"vertical\", \"horizontal\"]),\n      layout: function layout(props) {\n        var layout2 = props.layout;\n        if (layout2 === void 0)\n          return;\n        require_utils2().validateLayout(layout2, \"layout\");\n      },\n      margin: _propTypes.default.arrayOf(_propTypes.default.number),\n      containerPadding: _propTypes.default.arrayOf(_propTypes.default.number),\n      rowHeight: _propTypes.default.number,\n      maxRows: _propTypes.default.number,\n      isBounded: _propTypes.default.bool,\n      isDraggable: _propTypes.default.bool,\n      isResizable: _propTypes.default.bool,\n      allowOverlap: _propTypes.default.bool,\n      preventCollision: _propTypes.default.bool,\n      useCSSTransforms: _propTypes.default.bool,\n      transformScale: _propTypes.default.number,\n      isDroppable: _propTypes.default.bool,\n      resizeHandles: resizeHandleAxesType,\n      resizeHandle: resizeHandleType,\n      onLayoutChange: _propTypes.default.func,\n      onDragStart: _propTypes.default.func,\n      onDrag: _propTypes.default.func,\n      onDragStop: _propTypes.default.func,\n      onResizeStart: _propTypes.default.func,\n      onResize: _propTypes.default.func,\n      onResizeStop: _propTypes.default.func,\n      onDrop: _propTypes.default.func,\n      droppingItem: _propTypes.default.shape({\n        i: _propTypes.default.string.isRequired,\n        w: _propTypes.default.number.isRequired,\n        h: _propTypes.default.number.isRequired\n      }),\n      children: function children(props, propName) {\n        var children2 = props[propName];\n        var keys = {};\n        _react.default.Children.forEach(children2, function(child) {\n          if ((child === null || child === void 0 ? void 0 : child.key) == null)\n            return;\n          if (keys[child.key]) {\n            throw new Error('Duplicate child key \"' + child.key + '\" found! This will cause problems in ReactGridLayout.');\n          }\n          keys[child.key] = true;\n        });\n      },\n      innerRef: _propTypes.default.any\n    };\n    exports2.default = _default;\n  }\n});\n\n// node_modules/react-grid-layout/build/GridItem.js\nvar require_GridItem = __commonJS({\n  \"node_modules/react-grid-layout/build/GridItem.js\"(exports2) {\n    \"use strict\";\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      return _typeof = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(obj2) {\n        return typeof obj2;\n      } : function(obj2) {\n        return obj2 && typeof Symbol == \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.default = void 0;\n    var _react = _interopRequireDefault(require(\"react\"));\n    var _propTypes = _interopRequireDefault(require_prop_types());\n    var _reactDraggable = require_cjs2();\n    var _reactResizable = require_react_resizable();\n    var _utils = require_utils2();\n    var _calculateUtils = require_calculateUtils();\n    var _ReactGridLayoutPropTypes = require_ReactGridLayoutPropTypes();\n    var _clsx = _interopRequireDefault(require_clsx());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n      return target;\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n          descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps)\n        _defineProperties(Constructor, staticProps);\n      Object.defineProperty(Constructor, \"prototype\", { writable: false });\n      return Constructor;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });\n      Object.defineProperty(subClass, \"prototype\", { writable: false });\n      if (superClass)\n        _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _createSuper(Derived) {\n      var hasNativeReflectConstruct = _isNativeReflectConstruct();\n      return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n          var NewTarget = _getPrototypeOf(this).constructor;\n          result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n          result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n      };\n    }\n    function _possibleConstructorReturn(self2, call) {\n      if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n      } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n      }\n      return _assertThisInitialized(self2);\n    }\n    function _assertThisInitialized(self2) {\n      if (self2 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self2;\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct)\n        return false;\n      if (Reflect.construct.sham)\n        return false;\n      if (typeof Proxy === \"function\")\n        return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      };\n      return _getPrototypeOf(o);\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    var GridItem = /* @__PURE__ */ function(_React$Component) {\n      _inherits(GridItem2, _React$Component);\n      var _super = _createSuper(GridItem2);\n      function GridItem2() {\n        var _this;\n        _classCallCheck(this, GridItem2);\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        _this = _super.call.apply(_super, [this].concat(args));\n        _defineProperty(_assertThisInitialized(_this), \"state\", {\n          resizing: null,\n          dragging: null,\n          className: \"\"\n        });\n        _defineProperty(_assertThisInitialized(_this), \"elementRef\", /* @__PURE__ */ _react.default.createRef());\n        _defineProperty(_assertThisInitialized(_this), \"onDragStart\", function(e, _ref) {\n          var node = _ref.node;\n          var _this$props = _this.props, onDragStart = _this$props.onDragStart, transformScale = _this$props.transformScale;\n          if (!onDragStart)\n            return;\n          var newPosition = {\n            top: 0,\n            left: 0\n          };\n          var offsetParent = node.offsetParent;\n          if (!offsetParent)\n            return;\n          var parentRect = offsetParent.getBoundingClientRect();\n          var clientRect = node.getBoundingClientRect();\n          var cLeft = clientRect.left / transformScale;\n          var pLeft = parentRect.left / transformScale;\n          var cTop = clientRect.top / transformScale;\n          var pTop = parentRect.top / transformScale;\n          newPosition.left = cLeft - pLeft + offsetParent.scrollLeft;\n          newPosition.top = cTop - pTop + offsetParent.scrollTop;\n          _this.setState({\n            dragging: newPosition\n          });\n          var _calcXY = (0, _calculateUtils.calcXY)(_this.getPositionParams(), newPosition.top, newPosition.left, _this.props.w, _this.props.h), x = _calcXY.x, y = _calcXY.y;\n          return onDragStart.call(_assertThisInitialized(_this), _this.props.i, x, y, {\n            e,\n            node,\n            newPosition\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onDrag\", function(e, _ref2) {\n          var node = _ref2.node, deltaX = _ref2.deltaX, deltaY = _ref2.deltaY;\n          var onDrag = _this.props.onDrag;\n          if (!onDrag)\n            return;\n          if (!_this.state.dragging) {\n            throw new Error(\"onDrag called before onDragStart.\");\n          }\n          var top = _this.state.dragging.top + deltaY;\n          var left = _this.state.dragging.left + deltaX;\n          var _this$props2 = _this.props, isBounded = _this$props2.isBounded, i = _this$props2.i, w = _this$props2.w, h = _this$props2.h, containerWidth = _this$props2.containerWidth;\n          var positionParams = _this.getPositionParams();\n          if (isBounded) {\n            var offsetParent = node.offsetParent;\n            if (offsetParent) {\n              var _this$props3 = _this.props, margin = _this$props3.margin, rowHeight = _this$props3.rowHeight;\n              var bottomBoundary = offsetParent.clientHeight - (0, _calculateUtils.calcGridItemWHPx)(h, rowHeight, margin[1]);\n              top = (0, _calculateUtils.clamp)(top, 0, bottomBoundary);\n              var colWidth = (0, _calculateUtils.calcGridColWidth)(positionParams);\n              var rightBoundary = containerWidth - (0, _calculateUtils.calcGridItemWHPx)(w, colWidth, margin[0]);\n              left = (0, _calculateUtils.clamp)(left, 0, rightBoundary);\n            }\n          }\n          var newPosition = {\n            top,\n            left\n          };\n          _this.setState({\n            dragging: newPosition\n          });\n          var _calcXY2 = (0, _calculateUtils.calcXY)(positionParams, top, left, w, h), x = _calcXY2.x, y = _calcXY2.y;\n          return onDrag.call(_assertThisInitialized(_this), i, x, y, {\n            e,\n            node,\n            newPosition\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onDragStop\", function(e, _ref3) {\n          var node = _ref3.node;\n          var onDragStop = _this.props.onDragStop;\n          if (!onDragStop)\n            return;\n          if (!_this.state.dragging) {\n            throw new Error(\"onDragEnd called before onDragStart.\");\n          }\n          var _this$props4 = _this.props, w = _this$props4.w, h = _this$props4.h, i = _this$props4.i;\n          var _this$state$dragging = _this.state.dragging, left = _this$state$dragging.left, top = _this$state$dragging.top;\n          var newPosition = {\n            top,\n            left\n          };\n          _this.setState({\n            dragging: null\n          });\n          var _calcXY3 = (0, _calculateUtils.calcXY)(_this.getPositionParams(), top, left, w, h), x = _calcXY3.x, y = _calcXY3.y;\n          return onDragStop.call(_assertThisInitialized(_this), i, x, y, {\n            e,\n            node,\n            newPosition\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onResizeStop\", function(e, callbackData) {\n          _this.onResizeHandler(e, callbackData, \"onResizeStop\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onResizeStart\", function(e, callbackData) {\n          _this.onResizeHandler(e, callbackData, \"onResizeStart\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onResize\", function(e, callbackData) {\n          _this.onResizeHandler(e, callbackData, \"onResize\");\n        });\n        return _this;\n      }\n      _createClass(GridItem2, [{\n        key: \"shouldComponentUpdate\",\n        value: function shouldComponentUpdate(nextProps, nextState) {\n          if (this.props.children !== nextProps.children)\n            return true;\n          if (this.props.droppingPosition !== nextProps.droppingPosition)\n            return true;\n          var oldPosition = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(this.props), this.props.x, this.props.y, this.props.w, this.props.h, this.state);\n          var newPosition = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(nextProps), nextProps.x, nextProps.y, nextProps.w, nextProps.h, nextState);\n          return !(0, _utils.fastPositionEqual)(oldPosition, newPosition) || this.props.useCSSTransforms !== nextProps.useCSSTransforms;\n        }\n      }, {\n        key: \"componentDidMount\",\n        value: function componentDidMount() {\n          this.moveDroppingItem({});\n        }\n      }, {\n        key: \"componentDidUpdate\",\n        value: function componentDidUpdate(prevProps) {\n          this.moveDroppingItem(prevProps);\n        }\n      }, {\n        key: \"moveDroppingItem\",\n        value: function moveDroppingItem(prevProps) {\n          var droppingPosition = this.props.droppingPosition;\n          if (!droppingPosition)\n            return;\n          var node = this.elementRef.current;\n          if (!node)\n            return;\n          var prevDroppingPosition = prevProps.droppingPosition || {\n            left: 0,\n            top: 0\n          };\n          var dragging = this.state.dragging;\n          var shouldDrag = dragging && droppingPosition.left !== prevDroppingPosition.left || droppingPosition.top !== prevDroppingPosition.top;\n          if (!dragging) {\n            this.onDragStart(droppingPosition.e, {\n              node,\n              deltaX: droppingPosition.left,\n              deltaY: droppingPosition.top\n            });\n          } else if (shouldDrag) {\n            var deltaX = droppingPosition.left - dragging.left;\n            var deltaY = droppingPosition.top - dragging.top;\n            this.onDrag(droppingPosition.e, {\n              node,\n              deltaX,\n              deltaY\n            });\n          }\n        }\n      }, {\n        key: \"getPositionParams\",\n        value: function getPositionParams() {\n          var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;\n          return {\n            cols: props.cols,\n            containerPadding: props.containerPadding,\n            containerWidth: props.containerWidth,\n            margin: props.margin,\n            maxRows: props.maxRows,\n            rowHeight: props.rowHeight\n          };\n        }\n      }, {\n        key: \"createStyle\",\n        value: function createStyle(pos) {\n          var _this$props5 = this.props, usePercentages = _this$props5.usePercentages, containerWidth = _this$props5.containerWidth, useCSSTransforms = _this$props5.useCSSTransforms;\n          var style;\n          if (useCSSTransforms) {\n            style = (0, _utils.setTransform)(pos);\n          } else {\n            style = (0, _utils.setTopLeft)(pos);\n            if (usePercentages) {\n              style.left = (0, _utils.perc)(pos.left / containerWidth);\n              style.width = (0, _utils.perc)(pos.width / containerWidth);\n            }\n          }\n          return style;\n        }\n      }, {\n        key: \"mixinDraggable\",\n        value: function mixinDraggable(child, isDraggable) {\n          return /* @__PURE__ */ _react.default.createElement(_reactDraggable.DraggableCore, {\n            disabled: !isDraggable,\n            onStart: this.onDragStart,\n            onDrag: this.onDrag,\n            onStop: this.onDragStop,\n            handle: this.props.handle,\n            cancel: \".react-resizable-handle\" + (this.props.cancel ? \",\" + this.props.cancel : \"\"),\n            scale: this.props.transformScale,\n            nodeRef: this.elementRef\n          }, child);\n        }\n      }, {\n        key: \"mixinResizable\",\n        value: function mixinResizable(child, position, isResizable) {\n          var _this$props6 = this.props, cols = _this$props6.cols, x = _this$props6.x, minW = _this$props6.minW, minH = _this$props6.minH, maxW = _this$props6.maxW, maxH = _this$props6.maxH, transformScale = _this$props6.transformScale, resizeHandles = _this$props6.resizeHandles, resizeHandle = _this$props6.resizeHandle;\n          var positionParams = this.getPositionParams();\n          var maxWidth = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, cols - x, 0).width;\n          var mins = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, minW, minH);\n          var maxes = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, maxW, maxH);\n          var minConstraints = [mins.width, mins.height];\n          var maxConstraints = [Math.min(maxes.width, maxWidth), Math.min(maxes.height, Infinity)];\n          return /* @__PURE__ */ _react.default.createElement(_reactResizable.Resizable, {\n            draggableOpts: {\n              disabled: !isResizable\n            },\n            className: isResizable ? void 0 : \"react-resizable-hide\",\n            width: position.width,\n            height: position.height,\n            minConstraints,\n            maxConstraints,\n            onResizeStop: this.onResizeStop,\n            onResizeStart: this.onResizeStart,\n            onResize: this.onResize,\n            transformScale,\n            resizeHandles,\n            handle: resizeHandle\n          }, child);\n        }\n      }, {\n        key: \"onResizeHandler\",\n        value: function onResizeHandler(e, _ref4, handlerName) {\n          var node = _ref4.node, size = _ref4.size;\n          var handler = this.props[handlerName];\n          if (!handler)\n            return;\n          var _this$props7 = this.props, cols = _this$props7.cols, x = _this$props7.x, y = _this$props7.y, i = _this$props7.i, maxH = _this$props7.maxH, minH = _this$props7.minH;\n          var _this$props8 = this.props, minW = _this$props8.minW, maxW = _this$props8.maxW;\n          var _calcWH = (0, _calculateUtils.calcWH)(this.getPositionParams(), size.width, size.height, x, y), w = _calcWH.w, h = _calcWH.h;\n          minW = Math.max(minW, 1);\n          maxW = Math.min(maxW, cols - x);\n          w = (0, _calculateUtils.clamp)(w, minW, maxW);\n          h = (0, _calculateUtils.clamp)(h, minH, maxH);\n          this.setState({\n            resizing: handlerName === \"onResizeStop\" ? null : size\n          });\n          handler.call(this, i, w, h, {\n            e,\n            node,\n            size\n          });\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var _this$props9 = this.props, x = _this$props9.x, y = _this$props9.y, w = _this$props9.w, h = _this$props9.h, isDraggable = _this$props9.isDraggable, isResizable = _this$props9.isResizable, droppingPosition = _this$props9.droppingPosition, useCSSTransforms = _this$props9.useCSSTransforms;\n          var pos = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(), x, y, w, h, this.state);\n          var child = _react.default.Children.only(this.props.children);\n          var newChild = /* @__PURE__ */ _react.default.cloneElement(child, {\n            ref: this.elementRef,\n            className: (0, _clsx.default)(\"react-grid-item\", child.props.className, this.props.className, {\n              static: this.props.static,\n              resizing: Boolean(this.state.resizing),\n              \"react-draggable\": isDraggable,\n              \"react-draggable-dragging\": Boolean(this.state.dragging),\n              dropping: Boolean(droppingPosition),\n              cssTransforms: useCSSTransforms\n            }),\n            style: _objectSpread(_objectSpread(_objectSpread({}, this.props.style), child.props.style), this.createStyle(pos))\n          });\n          newChild = this.mixinResizable(newChild, pos, isResizable);\n          newChild = this.mixinDraggable(newChild, isDraggable);\n          return newChild;\n        }\n      }]);\n      return GridItem2;\n    }(_react.default.Component);\n    exports2.default = GridItem;\n    _defineProperty(GridItem, \"propTypes\", {\n      children: _propTypes.default.element,\n      cols: _propTypes.default.number.isRequired,\n      containerWidth: _propTypes.default.number.isRequired,\n      rowHeight: _propTypes.default.number.isRequired,\n      margin: _propTypes.default.array.isRequired,\n      maxRows: _propTypes.default.number.isRequired,\n      containerPadding: _propTypes.default.array.isRequired,\n      x: _propTypes.default.number.isRequired,\n      y: _propTypes.default.number.isRequired,\n      w: _propTypes.default.number.isRequired,\n      h: _propTypes.default.number.isRequired,\n      minW: function minW(props, propName) {\n        var value = props[propName];\n        if (typeof value !== \"number\")\n          return new Error(\"minWidth not Number\");\n        if (value > props.w || value > props.maxW)\n          return new Error(\"minWidth larger than item width/maxWidth\");\n      },\n      maxW: function maxW(props, propName) {\n        var value = props[propName];\n        if (typeof value !== \"number\")\n          return new Error(\"maxWidth not Number\");\n        if (value < props.w || value < props.minW)\n          return new Error(\"maxWidth smaller than item width/minWidth\");\n      },\n      minH: function minH(props, propName) {\n        var value = props[propName];\n        if (typeof value !== \"number\")\n          return new Error(\"minHeight not Number\");\n        if (value > props.h || value > props.maxH)\n          return new Error(\"minHeight larger than item height/maxHeight\");\n      },\n      maxH: function maxH(props, propName) {\n        var value = props[propName];\n        if (typeof value !== \"number\")\n          return new Error(\"maxHeight not Number\");\n        if (value < props.h || value < props.minH)\n          return new Error(\"maxHeight smaller than item height/minHeight\");\n      },\n      i: _propTypes.default.string.isRequired,\n      resizeHandles: _ReactGridLayoutPropTypes.resizeHandleAxesType,\n      resizeHandle: _ReactGridLayoutPropTypes.resizeHandleType,\n      onDragStop: _propTypes.default.func,\n      onDragStart: _propTypes.default.func,\n      onDrag: _propTypes.default.func,\n      onResizeStop: _propTypes.default.func,\n      onResizeStart: _propTypes.default.func,\n      onResize: _propTypes.default.func,\n      isDraggable: _propTypes.default.bool.isRequired,\n      isResizable: _propTypes.default.bool.isRequired,\n      isBounded: _propTypes.default.bool.isRequired,\n      static: _propTypes.default.bool,\n      useCSSTransforms: _propTypes.default.bool.isRequired,\n      transformScale: _propTypes.default.number,\n      className: _propTypes.default.string,\n      handle: _propTypes.default.string,\n      cancel: _propTypes.default.string,\n      droppingPosition: _propTypes.default.shape({\n        e: _propTypes.default.object.isRequired,\n        left: _propTypes.default.number.isRequired,\n        top: _propTypes.default.number.isRequired\n      })\n    });\n    _defineProperty(GridItem, \"defaultProps\", {\n      className: \"\",\n      cancel: \"\",\n      handle: \"\",\n      minH: 1,\n      minW: 1,\n      maxH: Infinity,\n      maxW: Infinity,\n      transformScale: 1\n    });\n  }\n});\n\n// node_modules/react-grid-layout/build/ReactGridLayout.js\nvar require_ReactGridLayout = __commonJS({\n  \"node_modules/react-grid-layout/build/ReactGridLayout.js\"(exports2) {\n    \"use strict\";\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      return _typeof = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(obj2) {\n        return typeof obj2;\n      } : function(obj2) {\n        return obj2 && typeof Symbol == \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.default = void 0;\n    var React3 = _interopRequireWildcard(require(\"react\"));\n    var _lodash = _interopRequireDefault(require_lodash());\n    var _clsx = _interopRequireDefault(require_clsx());\n    var _utils = require_utils2();\n    var _calculateUtils = require_calculateUtils();\n    var _GridItem = _interopRequireDefault(require_GridItem());\n    var _ReactGridLayoutPropTypes = _interopRequireDefault(require_ReactGridLayoutPropTypes());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n    function _getRequireWildcardCache(nodeInterop) {\n      if (typeof WeakMap !== \"function\")\n        return null;\n      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();\n      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();\n      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {\n        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;\n      })(nodeInterop);\n    }\n    function _interopRequireWildcard(obj, nodeInterop) {\n      if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n      }\n      if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n        return { default: obj };\n      }\n      var cache = _getRequireWildcardCache(nodeInterop);\n      if (cache && cache.has(obj)) {\n        return cache.get(obj);\n      }\n      var newObj = {};\n      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var key in obj) {\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n          if (desc && (desc.get || desc.set)) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n      newObj.default = obj;\n      if (cache) {\n        cache.set(obj, newObj);\n      }\n      return newObj;\n    }\n    function _toConsumableArray(arr) {\n      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n    }\n    function _nonIterableSpread() {\n      throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    function _iterableToArray(iter) {\n      if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null)\n        return Array.from(iter);\n    }\n    function _arrayWithoutHoles(arr) {\n      if (Array.isArray(arr))\n        return _arrayLikeToArray(arr);\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n      return target;\n    }\n    function _slicedToArray(arr, i) {\n      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n    }\n    function _nonIterableRest() {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    function _unsupportedIterableToArray(o, minLen) {\n      if (!o)\n        return;\n      if (typeof o === \"string\")\n        return _arrayLikeToArray(o, minLen);\n      var n = Object.prototype.toString.call(o).slice(8, -1);\n      if (n === \"Object\" && o.constructor)\n        n = o.constructor.name;\n      if (n === \"Map\" || n === \"Set\")\n        return Array.from(o);\n      if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n        return _arrayLikeToArray(o, minLen);\n    }\n    function _arrayLikeToArray(arr, len) {\n      if (len == null || len > arr.length)\n        len = arr.length;\n      for (var i = 0, arr2 = new Array(len); i < len; i++) {\n        arr2[i] = arr[i];\n      }\n      return arr2;\n    }\n    function _iterableToArrayLimit(arr, i) {\n      var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n      if (_i == null)\n        return;\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _s, _e;\n      try {\n        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n          if (i && _arr.length === i)\n            break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i[\"return\"] != null)\n            _i[\"return\"]();\n        } finally {\n          if (_d)\n            throw _e;\n        }\n      }\n      return _arr;\n    }\n    function _arrayWithHoles(arr) {\n      if (Array.isArray(arr))\n        return arr;\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n          descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps)\n        _defineProperties(Constructor, staticProps);\n      Object.defineProperty(Constructor, \"prototype\", { writable: false });\n      return Constructor;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });\n      Object.defineProperty(subClass, \"prototype\", { writable: false });\n      if (superClass)\n        _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _createSuper(Derived) {\n      var hasNativeReflectConstruct = _isNativeReflectConstruct();\n      return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n          var NewTarget = _getPrototypeOf(this).constructor;\n          result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n          result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n      };\n    }\n    function _possibleConstructorReturn(self2, call) {\n      if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n      } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n      }\n      return _assertThisInitialized(self2);\n    }\n    function _assertThisInitialized(self2) {\n      if (self2 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self2;\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct)\n        return false;\n      if (Reflect.construct.sham)\n        return false;\n      if (typeof Proxy === \"function\")\n        return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      };\n      return _getPrototypeOf(o);\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    var layoutClassName = \"react-grid-layout\";\n    var isFirefox = false;\n    try {\n      isFirefox = /firefox/i.test(navigator.userAgent);\n    } catch (e) {\n    }\n    var ReactGridLayout = /* @__PURE__ */ function(_React$Component) {\n      _inherits(ReactGridLayout2, _React$Component);\n      var _super = _createSuper(ReactGridLayout2);\n      function ReactGridLayout2() {\n        var _this;\n        _classCallCheck(this, ReactGridLayout2);\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        _this = _super.call.apply(_super, [this].concat(args));\n        _defineProperty(_assertThisInitialized(_this), \"state\", {\n          activeDrag: null,\n          layout: (0, _utils.synchronizeLayoutWithChildren)(_this.props.layout, _this.props.children, _this.props.cols, (0, _utils.compactType)(_this.props), _this.props.allowOverlap),\n          mounted: false,\n          oldDragItem: null,\n          oldLayout: null,\n          oldResizeItem: null,\n          droppingDOMNode: null,\n          children: []\n        });\n        _defineProperty(_assertThisInitialized(_this), \"dragEnterCounter\", 0);\n        _defineProperty(_assertThisInitialized(_this), \"onDragStart\", function(i, x, y, _ref) {\n          var e = _ref.e, node = _ref.node;\n          var layout = _this.state.layout;\n          var l = (0, _utils.getLayoutItem)(layout, i);\n          if (!l)\n            return;\n          _this.setState({\n            oldDragItem: (0, _utils.cloneLayoutItem)(l),\n            oldLayout: layout\n          });\n          return _this.props.onDragStart(layout, l, l, null, e, node);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onDrag\", function(i, x, y, _ref2) {\n          var e = _ref2.e, node = _ref2.node;\n          var oldDragItem = _this.state.oldDragItem;\n          var layout = _this.state.layout;\n          var _this$props = _this.props, cols = _this$props.cols, allowOverlap = _this$props.allowOverlap, preventCollision = _this$props.preventCollision;\n          var l = (0, _utils.getLayoutItem)(layout, i);\n          if (!l)\n            return;\n          var placeholder = {\n            w: l.w,\n            h: l.h,\n            x: l.x,\n            y: l.y,\n            placeholder: true,\n            i\n          };\n          var isUserAction = true;\n          layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(_this.props), cols, allowOverlap);\n          _this.props.onDrag(layout, oldDragItem, l, placeholder, e, node);\n          _this.setState({\n            layout: allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(_this.props), cols),\n            activeDrag: placeholder\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onDragStop\", function(i, x, y, _ref3) {\n          var e = _ref3.e, node = _ref3.node;\n          if (!_this.state.activeDrag)\n            return;\n          var oldDragItem = _this.state.oldDragItem;\n          var layout = _this.state.layout;\n          var _this$props2 = _this.props, cols = _this$props2.cols, preventCollision = _this$props2.preventCollision, allowOverlap = _this$props2.allowOverlap;\n          var l = (0, _utils.getLayoutItem)(layout, i);\n          if (!l)\n            return;\n          var isUserAction = true;\n          layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(_this.props), cols, allowOverlap);\n          _this.props.onDragStop(layout, oldDragItem, l, null, e, node);\n          var newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(_this.props), cols);\n          var oldLayout = _this.state.oldLayout;\n          _this.setState({\n            activeDrag: null,\n            layout: newLayout,\n            oldDragItem: null,\n            oldLayout: null\n          });\n          _this.onLayoutMaybeChanged(newLayout, oldLayout);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onResizeStart\", function(i, w, h, _ref4) {\n          var e = _ref4.e, node = _ref4.node;\n          var layout = _this.state.layout;\n          var l = (0, _utils.getLayoutItem)(layout, i);\n          if (!l)\n            return;\n          _this.setState({\n            oldResizeItem: (0, _utils.cloneLayoutItem)(l),\n            oldLayout: _this.state.layout\n          });\n          _this.props.onResizeStart(layout, l, l, null, e, node);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onResize\", function(i, w, h, _ref5) {\n          var e = _ref5.e, node = _ref5.node;\n          var _this$state = _this.state, layout = _this$state.layout, oldResizeItem = _this$state.oldResizeItem;\n          var _this$props3 = _this.props, cols = _this$props3.cols, preventCollision = _this$props3.preventCollision, allowOverlap = _this$props3.allowOverlap;\n          var _withLayoutItem = (0, _utils.withLayoutItem)(layout, i, function(l2) {\n            var hasCollisions;\n            if (preventCollision && !allowOverlap) {\n              var collisions = (0, _utils.getAllCollisions)(layout, _objectSpread(_objectSpread({}, l2), {}, {\n                w,\n                h\n              })).filter(function(layoutItem) {\n                return layoutItem.i !== l2.i;\n              });\n              hasCollisions = collisions.length > 0;\n              if (hasCollisions) {\n                var leastX = Infinity, leastY = Infinity;\n                collisions.forEach(function(layoutItem) {\n                  if (layoutItem.x > l2.x)\n                    leastX = Math.min(leastX, layoutItem.x);\n                  if (layoutItem.y > l2.y)\n                    leastY = Math.min(leastY, layoutItem.y);\n                });\n                if (Number.isFinite(leastX))\n                  l2.w = leastX - l2.x;\n                if (Number.isFinite(leastY))\n                  l2.h = leastY - l2.y;\n              }\n            }\n            if (!hasCollisions) {\n              l2.w = w;\n              l2.h = h;\n            }\n            return l2;\n          }), _withLayoutItem2 = _slicedToArray(_withLayoutItem, 2), newLayout = _withLayoutItem2[0], l = _withLayoutItem2[1];\n          if (!l)\n            return;\n          var placeholder = {\n            w: l.w,\n            h: l.h,\n            x: l.x,\n            y: l.y,\n            static: true,\n            i\n          };\n          _this.props.onResize(newLayout, oldResizeItem, l, placeholder, e, node);\n          _this.setState({\n            layout: allowOverlap ? newLayout : (0, _utils.compact)(newLayout, (0, _utils.compactType)(_this.props), cols),\n            activeDrag: placeholder\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onResizeStop\", function(i, w, h, _ref6) {\n          var e = _ref6.e, node = _ref6.node;\n          var _this$state2 = _this.state, layout = _this$state2.layout, oldResizeItem = _this$state2.oldResizeItem;\n          var _this$props4 = _this.props, cols = _this$props4.cols, allowOverlap = _this$props4.allowOverlap;\n          var l = (0, _utils.getLayoutItem)(layout, i);\n          _this.props.onResizeStop(layout, oldResizeItem, l, null, e, node);\n          var newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(_this.props), cols);\n          var oldLayout = _this.state.oldLayout;\n          _this.setState({\n            activeDrag: null,\n            layout: newLayout,\n            oldResizeItem: null,\n            oldLayout: null\n          });\n          _this.onLayoutMaybeChanged(newLayout, oldLayout);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onDragOver\", function(e) {\n          var _e$nativeEvent$target;\n          e.preventDefault();\n          e.stopPropagation();\n          if (isFirefox && !((_e$nativeEvent$target = e.nativeEvent.target) !== null && _e$nativeEvent$target !== void 0 && _e$nativeEvent$target.classList.contains(layoutClassName))) {\n            return false;\n          }\n          var _this$props5 = _this.props, droppingItem = _this$props5.droppingItem, onDropDragOver = _this$props5.onDropDragOver, margin = _this$props5.margin, cols = _this$props5.cols, rowHeight = _this$props5.rowHeight, maxRows = _this$props5.maxRows, width = _this$props5.width, containerPadding = _this$props5.containerPadding, transformScale = _this$props5.transformScale;\n          var onDragOverResult = onDropDragOver === null || onDropDragOver === void 0 ? void 0 : onDropDragOver(e);\n          if (onDragOverResult === false) {\n            if (_this.state.droppingDOMNode) {\n              _this.removeDroppingPlaceholder();\n            }\n            return false;\n          }\n          var finalDroppingItem = _objectSpread(_objectSpread({}, droppingItem), onDragOverResult);\n          var layout = _this.state.layout;\n          var _e$nativeEvent = e.nativeEvent, layerX = _e$nativeEvent.layerX, layerY = _e$nativeEvent.layerY;\n          var droppingPosition = {\n            left: layerX / transformScale,\n            top: layerY / transformScale,\n            e\n          };\n          if (!_this.state.droppingDOMNode) {\n            var positionParams = {\n              cols,\n              margin,\n              maxRows,\n              rowHeight,\n              containerWidth: width,\n              containerPadding: containerPadding || margin\n            };\n            var calculatedPosition = (0, _calculateUtils.calcXY)(positionParams, layerY, layerX, finalDroppingItem.w, finalDroppingItem.h);\n            _this.setState({\n              droppingDOMNode: /* @__PURE__ */ React3.createElement(\"div\", {\n                key: finalDroppingItem.i\n              }),\n              droppingPosition,\n              layout: [].concat(_toConsumableArray(layout), [_objectSpread(_objectSpread({}, finalDroppingItem), {}, {\n                x: calculatedPosition.x,\n                y: calculatedPosition.y,\n                static: false,\n                isDraggable: true\n              })])\n            });\n          } else if (_this.state.droppingPosition) {\n            var _this$state$droppingP = _this.state.droppingPosition, left = _this$state$droppingP.left, top = _this$state$droppingP.top;\n            var shouldUpdatePosition = left != layerX || top != layerY;\n            if (shouldUpdatePosition) {\n              _this.setState({\n                droppingPosition\n              });\n            }\n          }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"removeDroppingPlaceholder\", function() {\n          var _this$props6 = _this.props, droppingItem = _this$props6.droppingItem, cols = _this$props6.cols;\n          var layout = _this.state.layout;\n          var newLayout = (0, _utils.compact)(layout.filter(function(l) {\n            return l.i !== droppingItem.i;\n          }), (0, _utils.compactType)(_this.props), cols);\n          _this.setState({\n            layout: newLayout,\n            droppingDOMNode: null,\n            activeDrag: null,\n            droppingPosition: void 0\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onDragLeave\", function(e) {\n          e.preventDefault();\n          e.stopPropagation();\n          _this.dragEnterCounter--;\n          if (_this.dragEnterCounter === 0) {\n            _this.removeDroppingPlaceholder();\n          }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onDragEnter\", function(e) {\n          e.preventDefault();\n          e.stopPropagation();\n          _this.dragEnterCounter++;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onDrop\", function(e) {\n          e.preventDefault();\n          e.stopPropagation();\n          var droppingItem = _this.props.droppingItem;\n          var layout = _this.state.layout;\n          var item = layout.find(function(l) {\n            return l.i === droppingItem.i;\n          });\n          _this.dragEnterCounter = 0;\n          _this.removeDroppingPlaceholder();\n          _this.props.onDrop(layout, item, e);\n        });\n        return _this;\n      }\n      _createClass(ReactGridLayout2, [{\n        key: \"componentDidMount\",\n        value: function componentDidMount() {\n          this.setState({\n            mounted: true\n          });\n          this.onLayoutMaybeChanged(this.state.layout, this.props.layout);\n        }\n      }, {\n        key: \"shouldComponentUpdate\",\n        value: function shouldComponentUpdate(nextProps, nextState) {\n          return this.props.children !== nextProps.children || !(0, _utils.fastRGLPropsEqual)(this.props, nextProps, _lodash.default) || this.state.activeDrag !== nextState.activeDrag || this.state.mounted !== nextState.mounted || this.state.droppingPosition !== nextState.droppingPosition;\n        }\n      }, {\n        key: \"componentDidUpdate\",\n        value: function componentDidUpdate(prevProps, prevState) {\n          if (!this.state.activeDrag) {\n            var newLayout = this.state.layout;\n            var oldLayout = prevState.layout;\n            this.onLayoutMaybeChanged(newLayout, oldLayout);\n          }\n        }\n      }, {\n        key: \"containerHeight\",\n        value: function containerHeight() {\n          if (!this.props.autoSize)\n            return;\n          var nbRow = (0, _utils.bottom)(this.state.layout);\n          var containerPaddingY = this.props.containerPadding ? this.props.containerPadding[1] : this.props.margin[1];\n          return nbRow * this.props.rowHeight + (nbRow - 1) * this.props.margin[1] + containerPaddingY * 2 + \"px\";\n        }\n      }, {\n        key: \"onLayoutMaybeChanged\",\n        value: function onLayoutMaybeChanged(newLayout, oldLayout) {\n          if (!oldLayout)\n            oldLayout = this.state.layout;\n          if (!(0, _lodash.default)(oldLayout, newLayout)) {\n            this.props.onLayoutChange(newLayout);\n          }\n        }\n      }, {\n        key: \"placeholder\",\n        value: function placeholder() {\n          var activeDrag = this.state.activeDrag;\n          if (!activeDrag)\n            return null;\n          var _this$props7 = this.props, width = _this$props7.width, cols = _this$props7.cols, margin = _this$props7.margin, containerPadding = _this$props7.containerPadding, rowHeight = _this$props7.rowHeight, maxRows = _this$props7.maxRows, useCSSTransforms = _this$props7.useCSSTransforms, transformScale = _this$props7.transformScale;\n          return /* @__PURE__ */ React3.createElement(_GridItem.default, {\n            w: activeDrag.w,\n            h: activeDrag.h,\n            x: activeDrag.x,\n            y: activeDrag.y,\n            i: activeDrag.i,\n            className: \"react-grid-placeholder\",\n            containerWidth: width,\n            cols,\n            margin,\n            containerPadding: containerPadding || margin,\n            maxRows,\n            rowHeight,\n            isDraggable: false,\n            isResizable: false,\n            isBounded: false,\n            useCSSTransforms,\n            transformScale\n          }, /* @__PURE__ */ React3.createElement(\"div\", null));\n        }\n      }, {\n        key: \"processGridItem\",\n        value: function processGridItem(child, isDroppingItem) {\n          if (!child || !child.key)\n            return;\n          var l = (0, _utils.getLayoutItem)(this.state.layout, String(child.key));\n          if (!l)\n            return null;\n          var _this$props8 = this.props, width = _this$props8.width, cols = _this$props8.cols, margin = _this$props8.margin, containerPadding = _this$props8.containerPadding, rowHeight = _this$props8.rowHeight, maxRows = _this$props8.maxRows, isDraggable = _this$props8.isDraggable, isResizable = _this$props8.isResizable, isBounded = _this$props8.isBounded, useCSSTransforms = _this$props8.useCSSTransforms, transformScale = _this$props8.transformScale, draggableCancel = _this$props8.draggableCancel, draggableHandle = _this$props8.draggableHandle, resizeHandles = _this$props8.resizeHandles, resizeHandle = _this$props8.resizeHandle;\n          var _this$state3 = this.state, mounted = _this$state3.mounted, droppingPosition = _this$state3.droppingPosition;\n          var draggable = typeof l.isDraggable === \"boolean\" ? l.isDraggable : !l.static && isDraggable;\n          var resizable = typeof l.isResizable === \"boolean\" ? l.isResizable : !l.static && isResizable;\n          var resizeHandlesOptions = l.resizeHandles || resizeHandles;\n          var bounded = draggable && isBounded && l.isBounded !== false;\n          return /* @__PURE__ */ React3.createElement(_GridItem.default, {\n            containerWidth: width,\n            cols,\n            margin,\n            containerPadding: containerPadding || margin,\n            maxRows,\n            rowHeight,\n            cancel: draggableCancel,\n            handle: draggableHandle,\n            onDragStop: this.onDragStop,\n            onDragStart: this.onDragStart,\n            onDrag: this.onDrag,\n            onResizeStart: this.onResizeStart,\n            onResize: this.onResize,\n            onResizeStop: this.onResizeStop,\n            isDraggable: draggable,\n            isResizable: resizable,\n            isBounded: bounded,\n            useCSSTransforms: useCSSTransforms && mounted,\n            usePercentages: !mounted,\n            transformScale,\n            w: l.w,\n            h: l.h,\n            x: l.x,\n            y: l.y,\n            i: l.i,\n            minH: l.minH,\n            minW: l.minW,\n            maxH: l.maxH,\n            maxW: l.maxW,\n            static: l.static,\n            droppingPosition: isDroppingItem ? droppingPosition : void 0,\n            resizeHandles: resizeHandlesOptions,\n            resizeHandle\n          }, child);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var _this2 = this;\n          var _this$props9 = this.props, className = _this$props9.className, style = _this$props9.style, isDroppable = _this$props9.isDroppable, innerRef = _this$props9.innerRef;\n          var mergedClassName = (0, _clsx.default)(layoutClassName, className);\n          var mergedStyle = _objectSpread({\n            height: this.containerHeight()\n          }, style);\n          return /* @__PURE__ */ React3.createElement(\"div\", {\n            ref: innerRef,\n            className: mergedClassName,\n            style: mergedStyle,\n            onDrop: isDroppable ? this.onDrop : _utils.noop,\n            onDragLeave: isDroppable ? this.onDragLeave : _utils.noop,\n            onDragEnter: isDroppable ? this.onDragEnter : _utils.noop,\n            onDragOver: isDroppable ? this.onDragOver : _utils.noop\n          }, React3.Children.map(this.props.children, function(child) {\n            return _this2.processGridItem(child);\n          }), isDroppable && this.state.droppingDOMNode && this.processGridItem(this.state.droppingDOMNode, true), this.placeholder());\n        }\n      }], [{\n        key: \"getDerivedStateFromProps\",\n        value: function getDerivedStateFromProps(nextProps, prevState) {\n          var newLayoutBase;\n          if (prevState.activeDrag) {\n            return null;\n          }\n          if (!(0, _lodash.default)(nextProps.layout, prevState.propsLayout) || nextProps.compactType !== prevState.compactType) {\n            newLayoutBase = nextProps.layout;\n          } else if (!(0, _utils.childrenEqual)(nextProps.children, prevState.children)) {\n            newLayoutBase = prevState.layout;\n          }\n          if (newLayoutBase) {\n            var newLayout = (0, _utils.synchronizeLayoutWithChildren)(newLayoutBase, nextProps.children, nextProps.cols, (0, _utils.compactType)(nextProps), nextProps.allowOverlap);\n            return {\n              layout: newLayout,\n              compactType: nextProps.compactType,\n              children: nextProps.children,\n              propsLayout: nextProps.layout\n            };\n          }\n          return null;\n        }\n      }]);\n      return ReactGridLayout2;\n    }(React3.Component);\n    exports2.default = ReactGridLayout;\n    _defineProperty(ReactGridLayout, \"displayName\", \"ReactGridLayout\");\n    _defineProperty(ReactGridLayout, \"propTypes\", _ReactGridLayoutPropTypes.default);\n    _defineProperty(ReactGridLayout, \"defaultProps\", {\n      autoSize: true,\n      cols: 12,\n      className: \"\",\n      style: {},\n      draggableHandle: \"\",\n      draggableCancel: \"\",\n      containerPadding: null,\n      rowHeight: 150,\n      maxRows: Infinity,\n      layout: [],\n      margin: [10, 10],\n      isBounded: false,\n      isDraggable: true,\n      isResizable: true,\n      allowOverlap: false,\n      isDroppable: false,\n      useCSSTransforms: true,\n      transformScale: 1,\n      verticalCompact: true,\n      compactType: \"vertical\",\n      preventCollision: false,\n      droppingItem: {\n        i: \"__dropping-elem__\",\n        h: 1,\n        w: 1\n      },\n      resizeHandles: [\"se\"],\n      onLayoutChange: _utils.noop,\n      onDragStart: _utils.noop,\n      onDrag: _utils.noop,\n      onDragStop: _utils.noop,\n      onResizeStart: _utils.noop,\n      onResize: _utils.noop,\n      onResizeStop: _utils.noop,\n      onDrop: _utils.noop,\n      onDropDragOver: _utils.noop\n    });\n  }\n});\n\n// node_modules/react-grid-layout/build/responsiveUtils.js\nvar require_responsiveUtils = __commonJS({\n  \"node_modules/react-grid-layout/build/responsiveUtils.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.findOrGenerateResponsiveLayout = findOrGenerateResponsiveLayout;\n    exports2.getBreakpointFromWidth = getBreakpointFromWidth;\n    exports2.getColsFromBreakpoint = getColsFromBreakpoint;\n    exports2.sortBreakpoints = sortBreakpoints;\n    var _utils = require_utils2();\n    function getBreakpointFromWidth(breakpoints, width) {\n      var sorted = sortBreakpoints(breakpoints);\n      var matching = sorted[0];\n      for (var i = 1, len = sorted.length; i < len; i++) {\n        var breakpointName = sorted[i];\n        if (width > breakpoints[breakpointName])\n          matching = breakpointName;\n      }\n      return matching;\n    }\n    function getColsFromBreakpoint(breakpoint, cols) {\n      if (!cols[breakpoint]) {\n        throw new Error(\"ResponsiveReactGridLayout: `cols` entry for breakpoint \" + breakpoint + \" is missing!\");\n      }\n      return cols[breakpoint];\n    }\n    function findOrGenerateResponsiveLayout(layouts, breakpoints, breakpoint, lastBreakpoint, cols, compactType) {\n      if (layouts[breakpoint])\n        return (0, _utils.cloneLayout)(layouts[breakpoint]);\n      var layout = layouts[lastBreakpoint];\n      var breakpointsSorted = sortBreakpoints(breakpoints);\n      var breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\n      for (var i = 0, len = breakpointsAbove.length; i < len; i++) {\n        var b = breakpointsAbove[i];\n        if (layouts[b]) {\n          layout = layouts[b];\n          break;\n        }\n      }\n      layout = (0, _utils.cloneLayout)(layout || []);\n      return (0, _utils.compact)((0, _utils.correctBounds)(layout, {\n        cols\n      }), compactType, cols);\n    }\n    function sortBreakpoints(breakpoints) {\n      var keys = Object.keys(breakpoints);\n      return keys.sort(function(a, b) {\n        return breakpoints[a] - breakpoints[b];\n      });\n    }\n  }\n});\n\n// node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js\nvar require_ResponsiveReactGridLayout = __commonJS({\n  \"node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js\"(exports2) {\n    \"use strict\";\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      return _typeof = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(obj2) {\n        return typeof obj2;\n      } : function(obj2) {\n        return obj2 && typeof Symbol == \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.default = void 0;\n    var React3 = _interopRequireWildcard(require(\"react\"));\n    var _propTypes = _interopRequireDefault(require_prop_types());\n    var _lodash = _interopRequireDefault(require_lodash());\n    var _utils = require_utils2();\n    var _responsiveUtils = require_responsiveUtils();\n    var _ReactGridLayout = _interopRequireDefault(require_ReactGridLayout());\n    var _excluded = [\"breakpoint\", \"breakpoints\", \"cols\", \"layouts\", \"margin\", \"containerPadding\", \"onBreakpointChange\", \"onLayoutChange\", \"onWidthChange\"];\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n    function _getRequireWildcardCache(nodeInterop) {\n      if (typeof WeakMap !== \"function\")\n        return null;\n      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();\n      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();\n      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {\n        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;\n      })(nodeInterop);\n    }\n    function _interopRequireWildcard(obj, nodeInterop) {\n      if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n      }\n      if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n        return { default: obj };\n      }\n      var cache = _getRequireWildcardCache(nodeInterop);\n      if (cache && cache.has(obj)) {\n        return cache.get(obj);\n      }\n      var newObj = {};\n      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var key in obj) {\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n          if (desc && (desc.get || desc.set)) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n      newObj.default = obj;\n      if (cache) {\n        cache.set(obj, newObj);\n      }\n      return newObj;\n    }\n    function _extends() {\n      _extends = Object.assign || function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      };\n      return _extends.apply(this, arguments);\n    }\n    function _objectWithoutProperties(source, excluded) {\n      if (source == null)\n        return {};\n      var target = _objectWithoutPropertiesLoose(source, excluded);\n      var key, i;\n      if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for (i = 0; i < sourceSymbolKeys.length; i++) {\n          key = sourceSymbolKeys[i];\n          if (excluded.indexOf(key) >= 0)\n            continue;\n          if (!Object.prototype.propertyIsEnumerable.call(source, key))\n            continue;\n          target[key] = source[key];\n        }\n      }\n      return target;\n    }\n    function _objectWithoutPropertiesLoose(source, excluded) {\n      if (source == null)\n        return {};\n      var target = {};\n      var sourceKeys = Object.keys(source);\n      var key, i;\n      for (i = 0; i < sourceKeys.length; i++) {\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0)\n          continue;\n        target[key] = source[key];\n      }\n      return target;\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n      return target;\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n          descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps)\n        _defineProperties(Constructor, staticProps);\n      Object.defineProperty(Constructor, \"prototype\", { writable: false });\n      return Constructor;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });\n      Object.defineProperty(subClass, \"prototype\", { writable: false });\n      if (superClass)\n        _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _createSuper(Derived) {\n      var hasNativeReflectConstruct = _isNativeReflectConstruct();\n      return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n          var NewTarget = _getPrototypeOf(this).constructor;\n          result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n          result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n      };\n    }\n    function _possibleConstructorReturn(self2, call) {\n      if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n      } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n      }\n      return _assertThisInitialized(self2);\n    }\n    function _assertThisInitialized(self2) {\n      if (self2 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self2;\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct)\n        return false;\n      if (Reflect.construct.sham)\n        return false;\n      if (typeof Proxy === \"function\")\n        return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      };\n      return _getPrototypeOf(o);\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    var type = function type2(obj) {\n      return Object.prototype.toString.call(obj);\n    };\n    function getIndentationValue(param, breakpoint) {\n      if (param == null)\n        return null;\n      return Array.isArray(param) ? param : param[breakpoint];\n    }\n    var ResponsiveReactGridLayout = /* @__PURE__ */ function(_React$Component) {\n      _inherits(ResponsiveReactGridLayout2, _React$Component);\n      var _super = _createSuper(ResponsiveReactGridLayout2);\n      function ResponsiveReactGridLayout2() {\n        var _this;\n        _classCallCheck(this, ResponsiveReactGridLayout2);\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        _this = _super.call.apply(_super, [this].concat(args));\n        _defineProperty(_assertThisInitialized(_this), \"state\", _this.generateInitialState());\n        _defineProperty(_assertThisInitialized(_this), \"onLayoutChange\", function(layout) {\n          _this.props.onLayoutChange(layout, _objectSpread(_objectSpread({}, _this.props.layouts), {}, _defineProperty({}, _this.state.breakpoint, layout)));\n        });\n        return _this;\n      }\n      _createClass(ResponsiveReactGridLayout2, [{\n        key: \"generateInitialState\",\n        value: function generateInitialState() {\n          var _this$props = this.props, width = _this$props.width, breakpoints = _this$props.breakpoints, layouts = _this$props.layouts, cols = _this$props.cols;\n          var breakpoint = (0, _responsiveUtils.getBreakpointFromWidth)(breakpoints, width);\n          var colNo = (0, _responsiveUtils.getColsFromBreakpoint)(breakpoint, cols);\n          var compactType = this.props.verticalCompact === false ? null : this.props.compactType;\n          var initialLayout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(layouts, breakpoints, breakpoint, breakpoint, colNo, compactType);\n          return {\n            layout: initialLayout,\n            breakpoint,\n            cols: colNo\n          };\n        }\n      }, {\n        key: \"componentDidUpdate\",\n        value: function componentDidUpdate(prevProps) {\n          if (this.props.width != prevProps.width || this.props.breakpoint !== prevProps.breakpoint || !(0, _lodash.default)(this.props.breakpoints, prevProps.breakpoints) || !(0, _lodash.default)(this.props.cols, prevProps.cols)) {\n            this.onWidthChange(prevProps);\n          }\n        }\n      }, {\n        key: \"onWidthChange\",\n        value: function onWidthChange(prevProps) {\n          var _this$props2 = this.props, breakpoints = _this$props2.breakpoints, cols = _this$props2.cols, layouts = _this$props2.layouts, compactType = _this$props2.compactType;\n          var newBreakpoint = this.props.breakpoint || (0, _responsiveUtils.getBreakpointFromWidth)(this.props.breakpoints, this.props.width);\n          var lastBreakpoint = this.state.breakpoint;\n          var newCols = (0, _responsiveUtils.getColsFromBreakpoint)(newBreakpoint, cols);\n          var newLayouts = _objectSpread({}, layouts);\n          if (lastBreakpoint !== newBreakpoint || prevProps.breakpoints !== breakpoints || prevProps.cols !== cols) {\n            if (!(lastBreakpoint in newLayouts))\n              newLayouts[lastBreakpoint] = (0, _utils.cloneLayout)(this.state.layout);\n            var layout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(newLayouts, breakpoints, newBreakpoint, lastBreakpoint, newCols, compactType);\n            layout = (0, _utils.synchronizeLayoutWithChildren)(layout, this.props.children, newCols, compactType, this.props.allowOverlap);\n            newLayouts[newBreakpoint] = layout;\n            this.props.onLayoutChange(layout, newLayouts);\n            this.props.onBreakpointChange(newBreakpoint, newCols);\n            this.setState({\n              breakpoint: newBreakpoint,\n              layout,\n              cols: newCols\n            });\n          }\n          var margin = getIndentationValue(this.props.margin, newBreakpoint);\n          var containerPadding = getIndentationValue(this.props.containerPadding, newBreakpoint);\n          this.props.onWidthChange(this.props.width, margin, newCols, containerPadding);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var _this$props3 = this.props, breakpoint = _this$props3.breakpoint, breakpoints = _this$props3.breakpoints, cols = _this$props3.cols, layouts = _this$props3.layouts, margin = _this$props3.margin, containerPadding = _this$props3.containerPadding, onBreakpointChange = _this$props3.onBreakpointChange, onLayoutChange = _this$props3.onLayoutChange, onWidthChange = _this$props3.onWidthChange, other = _objectWithoutProperties(_this$props3, _excluded);\n          return /* @__PURE__ */ React3.createElement(_ReactGridLayout.default, _extends({}, other, {\n            margin: getIndentationValue(margin, this.state.breakpoint),\n            containerPadding: getIndentationValue(containerPadding, this.state.breakpoint),\n            onLayoutChange: this.onLayoutChange,\n            layout: this.state.layout,\n            cols: this.state.cols\n          }));\n        }\n      }], [{\n        key: \"getDerivedStateFromProps\",\n        value: function getDerivedStateFromProps(nextProps, prevState) {\n          if (!(0, _lodash.default)(nextProps.layouts, prevState.layouts)) {\n            var breakpoint = prevState.breakpoint, _cols = prevState.cols;\n            var newLayout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(nextProps.layouts, nextProps.breakpoints, breakpoint, breakpoint, _cols, nextProps.compactType);\n            return {\n              layout: newLayout,\n              layouts: nextProps.layouts\n            };\n          }\n          return null;\n        }\n      }]);\n      return ResponsiveReactGridLayout2;\n    }(React3.Component);\n    exports2.default = ResponsiveReactGridLayout;\n    _defineProperty(ResponsiveReactGridLayout, \"propTypes\", {\n      breakpoint: _propTypes.default.string,\n      breakpoints: _propTypes.default.object,\n      allowOverlap: _propTypes.default.bool,\n      cols: _propTypes.default.object,\n      margin: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.object]),\n      containerPadding: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.object]),\n      layouts: function layouts(props, propName) {\n        if (type(props[propName]) !== \"[object Object]\") {\n          throw new Error(\"Layout property must be an object. Received: \" + type(props[propName]));\n        }\n        Object.keys(props[propName]).forEach(function(key) {\n          if (!(key in props.breakpoints)) {\n            throw new Error(\"Each key in layouts must align with a key in breakpoints.\");\n          }\n          (0, _utils.validateLayout)(props.layouts[key], \"layouts.\" + key);\n        });\n      },\n      width: _propTypes.default.number.isRequired,\n      onBreakpointChange: _propTypes.default.func,\n      onLayoutChange: _propTypes.default.func,\n      onWidthChange: _propTypes.default.func\n    });\n    _defineProperty(ResponsiveReactGridLayout, \"defaultProps\", {\n      breakpoints: {\n        lg: 1200,\n        md: 996,\n        sm: 768,\n        xs: 480,\n        xxs: 0\n      },\n      cols: {\n        lg: 12,\n        md: 10,\n        sm: 6,\n        xs: 4,\n        xxs: 2\n      },\n      containerPadding: {\n        lg: null,\n        md: null,\n        sm: null,\n        xs: null,\n        xxs: null\n      },\n      layouts: {},\n      margin: [10, 10],\n      allowOverlap: false,\n      onBreakpointChange: _utils.noop,\n      onLayoutChange: _utils.noop,\n      onWidthChange: _utils.noop\n    });\n  }\n});\n\n// node_modules/react-grid-layout/build/components/WidthProvider.js\nvar require_WidthProvider = __commonJS({\n  \"node_modules/react-grid-layout/build/components/WidthProvider.js\"(exports2) {\n    \"use strict\";\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      return _typeof = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(obj2) {\n        return typeof obj2;\n      } : function(obj2) {\n        return obj2 && typeof Symbol == \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.default = WidthProvideRGL;\n    var React3 = _interopRequireWildcard(require(\"react\"));\n    var _propTypes = _interopRequireDefault(require_prop_types());\n    var _clsx = _interopRequireDefault(require_clsx());\n    var _excluded = [\"measureBeforeMount\"];\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n    function _getRequireWildcardCache(nodeInterop) {\n      if (typeof WeakMap !== \"function\")\n        return null;\n      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();\n      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();\n      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {\n        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;\n      })(nodeInterop);\n    }\n    function _interopRequireWildcard(obj, nodeInterop) {\n      if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n      }\n      if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n        return { default: obj };\n      }\n      var cache = _getRequireWildcardCache(nodeInterop);\n      if (cache && cache.has(obj)) {\n        return cache.get(obj);\n      }\n      var newObj = {};\n      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var key in obj) {\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n          if (desc && (desc.get || desc.set)) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n      newObj.default = obj;\n      if (cache) {\n        cache.set(obj, newObj);\n      }\n      return newObj;\n    }\n    function _extends() {\n      _extends = Object.assign || function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      };\n      return _extends.apply(this, arguments);\n    }\n    function _objectWithoutProperties(source, excluded) {\n      if (source == null)\n        return {};\n      var target = _objectWithoutPropertiesLoose(source, excluded);\n      var key, i;\n      if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for (i = 0; i < sourceSymbolKeys.length; i++) {\n          key = sourceSymbolKeys[i];\n          if (excluded.indexOf(key) >= 0)\n            continue;\n          if (!Object.prototype.propertyIsEnumerable.call(source, key))\n            continue;\n          target[key] = source[key];\n        }\n      }\n      return target;\n    }\n    function _objectWithoutPropertiesLoose(source, excluded) {\n      if (source == null)\n        return {};\n      var target = {};\n      var sourceKeys = Object.keys(source);\n      var key, i;\n      for (i = 0; i < sourceKeys.length; i++) {\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0)\n          continue;\n        target[key] = source[key];\n      }\n      return target;\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n          descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps)\n        _defineProperties(Constructor, staticProps);\n      Object.defineProperty(Constructor, \"prototype\", { writable: false });\n      return Constructor;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });\n      Object.defineProperty(subClass, \"prototype\", { writable: false });\n      if (superClass)\n        _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _createSuper(Derived) {\n      var hasNativeReflectConstruct = _isNativeReflectConstruct();\n      return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n          var NewTarget = _getPrototypeOf(this).constructor;\n          result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n          result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n      };\n    }\n    function _possibleConstructorReturn(self2, call) {\n      if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n      } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n      }\n      return _assertThisInitialized(self2);\n    }\n    function _assertThisInitialized(self2) {\n      if (self2 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self2;\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct)\n        return false;\n      if (Reflect.construct.sham)\n        return false;\n      if (typeof Proxy === \"function\")\n        return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      };\n      return _getPrototypeOf(o);\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    var layoutClassName = \"react-grid-layout\";\n    function WidthProvideRGL(ComposedComponent) {\n      var _class;\n      return _class = /* @__PURE__ */ function(_React$Component) {\n        _inherits(WidthProvider, _React$Component);\n        var _super = _createSuper(WidthProvider);\n        function WidthProvider() {\n          var _this;\n          _classCallCheck(this, WidthProvider);\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n          _this = _super.call.apply(_super, [this].concat(args));\n          _defineProperty(_assertThisInitialized(_this), \"state\", {\n            width: 1280\n          });\n          _defineProperty(_assertThisInitialized(_this), \"elementRef\", /* @__PURE__ */ React3.createRef());\n          _defineProperty(_assertThisInitialized(_this), \"mounted\", false);\n          _defineProperty(_assertThisInitialized(_this), \"onWindowResize\", function() {\n            if (!_this.mounted)\n              return;\n            var node = _this.elementRef.current;\n            if (node instanceof HTMLElement && node.offsetWidth) {\n              _this.setState({\n                width: node.offsetWidth\n              });\n            }\n          });\n          return _this;\n        }\n        _createClass(WidthProvider, [{\n          key: \"componentDidMount\",\n          value: function componentDidMount() {\n            this.mounted = true;\n            window.addEventListener(\"resize\", this.onWindowResize);\n            this.onWindowResize();\n          }\n        }, {\n          key: \"componentWillUnmount\",\n          value: function componentWillUnmount() {\n            this.mounted = false;\n            window.removeEventListener(\"resize\", this.onWindowResize);\n          }\n        }, {\n          key: \"render\",\n          value: function render() {\n            var _this$props = this.props, measureBeforeMount = _this$props.measureBeforeMount, rest = _objectWithoutProperties(_this$props, _excluded);\n            if (measureBeforeMount && !this.mounted) {\n              return /* @__PURE__ */ React3.createElement(\"div\", {\n                className: (0, _clsx.default)(this.props.className, layoutClassName),\n                style: this.props.style,\n                ref: this.elementRef\n              });\n            }\n            return /* @__PURE__ */ React3.createElement(ComposedComponent, _extends({\n              innerRef: this.elementRef\n            }, rest, this.state));\n          }\n        }]);\n        return WidthProvider;\n      }(React3.Component), _defineProperty(_class, \"defaultProps\", {\n        measureBeforeMount: false\n      }), _defineProperty(_class, \"propTypes\", {\n        measureBeforeMount: _propTypes.default.bool\n      }), _class;\n    }\n  }\n});\n\n// node_modules/react-grid-layout/index.js\nvar require_react_grid_layout = __commonJS({\n  \"node_modules/react-grid-layout/index.js\"(exports2, module2) {\n    module2.exports = require_ReactGridLayout().default;\n    module2.exports.utils = require_utils2();\n    module2.exports.Responsive = require_ResponsiveReactGridLayout().default;\n    module2.exports.Responsive.utils = require_responsiveUtils();\n    module2.exports.WidthProvider = require_WidthProvider().default;\n  }\n});\n\n// node_modules/lodash.debounce/index.js\nvar require_lodash2 = __commonJS({\n  \"node_modules/lodash.debounce/index.js\"(exports2, module2) {\n    var FUNC_ERROR_TEXT = \"Expected a function\";\n    var NAN = 0 / 0;\n    var symbolTag = \"[object Symbol]\";\n    var reTrim = /^\\s+|\\s+$/g;\n    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n    var reIsBinary = /^0b[01]+$/i;\n    var reIsOctal = /^0o[0-7]+$/i;\n    var freeParseInt = parseInt;\n    var freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\n    var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n    var root = freeGlobal || freeSelf || Function(\"return this\")();\n    var objectProto = Object.prototype;\n    var objectToString = objectProto.toString;\n    var nativeMax = Math.max;\n    var nativeMin = Math.min;\n    var now = function() {\n      return root.Date.now();\n    };\n    function debounce4(func, wait, options) {\n      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n      if (typeof func != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = \"maxWait\" in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n      }\n      function invokeFunc(time) {\n        var args = lastArgs, thisArg = lastThis;\n        lastArgs = lastThis = void 0;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n      function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = setTimeout(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n      }\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;\n        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;\n      }\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n      }\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n      function trailingEdge(time) {\n        timerId = void 0;\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = void 0;\n        return result;\n      }\n      function cancel() {\n        if (timerId !== void 0) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = void 0;\n      }\n      function flush() {\n        return timerId === void 0 ? result : trailingEdge(now());\n      }\n      function debounced() {\n        var time = now(), isInvoking = shouldInvoke(time);\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n          if (timerId === void 0) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === void 0) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n    function isObject(value) {\n      var type = typeof value;\n      return !!value && (type == \"object\" || type == \"function\");\n    }\n    function isObjectLike(value) {\n      return !!value && typeof value == \"object\";\n    }\n    function isSymbol(value) {\n      return typeof value == \"symbol\" || isObjectLike(value) && objectToString.call(value) == symbolTag;\n    }\n    function toNumber(value) {\n      if (typeof value == \"number\") {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n        value = isObject(other) ? other + \"\" : other;\n      }\n      if (typeof value != \"string\") {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, \"\");\n      var isBinary = reIsBinary.test(value);\n      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n    }\n    module2.exports = debounce4;\n  }\n});\n\n// node_modules/lodash.throttle/index.js\nvar require_lodash3 = __commonJS({\n  \"node_modules/lodash.throttle/index.js\"(exports2, module2) {\n    var FUNC_ERROR_TEXT = \"Expected a function\";\n    var NAN = 0 / 0;\n    var symbolTag = \"[object Symbol]\";\n    var reTrim = /^\\s+|\\s+$/g;\n    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n    var reIsBinary = /^0b[01]+$/i;\n    var reIsOctal = /^0o[0-7]+$/i;\n    var freeParseInt = parseInt;\n    var freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\n    var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n    var root = freeGlobal || freeSelf || Function(\"return this\")();\n    var objectProto = Object.prototype;\n    var objectToString = objectProto.toString;\n    var nativeMax = Math.max;\n    var nativeMin = Math.min;\n    var now = function() {\n      return root.Date.now();\n    };\n    function debounce4(func, wait, options) {\n      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n      if (typeof func != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = \"maxWait\" in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n      }\n      function invokeFunc(time) {\n        var args = lastArgs, thisArg = lastThis;\n        lastArgs = lastThis = void 0;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n      function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = setTimeout(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n      }\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;\n        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;\n      }\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n      }\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n      function trailingEdge(time) {\n        timerId = void 0;\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = void 0;\n        return result;\n      }\n      function cancel() {\n        if (timerId !== void 0) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = void 0;\n      }\n      function flush() {\n        return timerId === void 0 ? result : trailingEdge(now());\n      }\n      function debounced() {\n        var time = now(), isInvoking = shouldInvoke(time);\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n          if (timerId === void 0) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === void 0) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n    function throttle2(func, wait, options) {\n      var leading = true, trailing = true;\n      if (typeof func != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = \"leading\" in options ? !!options.leading : leading;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n      }\n      return debounce4(func, wait, {\n        \"leading\": leading,\n        \"maxWait\": wait,\n        \"trailing\": trailing\n      });\n    }\n    function isObject(value) {\n      var type = typeof value;\n      return !!value && (type == \"object\" || type == \"function\");\n    }\n    function isObjectLike(value) {\n      return !!value && typeof value == \"object\";\n    }\n    function isSymbol(value) {\n      return typeof value == \"symbol\" || isObjectLike(value) && objectToString.call(value) == symbolTag;\n    }\n    function toNumber(value) {\n      if (typeof value == \"number\") {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n        value = isObject(other) ? other + \"\" : other;\n      }\n      if (typeof value != \"string\") {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, \"\");\n      var isBinary = reIsBinary.test(value);\n      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n    }\n    module2.exports = throttle2;\n  }\n});\n\n// src/flowtiwi-sidebar.ts\nvar import_debounce = __toESM(require_debounce());\n\n// src/components/multi-column.tsx\nvar import_react34 = __toESM(require(\"react\"));\nvar import_tw_react2 = __toESM(require_tw_react());\nvar import_react_sizeme = __toESM(require_react_sizeme());\nvar import_react_grid_layout = __toESM(require_react_grid_layout());\n\n// node_modules/beautiful-react-hooks/esm/useDidMount.js\nvar import_react2 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/shared/useHandlerSetterRef.js\nvar import_react = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useWillUnmount.js\nvar import_react3 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useGlobalEvent.js\nvar import_react4 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useDebouncedCallback.js\nvar import_react5 = require(\"react\");\nvar import_lodash = __toESM(require_lodash2());\nvar defaultOptions = {\n  leading: false,\n  trailing: true\n};\nvar useDebouncedCallback = (fn, dependencies = [], wait = 250, options = defaultOptions) => {\n  const debounced = (0, import_react5.useRef)((0, import_lodash.default)(fn, wait, options));\n  (0, import_react5.useEffect)(() => {\n    debounced.current = (0, import_lodash.default)(fn, wait, options);\n  }, [fn, wait, options]);\n  return (0, import_react5.useCallback)(debounced.current, dependencies);\n};\nvar useDebouncedCallback_default = useDebouncedCallback;\n\n// node_modules/beautiful-react-hooks/esm/useThrottledCallback.js\nvar import_react6 = require(\"react\");\nvar import_lodash2 = __toESM(require_lodash3());\n\n// node_modules/beautiful-react-hooks/esm/shared/assignEventOnMount.js\nvar import_react7 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useMouseState.js\nvar import_react8 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useTimeout.js\nvar import_react9 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useInterval.js\nvar import_react10 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/usePreviousValue.js\nvar import_react11 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useGeolocationState.js\nvar import_react13 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useGeolocationEvents.js\nvar import_react12 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/shared/geolocationStandardOptions.js\nvar geoStandardOptions = Object.freeze({\n  enableHighAccuracy: false,\n  timeout: 4294967295,\n  maximumAge: 0\n});\n\n// node_modules/beautiful-react-hooks/esm/useMediaQuery.js\nvar import_react14 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/shared/isClient.js\nvar isClient = typeof window === \"object\";\nvar isClient_default = isClient;\n\n// node_modules/beautiful-react-hooks/esm/shared/isAPISupported.js\nvar isApiSupported = (api) => typeof window !== \"undefined\" ? api in window : false;\nvar isAPISupported_default = isApiSupported;\n\n// node_modules/beautiful-react-hooks/esm/useValueHistory.js\nvar import_react15 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useOnlineState.js\nvar import_react16 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useViewportSpy.js\nvar import_react17 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/shared/isDevelopment.js\nvar isDevelopment = typeof process !== \"undefined\" && process.env && true;\nvar isDevelopment_default = isDevelopment;\n\n// node_modules/beautiful-react-hooks/esm/useValidatedState.js\nvar import_react18 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useDragEvents.js\nvar import_react19 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useDrag.js\nvar import_react20 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useDropZone.js\nvar import_react21 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useRequestAnimationFrame.js\nvar import_react22 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/shared/createStorageHook.js\nvar import_react23 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/shared/safelyParseJson.js\nvar safelyParseJson = (parseString) => {\n  try {\n    return JSON.parse(parseString);\n  } catch (e) {\n    return null;\n  }\n};\nvar safelyParseJson_default = safelyParseJson;\n\n// node_modules/beautiful-react-hooks/esm/shared/createStorageHook.js\nvar createStorageHook = (type) => {\n  const storageName = `${type}Storage`;\n  if (isClient_default && !isAPISupported_default(storageName)) {\n    console.warn(`${storageName} is not supported`);\n  }\n  return (storageKey, defaultValue) => {\n    if (!isClient_default) {\n      if (isDevelopment_default) {\n        console.warn(`Please be aware that ${storageName} could not be available during SSR`);\n      }\n      return [JSON.stringify(defaultValue), () => void 0];\n    }\n    const storage = window[storageName];\n    const [value, setValue] = (0, import_react23.useState)(safelyParseJson_default(storage.getItem(storageKey) || JSON.stringify(defaultValue)));\n    (0, import_react23.useEffect)(() => {\n      storage.setItem(storageKey, JSON.stringify(value));\n    }, [storageKey, value]);\n    return [value, setValue];\n  };\n};\nvar createStorageHook_default = createStorageHook;\n\n// node_modules/beautiful-react-hooks/esm/useLocalStorage.js\nvar useLocalStorage = createStorageHook_default(\"local\");\n\n// node_modules/beautiful-react-hooks/esm/useSessionStorage.js\nvar useSessionStorage = createStorageHook_default(\"session\");\n\n// node_modules/beautiful-react-hooks/esm/useResizeObserver.js\nvar import_react24 = require(\"react\");\nvar import_lodash3 = __toESM(require_lodash2());\n\n// node_modules/beautiful-react-hooks/esm/useDefaultedState.js\nvar import_react25 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useObservable.js\nvar import_react26 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useSpeechSynthesis.js\nvar import_react27 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useSystemVoices.js\nvar import_react28 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useRenderInfo.js\nvar import_react29 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useSwipe.js\nvar import_react30 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useSwipeEvents.js\nvar import_react31 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/useConditionalTimeout.js\nvar import_react32 = require(\"react\");\n\n// src/components/content.tsx\nvar import_react33 = __toESM(require(\"react\"));\nvar import_tw_react = __toESM(require_tw_react());\nfunction SideBarContent(props) {\n  const tabContentRef = (0, import_react33.createRef)();\n  (0, import_tw_react.useRenderTiddler)(props.title, tabContentRef);\n  return /* @__PURE__ */ import_react33.default.createElement(\"div\", {\n    className: \"flowtiwi-sidebar-tab-content\",\n    ref: tabContentRef\n  });\n}\n\n// src/components/multi-column.tsx\nvar import_tw_react3 = __toESM(require_tw_react());\n\n// src/config.ts\nvar DEBOUNCE_UPDATE_INTERVAL = 2e3;\n\n// src/components/multi-column.tsx\nvar defaultBreakpoints = { lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 };\nvar defaultCols = { lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 };\nvar defaultMargin = [0, 0];\nfunction MultiColumn(props) {\n  const [allLayouts, setAllLayouts] = (0, import_react34.useState)(props.layouts);\n  const debouncedOnChange = useDebouncedCallback_default(props.onChange, [], 1e3);\n  const onLayoutChange = (layout, newAllLayouts) => {\n    setAllLayouts(newAllLayouts);\n    debouncedOnChange(newAllLayouts);\n  };\n  const onClick = (0, import_react34.useCallback)((event, to) => {\n    if (!props.parentWidget)\n      return;\n    event.preventDefault();\n    event.stopPropagation();\n    const twNavigateEvent = {\n      type: \"tm-navigate\",\n      navigateTo: to,\n      navigateFromTitle: props.parentWidget.getVariable(\"storyTiddler\"),\n      navigateFromNode: props.parentWidget,\n      navigateSuppressNavigation: event.metaKey || event.ctrlKey || event.button === 1,\n      metaKey: event.metaKey,\n      ctrlKey: event.ctrlKey,\n      altKey: event.altKey,\n      shiftKey: event.shiftKey,\n      event: event.nativeEvent\n    };\n    props.parentWidget.dispatchEvent(twNavigateEvent);\n  }, [props.parentWidget]);\n  const sidebarTabTitles = (0, import_tw_react2.useFilter)(\"[all[shadows+tiddlers]tag[$:/tags/SideBar]!has[draft.of]]\");\n  const gridChildren = (0, import_react34.useMemo)(() => sidebarTabTitles.map((title) => {\n    const tiddler = $tw.wiki.getTiddler(title);\n    const renderedCaption = $tw.wiki.renderText(\"text/plain\", \"text/vnd.tiddlywiki\", tiddler?.fields?.caption ?? title, {\n      parseAsInline: true,\n      parentWidget: props.parentWidget\n    });\n    return /* @__PURE__ */ import_react34.default.createElement(\"div\", {\n      key: title\n    }, /* @__PURE__ */ import_react34.default.createElement(\"div\", {\n      className: \"flowtiwi-sidebar-tab-handle\"\n    }, /* @__PURE__ */ import_react34.default.createElement(\"span\", {\n      className: \"flowtiwi-sidebar-tab-handle-title\",\n      onClick: (event) => onClick(event, title)\n    }, renderedCaption)), /* @__PURE__ */ import_react34.default.createElement(SideBarContent, {\n      title\n    }));\n  }), [sidebarTabTitles, onClick]);\n  return /* @__PURE__ */ import_react34.default.createElement(import_tw_react3.ParentWidgetContext.Provider, {\n    value: props.parentWidget\n  }, /* @__PURE__ */ import_react34.default.createElement(import_react_sizeme.SizeMe, {\n    refreshRate: DEBOUNCE_UPDATE_INTERVAL / 2\n  }, ({ size }) => size.width ? /* @__PURE__ */ import_react34.default.createElement(import_react_grid_layout.Responsive, {\n    draggableHandle: \".flowtiwi-sidebar-tab-handle\",\n    width: Math.floor(size.width),\n    className: \"layout tc-sidebar-tabs-main\",\n    onLayoutChange,\n    layouts: allLayouts,\n    isBounded: true,\n    breakpoints: defaultBreakpoints,\n    cols: defaultCols,\n    margin: defaultMargin,\n    autoSize: true\n  }, gridChildren) : /* @__PURE__ */ import_react34.default.createElement(\"div\", null)));\n}\n\n// src/flowtiwi-sidebar.ts\nvar Widget = require(\"$:/plugins/linonetwo/tw-react/widget.js\").widget;\nvar FlowTiWiWidget = class extends Widget {\n  constructor(parseTreeNode, options) {\n    super(parseTreeNode, options);\n    const debouncedRefresh = (0, import_debounce.default)(this.refresh.bind(this), DEBOUNCE_UPDATE_INTERVAL * 1.5);\n    this.refresh = (changedTiddlers) => {\n      debouncedRefresh(changedTiddlers);\n      return true;\n    };\n  }\n  refresh(changedTiddlers) {\n    const sidebarClosed = $tw.wiki.getTiddlerText(\"$:/state/sidebar\") === \"no\";\n    if (sidebarClosed) {\n      return false;\n    }\n    return this.refreshChildren(changedTiddlers);\n  }\n  reactComponent = MultiColumn;\n  getProps = () => {\n    const stateTiddler = this.getAttribute(\"stateTiddler\", \"$:/plugins/linonetwo/flowtiwi-sidebar/state\");\n    const layouts = $tw.wiki.getTiddlerData(stateTiddler, {});\n    const onChange = (newLayouts) => {\n      $tw.wiki.setTiddlerData(stateTiddler, newLayouts);\n    };\n    return { layouts, onChange, defaultItemLayout: { w: 2 } };\n  };\n};\nexports.flowTiWi = FlowTiWiWidget;\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n","creator":"LinOnetwo","type":"application/javascript","module-type":"widget"},"$:/plugins/linonetwo/flowtiwi-sidebar/readme":{"title":"$:/plugins/linonetwo/flowtiwi-sidebar/readme","creator":"LinOnetwo","type":"text/vnd.tiddlywiki","text":"!! Why this \n\nI always hope I can view multiple sidebar tabs at the same time, so I try to make this plugin. You can reorder sidebar tabs block with their title, and resize each tab block with the handle on the bottom right of each tab block.\n\nKnowledge is full of context, but the human brain has a limited working memory, so in order to keep this Cybersyn efficient when I/O knowledge through human-computer interface, we need the machine to provide an interface such as a dynamic sidebar to display real-time context to assist the human part of the system in obtaining context at low cost. Different types of work require different types and amounts of context, so the sidebar needs to be able to adjust the size of the display area and the content of area in real time through human interaction and automation API, to make the work unconstrained from the working memory.\n\n\n\n\n\n!! Install \n\n[[Install from CPL|https://tw-cpl.netlify.app/]]\n\n[[CPL|https://tw-cpl.netlify.app/]]\n\n!! How to use \n\nYou can resize the tab block to be narrower so there can be two columns of tab blocks. And you can resize the sidebar (using [[Resizable Sidebar|https://talk.tiddlywiki.org/t/resizable-sidebar-resize-your-sidebar-with-mouse-dragging/1740]]) so you get more space for more columns. \n\n([[Resizable Sidebar|https://talk.tiddlywiki.org/t/resizable-sidebar-resize-your-sidebar-with-mouse-dragging/1740]])\n"},"dist/plugins/linonetwo/flowtiwi-sidebar/style.css":{"title":"dist/plugins/linonetwo/flowtiwi-sidebar/style.css","text":".flowtiwi-sidebar-tab-content {\n  height: calc(100% - 1.5em);\n  overflow: hidden;\n\n  padding-left: 5px;\n}\n.flowtiwi-sidebar-tab-content:hover {\n  overflow: auto;\n  overflow: overlay;\n}\n/** remove default sidebar's some style */\n.tc-sidebar-header .tc-sidebar-lists p {\n  margin: 0;\n}\n/** these layers are generated, make sure they fit the height, so content using height 100% can fit the block without scrollbar */\n.flowtiwi-sidebar-tab-content > div,\n.flowtiwi-sidebar-tab-content > div > div,\n.flowtiwi-sidebar-tab-content > div > div > p {\n  height: 100%;\n  margin: 0;\n  padding: 0;\n}\n.flowtiwi-sidebar-tab-handle {\n  user-select: none;\n  cursor: grabbing;\n  text-overflow: ellipsis;\n\n  height: 1.5em;\n  white-space: nowrap;\n  overflow: hidden;\n  padding-left: 5px;\n}\n.flowtiwi-sidebar-tab-handle-title {\n  cursor: pointer;\n}\n"},"$:/themes/linonetwo/flowtiwi-sidebar/additional-style":{"title":"$:/themes/linonetwo/flowtiwi-sidebar/additional-style","tags":"$:/tags/Stylesheet","type":"text/vnd.tiddlywiki","text":".flowtiwi-sidebar-tab-handle {\n  background: <<colour button-background>>\n}\n"},"$:/core/ui/SideBarSegments/tabs":{"title":"$:/core/ui/SideBarSegments/tabs","tags":"$:/tags/SideBarSegment","text":"<div class=\"tc-sidebar-lists tc-sidebar-tabs\">\n\n<$flowTiWi />\n\n<!-- <$macrocall $name=\"tabs\" tabsList=\"[all[shadows+tiddlers]tag[$:/tags/SideBar]!has[draft.of]]\" default={{$:/config/DefaultSidebarTab}} state=\"$:/state/tab/sidebar\" class=\"tc-sidebar-tabs-main\" explicitState=\"$:/state/tab/sidebar--595412856\"/> -->\n\n</div>\n"}}}