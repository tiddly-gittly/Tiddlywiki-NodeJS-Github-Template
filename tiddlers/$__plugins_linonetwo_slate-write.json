{"tiddlers":{"$:/plugins/linonetwo/slate-write/develop":{"title":"$:/plugins/linonetwo/slate-write/develop","type":"text/vnd.tiddlywiki","text":"!! How this works\n\n# Offer an widget in `src/widget.js` and `src/components/index.ts`, where we provide props like `currentTiddler` to the actual react component in `src/components/editor.tsx`\n## Some basic mark and elements like ''bold'' and ordered list are supported by slate plugins imported from `src/config/plugins.ts`\n## render advanced tiddlywiki widgets using [[tw-react|https://github.com/tiddly-gittly/tw-react]]'s `useWidget` hook, in our own plugin `src/config/plugins/widget/WidgetBlock.tsx`\n### Things like widget, macro and codeblock are [[Void Node|https://docs.slatejs.org/api/nodes/element#void-vs-not-void]], slate won't render its AST children, we have full control\n### replace codeblock with codemirror or monaco, so plate's default prism code syntax highlighter won't need to be bundled with our plugin, it is too big\n# Transform AST to Slate JSON using transformers in src/transform, see `src/transform/README.md` for details. This also transform Slate JSON back to the wikiast and then serialize to wikitext.\n## we add some type of wikiast to [[tw5-typed|https://github.com/tiddly-gittly/TW5-Typed]], based on the real json output of `$tw.wiki.parseText('text/vnd.tiddlywiki', input).tree`\n## This is imported in editor by `import { deserialize, serialize } from '../../src/transform/serialize';`, and those serialize and deserialize functions uses things in the `src/transform`\n## All supported wikitext syntax are tested in the `test` folder, and the tests are run with `npm run test`, you should also add test if you are adding new transformers for new syntax.\n# handle keyboard shortcut and basic elements' rendering using slatejs plugins from [[Udecode's Plate framework|https://plate.udecode.io]].\n## our custom keyboard shortcuts are configured in `src/config/autoformat`\n## re-support `/` menu in [[Gk0Wk/TW5-CodeMirror-Enhanced|https://github.com/Gk0Wk/TW5-CodeMirror-Enhanced]] to add snippets and advanced elements like table and widget and any wikitext source code\n### `/` menu component is at `src/editor/components/SnippetCombobox.tsx`, and snippets are loaded in `src/editor/config/snippets.ts`\n# There will be a floating toolbar when you selecting text, and you can click on the toolbar to change the text's decoration, this is a react component defined in `src/config/components/Toolbars.tsx`\n# When hover on the left of a block, there will be a Drag and drop handle, render by `src/editor/components/withStyledDraggables.tsx`\n## Different block have different line height, so we need to add different padding here to align drag handle with the block.\n## allow drag to reorder blocks, onDrop listeners are in `src/editor/plugins/dnd/hooks` that copied from plate's source\n### code are copy from udecode/plate's repo to `src/editor/plugins/dnd` folder, and have modification in `src/editor/plugins/dnd/hooks/useDragBlock.ts` to set `$tw.dragInProgress = true`\n## support drag to reorder list items and widget, components registered in `src/editor/components/index.ts` will be draggable\n# autocomplete `[[`'s and `{{`'s linkable tiddlers result\n## the code handles special `auto_complete_input` node that contains text to search after typing `/` or `[[` is copied from plate to `src/editor/plugins/autoComplete`\n## `src/editor/plugins/autoComplete/withAutoComplete.ts` will put text in the `auto_complete_input` node to the redux (zustand npm package) store `useAutoCompletePluginStore`\n## code in `src/editor/plugins/comboBox` will get text and list from the store `useAutoCompletePluginStore`, and handles dropdown (combobox) interaction using `downshift` npm package\n## And the final comboBox React component and the data source of tiddlers/macros/snippets are in the `src/editor/components/combobox` folder\n## autocomplete `<<`'s available macros as discussed in [[TiddlyWiki5/discussions/6706|https://github.com/Jermolene/TiddlyWiki5/discussions/6706]]\n## autocomplete `<$`'s available widget and fields, see `src/editor/components/combobox/WidgetCombobox.tsx`, in `widgetItems`, text field is the text that will be inserted, this logic is at `src/editor/plugins/comboBox/getAutoCompleteOnSelectItem.ts`\n# Only import needed components from their deepest package to achieve \"tree shaking\" to reduce bundle size\n## e.g., `import { LinkElement } from '@udecode/plate-ui-link';` instead of `import { LinkElement } from '@udecode/plate';`\n## Some element from plate are not needed, like ImageElement can be replaced by tw's own image widget, so don't import it. And for code-block, we use our own codemirror based element located in `src/editor/plugins/codeblock/CodeBlockElement/CodeBlockElement.tsx`\n\n!! TODO\n\n# TODO: allow editing widget and any block's source code, and get preview at real time.\n# TODO: allow use tw's default editor toolbar's buttons and their keyboard shortcuts\n# TODO: optimization: use section splitter in section-editor to ensure only a small potion of text will `onChange` and rerender. And we can get start-end of section from section splitter, so replace the section of text onChange.\n# TODO: allow drag images in and import the image\n# TODO: context menu when click on the drag handle\n# TODO: context menu when select special block\n# TODO: i18n for readme and placeholder\n# TODO: allow 3rd party plugin to control the editor, for example, the command palette and the fishing plugin.\n# TODO: add more selection operation, or maybe in command palette, like \"refactor to new tiddler\"\n# TODO: insert latex math using `$$` or `￥￥` shortcut\n# TODO: open context aware autocomplete using `ctrl+space`, show corresponding dropdown menu using prefix of the selection\n# TODO: add excalidraw widget support\n\n!! Development\n\nInstall and run\n\n```sh\nnpm i\nnpm run dev\n```\n\nRun tests\n\n```sh\nnpm test\n```\n\nTest JSON plugin\n\n```sh\nnpm run dev-html\n```\n\nMake production build: See `.github/workflows/release.yml`, adding a tag like `v0.1.1` to a commit and push to github will make a build.\n\n!!! Modify build scripts\n\nScripts is based on [[Gk0Wk's|https://github.com/Gk0Wk]] [[tiddly-gittly/Modern.TiddlyDev|https://github.com/tiddly-gittly/Modern.TiddlyDev]] and [[LinOnetwo's|https://github.com/linonetwo]] [[tiddly-gittly/TiddlyWiki-TS-Plugin-Template|https://github.com/tiddly-gittly/TiddlyWiki-TS-Plugin-Template]]. With some modification to adapt react dom.\n"},"$:/plugins/linonetwo/slate-write/components/index.css":{"title":"$:/plugins/linonetwo/slate-write/components/index.css","text":".tippy-box[data-animation=scale][data-placement^=top]{transform-origin:bottom}.tippy-box[data-animation=scale][data-placement^=bottom]{transform-origin:top}.tippy-box[data-animation=scale][data-placement^=left]{transform-origin:right}.tippy-box[data-animation=scale][data-placement^=right]{transform-origin:left}.tippy-box[data-animation=scale][data-state=hidden]{transform:scale(.5);opacity:0}.tippy-box[data-animation=fade][data-state=hidden]{opacity:0}[data-tippy-root]{max-width:calc(100vw - 10px)}.tippy-box{position:relative;background-color:#333;color:#fff;border-radius:4px;font-size:14px;line-height:1.4;white-space:normal;outline:0;transition-property:transform,visibility,opacity}.tippy-box[data-placement^=top]>.tippy-arrow{bottom:0}.tippy-box[data-placement^=top]>.tippy-arrow:before{bottom:-7px;left:0;border-width:8px 8px 0;border-top-color:initial;transform-origin:center top}.tippy-box[data-placement^=bottom]>.tippy-arrow{top:0}.tippy-box[data-placement^=bottom]>.tippy-arrow:before{top:-7px;left:0;border-width:0 8px 8px;border-bottom-color:initial;transform-origin:center bottom}.tippy-box[data-placement^=left]>.tippy-arrow{right:0}.tippy-box[data-placement^=left]>.tippy-arrow:before{border-width:8px 0 8px 8px;border-left-color:initial;right:-7px;transform-origin:center left}.tippy-box[data-placement^=right]>.tippy-arrow{left:0}.tippy-box[data-placement^=right]>.tippy-arrow:before{left:-7px;border-width:8px 8px 8px 0;border-right-color:initial;transform-origin:center right}.tippy-box[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-arrow{width:16px;height:16px;color:#333}.tippy-arrow:before{content:\"\";position:absolute;border-color:transparent;border-style:solid}.tippy-content{position:relative;padding:5px 9px;z-index:1}","tags":"$:/tags/Stylesheet","type":"text/css"},"$:/plugins/linonetwo/slate-write/components/index.js":{"title":"$:/plugins/linonetwo/slate-write/components/index.js","text":"\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// node_modules/direction/index.js\nvar require_direction = __commonJS({\n  \"node_modules/direction/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = direction;\n    var RTL = \"\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC\";\n    var LTR = \"A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C\\uFE00-\\uFE6F\\uFEFD-\\uFFFF\";\n    var rtl = new RegExp(\"^[^\" + LTR + \"]*[\" + RTL + \"]\");\n    var ltr = new RegExp(\"^[^\" + RTL + \"]*[\" + LTR + \"]\");\n    function direction(value) {\n      value = String(value || \"\");\n      if (rtl.test(value)) {\n        return \"rtl\";\n      }\n      if (ltr.test(value)) {\n        return \"ltr\";\n      }\n      return \"neutral\";\n    }\n  }\n});\n\n// node_modules/lodash/isObject.js\nvar require_isObject = __commonJS({\n  \"node_modules/lodash/isObject.js\"(exports2, module2) {\n    function isObject7(value) {\n      var type = typeof value;\n      return value != null && (type == \"object\" || type == \"function\");\n    }\n    module2.exports = isObject7;\n  }\n});\n\n// node_modules/lodash/_freeGlobal.js\nvar require_freeGlobal = __commonJS({\n  \"node_modules/lodash/_freeGlobal.js\"(exports2, module2) {\n    var freeGlobal5 = typeof global == \"object\" && global && global.Object === Object && global;\n    module2.exports = freeGlobal5;\n  }\n});\n\n// node_modules/lodash/_root.js\nvar require_root = __commonJS({\n  \"node_modules/lodash/_root.js\"(exports2, module2) {\n    var freeGlobal5 = require_freeGlobal();\n    var freeSelf5 = typeof self == \"object\" && self && self.Object === Object && self;\n    var root5 = freeGlobal5 || freeSelf5 || Function(\"return this\")();\n    module2.exports = root5;\n  }\n});\n\n// node_modules/lodash/now.js\nvar require_now = __commonJS({\n  \"node_modules/lodash/now.js\"(exports2, module2) {\n    var root5 = require_root();\n    var now = function() {\n      return root5.Date.now();\n    };\n    module2.exports = now;\n  }\n});\n\n// node_modules/lodash/_trimmedEndIndex.js\nvar require_trimmedEndIndex = __commonJS({\n  \"node_modules/lodash/_trimmedEndIndex.js\"(exports2, module2) {\n    var reWhitespace = /\\s/;\n    function trimmedEndIndex(string2) {\n      var index5 = string2.length;\n      while (index5-- && reWhitespace.test(string2.charAt(index5))) {\n      }\n      return index5;\n    }\n    module2.exports = trimmedEndIndex;\n  }\n});\n\n// node_modules/lodash/_baseTrim.js\nvar require_baseTrim = __commonJS({\n  \"node_modules/lodash/_baseTrim.js\"(exports2, module2) {\n    var trimmedEndIndex = require_trimmedEndIndex();\n    var reTrimStart = /^\\s+/;\n    function baseTrim(string2) {\n      return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, \"\") : string2;\n    }\n    module2.exports = baseTrim;\n  }\n});\n\n// node_modules/lodash/_Symbol.js\nvar require_Symbol = __commonJS({\n  \"node_modules/lodash/_Symbol.js\"(exports2, module2) {\n    var root5 = require_root();\n    var Symbol4 = root5.Symbol;\n    module2.exports = Symbol4;\n  }\n});\n\n// node_modules/lodash/_getRawTag.js\nvar require_getRawTag = __commonJS({\n  \"node_modules/lodash/_getRawTag.js\"(exports2, module2) {\n    var Symbol4 = require_Symbol();\n    var objectProto5 = Object.prototype;\n    var hasOwnProperty6 = objectProto5.hasOwnProperty;\n    var nativeObjectToString5 = objectProto5.toString;\n    var symToStringTag5 = Symbol4 ? Symbol4.toStringTag : void 0;\n    function getRawTag5(value) {\n      var isOwn = hasOwnProperty6.call(value, symToStringTag5), tag = value[symToStringTag5];\n      try {\n        value[symToStringTag5] = void 0;\n        var unmasked = true;\n      } catch (e4) {\n      }\n      var result = nativeObjectToString5.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag5] = tag;\n        } else {\n          delete value[symToStringTag5];\n        }\n      }\n      return result;\n    }\n    module2.exports = getRawTag5;\n  }\n});\n\n// node_modules/lodash/_objectToString.js\nvar require_objectToString = __commonJS({\n  \"node_modules/lodash/_objectToString.js\"(exports2, module2) {\n    var objectProto5 = Object.prototype;\n    var nativeObjectToString5 = objectProto5.toString;\n    function objectToString5(value) {\n      return nativeObjectToString5.call(value);\n    }\n    module2.exports = objectToString5;\n  }\n});\n\n// node_modules/lodash/_baseGetTag.js\nvar require_baseGetTag = __commonJS({\n  \"node_modules/lodash/_baseGetTag.js\"(exports2, module2) {\n    var Symbol4 = require_Symbol();\n    var getRawTag5 = require_getRawTag();\n    var objectToString5 = require_objectToString();\n    var nullTag5 = \"[object Null]\";\n    var undefinedTag5 = \"[object Undefined]\";\n    var symToStringTag5 = Symbol4 ? Symbol4.toStringTag : void 0;\n    function baseGetTag5(value) {\n      if (value == null) {\n        return value === void 0 ? undefinedTag5 : nullTag5;\n      }\n      return symToStringTag5 && symToStringTag5 in Object(value) ? getRawTag5(value) : objectToString5(value);\n    }\n    module2.exports = baseGetTag5;\n  }\n});\n\n// node_modules/lodash/isObjectLike.js\nvar require_isObjectLike = __commonJS({\n  \"node_modules/lodash/isObjectLike.js\"(exports2, module2) {\n    function isObjectLike5(value) {\n      return value != null && typeof value == \"object\";\n    }\n    module2.exports = isObjectLike5;\n  }\n});\n\n// node_modules/lodash/isSymbol.js\nvar require_isSymbol = __commonJS({\n  \"node_modules/lodash/isSymbol.js\"(exports2, module2) {\n    var baseGetTag5 = require_baseGetTag();\n    var isObjectLike5 = require_isObjectLike();\n    var symbolTag4 = \"[object Symbol]\";\n    function isSymbol2(value) {\n      return typeof value == \"symbol\" || isObjectLike5(value) && baseGetTag5(value) == symbolTag4;\n    }\n    module2.exports = isSymbol2;\n  }\n});\n\n// node_modules/lodash/toNumber.js\nvar require_toNumber = __commonJS({\n  \"node_modules/lodash/toNumber.js\"(exports2, module2) {\n    var baseTrim = require_baseTrim();\n    var isObject7 = require_isObject();\n    var isSymbol2 = require_isSymbol();\n    var NAN = 0 / 0;\n    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n    var reIsBinary = /^0b[01]+$/i;\n    var reIsOctal = /^0o[0-7]+$/i;\n    var freeParseInt = parseInt;\n    function toNumber(value) {\n      if (typeof value == \"number\") {\n        return value;\n      }\n      if (isSymbol2(value)) {\n        return NAN;\n      }\n      if (isObject7(value)) {\n        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n        value = isObject7(other) ? other + \"\" : other;\n      }\n      if (typeof value != \"string\") {\n        return value === 0 ? value : +value;\n      }\n      value = baseTrim(value);\n      var isBinary = reIsBinary.test(value);\n      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n    }\n    module2.exports = toNumber;\n  }\n});\n\n// node_modules/lodash/debounce.js\nvar require_debounce = __commonJS({\n  \"node_modules/lodash/debounce.js\"(exports2, module2) {\n    var isObject7 = require_isObject();\n    var now = require_now();\n    var toNumber = require_toNumber();\n    var FUNC_ERROR_TEXT3 = \"Expected a function\";\n    var nativeMax2 = Math.max;\n    var nativeMin = Math.min;\n    function debounce6(func, wait, options) {\n      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n      if (typeof func != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT3);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject7(options)) {\n        leading = !!options.leading;\n        maxing = \"maxWait\" in options;\n        maxWait = maxing ? nativeMax2(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n      }\n      function invokeFunc(time) {\n        var args = lastArgs, thisArg = lastThis;\n        lastArgs = lastThis = void 0;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n      function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = setTimeout(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n      }\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;\n        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n      }\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n      }\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n      function trailingEdge(time) {\n        timerId = void 0;\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = void 0;\n        return result;\n      }\n      function cancel() {\n        if (timerId !== void 0) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = void 0;\n      }\n      function flush() {\n        return timerId === void 0 ? result : trailingEdge(now());\n      }\n      function debounced() {\n        var time = now(), isInvoking = shouldInvoke(time);\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n          if (timerId === void 0) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            clearTimeout(timerId);\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === void 0) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n    module2.exports = debounce6;\n  }\n});\n\n// node_modules/lodash/throttle.js\nvar require_throttle = __commonJS({\n  \"node_modules/lodash/throttle.js\"(exports2, module2) {\n    var debounce6 = require_debounce();\n    var isObject7 = require_isObject();\n    var FUNC_ERROR_TEXT3 = \"Expected a function\";\n    function throttle2(func, wait, options) {\n      var leading = true, trailing = true;\n      if (typeof func != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT3);\n      }\n      if (isObject7(options)) {\n        leading = \"leading\" in options ? !!options.leading : leading;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n      }\n      return debounce6(func, wait, {\n        \"leading\": leading,\n        \"maxWait\": wait,\n        \"trailing\": trailing\n      });\n    }\n    module2.exports = throttle2;\n  }\n});\n\n// node_modules/is-hotkey/lib/index.js\nvar require_lib = __commonJS({\n  \"node_modules/is-hotkey/lib/index.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    var IS_MAC = typeof window != \"undefined\" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n    var MODIFIERS = {\n      alt: \"altKey\",\n      control: \"ctrlKey\",\n      meta: \"metaKey\",\n      shift: \"shiftKey\"\n    };\n    var ALIASES = {\n      add: \"+\",\n      break: \"pause\",\n      cmd: \"meta\",\n      command: \"meta\",\n      ctl: \"control\",\n      ctrl: \"control\",\n      del: \"delete\",\n      down: \"arrowdown\",\n      esc: \"escape\",\n      ins: \"insert\",\n      left: \"arrowleft\",\n      mod: IS_MAC ? \"meta\" : \"control\",\n      opt: \"alt\",\n      option: \"alt\",\n      return: \"enter\",\n      right: \"arrowright\",\n      space: \" \",\n      spacebar: \" \",\n      up: \"arrowup\",\n      win: \"meta\",\n      windows: \"meta\"\n    };\n    var CODES = {\n      backspace: 8,\n      tab: 9,\n      enter: 13,\n      shift: 16,\n      control: 17,\n      alt: 18,\n      pause: 19,\n      capslock: 20,\n      escape: 27,\n      \" \": 32,\n      pageup: 33,\n      pagedown: 34,\n      end: 35,\n      home: 36,\n      arrowleft: 37,\n      arrowup: 38,\n      arrowright: 39,\n      arrowdown: 40,\n      insert: 45,\n      delete: 46,\n      meta: 91,\n      numlock: 144,\n      scrolllock: 145,\n      \";\": 186,\n      \"=\": 187,\n      \",\": 188,\n      \"-\": 189,\n      \".\": 190,\n      \"/\": 191,\n      \"`\": 192,\n      \"[\": 219,\n      \"\\\\\": 220,\n      \"]\": 221,\n      \"'\": 222\n    };\n    for (f5 = 1; f5 < 20; f5++) {\n      CODES[\"f\" + f5] = 111 + f5;\n    }\n    var f5;\n    function isHotkey9(hotkey, options, event) {\n      if (options && !(\"byKey\" in options)) {\n        event = options;\n        options = null;\n      }\n      if (!Array.isArray(hotkey)) {\n        hotkey = [hotkey];\n      }\n      var array = hotkey.map(function(string2) {\n        return parseHotkey(string2, options);\n      });\n      var check = function check2(e4) {\n        return array.some(function(object) {\n          return compareHotkey(object, e4);\n        });\n      };\n      var ret = event == null ? check : check(event);\n      return ret;\n    }\n    function isCodeHotkey(hotkey, event) {\n      return isHotkey9(hotkey, event);\n    }\n    function isKeyHotkey2(hotkey, event) {\n      return isHotkey9(hotkey, { byKey: true }, event);\n    }\n    function parseHotkey(hotkey, options) {\n      var byKey = options && options.byKey;\n      var ret = {};\n      hotkey = hotkey.replace(\"++\", \"+add\");\n      var values2 = hotkey.split(\"+\");\n      var length = values2.length;\n      for (var k3 in MODIFIERS) {\n        ret[MODIFIERS[k3]] = false;\n      }\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = void 0;\n      try {\n        for (var _iterator = values2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var value = _step.value;\n          var optional = value.endsWith(\"?\") && value.length > 1;\n          if (optional) {\n            value = value.slice(0, -1);\n          }\n          var name = toKeyName(value);\n          var modifier = MODIFIERS[name];\n          if (length === 1 || !modifier) {\n            if (byKey) {\n              ret.key = name;\n            } else {\n              ret.which = toKeyCode(value);\n            }\n          }\n          if (modifier) {\n            ret[modifier] = optional ? null : true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      return ret;\n    }\n    function compareHotkey(object, event) {\n      for (var key in object) {\n        var expected = object[key];\n        var actual = void 0;\n        if (expected == null) {\n          continue;\n        }\n        if (key === \"key\" && event.key != null) {\n          actual = event.key.toLowerCase();\n        } else if (key === \"which\") {\n          actual = expected === 91 && event.which === 93 ? 91 : event.which;\n        } else {\n          actual = event[key];\n        }\n        if (actual == null && expected === false) {\n          continue;\n        }\n        if (actual !== expected) {\n          return false;\n        }\n      }\n      return true;\n    }\n    function toKeyCode(name) {\n      name = toKeyName(name);\n      var code3 = CODES[name] || name.toUpperCase().charCodeAt(0);\n      return code3;\n    }\n    function toKeyName(name) {\n      name = name.toLowerCase();\n      name = ALIASES[name] || name;\n      return name;\n    }\n    exports2.default = isHotkey9;\n    exports2.isHotkey = isHotkey9;\n    exports2.isCodeHotkey = isCodeHotkey;\n    exports2.isKeyHotkey = isKeyHotkey2;\n    exports2.parseHotkey = parseHotkey;\n    exports2.compareHotkey = compareHotkey;\n    exports2.toKeyCode = toKeyCode;\n    exports2.toKeyName = toKeyName;\n  }\n});\n\n// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\nvar require_use_sync_external_store_shim_development = __commonJS({\n  \"node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\"(exports2) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var React69 = require(\"react\");\n        var ReactSharedInternals = React69.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format3) {\n          {\n            {\n              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                args[_key2 - 1] = arguments[_key2];\n              }\n              printWarning(\"error\", format3, args);\n            }\n          }\n        }\n        function printWarning(level, format3, args) {\n          {\n            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n            var stack = ReactDebugCurrentFrame.getStackAddendum();\n            if (stack !== \"\") {\n              format3 += \"%s\";\n              args = args.concat([stack]);\n            }\n            var argsWithFormat = args.map(function(item) {\n              return String(item);\n            });\n            argsWithFormat.unshift(\"Warning: \" + format3);\n            Function.prototype.apply.call(console[level], console, argsWithFormat);\n          }\n        }\n        function is4(x4, y5) {\n          return x4 === y5 && (x4 !== 0 || 1 / x4 === 1 / y5) || x4 !== x4 && y5 !== y5;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is4;\n        var useState14 = React69.useState, useEffect25 = React69.useEffect, useLayoutEffect9 = React69.useLayoutEffect, useDebugValue4 = React69.useDebugValue;\n        var didWarnOld18Alpha = false;\n        var didWarnUncachedGetSnapshot = false;\n        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n          {\n            if (!didWarnOld18Alpha) {\n              if (React69.startTransition !== void 0) {\n                didWarnOld18Alpha = true;\n                error(\"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\");\n              }\n            }\n          }\n          var value = getSnapshot();\n          {\n            if (!didWarnUncachedGetSnapshot) {\n              var cachedValue = getSnapshot();\n              if (!objectIs(value, cachedValue)) {\n                error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                didWarnUncachedGetSnapshot = true;\n              }\n            }\n          }\n          var _useState = useState14({\n            inst: {\n              value,\n              getSnapshot\n            }\n          }), inst = _useState[0].inst, forceUpdate = _useState[1];\n          useLayoutEffect9(function() {\n            inst.value = value;\n            inst.getSnapshot = getSnapshot;\n            if (checkIfSnapshotChanged(inst)) {\n              forceUpdate({\n                inst\n              });\n            }\n          }, [subscribe, value, getSnapshot]);\n          useEffect25(function() {\n            if (checkIfSnapshotChanged(inst)) {\n              forceUpdate({\n                inst\n              });\n            }\n            var handleStoreChange = function() {\n              if (checkIfSnapshotChanged(inst)) {\n                forceUpdate({\n                  inst\n                });\n              }\n            };\n            return subscribe(handleStoreChange);\n          }, [subscribe]);\n          useDebugValue4(value);\n          return value;\n        }\n        function checkIfSnapshotChanged(inst) {\n          var latestGetSnapshot = inst.getSnapshot;\n          var prevValue = inst.value;\n          try {\n            var nextValue = latestGetSnapshot();\n            return !objectIs(prevValue, nextValue);\n          } catch (error2) {\n            return true;\n          }\n        }\n        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n          return getSnapshot();\n        }\n        var canUseDOM = !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\n        var isServerEnvironment = !canUseDOM;\n        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\n        var useSyncExternalStore$2 = React69.useSyncExternalStore !== void 0 ? React69.useSyncExternalStore : shim;\n        exports2.useSyncExternalStore = useSyncExternalStore$2;\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n      })();\n    }\n  }\n});\n\n// node_modules/use-sync-external-store/shim/index.js\nvar require_shim = __commonJS({\n  \"node_modules/use-sync-external-store/shim/index.js\"(exports2, module2) {\n    \"use strict\";\n    if (false) {\n      module2.exports = null;\n    } else {\n      module2.exports = require_use_sync_external_store_shim_development();\n    }\n  }\n});\n\n// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\nvar require_with_selector_development = __commonJS({\n  \"node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\"(exports2) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var React69 = require(\"react\");\n        var shim = require_shim();\n        function is4(x4, y5) {\n          return x4 === y5 && (x4 !== 0 || 1 / x4 === 1 / y5) || x4 !== x4 && y5 !== y5;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is4;\n        var useSyncExternalStore = shim.useSyncExternalStore;\n        var useRef23 = React69.useRef, useEffect25 = React69.useEffect, useMemo33 = React69.useMemo, useDebugValue4 = React69.useDebugValue;\n        function useSyncExternalStoreWithSelector2(subscribe, getSnapshot, getServerSnapshot, selector, isEqual2) {\n          var instRef = useRef23(null);\n          var inst;\n          if (instRef.current === null) {\n            inst = {\n              hasValue: false,\n              value: null\n            };\n            instRef.current = inst;\n          } else {\n            inst = instRef.current;\n          }\n          var _useMemo = useMemo33(function() {\n            var hasMemo = false;\n            var memoizedSnapshot;\n            var memoizedSelection;\n            var memoizedSelector = function(nextSnapshot) {\n              if (!hasMemo) {\n                hasMemo = true;\n                memoizedSnapshot = nextSnapshot;\n                var _nextSelection = selector(nextSnapshot);\n                if (isEqual2 !== void 0) {\n                  if (inst.hasValue) {\n                    var currentSelection = inst.value;\n                    if (isEqual2(currentSelection, _nextSelection)) {\n                      memoizedSelection = currentSelection;\n                      return currentSelection;\n                    }\n                  }\n                }\n                memoizedSelection = _nextSelection;\n                return _nextSelection;\n              }\n              var prevSnapshot = memoizedSnapshot;\n              var prevSelection = memoizedSelection;\n              if (objectIs(prevSnapshot, nextSnapshot)) {\n                return prevSelection;\n              }\n              var nextSelection = selector(nextSnapshot);\n              if (isEqual2 !== void 0 && isEqual2(prevSelection, nextSelection)) {\n                return prevSelection;\n              }\n              memoizedSnapshot = nextSnapshot;\n              memoizedSelection = nextSelection;\n              return nextSelection;\n            };\n            var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;\n            var getSnapshotWithSelector = function() {\n              return memoizedSelector(getSnapshot());\n            };\n            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {\n              return memoizedSelector(maybeGetServerSnapshot());\n            };\n            return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n          }, [getSnapshot, getServerSnapshot, selector, isEqual2]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];\n          var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n          useEffect25(function() {\n            inst.hasValue = true;\n            inst.value = value;\n          }, [value]);\n          useDebugValue4(value);\n          return value;\n        }\n        exports2.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector2;\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n      })();\n    }\n  }\n});\n\n// node_modules/use-sync-external-store/shim/with-selector.js\nvar require_with_selector = __commonJS({\n  \"node_modules/use-sync-external-store/shim/with-selector.js\"(exports2, module2) {\n    \"use strict\";\n    if (false) {\n      module2.exports = null;\n    } else {\n      module2.exports = require_with_selector_development();\n    }\n  }\n});\n\n// node_modules/lodash.debounce/index.js\nvar require_lodash = __commonJS({\n  \"node_modules/lodash.debounce/index.js\"(exports2, module2) {\n    var FUNC_ERROR_TEXT3 = \"Expected a function\";\n    var NAN = 0 / 0;\n    var symbolTag4 = \"[object Symbol]\";\n    var reTrim = /^\\s+|\\s+$/g;\n    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n    var reIsBinary = /^0b[01]+$/i;\n    var reIsOctal = /^0o[0-7]+$/i;\n    var freeParseInt = parseInt;\n    var freeGlobal5 = typeof global == \"object\" && global && global.Object === Object && global;\n    var freeSelf5 = typeof self == \"object\" && self && self.Object === Object && self;\n    var root5 = freeGlobal5 || freeSelf5 || Function(\"return this\")();\n    var objectProto5 = Object.prototype;\n    var objectToString5 = objectProto5.toString;\n    var nativeMax2 = Math.max;\n    var nativeMin = Math.min;\n    var now = function() {\n      return root5.Date.now();\n    };\n    function debounce6(func, wait, options) {\n      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n      if (typeof func != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT3);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject7(options)) {\n        leading = !!options.leading;\n        maxing = \"maxWait\" in options;\n        maxWait = maxing ? nativeMax2(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n      }\n      function invokeFunc(time) {\n        var args = lastArgs, thisArg = lastThis;\n        lastArgs = lastThis = void 0;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n      function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = setTimeout(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n      }\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;\n        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;\n      }\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n      }\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n      function trailingEdge(time) {\n        timerId = void 0;\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = void 0;\n        return result;\n      }\n      function cancel() {\n        if (timerId !== void 0) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = void 0;\n      }\n      function flush() {\n        return timerId === void 0 ? result : trailingEdge(now());\n      }\n      function debounced() {\n        var time = now(), isInvoking = shouldInvoke(time);\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n          if (timerId === void 0) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === void 0) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n    function isObject7(value) {\n      var type = typeof value;\n      return !!value && (type == \"object\" || type == \"function\");\n    }\n    function isObjectLike5(value) {\n      return !!value && typeof value == \"object\";\n    }\n    function isSymbol2(value) {\n      return typeof value == \"symbol\" || isObjectLike5(value) && objectToString5.call(value) == symbolTag4;\n    }\n    function toNumber(value) {\n      if (typeof value == \"number\") {\n        return value;\n      }\n      if (isSymbol2(value)) {\n        return NAN;\n      }\n      if (isObject7(value)) {\n        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n        value = isObject7(other) ? other + \"\" : other;\n      }\n      if (typeof value != \"string\") {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, \"\");\n      var isBinary = reIsBinary.test(value);\n      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n    }\n    module2.exports = debounce6;\n  }\n});\n\n// node_modules/fast-deep-equal/index.js\nvar require_fast_deep_equal = __commonJS({\n  \"node_modules/fast-deep-equal/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = function equal2(a7, b4) {\n      if (a7 === b4)\n        return true;\n      if (a7 && b4 && typeof a7 == \"object\" && typeof b4 == \"object\") {\n        if (a7.constructor !== b4.constructor)\n          return false;\n        var length, i5, keys4;\n        if (Array.isArray(a7)) {\n          length = a7.length;\n          if (length != b4.length)\n            return false;\n          for (i5 = length; i5-- !== 0; )\n            if (!equal2(a7[i5], b4[i5]))\n              return false;\n          return true;\n        }\n        if (a7.constructor === RegExp)\n          return a7.source === b4.source && a7.flags === b4.flags;\n        if (a7.valueOf !== Object.prototype.valueOf)\n          return a7.valueOf() === b4.valueOf();\n        if (a7.toString !== Object.prototype.toString)\n          return a7.toString() === b4.toString();\n        keys4 = Object.keys(a7);\n        length = keys4.length;\n        if (length !== Object.keys(b4).length)\n          return false;\n        for (i5 = length; i5-- !== 0; )\n          if (!Object.prototype.hasOwnProperty.call(b4, keys4[i5]))\n            return false;\n        for (i5 = length; i5-- !== 0; ) {\n          var key = keys4[i5];\n          if (!equal2(a7[key], b4[key]))\n            return false;\n        }\n        return true;\n      }\n      return a7 !== a7 && b4 !== b4;\n    };\n  }\n});\n\n// node_modules/lodash/isArray.js\nvar require_isArray = __commonJS({\n  \"node_modules/lodash/isArray.js\"(exports2, module2) {\n    var isArray9 = Array.isArray;\n    module2.exports = isArray9;\n  }\n});\n\n// node_modules/lodash/_isKey.js\nvar require_isKey = __commonJS({\n  \"node_modules/lodash/_isKey.js\"(exports2, module2) {\n    var isArray9 = require_isArray();\n    var isSymbol2 = require_isSymbol();\n    var reIsDeepProp2 = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\n    var reIsPlainProp2 = /^\\w*$/;\n    function isKey2(value, object) {\n      if (isArray9(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == \"number\" || type == \"symbol\" || type == \"boolean\" || value == null || isSymbol2(value)) {\n        return true;\n      }\n      return reIsPlainProp2.test(value) || !reIsDeepProp2.test(value) || object != null && value in Object(object);\n    }\n    module2.exports = isKey2;\n  }\n});\n\n// node_modules/lodash/isFunction.js\nvar require_isFunction = __commonJS({\n  \"node_modules/lodash/isFunction.js\"(exports2, module2) {\n    var baseGetTag5 = require_baseGetTag();\n    var isObject7 = require_isObject();\n    var asyncTag5 = \"[object AsyncFunction]\";\n    var funcTag5 = \"[object Function]\";\n    var genTag5 = \"[object GeneratorFunction]\";\n    var proxyTag5 = \"[object Proxy]\";\n    function isFunction6(value) {\n      if (!isObject7(value)) {\n        return false;\n      }\n      var tag = baseGetTag5(value);\n      return tag == funcTag5 || tag == genTag5 || tag == asyncTag5 || tag == proxyTag5;\n    }\n    module2.exports = isFunction6;\n  }\n});\n\n// node_modules/lodash/_coreJsData.js\nvar require_coreJsData = __commonJS({\n  \"node_modules/lodash/_coreJsData.js\"(exports2, module2) {\n    var root5 = require_root();\n    var coreJsData5 = root5[\"__core-js_shared__\"];\n    module2.exports = coreJsData5;\n  }\n});\n\n// node_modules/lodash/_isMasked.js\nvar require_isMasked = __commonJS({\n  \"node_modules/lodash/_isMasked.js\"(exports2, module2) {\n    var coreJsData5 = require_coreJsData();\n    var maskSrcKey5 = function() {\n      var uid = /[^.]+$/.exec(coreJsData5 && coreJsData5.keys && coreJsData5.keys.IE_PROTO || \"\");\n      return uid ? \"Symbol(src)_1.\" + uid : \"\";\n    }();\n    function isMasked5(func) {\n      return !!maskSrcKey5 && maskSrcKey5 in func;\n    }\n    module2.exports = isMasked5;\n  }\n});\n\n// node_modules/lodash/_toSource.js\nvar require_toSource = __commonJS({\n  \"node_modules/lodash/_toSource.js\"(exports2, module2) {\n    var funcProto5 = Function.prototype;\n    var funcToString5 = funcProto5.toString;\n    function toSource5(func) {\n      if (func != null) {\n        try {\n          return funcToString5.call(func);\n        } catch (e4) {\n        }\n        try {\n          return func + \"\";\n        } catch (e4) {\n        }\n      }\n      return \"\";\n    }\n    module2.exports = toSource5;\n  }\n});\n\n// node_modules/lodash/_baseIsNative.js\nvar require_baseIsNative = __commonJS({\n  \"node_modules/lodash/_baseIsNative.js\"(exports2, module2) {\n    var isFunction6 = require_isFunction();\n    var isMasked5 = require_isMasked();\n    var isObject7 = require_isObject();\n    var toSource5 = require_toSource();\n    var reRegExpChar5 = /[\\\\^$.*+?()[\\]{}|]/g;\n    var reIsHostCtor5 = /^\\[object .+?Constructor\\]$/;\n    var funcProto5 = Function.prototype;\n    var objectProto5 = Object.prototype;\n    var funcToString5 = funcProto5.toString;\n    var hasOwnProperty6 = objectProto5.hasOwnProperty;\n    var reIsNative5 = RegExp(\n      \"^\" + funcToString5.call(hasOwnProperty6).replace(reRegExpChar5, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n    );\n    function baseIsNative5(value) {\n      if (!isObject7(value) || isMasked5(value)) {\n        return false;\n      }\n      var pattern = isFunction6(value) ? reIsNative5 : reIsHostCtor5;\n      return pattern.test(toSource5(value));\n    }\n    module2.exports = baseIsNative5;\n  }\n});\n\n// node_modules/lodash/_getValue.js\nvar require_getValue = __commonJS({\n  \"node_modules/lodash/_getValue.js\"(exports2, module2) {\n    function getValue5(object, key) {\n      return object == null ? void 0 : object[key];\n    }\n    module2.exports = getValue5;\n  }\n});\n\n// node_modules/lodash/_getNative.js\nvar require_getNative = __commonJS({\n  \"node_modules/lodash/_getNative.js\"(exports2, module2) {\n    var baseIsNative5 = require_baseIsNative();\n    var getValue5 = require_getValue();\n    function getNative5(object, key) {\n      var value = getValue5(object, key);\n      return baseIsNative5(value) ? value : void 0;\n    }\n    module2.exports = getNative5;\n  }\n});\n\n// node_modules/lodash/_nativeCreate.js\nvar require_nativeCreate = __commonJS({\n  \"node_modules/lodash/_nativeCreate.js\"(exports2, module2) {\n    var getNative5 = require_getNative();\n    var nativeCreate5 = getNative5(Object, \"create\");\n    module2.exports = nativeCreate5;\n  }\n});\n\n// node_modules/lodash/_hashClear.js\nvar require_hashClear = __commonJS({\n  \"node_modules/lodash/_hashClear.js\"(exports2, module2) {\n    var nativeCreate5 = require_nativeCreate();\n    function hashClear5() {\n      this.__data__ = nativeCreate5 ? nativeCreate5(null) : {};\n      this.size = 0;\n    }\n    module2.exports = hashClear5;\n  }\n});\n\n// node_modules/lodash/_hashDelete.js\nvar require_hashDelete = __commonJS({\n  \"node_modules/lodash/_hashDelete.js\"(exports2, module2) {\n    function hashDelete5(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n    module2.exports = hashDelete5;\n  }\n});\n\n// node_modules/lodash/_hashGet.js\nvar require_hashGet = __commonJS({\n  \"node_modules/lodash/_hashGet.js\"(exports2, module2) {\n    var nativeCreate5 = require_nativeCreate();\n    var HASH_UNDEFINED5 = \"__lodash_hash_undefined__\";\n    var objectProto5 = Object.prototype;\n    var hasOwnProperty6 = objectProto5.hasOwnProperty;\n    function hashGet5(key) {\n      var data = this.__data__;\n      if (nativeCreate5) {\n        var result = data[key];\n        return result === HASH_UNDEFINED5 ? void 0 : result;\n      }\n      return hasOwnProperty6.call(data, key) ? data[key] : void 0;\n    }\n    module2.exports = hashGet5;\n  }\n});\n\n// node_modules/lodash/_hashHas.js\nvar require_hashHas = __commonJS({\n  \"node_modules/lodash/_hashHas.js\"(exports2, module2) {\n    var nativeCreate5 = require_nativeCreate();\n    var objectProto5 = Object.prototype;\n    var hasOwnProperty6 = objectProto5.hasOwnProperty;\n    function hashHas5(key) {\n      var data = this.__data__;\n      return nativeCreate5 ? data[key] !== void 0 : hasOwnProperty6.call(data, key);\n    }\n    module2.exports = hashHas5;\n  }\n});\n\n// node_modules/lodash/_hashSet.js\nvar require_hashSet = __commonJS({\n  \"node_modules/lodash/_hashSet.js\"(exports2, module2) {\n    var nativeCreate5 = require_nativeCreate();\n    var HASH_UNDEFINED5 = \"__lodash_hash_undefined__\";\n    function hashSet5(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = nativeCreate5 && value === void 0 ? HASH_UNDEFINED5 : value;\n      return this;\n    }\n    module2.exports = hashSet5;\n  }\n});\n\n// node_modules/lodash/_Hash.js\nvar require_Hash = __commonJS({\n  \"node_modules/lodash/_Hash.js\"(exports2, module2) {\n    var hashClear5 = require_hashClear();\n    var hashDelete5 = require_hashDelete();\n    var hashGet5 = require_hashGet();\n    var hashHas5 = require_hashHas();\n    var hashSet5 = require_hashSet();\n    function Hash5(entries) {\n      var index5 = -1, length = entries == null ? 0 : entries.length;\n      this.clear();\n      while (++index5 < length) {\n        var entry = entries[index5];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    Hash5.prototype.clear = hashClear5;\n    Hash5.prototype[\"delete\"] = hashDelete5;\n    Hash5.prototype.get = hashGet5;\n    Hash5.prototype.has = hashHas5;\n    Hash5.prototype.set = hashSet5;\n    module2.exports = Hash5;\n  }\n});\n\n// node_modules/lodash/_listCacheClear.js\nvar require_listCacheClear = __commonJS({\n  \"node_modules/lodash/_listCacheClear.js\"(exports2, module2) {\n    function listCacheClear5() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n    module2.exports = listCacheClear5;\n  }\n});\n\n// node_modules/lodash/eq.js\nvar require_eq = __commonJS({\n  \"node_modules/lodash/eq.js\"(exports2, module2) {\n    function eq5(value, other) {\n      return value === other || value !== value && other !== other;\n    }\n    module2.exports = eq5;\n  }\n});\n\n// node_modules/lodash/_assocIndexOf.js\nvar require_assocIndexOf = __commonJS({\n  \"node_modules/lodash/_assocIndexOf.js\"(exports2, module2) {\n    var eq5 = require_eq();\n    function assocIndexOf5(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq5(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n    module2.exports = assocIndexOf5;\n  }\n});\n\n// node_modules/lodash/_listCacheDelete.js\nvar require_listCacheDelete = __commonJS({\n  \"node_modules/lodash/_listCacheDelete.js\"(exports2, module2) {\n    var assocIndexOf5 = require_assocIndexOf();\n    var arrayProto5 = Array.prototype;\n    var splice5 = arrayProto5.splice;\n    function listCacheDelete5(key) {\n      var data = this.__data__, index5 = assocIndexOf5(data, key);\n      if (index5 < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index5 == lastIndex) {\n        data.pop();\n      } else {\n        splice5.call(data, index5, 1);\n      }\n      --this.size;\n      return true;\n    }\n    module2.exports = listCacheDelete5;\n  }\n});\n\n// node_modules/lodash/_listCacheGet.js\nvar require_listCacheGet = __commonJS({\n  \"node_modules/lodash/_listCacheGet.js\"(exports2, module2) {\n    var assocIndexOf5 = require_assocIndexOf();\n    function listCacheGet5(key) {\n      var data = this.__data__, index5 = assocIndexOf5(data, key);\n      return index5 < 0 ? void 0 : data[index5][1];\n    }\n    module2.exports = listCacheGet5;\n  }\n});\n\n// node_modules/lodash/_listCacheHas.js\nvar require_listCacheHas = __commonJS({\n  \"node_modules/lodash/_listCacheHas.js\"(exports2, module2) {\n    var assocIndexOf5 = require_assocIndexOf();\n    function listCacheHas5(key) {\n      return assocIndexOf5(this.__data__, key) > -1;\n    }\n    module2.exports = listCacheHas5;\n  }\n});\n\n// node_modules/lodash/_listCacheSet.js\nvar require_listCacheSet = __commonJS({\n  \"node_modules/lodash/_listCacheSet.js\"(exports2, module2) {\n    var assocIndexOf5 = require_assocIndexOf();\n    function listCacheSet5(key, value) {\n      var data = this.__data__, index5 = assocIndexOf5(data, key);\n      if (index5 < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index5][1] = value;\n      }\n      return this;\n    }\n    module2.exports = listCacheSet5;\n  }\n});\n\n// node_modules/lodash/_ListCache.js\nvar require_ListCache = __commonJS({\n  \"node_modules/lodash/_ListCache.js\"(exports2, module2) {\n    var listCacheClear5 = require_listCacheClear();\n    var listCacheDelete5 = require_listCacheDelete();\n    var listCacheGet5 = require_listCacheGet();\n    var listCacheHas5 = require_listCacheHas();\n    var listCacheSet5 = require_listCacheSet();\n    function ListCache5(entries) {\n      var index5 = -1, length = entries == null ? 0 : entries.length;\n      this.clear();\n      while (++index5 < length) {\n        var entry = entries[index5];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    ListCache5.prototype.clear = listCacheClear5;\n    ListCache5.prototype[\"delete\"] = listCacheDelete5;\n    ListCache5.prototype.get = listCacheGet5;\n    ListCache5.prototype.has = listCacheHas5;\n    ListCache5.prototype.set = listCacheSet5;\n    module2.exports = ListCache5;\n  }\n});\n\n// node_modules/lodash/_Map.js\nvar require_Map = __commonJS({\n  \"node_modules/lodash/_Map.js\"(exports2, module2) {\n    var getNative5 = require_getNative();\n    var root5 = require_root();\n    var Map5 = getNative5(root5, \"Map\");\n    module2.exports = Map5;\n  }\n});\n\n// node_modules/lodash/_mapCacheClear.js\nvar require_mapCacheClear = __commonJS({\n  \"node_modules/lodash/_mapCacheClear.js\"(exports2, module2) {\n    var Hash5 = require_Hash();\n    var ListCache5 = require_ListCache();\n    var Map5 = require_Map();\n    function mapCacheClear5() {\n      this.size = 0;\n      this.__data__ = {\n        \"hash\": new Hash5(),\n        \"map\": new (Map5 || ListCache5)(),\n        \"string\": new Hash5()\n      };\n    }\n    module2.exports = mapCacheClear5;\n  }\n});\n\n// node_modules/lodash/_isKeyable.js\nvar require_isKeyable = __commonJS({\n  \"node_modules/lodash/_isKeyable.js\"(exports2, module2) {\n    function isKeyable5(value) {\n      var type = typeof value;\n      return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n    }\n    module2.exports = isKeyable5;\n  }\n});\n\n// node_modules/lodash/_getMapData.js\nvar require_getMapData = __commonJS({\n  \"node_modules/lodash/_getMapData.js\"(exports2, module2) {\n    var isKeyable5 = require_isKeyable();\n    function getMapData5(map2, key) {\n      var data = map2.__data__;\n      return isKeyable5(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n    }\n    module2.exports = getMapData5;\n  }\n});\n\n// node_modules/lodash/_mapCacheDelete.js\nvar require_mapCacheDelete = __commonJS({\n  \"node_modules/lodash/_mapCacheDelete.js\"(exports2, module2) {\n    var getMapData5 = require_getMapData();\n    function mapCacheDelete5(key) {\n      var result = getMapData5(this, key)[\"delete\"](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n    module2.exports = mapCacheDelete5;\n  }\n});\n\n// node_modules/lodash/_mapCacheGet.js\nvar require_mapCacheGet = __commonJS({\n  \"node_modules/lodash/_mapCacheGet.js\"(exports2, module2) {\n    var getMapData5 = require_getMapData();\n    function mapCacheGet5(key) {\n      return getMapData5(this, key).get(key);\n    }\n    module2.exports = mapCacheGet5;\n  }\n});\n\n// node_modules/lodash/_mapCacheHas.js\nvar require_mapCacheHas = __commonJS({\n  \"node_modules/lodash/_mapCacheHas.js\"(exports2, module2) {\n    var getMapData5 = require_getMapData();\n    function mapCacheHas5(key) {\n      return getMapData5(this, key).has(key);\n    }\n    module2.exports = mapCacheHas5;\n  }\n});\n\n// node_modules/lodash/_mapCacheSet.js\nvar require_mapCacheSet = __commonJS({\n  \"node_modules/lodash/_mapCacheSet.js\"(exports2, module2) {\n    var getMapData5 = require_getMapData();\n    function mapCacheSet5(key, value) {\n      var data = getMapData5(this, key), size = data.size;\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n    module2.exports = mapCacheSet5;\n  }\n});\n\n// node_modules/lodash/_MapCache.js\nvar require_MapCache = __commonJS({\n  \"node_modules/lodash/_MapCache.js\"(exports2, module2) {\n    var mapCacheClear5 = require_mapCacheClear();\n    var mapCacheDelete5 = require_mapCacheDelete();\n    var mapCacheGet5 = require_mapCacheGet();\n    var mapCacheHas5 = require_mapCacheHas();\n    var mapCacheSet5 = require_mapCacheSet();\n    function MapCache5(entries) {\n      var index5 = -1, length = entries == null ? 0 : entries.length;\n      this.clear();\n      while (++index5 < length) {\n        var entry = entries[index5];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    MapCache5.prototype.clear = mapCacheClear5;\n    MapCache5.prototype[\"delete\"] = mapCacheDelete5;\n    MapCache5.prototype.get = mapCacheGet5;\n    MapCache5.prototype.has = mapCacheHas5;\n    MapCache5.prototype.set = mapCacheSet5;\n    module2.exports = MapCache5;\n  }\n});\n\n// node_modules/lodash/memoize.js\nvar require_memoize = __commonJS({\n  \"node_modules/lodash/memoize.js\"(exports2, module2) {\n    var MapCache5 = require_MapCache();\n    var FUNC_ERROR_TEXT3 = \"Expected a function\";\n    function memoize4(func, resolver) {\n      if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT3);\n      }\n      var memoized = function() {\n        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;\n        if (cache2.has(key)) {\n          return cache2.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache2.set(key, result) || cache2;\n        return result;\n      };\n      memoized.cache = new (memoize4.Cache || MapCache5)();\n      return memoized;\n    }\n    memoize4.Cache = MapCache5;\n    module2.exports = memoize4;\n  }\n});\n\n// node_modules/lodash/_memoizeCapped.js\nvar require_memoizeCapped = __commonJS({\n  \"node_modules/lodash/_memoizeCapped.js\"(exports2, module2) {\n    var memoize4 = require_memoize();\n    var MAX_MEMOIZE_SIZE3 = 500;\n    function memoizeCapped3(func) {\n      var result = memoize4(func, function(key) {\n        if (cache2.size === MAX_MEMOIZE_SIZE3) {\n          cache2.clear();\n        }\n        return key;\n      });\n      var cache2 = result.cache;\n      return result;\n    }\n    module2.exports = memoizeCapped3;\n  }\n});\n\n// node_modules/lodash/_stringToPath.js\nvar require_stringToPath = __commonJS({\n  \"node_modules/lodash/_stringToPath.js\"(exports2, module2) {\n    var memoizeCapped3 = require_memoizeCapped();\n    var rePropName3 = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n    var reEscapeChar3 = /\\\\(\\\\)?/g;\n    var stringToPath3 = memoizeCapped3(function(string2) {\n      var result = [];\n      if (string2.charCodeAt(0) === 46) {\n        result.push(\"\");\n      }\n      string2.replace(rePropName3, function(match2, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar3, \"$1\") : number || match2);\n      });\n      return result;\n    });\n    module2.exports = stringToPath3;\n  }\n});\n\n// node_modules/lodash/_arrayMap.js\nvar require_arrayMap = __commonJS({\n  \"node_modules/lodash/_arrayMap.js\"(exports2, module2) {\n    function arrayMap2(array, iteratee) {\n      var index5 = -1, length = array == null ? 0 : array.length, result = Array(length);\n      while (++index5 < length) {\n        result[index5] = iteratee(array[index5], index5, array);\n      }\n      return result;\n    }\n    module2.exports = arrayMap2;\n  }\n});\n\n// node_modules/lodash/_baseToString.js\nvar require_baseToString = __commonJS({\n  \"node_modules/lodash/_baseToString.js\"(exports2, module2) {\n    var Symbol4 = require_Symbol();\n    var arrayMap2 = require_arrayMap();\n    var isArray9 = require_isArray();\n    var isSymbol2 = require_isSymbol();\n    var INFINITY3 = 1 / 0;\n    var symbolProto5 = Symbol4 ? Symbol4.prototype : void 0;\n    var symbolToString3 = symbolProto5 ? symbolProto5.toString : void 0;\n    function baseToString2(value) {\n      if (typeof value == \"string\") {\n        return value;\n      }\n      if (isArray9(value)) {\n        return arrayMap2(value, baseToString2) + \"\";\n      }\n      if (isSymbol2(value)) {\n        return symbolToString3 ? symbolToString3.call(value) : \"\";\n      }\n      var result = value + \"\";\n      return result == \"0\" && 1 / value == -INFINITY3 ? \"-0\" : result;\n    }\n    module2.exports = baseToString2;\n  }\n});\n\n// node_modules/lodash/toString.js\nvar require_toString = __commonJS({\n  \"node_modules/lodash/toString.js\"(exports2, module2) {\n    var baseToString2 = require_baseToString();\n    function toString2(value) {\n      return value == null ? \"\" : baseToString2(value);\n    }\n    module2.exports = toString2;\n  }\n});\n\n// node_modules/lodash/_castPath.js\nvar require_castPath = __commonJS({\n  \"node_modules/lodash/_castPath.js\"(exports2, module2) {\n    var isArray9 = require_isArray();\n    var isKey2 = require_isKey();\n    var stringToPath3 = require_stringToPath();\n    var toString2 = require_toString();\n    function castPath2(value, object) {\n      if (isArray9(value)) {\n        return value;\n      }\n      return isKey2(value, object) ? [value] : stringToPath3(toString2(value));\n    }\n    module2.exports = castPath2;\n  }\n});\n\n// node_modules/lodash/_toKey.js\nvar require_toKey = __commonJS({\n  \"node_modules/lodash/_toKey.js\"(exports2, module2) {\n    var isSymbol2 = require_isSymbol();\n    var INFINITY3 = 1 / 0;\n    function toKey2(value) {\n      if (typeof value == \"string\" || isSymbol2(value)) {\n        return value;\n      }\n      var result = value + \"\";\n      return result == \"0\" && 1 / value == -INFINITY3 ? \"-0\" : result;\n    }\n    module2.exports = toKey2;\n  }\n});\n\n// node_modules/lodash/_baseGet.js\nvar require_baseGet = __commonJS({\n  \"node_modules/lodash/_baseGet.js\"(exports2, module2) {\n    var castPath2 = require_castPath();\n    var toKey2 = require_toKey();\n    function baseGet2(object, path) {\n      path = castPath2(path, object);\n      var index5 = 0, length = path.length;\n      while (object != null && index5 < length) {\n        object = object[toKey2(path[index5++])];\n      }\n      return index5 && index5 == length ? object : void 0;\n    }\n    module2.exports = baseGet2;\n  }\n});\n\n// node_modules/lodash/_defineProperty.js\nvar require_defineProperty = __commonJS({\n  \"node_modules/lodash/_defineProperty.js\"(exports2, module2) {\n    var getNative5 = require_getNative();\n    var defineProperty5 = function() {\n      try {\n        var func = getNative5(Object, \"defineProperty\");\n        func({}, \"\", {});\n        return func;\n      } catch (e4) {\n      }\n    }();\n    module2.exports = defineProperty5;\n  }\n});\n\n// node_modules/lodash/_baseAssignValue.js\nvar require_baseAssignValue = __commonJS({\n  \"node_modules/lodash/_baseAssignValue.js\"(exports2, module2) {\n    var defineProperty5 = require_defineProperty();\n    function baseAssignValue4(object, key, value) {\n      if (key == \"__proto__\" && defineProperty5) {\n        defineProperty5(object, key, {\n          \"configurable\": true,\n          \"enumerable\": true,\n          \"value\": value,\n          \"writable\": true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n    module2.exports = baseAssignValue4;\n  }\n});\n\n// node_modules/lodash/_assignValue.js\nvar require_assignValue = __commonJS({\n  \"node_modules/lodash/_assignValue.js\"(exports2, module2) {\n    var baseAssignValue4 = require_baseAssignValue();\n    var eq5 = require_eq();\n    var objectProto5 = Object.prototype;\n    var hasOwnProperty6 = objectProto5.hasOwnProperty;\n    function assignValue4(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty6.call(object, key) && eq5(objValue, value)) || value === void 0 && !(key in object)) {\n        baseAssignValue4(object, key, value);\n      }\n    }\n    module2.exports = assignValue4;\n  }\n});\n\n// node_modules/lodash/_isIndex.js\nvar require_isIndex = __commonJS({\n  \"node_modules/lodash/_isIndex.js\"(exports2, module2) {\n    var MAX_SAFE_INTEGER5 = 9007199254740991;\n    var reIsUint4 = /^(?:0|[1-9]\\d*)$/;\n    function isIndex4(value, length) {\n      var type = typeof value;\n      length = length == null ? MAX_SAFE_INTEGER5 : length;\n      return !!length && (type == \"number\" || type != \"symbol\" && reIsUint4.test(value)) && (value > -1 && value % 1 == 0 && value < length);\n    }\n    module2.exports = isIndex4;\n  }\n});\n\n// node_modules/lodash/_baseSet.js\nvar require_baseSet = __commonJS({\n  \"node_modules/lodash/_baseSet.js\"(exports2, module2) {\n    var assignValue4 = require_assignValue();\n    var castPath2 = require_castPath();\n    var isIndex4 = require_isIndex();\n    var isObject7 = require_isObject();\n    var toKey2 = require_toKey();\n    function baseSet(object, path, value, customizer) {\n      if (!isObject7(object)) {\n        return object;\n      }\n      path = castPath2(path, object);\n      var index5 = -1, length = path.length, lastIndex = length - 1, nested = object;\n      while (nested != null && ++index5 < length) {\n        var key = toKey2(path[index5]), newValue = value;\n        if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n          return object;\n        }\n        if (index5 != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : void 0;\n          if (newValue === void 0) {\n            newValue = isObject7(objValue) ? objValue : isIndex4(path[index5 + 1]) ? [] : {};\n          }\n        }\n        assignValue4(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n    module2.exports = baseSet;\n  }\n});\n\n// node_modules/lodash/_basePickBy.js\nvar require_basePickBy = __commonJS({\n  \"node_modules/lodash/_basePickBy.js\"(exports2, module2) {\n    var baseGet2 = require_baseGet();\n    var baseSet = require_baseSet();\n    var castPath2 = require_castPath();\n    function basePickBy(object, paths, predicate) {\n      var index5 = -1, length = paths.length, result = {};\n      while (++index5 < length) {\n        var path = paths[index5], value = baseGet2(object, path);\n        if (predicate(value, path)) {\n          baseSet(result, castPath2(path, object), value);\n        }\n      }\n      return result;\n    }\n    module2.exports = basePickBy;\n  }\n});\n\n// node_modules/lodash/_baseHasIn.js\nvar require_baseHasIn = __commonJS({\n  \"node_modules/lodash/_baseHasIn.js\"(exports2, module2) {\n    function baseHasIn2(object, key) {\n      return object != null && key in Object(object);\n    }\n    module2.exports = baseHasIn2;\n  }\n});\n\n// node_modules/lodash/_baseIsArguments.js\nvar require_baseIsArguments = __commonJS({\n  \"node_modules/lodash/_baseIsArguments.js\"(exports2, module2) {\n    var baseGetTag5 = require_baseGetTag();\n    var isObjectLike5 = require_isObjectLike();\n    var argsTag4 = \"[object Arguments]\";\n    function baseIsArguments5(value) {\n      return isObjectLike5(value) && baseGetTag5(value) == argsTag4;\n    }\n    module2.exports = baseIsArguments5;\n  }\n});\n\n// node_modules/lodash/isArguments.js\nvar require_isArguments = __commonJS({\n  \"node_modules/lodash/isArguments.js\"(exports2, module2) {\n    var baseIsArguments5 = require_baseIsArguments();\n    var isObjectLike5 = require_isObjectLike();\n    var objectProto5 = Object.prototype;\n    var hasOwnProperty6 = objectProto5.hasOwnProperty;\n    var propertyIsEnumerable5 = objectProto5.propertyIsEnumerable;\n    var isArguments5 = baseIsArguments5(function() {\n      return arguments;\n    }()) ? baseIsArguments5 : function(value) {\n      return isObjectLike5(value) && hasOwnProperty6.call(value, \"callee\") && !propertyIsEnumerable5.call(value, \"callee\");\n    };\n    module2.exports = isArguments5;\n  }\n});\n\n// node_modules/lodash/isLength.js\nvar require_isLength = __commonJS({\n  \"node_modules/lodash/isLength.js\"(exports2, module2) {\n    var MAX_SAFE_INTEGER5 = 9007199254740991;\n    function isLength5(value) {\n      return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER5;\n    }\n    module2.exports = isLength5;\n  }\n});\n\n// node_modules/lodash/_hasPath.js\nvar require_hasPath = __commonJS({\n  \"node_modules/lodash/_hasPath.js\"(exports2, module2) {\n    var castPath2 = require_castPath();\n    var isArguments5 = require_isArguments();\n    var isArray9 = require_isArray();\n    var isIndex4 = require_isIndex();\n    var isLength5 = require_isLength();\n    var toKey2 = require_toKey();\n    function hasPath2(object, path, hasFunc) {\n      path = castPath2(path, object);\n      var index5 = -1, length = path.length, result = false;\n      while (++index5 < length) {\n        var key = toKey2(path[index5]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index5 != length) {\n        return result;\n      }\n      length = object == null ? 0 : object.length;\n      return !!length && isLength5(length) && isIndex4(key, length) && (isArray9(object) || isArguments5(object));\n    }\n    module2.exports = hasPath2;\n  }\n});\n\n// node_modules/lodash/hasIn.js\nvar require_hasIn = __commonJS({\n  \"node_modules/lodash/hasIn.js\"(exports2, module2) {\n    var baseHasIn2 = require_baseHasIn();\n    var hasPath2 = require_hasPath();\n    function hasIn2(object, path) {\n      return object != null && hasPath2(object, path, baseHasIn2);\n    }\n    module2.exports = hasIn2;\n  }\n});\n\n// node_modules/lodash/_basePick.js\nvar require_basePick = __commonJS({\n  \"node_modules/lodash/_basePick.js\"(exports2, module2) {\n    var basePickBy = require_basePickBy();\n    var hasIn2 = require_hasIn();\n    function basePick(object, paths) {\n      return basePickBy(object, paths, function(value, path) {\n        return hasIn2(object, path);\n      });\n    }\n    module2.exports = basePick;\n  }\n});\n\n// node_modules/lodash/_arrayPush.js\nvar require_arrayPush = __commonJS({\n  \"node_modules/lodash/_arrayPush.js\"(exports2, module2) {\n    function arrayPush4(array, values2) {\n      var index5 = -1, length = values2.length, offset3 = array.length;\n      while (++index5 < length) {\n        array[offset3 + index5] = values2[index5];\n      }\n      return array;\n    }\n    module2.exports = arrayPush4;\n  }\n});\n\n// node_modules/lodash/_isFlattenable.js\nvar require_isFlattenable = __commonJS({\n  \"node_modules/lodash/_isFlattenable.js\"(exports2, module2) {\n    var Symbol4 = require_Symbol();\n    var isArguments5 = require_isArguments();\n    var isArray9 = require_isArray();\n    var spreadableSymbol2 = Symbol4 ? Symbol4.isConcatSpreadable : void 0;\n    function isFlattenable2(value) {\n      return isArray9(value) || isArguments5(value) || !!(spreadableSymbol2 && value && value[spreadableSymbol2]);\n    }\n    module2.exports = isFlattenable2;\n  }\n});\n\n// node_modules/lodash/_baseFlatten.js\nvar require_baseFlatten = __commonJS({\n  \"node_modules/lodash/_baseFlatten.js\"(exports2, module2) {\n    var arrayPush4 = require_arrayPush();\n    var isFlattenable2 = require_isFlattenable();\n    function baseFlatten2(array, depth, predicate, isStrict, result) {\n      var index5 = -1, length = array.length;\n      predicate || (predicate = isFlattenable2);\n      result || (result = []);\n      while (++index5 < length) {\n        var value = array[index5];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            baseFlatten2(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush4(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n    module2.exports = baseFlatten2;\n  }\n});\n\n// node_modules/lodash/flatten.js\nvar require_flatten = __commonJS({\n  \"node_modules/lodash/flatten.js\"(exports2, module2) {\n    var baseFlatten2 = require_baseFlatten();\n    function flatten2(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten2(array, 1) : [];\n    }\n    module2.exports = flatten2;\n  }\n});\n\n// node_modules/lodash/_apply.js\nvar require_apply = __commonJS({\n  \"node_modules/lodash/_apply.js\"(exports2, module2) {\n    function apply2(func, thisArg, args) {\n      switch (args.length) {\n        case 0:\n          return func.call(thisArg);\n        case 1:\n          return func.call(thisArg, args[0]);\n        case 2:\n          return func.call(thisArg, args[0], args[1]);\n        case 3:\n          return func.call(thisArg, args[0], args[1], args[2]);\n      }\n      return func.apply(thisArg, args);\n    }\n    module2.exports = apply2;\n  }\n});\n\n// node_modules/lodash/_overRest.js\nvar require_overRest = __commonJS({\n  \"node_modules/lodash/_overRest.js\"(exports2, module2) {\n    var apply2 = require_apply();\n    var nativeMax2 = Math.max;\n    function overRest2(func, start2, transform) {\n      start2 = nativeMax2(start2 === void 0 ? func.length - 1 : start2, 0);\n      return function() {\n        var args = arguments, index5 = -1, length = nativeMax2(args.length - start2, 0), array = Array(length);\n        while (++index5 < length) {\n          array[index5] = args[start2 + index5];\n        }\n        index5 = -1;\n        var otherArgs = Array(start2 + 1);\n        while (++index5 < start2) {\n          otherArgs[index5] = args[index5];\n        }\n        otherArgs[start2] = transform(array);\n        return apply2(func, this, otherArgs);\n      };\n    }\n    module2.exports = overRest2;\n  }\n});\n\n// node_modules/lodash/constant.js\nvar require_constant = __commonJS({\n  \"node_modules/lodash/constant.js\"(exports2, module2) {\n    function constant2(value) {\n      return function() {\n        return value;\n      };\n    }\n    module2.exports = constant2;\n  }\n});\n\n// node_modules/lodash/identity.js\nvar require_identity = __commonJS({\n  \"node_modules/lodash/identity.js\"(exports2, module2) {\n    function identity2(value) {\n      return value;\n    }\n    module2.exports = identity2;\n  }\n});\n\n// node_modules/lodash/_baseSetToString.js\nvar require_baseSetToString = __commonJS({\n  \"node_modules/lodash/_baseSetToString.js\"(exports2, module2) {\n    var constant2 = require_constant();\n    var defineProperty5 = require_defineProperty();\n    var identity2 = require_identity();\n    var baseSetToString2 = !defineProperty5 ? identity2 : function(func, string2) {\n      return defineProperty5(func, \"toString\", {\n        \"configurable\": true,\n        \"enumerable\": false,\n        \"value\": constant2(string2),\n        \"writable\": true\n      });\n    };\n    module2.exports = baseSetToString2;\n  }\n});\n\n// node_modules/lodash/_shortOut.js\nvar require_shortOut = __commonJS({\n  \"node_modules/lodash/_shortOut.js\"(exports2, module2) {\n    var HOT_COUNT2 = 800;\n    var HOT_SPAN2 = 16;\n    var nativeNow2 = Date.now;\n    function shortOut2(func) {\n      var count2 = 0, lastCalled = 0;\n      return function() {\n        var stamp = nativeNow2(), remaining = HOT_SPAN2 - (stamp - lastCalled);\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count2 >= HOT_COUNT2) {\n            return arguments[0];\n          }\n        } else {\n          count2 = 0;\n        }\n        return func.apply(void 0, arguments);\n      };\n    }\n    module2.exports = shortOut2;\n  }\n});\n\n// node_modules/lodash/_setToString.js\nvar require_setToString = __commonJS({\n  \"node_modules/lodash/_setToString.js\"(exports2, module2) {\n    var baseSetToString2 = require_baseSetToString();\n    var shortOut2 = require_shortOut();\n    var setToString2 = shortOut2(baseSetToString2);\n    module2.exports = setToString2;\n  }\n});\n\n// node_modules/lodash/_flatRest.js\nvar require_flatRest = __commonJS({\n  \"node_modules/lodash/_flatRest.js\"(exports2, module2) {\n    var flatten2 = require_flatten();\n    var overRest2 = require_overRest();\n    var setToString2 = require_setToString();\n    function flatRest2(func) {\n      return setToString2(overRest2(func, void 0, flatten2), func + \"\");\n    }\n    module2.exports = flatRest2;\n  }\n});\n\n// node_modules/lodash/pick.js\nvar require_pick = __commonJS({\n  \"node_modules/lodash/pick.js\"(exports2, module2) {\n    var basePick = require_basePick();\n    var flatRest2 = require_flatRest();\n    var pick3 = flatRest2(function(object, paths) {\n      return object == null ? {} : basePick(object, paths);\n    });\n    module2.exports = pick3;\n  }\n});\n\n// node_modules/html-tags/html-tags.json\nvar require_html_tags = __commonJS({\n  \"node_modules/html-tags/html-tags.json\"(exports2, module2) {\n    module2.exports = [\n      \"a\",\n      \"abbr\",\n      \"address\",\n      \"area\",\n      \"article\",\n      \"aside\",\n      \"audio\",\n      \"b\",\n      \"base\",\n      \"bdi\",\n      \"bdo\",\n      \"blockquote\",\n      \"body\",\n      \"br\",\n      \"button\",\n      \"canvas\",\n      \"caption\",\n      \"cite\",\n      \"code\",\n      \"col\",\n      \"colgroup\",\n      \"data\",\n      \"datalist\",\n      \"dd\",\n      \"del\",\n      \"details\",\n      \"dfn\",\n      \"dialog\",\n      \"div\",\n      \"dl\",\n      \"dt\",\n      \"em\",\n      \"embed\",\n      \"fieldset\",\n      \"figcaption\",\n      \"figure\",\n      \"footer\",\n      \"form\",\n      \"h1\",\n      \"h2\",\n      \"h3\",\n      \"h4\",\n      \"h5\",\n      \"h6\",\n      \"head\",\n      \"header\",\n      \"hgroup\",\n      \"hr\",\n      \"html\",\n      \"i\",\n      \"iframe\",\n      \"img\",\n      \"input\",\n      \"ins\",\n      \"kbd\",\n      \"label\",\n      \"legend\",\n      \"li\",\n      \"link\",\n      \"main\",\n      \"map\",\n      \"mark\",\n      \"math\",\n      \"menu\",\n      \"menuitem\",\n      \"meta\",\n      \"meter\",\n      \"nav\",\n      \"noscript\",\n      \"object\",\n      \"ol\",\n      \"optgroup\",\n      \"option\",\n      \"output\",\n      \"p\",\n      \"param\",\n      \"picture\",\n      \"pre\",\n      \"progress\",\n      \"q\",\n      \"rb\",\n      \"rp\",\n      \"rt\",\n      \"rtc\",\n      \"ruby\",\n      \"s\",\n      \"samp\",\n      \"script\",\n      \"section\",\n      \"select\",\n      \"slot\",\n      \"small\",\n      \"source\",\n      \"span\",\n      \"strong\",\n      \"style\",\n      \"sub\",\n      \"summary\",\n      \"sup\",\n      \"svg\",\n      \"table\",\n      \"tbody\",\n      \"td\",\n      \"template\",\n      \"textarea\",\n      \"tfoot\",\n      \"th\",\n      \"thead\",\n      \"time\",\n      \"title\",\n      \"tr\",\n      \"track\",\n      \"u\",\n      \"ul\",\n      \"var\",\n      \"video\",\n      \"wbr\"\n    ];\n  }\n});\n\n// node_modules/html-tags/index.js\nvar require_html_tags2 = __commonJS({\n  \"node_modules/html-tags/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = require_html_tags();\n  }\n});\n\n// node_modules/lodash/_stackClear.js\nvar require_stackClear = __commonJS({\n  \"node_modules/lodash/_stackClear.js\"(exports2, module2) {\n    var ListCache5 = require_ListCache();\n    function stackClear5() {\n      this.__data__ = new ListCache5();\n      this.size = 0;\n    }\n    module2.exports = stackClear5;\n  }\n});\n\n// node_modules/lodash/_stackDelete.js\nvar require_stackDelete = __commonJS({\n  \"node_modules/lodash/_stackDelete.js\"(exports2, module2) {\n    function stackDelete5(key) {\n      var data = this.__data__, result = data[\"delete\"](key);\n      this.size = data.size;\n      return result;\n    }\n    module2.exports = stackDelete5;\n  }\n});\n\n// node_modules/lodash/_stackGet.js\nvar require_stackGet = __commonJS({\n  \"node_modules/lodash/_stackGet.js\"(exports2, module2) {\n    function stackGet5(key) {\n      return this.__data__.get(key);\n    }\n    module2.exports = stackGet5;\n  }\n});\n\n// node_modules/lodash/_stackHas.js\nvar require_stackHas = __commonJS({\n  \"node_modules/lodash/_stackHas.js\"(exports2, module2) {\n    function stackHas5(key) {\n      return this.__data__.has(key);\n    }\n    module2.exports = stackHas5;\n  }\n});\n\n// node_modules/lodash/_stackSet.js\nvar require_stackSet = __commonJS({\n  \"node_modules/lodash/_stackSet.js\"(exports2, module2) {\n    var ListCache5 = require_ListCache();\n    var Map5 = require_Map();\n    var MapCache5 = require_MapCache();\n    var LARGE_ARRAY_SIZE5 = 200;\n    function stackSet5(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache5) {\n        var pairs = data.__data__;\n        if (!Map5 || pairs.length < LARGE_ARRAY_SIZE5 - 1) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache5(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n    module2.exports = stackSet5;\n  }\n});\n\n// node_modules/lodash/_Stack.js\nvar require_Stack = __commonJS({\n  \"node_modules/lodash/_Stack.js\"(exports2, module2) {\n    var ListCache5 = require_ListCache();\n    var stackClear5 = require_stackClear();\n    var stackDelete5 = require_stackDelete();\n    var stackGet5 = require_stackGet();\n    var stackHas5 = require_stackHas();\n    var stackSet5 = require_stackSet();\n    function Stack5(entries) {\n      var data = this.__data__ = new ListCache5(entries);\n      this.size = data.size;\n    }\n    Stack5.prototype.clear = stackClear5;\n    Stack5.prototype[\"delete\"] = stackDelete5;\n    Stack5.prototype.get = stackGet5;\n    Stack5.prototype.has = stackHas5;\n    Stack5.prototype.set = stackSet5;\n    module2.exports = Stack5;\n  }\n});\n\n// node_modules/lodash/_arrayEach.js\nvar require_arrayEach = __commonJS({\n  \"node_modules/lodash/_arrayEach.js\"(exports2, module2) {\n    function arrayEach4(array, iteratee) {\n      var index5 = -1, length = array == null ? 0 : array.length;\n      while (++index5 < length) {\n        if (iteratee(array[index5], index5, array) === false) {\n          break;\n        }\n      }\n      return array;\n    }\n    module2.exports = arrayEach4;\n  }\n});\n\n// node_modules/lodash/_copyObject.js\nvar require_copyObject = __commonJS({\n  \"node_modules/lodash/_copyObject.js\"(exports2, module2) {\n    var assignValue4 = require_assignValue();\n    var baseAssignValue4 = require_baseAssignValue();\n    function copyObject4(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n      var index5 = -1, length = props.length;\n      while (++index5 < length) {\n        var key = props[index5];\n        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;\n        if (newValue === void 0) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue4(object, key, newValue);\n        } else {\n          assignValue4(object, key, newValue);\n        }\n      }\n      return object;\n    }\n    module2.exports = copyObject4;\n  }\n});\n\n// node_modules/lodash/_baseTimes.js\nvar require_baseTimes = __commonJS({\n  \"node_modules/lodash/_baseTimes.js\"(exports2, module2) {\n    function baseTimes4(n8, iteratee) {\n      var index5 = -1, result = Array(n8);\n      while (++index5 < n8) {\n        result[index5] = iteratee(index5);\n      }\n      return result;\n    }\n    module2.exports = baseTimes4;\n  }\n});\n\n// node_modules/lodash/stubFalse.js\nvar require_stubFalse = __commonJS({\n  \"node_modules/lodash/stubFalse.js\"(exports2, module2) {\n    function stubFalse5() {\n      return false;\n    }\n    module2.exports = stubFalse5;\n  }\n});\n\n// node_modules/lodash/isBuffer.js\nvar require_isBuffer = __commonJS({\n  \"node_modules/lodash/isBuffer.js\"(exports2, module2) {\n    var root5 = require_root();\n    var stubFalse5 = require_stubFalse();\n    var freeExports = typeof exports2 == \"object\" && exports2 && !exports2.nodeType && exports2;\n    var freeModule = freeExports && typeof module2 == \"object\" && module2 && !module2.nodeType && module2;\n    var moduleExports = freeModule && freeModule.exports === freeExports;\n    var Buffer2 = moduleExports ? root5.Buffer : void 0;\n    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;\n    var isBuffer = nativeIsBuffer || stubFalse5;\n    module2.exports = isBuffer;\n  }\n});\n\n// node_modules/lodash/_baseIsTypedArray.js\nvar require_baseIsTypedArray = __commonJS({\n  \"node_modules/lodash/_baseIsTypedArray.js\"(exports2, module2) {\n    var baseGetTag5 = require_baseGetTag();\n    var isLength5 = require_isLength();\n    var isObjectLike5 = require_isObjectLike();\n    var argsTag4 = \"[object Arguments]\";\n    var arrayTag4 = \"[object Array]\";\n    var boolTag4 = \"[object Boolean]\";\n    var dateTag4 = \"[object Date]\";\n    var errorTag4 = \"[object Error]\";\n    var funcTag5 = \"[object Function]\";\n    var mapTag5 = \"[object Map]\";\n    var numberTag4 = \"[object Number]\";\n    var objectTag4 = \"[object Object]\";\n    var regexpTag4 = \"[object RegExp]\";\n    var setTag5 = \"[object Set]\";\n    var stringTag4 = \"[object String]\";\n    var weakMapTag5 = \"[object WeakMap]\";\n    var arrayBufferTag4 = \"[object ArrayBuffer]\";\n    var dataViewTag5 = \"[object DataView]\";\n    var float32Tag5 = \"[object Float32Array]\";\n    var float64Tag5 = \"[object Float64Array]\";\n    var int8Tag5 = \"[object Int8Array]\";\n    var int16Tag5 = \"[object Int16Array]\";\n    var int32Tag5 = \"[object Int32Array]\";\n    var uint8Tag5 = \"[object Uint8Array]\";\n    var uint8ClampedTag5 = \"[object Uint8ClampedArray]\";\n    var uint16Tag5 = \"[object Uint16Array]\";\n    var uint32Tag5 = \"[object Uint32Array]\";\n    var typedArrayTags5 = {};\n    typedArrayTags5[float32Tag5] = typedArrayTags5[float64Tag5] = typedArrayTags5[int8Tag5] = typedArrayTags5[int16Tag5] = typedArrayTags5[int32Tag5] = typedArrayTags5[uint8Tag5] = typedArrayTags5[uint8ClampedTag5] = typedArrayTags5[uint16Tag5] = typedArrayTags5[uint32Tag5] = true;\n    typedArrayTags5[argsTag4] = typedArrayTags5[arrayTag4] = typedArrayTags5[arrayBufferTag4] = typedArrayTags5[boolTag4] = typedArrayTags5[dataViewTag5] = typedArrayTags5[dateTag4] = typedArrayTags5[errorTag4] = typedArrayTags5[funcTag5] = typedArrayTags5[mapTag5] = typedArrayTags5[numberTag4] = typedArrayTags5[objectTag4] = typedArrayTags5[regexpTag4] = typedArrayTags5[setTag5] = typedArrayTags5[stringTag4] = typedArrayTags5[weakMapTag5] = false;\n    function baseIsTypedArray5(value) {\n      return isObjectLike5(value) && isLength5(value.length) && !!typedArrayTags5[baseGetTag5(value)];\n    }\n    module2.exports = baseIsTypedArray5;\n  }\n});\n\n// node_modules/lodash/_baseUnary.js\nvar require_baseUnary = __commonJS({\n  \"node_modules/lodash/_baseUnary.js\"(exports2, module2) {\n    function baseUnary5(func) {\n      return function(value) {\n        return func(value);\n      };\n    }\n    module2.exports = baseUnary5;\n  }\n});\n\n// node_modules/lodash/_nodeUtil.js\nvar require_nodeUtil = __commonJS({\n  \"node_modules/lodash/_nodeUtil.js\"(exports2, module2) {\n    var freeGlobal5 = require_freeGlobal();\n    var freeExports = typeof exports2 == \"object\" && exports2 && !exports2.nodeType && exports2;\n    var freeModule = freeExports && typeof module2 == \"object\" && module2 && !module2.nodeType && module2;\n    var moduleExports = freeModule && freeModule.exports === freeExports;\n    var freeProcess = moduleExports && freeGlobal5.process;\n    var nodeUtil = function() {\n      try {\n        var types = freeModule && freeModule.require && freeModule.require(\"util\").types;\n        if (types) {\n          return types;\n        }\n        return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n      } catch (e4) {\n      }\n    }();\n    module2.exports = nodeUtil;\n  }\n});\n\n// node_modules/lodash/isTypedArray.js\nvar require_isTypedArray = __commonJS({\n  \"node_modules/lodash/isTypedArray.js\"(exports2, module2) {\n    var baseIsTypedArray5 = require_baseIsTypedArray();\n    var baseUnary5 = require_baseUnary();\n    var nodeUtil = require_nodeUtil();\n    var nodeIsTypedArray5 = nodeUtil && nodeUtil.isTypedArray;\n    var isTypedArray5 = nodeIsTypedArray5 ? baseUnary5(nodeIsTypedArray5) : baseIsTypedArray5;\n    module2.exports = isTypedArray5;\n  }\n});\n\n// node_modules/lodash/_arrayLikeKeys.js\nvar require_arrayLikeKeys = __commonJS({\n  \"node_modules/lodash/_arrayLikeKeys.js\"(exports2, module2) {\n    var baseTimes4 = require_baseTimes();\n    var isArguments5 = require_isArguments();\n    var isArray9 = require_isArray();\n    var isBuffer = require_isBuffer();\n    var isIndex4 = require_isIndex();\n    var isTypedArray5 = require_isTypedArray();\n    var objectProto5 = Object.prototype;\n    var hasOwnProperty6 = objectProto5.hasOwnProperty;\n    function arrayLikeKeys4(value, inherited) {\n      var isArr = isArray9(value), isArg = !isArr && isArguments5(value), isBuff = !isArr && !isArg && isBuffer(value), isType3 = !isArr && !isArg && !isBuff && isTypedArray5(value), skipIndexes = isArr || isArg || isBuff || isType3, result = skipIndexes ? baseTimes4(value.length, String) : [], length = result.length;\n      for (var key in value) {\n        if ((inherited || hasOwnProperty6.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.\n        (key == \"length\" || isBuff && (key == \"offset\" || key == \"parent\") || isType3 && (key == \"buffer\" || key == \"byteLength\" || key == \"byteOffset\") || // Skip index properties.\n        isIndex4(key, length)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n    module2.exports = arrayLikeKeys4;\n  }\n});\n\n// node_modules/lodash/_isPrototype.js\nvar require_isPrototype = __commonJS({\n  \"node_modules/lodash/_isPrototype.js\"(exports2, module2) {\n    var objectProto5 = Object.prototype;\n    function isPrototype4(value) {\n      var Ctor = value && value.constructor, proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto5;\n      return value === proto;\n    }\n    module2.exports = isPrototype4;\n  }\n});\n\n// node_modules/lodash/_overArg.js\nvar require_overArg = __commonJS({\n  \"node_modules/lodash/_overArg.js\"(exports2, module2) {\n    function overArg5(func, transform) {\n      return function(arg) {\n        return func(transform(arg));\n      };\n    }\n    module2.exports = overArg5;\n  }\n});\n\n// node_modules/lodash/_nativeKeys.js\nvar require_nativeKeys = __commonJS({\n  \"node_modules/lodash/_nativeKeys.js\"(exports2, module2) {\n    var overArg5 = require_overArg();\n    var nativeKeys5 = overArg5(Object.keys, Object);\n    module2.exports = nativeKeys5;\n  }\n});\n\n// node_modules/lodash/_baseKeys.js\nvar require_baseKeys = __commonJS({\n  \"node_modules/lodash/_baseKeys.js\"(exports2, module2) {\n    var isPrototype4 = require_isPrototype();\n    var nativeKeys5 = require_nativeKeys();\n    var objectProto5 = Object.prototype;\n    var hasOwnProperty6 = objectProto5.hasOwnProperty;\n    function baseKeys4(object) {\n      if (!isPrototype4(object)) {\n        return nativeKeys5(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty6.call(object, key) && key != \"constructor\") {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n    module2.exports = baseKeys4;\n  }\n});\n\n// node_modules/lodash/isArrayLike.js\nvar require_isArrayLike = __commonJS({\n  \"node_modules/lodash/isArrayLike.js\"(exports2, module2) {\n    var isFunction6 = require_isFunction();\n    var isLength5 = require_isLength();\n    function isArrayLike4(value) {\n      return value != null && isLength5(value.length) && !isFunction6(value);\n    }\n    module2.exports = isArrayLike4;\n  }\n});\n\n// node_modules/lodash/keys.js\nvar require_keys = __commonJS({\n  \"node_modules/lodash/keys.js\"(exports2, module2) {\n    var arrayLikeKeys4 = require_arrayLikeKeys();\n    var baseKeys4 = require_baseKeys();\n    var isArrayLike4 = require_isArrayLike();\n    function keys4(object) {\n      return isArrayLike4(object) ? arrayLikeKeys4(object) : baseKeys4(object);\n    }\n    module2.exports = keys4;\n  }\n});\n\n// node_modules/lodash/_baseAssign.js\nvar require_baseAssign = __commonJS({\n  \"node_modules/lodash/_baseAssign.js\"(exports2, module2) {\n    var copyObject4 = require_copyObject();\n    var keys4 = require_keys();\n    function baseAssign4(object, source) {\n      return object && copyObject4(source, keys4(source), object);\n    }\n    module2.exports = baseAssign4;\n  }\n});\n\n// node_modules/lodash/_nativeKeysIn.js\nvar require_nativeKeysIn = __commonJS({\n  \"node_modules/lodash/_nativeKeysIn.js\"(exports2, module2) {\n    function nativeKeysIn4(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n    module2.exports = nativeKeysIn4;\n  }\n});\n\n// node_modules/lodash/_baseKeysIn.js\nvar require_baseKeysIn = __commonJS({\n  \"node_modules/lodash/_baseKeysIn.js\"(exports2, module2) {\n    var isObject7 = require_isObject();\n    var isPrototype4 = require_isPrototype();\n    var nativeKeysIn4 = require_nativeKeysIn();\n    var objectProto5 = Object.prototype;\n    var hasOwnProperty6 = objectProto5.hasOwnProperty;\n    function baseKeysIn4(object) {\n      if (!isObject7(object)) {\n        return nativeKeysIn4(object);\n      }\n      var isProto = isPrototype4(object), result = [];\n      for (var key in object) {\n        if (!(key == \"constructor\" && (isProto || !hasOwnProperty6.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n    module2.exports = baseKeysIn4;\n  }\n});\n\n// node_modules/lodash/keysIn.js\nvar require_keysIn = __commonJS({\n  \"node_modules/lodash/keysIn.js\"(exports2, module2) {\n    var arrayLikeKeys4 = require_arrayLikeKeys();\n    var baseKeysIn4 = require_baseKeysIn();\n    var isArrayLike4 = require_isArrayLike();\n    function keysIn4(object) {\n      return isArrayLike4(object) ? arrayLikeKeys4(object, true) : baseKeysIn4(object);\n    }\n    module2.exports = keysIn4;\n  }\n});\n\n// node_modules/lodash/_baseAssignIn.js\nvar require_baseAssignIn = __commonJS({\n  \"node_modules/lodash/_baseAssignIn.js\"(exports2, module2) {\n    var copyObject4 = require_copyObject();\n    var keysIn4 = require_keysIn();\n    function baseAssignIn4(object, source) {\n      return object && copyObject4(source, keysIn4(source), object);\n    }\n    module2.exports = baseAssignIn4;\n  }\n});\n\n// node_modules/lodash/_cloneBuffer.js\nvar require_cloneBuffer = __commonJS({\n  \"node_modules/lodash/_cloneBuffer.js\"(exports2, module2) {\n    var root5 = require_root();\n    var freeExports = typeof exports2 == \"object\" && exports2 && !exports2.nodeType && exports2;\n    var freeModule = freeExports && typeof module2 == \"object\" && module2 && !module2.nodeType && module2;\n    var moduleExports = freeModule && freeModule.exports === freeExports;\n    var Buffer2 = moduleExports ? root5.Buffer : void 0;\n    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n      buffer.copy(result);\n      return result;\n    }\n    module2.exports = cloneBuffer;\n  }\n});\n\n// node_modules/lodash/_copyArray.js\nvar require_copyArray = __commonJS({\n  \"node_modules/lodash/_copyArray.js\"(exports2, module2) {\n    function copyArray4(source, array) {\n      var index5 = -1, length = source.length;\n      array || (array = Array(length));\n      while (++index5 < length) {\n        array[index5] = source[index5];\n      }\n      return array;\n    }\n    module2.exports = copyArray4;\n  }\n});\n\n// node_modules/lodash/_arrayFilter.js\nvar require_arrayFilter = __commonJS({\n  \"node_modules/lodash/_arrayFilter.js\"(exports2, module2) {\n    function arrayFilter4(array, predicate) {\n      var index5 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];\n      while (++index5 < length) {\n        var value = array[index5];\n        if (predicate(value, index5, array)) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n    module2.exports = arrayFilter4;\n  }\n});\n\n// node_modules/lodash/stubArray.js\nvar require_stubArray = __commonJS({\n  \"node_modules/lodash/stubArray.js\"(exports2, module2) {\n    function stubArray4() {\n      return [];\n    }\n    module2.exports = stubArray4;\n  }\n});\n\n// node_modules/lodash/_getSymbols.js\nvar require_getSymbols = __commonJS({\n  \"node_modules/lodash/_getSymbols.js\"(exports2, module2) {\n    var arrayFilter4 = require_arrayFilter();\n    var stubArray4 = require_stubArray();\n    var objectProto5 = Object.prototype;\n    var propertyIsEnumerable5 = objectProto5.propertyIsEnumerable;\n    var nativeGetSymbols4 = Object.getOwnPropertySymbols;\n    var getSymbols4 = !nativeGetSymbols4 ? stubArray4 : function(object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter4(nativeGetSymbols4(object), function(symbol) {\n        return propertyIsEnumerable5.call(object, symbol);\n      });\n    };\n    module2.exports = getSymbols4;\n  }\n});\n\n// node_modules/lodash/_copySymbols.js\nvar require_copySymbols = __commonJS({\n  \"node_modules/lodash/_copySymbols.js\"(exports2, module2) {\n    var copyObject4 = require_copyObject();\n    var getSymbols4 = require_getSymbols();\n    function copySymbols4(source, object) {\n      return copyObject4(source, getSymbols4(source), object);\n    }\n    module2.exports = copySymbols4;\n  }\n});\n\n// node_modules/lodash/_getPrototype.js\nvar require_getPrototype = __commonJS({\n  \"node_modules/lodash/_getPrototype.js\"(exports2, module2) {\n    var overArg5 = require_overArg();\n    var getPrototype4 = overArg5(Object.getPrototypeOf, Object);\n    module2.exports = getPrototype4;\n  }\n});\n\n// node_modules/lodash/_getSymbolsIn.js\nvar require_getSymbolsIn = __commonJS({\n  \"node_modules/lodash/_getSymbolsIn.js\"(exports2, module2) {\n    var arrayPush4 = require_arrayPush();\n    var getPrototype4 = require_getPrototype();\n    var getSymbols4 = require_getSymbols();\n    var stubArray4 = require_stubArray();\n    var nativeGetSymbols4 = Object.getOwnPropertySymbols;\n    var getSymbolsIn4 = !nativeGetSymbols4 ? stubArray4 : function(object) {\n      var result = [];\n      while (object) {\n        arrayPush4(result, getSymbols4(object));\n        object = getPrototype4(object);\n      }\n      return result;\n    };\n    module2.exports = getSymbolsIn4;\n  }\n});\n\n// node_modules/lodash/_copySymbolsIn.js\nvar require_copySymbolsIn = __commonJS({\n  \"node_modules/lodash/_copySymbolsIn.js\"(exports2, module2) {\n    var copyObject4 = require_copyObject();\n    var getSymbolsIn4 = require_getSymbolsIn();\n    function copySymbolsIn4(source, object) {\n      return copyObject4(source, getSymbolsIn4(source), object);\n    }\n    module2.exports = copySymbolsIn4;\n  }\n});\n\n// node_modules/lodash/_baseGetAllKeys.js\nvar require_baseGetAllKeys = __commonJS({\n  \"node_modules/lodash/_baseGetAllKeys.js\"(exports2, module2) {\n    var arrayPush4 = require_arrayPush();\n    var isArray9 = require_isArray();\n    function baseGetAllKeys4(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray9(object) ? result : arrayPush4(result, symbolsFunc(object));\n    }\n    module2.exports = baseGetAllKeys4;\n  }\n});\n\n// node_modules/lodash/_getAllKeys.js\nvar require_getAllKeys = __commonJS({\n  \"node_modules/lodash/_getAllKeys.js\"(exports2, module2) {\n    var baseGetAllKeys4 = require_baseGetAllKeys();\n    var getSymbols4 = require_getSymbols();\n    var keys4 = require_keys();\n    function getAllKeys4(object) {\n      return baseGetAllKeys4(object, keys4, getSymbols4);\n    }\n    module2.exports = getAllKeys4;\n  }\n});\n\n// node_modules/lodash/_getAllKeysIn.js\nvar require_getAllKeysIn = __commonJS({\n  \"node_modules/lodash/_getAllKeysIn.js\"(exports2, module2) {\n    var baseGetAllKeys4 = require_baseGetAllKeys();\n    var getSymbolsIn4 = require_getSymbolsIn();\n    var keysIn4 = require_keysIn();\n    function getAllKeysIn4(object) {\n      return baseGetAllKeys4(object, keysIn4, getSymbolsIn4);\n    }\n    module2.exports = getAllKeysIn4;\n  }\n});\n\n// node_modules/lodash/_DataView.js\nvar require_DataView = __commonJS({\n  \"node_modules/lodash/_DataView.js\"(exports2, module2) {\n    var getNative5 = require_getNative();\n    var root5 = require_root();\n    var DataView5 = getNative5(root5, \"DataView\");\n    module2.exports = DataView5;\n  }\n});\n\n// node_modules/lodash/_Promise.js\nvar require_Promise = __commonJS({\n  \"node_modules/lodash/_Promise.js\"(exports2, module2) {\n    var getNative5 = require_getNative();\n    var root5 = require_root();\n    var Promise2 = getNative5(root5, \"Promise\");\n    module2.exports = Promise2;\n  }\n});\n\n// node_modules/lodash/_Set.js\nvar require_Set = __commonJS({\n  \"node_modules/lodash/_Set.js\"(exports2, module2) {\n    var getNative5 = require_getNative();\n    var root5 = require_root();\n    var Set6 = getNative5(root5, \"Set\");\n    module2.exports = Set6;\n  }\n});\n\n// node_modules/lodash/_WeakMap.js\nvar require_WeakMap = __commonJS({\n  \"node_modules/lodash/_WeakMap.js\"(exports2, module2) {\n    var getNative5 = require_getNative();\n    var root5 = require_root();\n    var WeakMap5 = getNative5(root5, \"WeakMap\");\n    module2.exports = WeakMap5;\n  }\n});\n\n// node_modules/lodash/_getTag.js\nvar require_getTag = __commonJS({\n  \"node_modules/lodash/_getTag.js\"(exports2, module2) {\n    var DataView5 = require_DataView();\n    var Map5 = require_Map();\n    var Promise2 = require_Promise();\n    var Set6 = require_Set();\n    var WeakMap5 = require_WeakMap();\n    var baseGetTag5 = require_baseGetTag();\n    var toSource5 = require_toSource();\n    var mapTag5 = \"[object Map]\";\n    var objectTag4 = \"[object Object]\";\n    var promiseTag5 = \"[object Promise]\";\n    var setTag5 = \"[object Set]\";\n    var weakMapTag5 = \"[object WeakMap]\";\n    var dataViewTag5 = \"[object DataView]\";\n    var dataViewCtorString5 = toSource5(DataView5);\n    var mapCtorString5 = toSource5(Map5);\n    var promiseCtorString5 = toSource5(Promise2);\n    var setCtorString5 = toSource5(Set6);\n    var weakMapCtorString5 = toSource5(WeakMap5);\n    var getTag5 = baseGetTag5;\n    if (DataView5 && getTag5(new DataView5(new ArrayBuffer(1))) != dataViewTag5 || Map5 && getTag5(new Map5()) != mapTag5 || Promise2 && getTag5(Promise2.resolve()) != promiseTag5 || Set6 && getTag5(new Set6()) != setTag5 || WeakMap5 && getTag5(new WeakMap5()) != weakMapTag5) {\n      getTag5 = function(value) {\n        var result = baseGetTag5(value), Ctor = result == objectTag4 ? value.constructor : void 0, ctorString = Ctor ? toSource5(Ctor) : \"\";\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString5:\n              return dataViewTag5;\n            case mapCtorString5:\n              return mapTag5;\n            case promiseCtorString5:\n              return promiseTag5;\n            case setCtorString5:\n              return setTag5;\n            case weakMapCtorString5:\n              return weakMapTag5;\n          }\n        }\n        return result;\n      };\n    }\n    module2.exports = getTag5;\n  }\n});\n\n// node_modules/lodash/_initCloneArray.js\nvar require_initCloneArray = __commonJS({\n  \"node_modules/lodash/_initCloneArray.js\"(exports2, module2) {\n    var objectProto5 = Object.prototype;\n    var hasOwnProperty6 = objectProto5.hasOwnProperty;\n    function initCloneArray4(array) {\n      var length = array.length, result = new array.constructor(length);\n      if (length && typeof array[0] == \"string\" && hasOwnProperty6.call(array, \"index\")) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n    module2.exports = initCloneArray4;\n  }\n});\n\n// node_modules/lodash/_Uint8Array.js\nvar require_Uint8Array = __commonJS({\n  \"node_modules/lodash/_Uint8Array.js\"(exports2, module2) {\n    var root5 = require_root();\n    var Uint8Array6 = root5.Uint8Array;\n    module2.exports = Uint8Array6;\n  }\n});\n\n// node_modules/lodash/_cloneArrayBuffer.js\nvar require_cloneArrayBuffer = __commonJS({\n  \"node_modules/lodash/_cloneArrayBuffer.js\"(exports2, module2) {\n    var Uint8Array6 = require_Uint8Array();\n    function cloneArrayBuffer4(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array6(result).set(new Uint8Array6(arrayBuffer));\n      return result;\n    }\n    module2.exports = cloneArrayBuffer4;\n  }\n});\n\n// node_modules/lodash/_cloneDataView.js\nvar require_cloneDataView = __commonJS({\n  \"node_modules/lodash/_cloneDataView.js\"(exports2, module2) {\n    var cloneArrayBuffer4 = require_cloneArrayBuffer();\n    function cloneDataView4(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer4(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n    module2.exports = cloneDataView4;\n  }\n});\n\n// node_modules/lodash/_cloneRegExp.js\nvar require_cloneRegExp = __commonJS({\n  \"node_modules/lodash/_cloneRegExp.js\"(exports2, module2) {\n    var reFlags4 = /\\w*$/;\n    function cloneRegExp4(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags4.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n    module2.exports = cloneRegExp4;\n  }\n});\n\n// node_modules/lodash/_cloneSymbol.js\nvar require_cloneSymbol = __commonJS({\n  \"node_modules/lodash/_cloneSymbol.js\"(exports2, module2) {\n    var Symbol4 = require_Symbol();\n    var symbolProto5 = Symbol4 ? Symbol4.prototype : void 0;\n    var symbolValueOf5 = symbolProto5 ? symbolProto5.valueOf : void 0;\n    function cloneSymbol4(symbol) {\n      return symbolValueOf5 ? Object(symbolValueOf5.call(symbol)) : {};\n    }\n    module2.exports = cloneSymbol4;\n  }\n});\n\n// node_modules/lodash/_cloneTypedArray.js\nvar require_cloneTypedArray = __commonJS({\n  \"node_modules/lodash/_cloneTypedArray.js\"(exports2, module2) {\n    var cloneArrayBuffer4 = require_cloneArrayBuffer();\n    function cloneTypedArray4(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer4(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n    module2.exports = cloneTypedArray4;\n  }\n});\n\n// node_modules/lodash/_initCloneByTag.js\nvar require_initCloneByTag = __commonJS({\n  \"node_modules/lodash/_initCloneByTag.js\"(exports2, module2) {\n    var cloneArrayBuffer4 = require_cloneArrayBuffer();\n    var cloneDataView4 = require_cloneDataView();\n    var cloneRegExp4 = require_cloneRegExp();\n    var cloneSymbol4 = require_cloneSymbol();\n    var cloneTypedArray4 = require_cloneTypedArray();\n    var boolTag4 = \"[object Boolean]\";\n    var dateTag4 = \"[object Date]\";\n    var mapTag5 = \"[object Map]\";\n    var numberTag4 = \"[object Number]\";\n    var regexpTag4 = \"[object RegExp]\";\n    var setTag5 = \"[object Set]\";\n    var stringTag4 = \"[object String]\";\n    var symbolTag4 = \"[object Symbol]\";\n    var arrayBufferTag4 = \"[object ArrayBuffer]\";\n    var dataViewTag5 = \"[object DataView]\";\n    var float32Tag5 = \"[object Float32Array]\";\n    var float64Tag5 = \"[object Float64Array]\";\n    var int8Tag5 = \"[object Int8Array]\";\n    var int16Tag5 = \"[object Int16Array]\";\n    var int32Tag5 = \"[object Int32Array]\";\n    var uint8Tag5 = \"[object Uint8Array]\";\n    var uint8ClampedTag5 = \"[object Uint8ClampedArray]\";\n    var uint16Tag5 = \"[object Uint16Array]\";\n    var uint32Tag5 = \"[object Uint32Array]\";\n    function initCloneByTag4(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag4:\n          return cloneArrayBuffer4(object);\n        case boolTag4:\n        case dateTag4:\n          return new Ctor(+object);\n        case dataViewTag5:\n          return cloneDataView4(object, isDeep);\n        case float32Tag5:\n        case float64Tag5:\n        case int8Tag5:\n        case int16Tag5:\n        case int32Tag5:\n        case uint8Tag5:\n        case uint8ClampedTag5:\n        case uint16Tag5:\n        case uint32Tag5:\n          return cloneTypedArray4(object, isDeep);\n        case mapTag5:\n          return new Ctor();\n        case numberTag4:\n        case stringTag4:\n          return new Ctor(object);\n        case regexpTag4:\n          return cloneRegExp4(object);\n        case setTag5:\n          return new Ctor();\n        case symbolTag4:\n          return cloneSymbol4(object);\n      }\n    }\n    module2.exports = initCloneByTag4;\n  }\n});\n\n// node_modules/lodash/_baseCreate.js\nvar require_baseCreate = __commonJS({\n  \"node_modules/lodash/_baseCreate.js\"(exports2, module2) {\n    var isObject7 = require_isObject();\n    var objectCreate4 = Object.create;\n    var baseCreate4 = function() {\n      function object() {\n      }\n      return function(proto) {\n        if (!isObject7(proto)) {\n          return {};\n        }\n        if (objectCreate4) {\n          return objectCreate4(proto);\n        }\n        object.prototype = proto;\n        var result = new object();\n        object.prototype = void 0;\n        return result;\n      };\n    }();\n    module2.exports = baseCreate4;\n  }\n});\n\n// node_modules/lodash/_initCloneObject.js\nvar require_initCloneObject = __commonJS({\n  \"node_modules/lodash/_initCloneObject.js\"(exports2, module2) {\n    var baseCreate4 = require_baseCreate();\n    var getPrototype4 = require_getPrototype();\n    var isPrototype4 = require_isPrototype();\n    function initCloneObject4(object) {\n      return typeof object.constructor == \"function\" && !isPrototype4(object) ? baseCreate4(getPrototype4(object)) : {};\n    }\n    module2.exports = initCloneObject4;\n  }\n});\n\n// node_modules/lodash/_baseIsMap.js\nvar require_baseIsMap = __commonJS({\n  \"node_modules/lodash/_baseIsMap.js\"(exports2, module2) {\n    var getTag5 = require_getTag();\n    var isObjectLike5 = require_isObjectLike();\n    var mapTag5 = \"[object Map]\";\n    function baseIsMap4(value) {\n      return isObjectLike5(value) && getTag5(value) == mapTag5;\n    }\n    module2.exports = baseIsMap4;\n  }\n});\n\n// node_modules/lodash/isMap.js\nvar require_isMap = __commonJS({\n  \"node_modules/lodash/isMap.js\"(exports2, module2) {\n    var baseIsMap4 = require_baseIsMap();\n    var baseUnary5 = require_baseUnary();\n    var nodeUtil = require_nodeUtil();\n    var nodeIsMap4 = nodeUtil && nodeUtil.isMap;\n    var isMap4 = nodeIsMap4 ? baseUnary5(nodeIsMap4) : baseIsMap4;\n    module2.exports = isMap4;\n  }\n});\n\n// node_modules/lodash/_baseIsSet.js\nvar require_baseIsSet = __commonJS({\n  \"node_modules/lodash/_baseIsSet.js\"(exports2, module2) {\n    var getTag5 = require_getTag();\n    var isObjectLike5 = require_isObjectLike();\n    var setTag5 = \"[object Set]\";\n    function baseIsSet4(value) {\n      return isObjectLike5(value) && getTag5(value) == setTag5;\n    }\n    module2.exports = baseIsSet4;\n  }\n});\n\n// node_modules/lodash/isSet.js\nvar require_isSet = __commonJS({\n  \"node_modules/lodash/isSet.js\"(exports2, module2) {\n    var baseIsSet4 = require_baseIsSet();\n    var baseUnary5 = require_baseUnary();\n    var nodeUtil = require_nodeUtil();\n    var nodeIsSet4 = nodeUtil && nodeUtil.isSet;\n    var isSet4 = nodeIsSet4 ? baseUnary5(nodeIsSet4) : baseIsSet4;\n    module2.exports = isSet4;\n  }\n});\n\n// node_modules/lodash/_baseClone.js\nvar require_baseClone = __commonJS({\n  \"node_modules/lodash/_baseClone.js\"(exports2, module2) {\n    var Stack5 = require_Stack();\n    var arrayEach4 = require_arrayEach();\n    var assignValue4 = require_assignValue();\n    var baseAssign4 = require_baseAssign();\n    var baseAssignIn4 = require_baseAssignIn();\n    var cloneBuffer = require_cloneBuffer();\n    var copyArray4 = require_copyArray();\n    var copySymbols4 = require_copySymbols();\n    var copySymbolsIn4 = require_copySymbolsIn();\n    var getAllKeys4 = require_getAllKeys();\n    var getAllKeysIn4 = require_getAllKeysIn();\n    var getTag5 = require_getTag();\n    var initCloneArray4 = require_initCloneArray();\n    var initCloneByTag4 = require_initCloneByTag();\n    var initCloneObject4 = require_initCloneObject();\n    var isArray9 = require_isArray();\n    var isBuffer = require_isBuffer();\n    var isMap4 = require_isMap();\n    var isObject7 = require_isObject();\n    var isSet4 = require_isSet();\n    var keys4 = require_keys();\n    var keysIn4 = require_keysIn();\n    var CLONE_DEEP_FLAG4 = 1;\n    var CLONE_FLAT_FLAG4 = 2;\n    var CLONE_SYMBOLS_FLAG4 = 4;\n    var argsTag4 = \"[object Arguments]\";\n    var arrayTag4 = \"[object Array]\";\n    var boolTag4 = \"[object Boolean]\";\n    var dateTag4 = \"[object Date]\";\n    var errorTag4 = \"[object Error]\";\n    var funcTag5 = \"[object Function]\";\n    var genTag5 = \"[object GeneratorFunction]\";\n    var mapTag5 = \"[object Map]\";\n    var numberTag4 = \"[object Number]\";\n    var objectTag4 = \"[object Object]\";\n    var regexpTag4 = \"[object RegExp]\";\n    var setTag5 = \"[object Set]\";\n    var stringTag4 = \"[object String]\";\n    var symbolTag4 = \"[object Symbol]\";\n    var weakMapTag5 = \"[object WeakMap]\";\n    var arrayBufferTag4 = \"[object ArrayBuffer]\";\n    var dataViewTag5 = \"[object DataView]\";\n    var float32Tag5 = \"[object Float32Array]\";\n    var float64Tag5 = \"[object Float64Array]\";\n    var int8Tag5 = \"[object Int8Array]\";\n    var int16Tag5 = \"[object Int16Array]\";\n    var int32Tag5 = \"[object Int32Array]\";\n    var uint8Tag5 = \"[object Uint8Array]\";\n    var uint8ClampedTag5 = \"[object Uint8ClampedArray]\";\n    var uint16Tag5 = \"[object Uint16Array]\";\n    var uint32Tag5 = \"[object Uint32Array]\";\n    var cloneableTags4 = {};\n    cloneableTags4[argsTag4] = cloneableTags4[arrayTag4] = cloneableTags4[arrayBufferTag4] = cloneableTags4[dataViewTag5] = cloneableTags4[boolTag4] = cloneableTags4[dateTag4] = cloneableTags4[float32Tag5] = cloneableTags4[float64Tag5] = cloneableTags4[int8Tag5] = cloneableTags4[int16Tag5] = cloneableTags4[int32Tag5] = cloneableTags4[mapTag5] = cloneableTags4[numberTag4] = cloneableTags4[objectTag4] = cloneableTags4[regexpTag4] = cloneableTags4[setTag5] = cloneableTags4[stringTag4] = cloneableTags4[symbolTag4] = cloneableTags4[uint8Tag5] = cloneableTags4[uint8ClampedTag5] = cloneableTags4[uint16Tag5] = cloneableTags4[uint32Tag5] = true;\n    cloneableTags4[errorTag4] = cloneableTags4[funcTag5] = cloneableTags4[weakMapTag5] = false;\n    function baseClone4(value, bitmask, customizer, key, object, stack) {\n      var result, isDeep = bitmask & CLONE_DEEP_FLAG4, isFlat = bitmask & CLONE_FLAT_FLAG4, isFull = bitmask & CLONE_SYMBOLS_FLAG4;\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== void 0) {\n        return result;\n      }\n      if (!isObject7(value)) {\n        return value;\n      }\n      var isArr = isArray9(value);\n      if (isArr) {\n        result = initCloneArray4(value);\n        if (!isDeep) {\n          return copyArray4(value, result);\n        }\n      } else {\n        var tag = getTag5(value), isFunc = tag == funcTag5 || tag == genTag5;\n        if (isBuffer(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag4 || tag == argsTag4 || isFunc && !object) {\n          result = isFlat || isFunc ? {} : initCloneObject4(value);\n          if (!isDeep) {\n            return isFlat ? copySymbolsIn4(value, baseAssignIn4(result, value)) : copySymbols4(value, baseAssign4(result, value));\n          }\n        } else {\n          if (!cloneableTags4[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag4(value, tag, isDeep);\n        }\n      }\n      stack || (stack = new Stack5());\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n      if (isSet4(value)) {\n        value.forEach(function(subValue) {\n          result.add(baseClone4(subValue, bitmask, customizer, subValue, value, stack));\n        });\n      } else if (isMap4(value)) {\n        value.forEach(function(subValue, key2) {\n          result.set(key2, baseClone4(subValue, bitmask, customizer, key2, value, stack));\n        });\n      }\n      var keysFunc = isFull ? isFlat ? getAllKeysIn4 : getAllKeys4 : isFlat ? keysIn4 : keys4;\n      var props = isArr ? void 0 : keysFunc(value);\n      arrayEach4(props || value, function(subValue, key2) {\n        if (props) {\n          key2 = subValue;\n          subValue = value[key2];\n        }\n        assignValue4(result, key2, baseClone4(subValue, bitmask, customizer, key2, value, stack));\n      });\n      return result;\n    }\n    module2.exports = baseClone4;\n  }\n});\n\n// node_modules/lodash/last.js\nvar require_last = __commonJS({\n  \"node_modules/lodash/last.js\"(exports2, module2) {\n    function last2(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? array[length - 1] : void 0;\n    }\n    module2.exports = last2;\n  }\n});\n\n// node_modules/lodash/_baseSlice.js\nvar require_baseSlice = __commonJS({\n  \"node_modules/lodash/_baseSlice.js\"(exports2, module2) {\n    function baseSlice2(array, start2, end2) {\n      var index5 = -1, length = array.length;\n      if (start2 < 0) {\n        start2 = -start2 > length ? 0 : length + start2;\n      }\n      end2 = end2 > length ? length : end2;\n      if (end2 < 0) {\n        end2 += length;\n      }\n      length = start2 > end2 ? 0 : end2 - start2 >>> 0;\n      start2 >>>= 0;\n      var result = Array(length);\n      while (++index5 < length) {\n        result[index5] = array[index5 + start2];\n      }\n      return result;\n    }\n    module2.exports = baseSlice2;\n  }\n});\n\n// node_modules/lodash/_parent.js\nvar require_parent = __commonJS({\n  \"node_modules/lodash/_parent.js\"(exports2, module2) {\n    var baseGet2 = require_baseGet();\n    var baseSlice2 = require_baseSlice();\n    function parent2(object, path) {\n      return path.length < 2 ? object : baseGet2(object, baseSlice2(path, 0, -1));\n    }\n    module2.exports = parent2;\n  }\n});\n\n// node_modules/lodash/_baseUnset.js\nvar require_baseUnset = __commonJS({\n  \"node_modules/lodash/_baseUnset.js\"(exports2, module2) {\n    var castPath2 = require_castPath();\n    var last2 = require_last();\n    var parent2 = require_parent();\n    var toKey2 = require_toKey();\n    function baseUnset2(object, path) {\n      path = castPath2(path, object);\n      object = parent2(object, path);\n      return object == null || delete object[toKey2(last2(path))];\n    }\n    module2.exports = baseUnset2;\n  }\n});\n\n// node_modules/lodash/isPlainObject.js\nvar require_isPlainObject = __commonJS({\n  \"node_modules/lodash/isPlainObject.js\"(exports2, module2) {\n    var baseGetTag5 = require_baseGetTag();\n    var getPrototype4 = require_getPrototype();\n    var isObjectLike5 = require_isObjectLike();\n    var objectTag4 = \"[object Object]\";\n    var funcProto5 = Function.prototype;\n    var objectProto5 = Object.prototype;\n    var funcToString5 = funcProto5.toString;\n    var hasOwnProperty6 = objectProto5.hasOwnProperty;\n    var objectCtorString2 = funcToString5.call(Object);\n    function isPlainObject5(value) {\n      if (!isObjectLike5(value) || baseGetTag5(value) != objectTag4) {\n        return false;\n      }\n      var proto = getPrototype4(value);\n      if (proto === null) {\n        return true;\n      }\n      var Ctor = hasOwnProperty6.call(proto, \"constructor\") && proto.constructor;\n      return typeof Ctor == \"function\" && Ctor instanceof Ctor && funcToString5.call(Ctor) == objectCtorString2;\n    }\n    module2.exports = isPlainObject5;\n  }\n});\n\n// node_modules/lodash/_customOmitClone.js\nvar require_customOmitClone = __commonJS({\n  \"node_modules/lodash/_customOmitClone.js\"(exports2, module2) {\n    var isPlainObject5 = require_isPlainObject();\n    function customOmitClone2(value) {\n      return isPlainObject5(value) ? void 0 : value;\n    }\n    module2.exports = customOmitClone2;\n  }\n});\n\n// node_modules/lodash/omit.js\nvar require_omit = __commonJS({\n  \"node_modules/lodash/omit.js\"(exports2, module2) {\n    var arrayMap2 = require_arrayMap();\n    var baseClone4 = require_baseClone();\n    var baseUnset2 = require_baseUnset();\n    var castPath2 = require_castPath();\n    var copyObject4 = require_copyObject();\n    var customOmitClone2 = require_customOmitClone();\n    var flatRest2 = require_flatRest();\n    var getAllKeysIn4 = require_getAllKeysIn();\n    var CLONE_DEEP_FLAG4 = 1;\n    var CLONE_FLAT_FLAG4 = 2;\n    var CLONE_SYMBOLS_FLAG4 = 4;\n    var omit3 = flatRest2(function(object, paths) {\n      var result = {};\n      if (object == null) {\n        return result;\n      }\n      var isDeep = false;\n      paths = arrayMap2(paths, function(path) {\n        path = castPath2(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n      });\n      copyObject4(object, getAllKeysIn4(object), result);\n      if (isDeep) {\n        result = baseClone4(result, CLONE_DEEP_FLAG4 | CLONE_FLAT_FLAG4 | CLONE_SYMBOLS_FLAG4, customOmitClone2);\n      }\n      var length = paths.length;\n      while (length--) {\n        baseUnset2(result, paths[length]);\n      }\n      return result;\n    });\n    module2.exports = omit3;\n  }\n});\n\n// node_modules/lodash/cloneDeep.js\nvar require_cloneDeep = __commonJS({\n  \"node_modules/lodash/cloneDeep.js\"(exports2, module2) {\n    var baseClone4 = require_baseClone();\n    var CLONE_DEEP_FLAG4 = 1;\n    var CLONE_SYMBOLS_FLAG4 = 4;\n    function cloneDeep5(value) {\n      return baseClone4(value, CLONE_DEEP_FLAG4 | CLONE_SYMBOLS_FLAG4);\n    }\n    module2.exports = cloneDeep5;\n  }\n});\n\n// node_modules/lodash/_setCacheAdd.js\nvar require_setCacheAdd = __commonJS({\n  \"node_modules/lodash/_setCacheAdd.js\"(exports2, module2) {\n    var HASH_UNDEFINED5 = \"__lodash_hash_undefined__\";\n    function setCacheAdd3(value) {\n      this.__data__.set(value, HASH_UNDEFINED5);\n      return this;\n    }\n    module2.exports = setCacheAdd3;\n  }\n});\n\n// node_modules/lodash/_setCacheHas.js\nvar require_setCacheHas = __commonJS({\n  \"node_modules/lodash/_setCacheHas.js\"(exports2, module2) {\n    function setCacheHas3(value) {\n      return this.__data__.has(value);\n    }\n    module2.exports = setCacheHas3;\n  }\n});\n\n// node_modules/lodash/_SetCache.js\nvar require_SetCache = __commonJS({\n  \"node_modules/lodash/_SetCache.js\"(exports2, module2) {\n    var MapCache5 = require_MapCache();\n    var setCacheAdd3 = require_setCacheAdd();\n    var setCacheHas3 = require_setCacheHas();\n    function SetCache3(values2) {\n      var index5 = -1, length = values2 == null ? 0 : values2.length;\n      this.__data__ = new MapCache5();\n      while (++index5 < length) {\n        this.add(values2[index5]);\n      }\n    }\n    SetCache3.prototype.add = SetCache3.prototype.push = setCacheAdd3;\n    SetCache3.prototype.has = setCacheHas3;\n    module2.exports = SetCache3;\n  }\n});\n\n// node_modules/lodash/_arraySome.js\nvar require_arraySome = __commonJS({\n  \"node_modules/lodash/_arraySome.js\"(exports2, module2) {\n    function arraySome2(array, predicate) {\n      var index5 = -1, length = array == null ? 0 : array.length;\n      while (++index5 < length) {\n        if (predicate(array[index5], index5, array)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    module2.exports = arraySome2;\n  }\n});\n\n// node_modules/lodash/_cacheHas.js\nvar require_cacheHas = __commonJS({\n  \"node_modules/lodash/_cacheHas.js\"(exports2, module2) {\n    function cacheHas2(cache2, key) {\n      return cache2.has(key);\n    }\n    module2.exports = cacheHas2;\n  }\n});\n\n// node_modules/lodash/_equalArrays.js\nvar require_equalArrays = __commonJS({\n  \"node_modules/lodash/_equalArrays.js\"(exports2, module2) {\n    var SetCache3 = require_SetCache();\n    var arraySome2 = require_arraySome();\n    var cacheHas2 = require_cacheHas();\n    var COMPARE_PARTIAL_FLAG2 = 1;\n    var COMPARE_UNORDERED_FLAG2 = 2;\n    function equalArrays2(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2, arrLength = array.length, othLength = other.length;\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      var arrStacked = stack.get(array);\n      var othStacked = stack.get(other);\n      if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n      }\n      var index5 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG2 ? new SetCache3() : void 0;\n      stack.set(array, other);\n      stack.set(other, array);\n      while (++index5 < arrLength) {\n        var arrValue = array[index5], othValue = other[index5];\n        if (customizer) {\n          var compared = isPartial ? customizer(othValue, arrValue, index5, other, array, stack) : customizer(arrValue, othValue, index5, array, other, stack);\n        }\n        if (compared !== void 0) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        if (seen) {\n          if (!arraySome2(other, function(othValue2, othIndex) {\n            if (!cacheHas2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n            result = false;\n            break;\n          }\n        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n          result = false;\n          break;\n        }\n      }\n      stack[\"delete\"](array);\n      stack[\"delete\"](other);\n      return result;\n    }\n    module2.exports = equalArrays2;\n  }\n});\n\n// node_modules/lodash/_mapToArray.js\nvar require_mapToArray = __commonJS({\n  \"node_modules/lodash/_mapToArray.js\"(exports2, module2) {\n    function mapToArray2(map2) {\n      var index5 = -1, result = Array(map2.size);\n      map2.forEach(function(value, key) {\n        result[++index5] = [key, value];\n      });\n      return result;\n    }\n    module2.exports = mapToArray2;\n  }\n});\n\n// node_modules/lodash/_setToArray.js\nvar require_setToArray = __commonJS({\n  \"node_modules/lodash/_setToArray.js\"(exports2, module2) {\n    function setToArray2(set4) {\n      var index5 = -1, result = Array(set4.size);\n      set4.forEach(function(value) {\n        result[++index5] = value;\n      });\n      return result;\n    }\n    module2.exports = setToArray2;\n  }\n});\n\n// node_modules/lodash/_equalByTag.js\nvar require_equalByTag = __commonJS({\n  \"node_modules/lodash/_equalByTag.js\"(exports2, module2) {\n    var Symbol4 = require_Symbol();\n    var Uint8Array6 = require_Uint8Array();\n    var eq5 = require_eq();\n    var equalArrays2 = require_equalArrays();\n    var mapToArray2 = require_mapToArray();\n    var setToArray2 = require_setToArray();\n    var COMPARE_PARTIAL_FLAG2 = 1;\n    var COMPARE_UNORDERED_FLAG2 = 2;\n    var boolTag4 = \"[object Boolean]\";\n    var dateTag4 = \"[object Date]\";\n    var errorTag4 = \"[object Error]\";\n    var mapTag5 = \"[object Map]\";\n    var numberTag4 = \"[object Number]\";\n    var regexpTag4 = \"[object RegExp]\";\n    var setTag5 = \"[object Set]\";\n    var stringTag4 = \"[object String]\";\n    var symbolTag4 = \"[object Symbol]\";\n    var arrayBufferTag4 = \"[object ArrayBuffer]\";\n    var dataViewTag5 = \"[object DataView]\";\n    var symbolProto5 = Symbol4 ? Symbol4.prototype : void 0;\n    var symbolValueOf5 = symbolProto5 ? symbolProto5.valueOf : void 0;\n    function equalByTag2(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag5:\n          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n        case arrayBufferTag4:\n          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array6(object), new Uint8Array6(other))) {\n            return false;\n          }\n          return true;\n        case boolTag4:\n        case dateTag4:\n        case numberTag4:\n          return eq5(+object, +other);\n        case errorTag4:\n          return object.name == other.name && object.message == other.message;\n        case regexpTag4:\n        case stringTag4:\n          return object == other + \"\";\n        case mapTag5:\n          var convert = mapToArray2;\n        case setTag5:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;\n          convert || (convert = setToArray2);\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG2;\n          stack.set(object, other);\n          var result = equalArrays2(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack[\"delete\"](object);\n          return result;\n        case symbolTag4:\n          if (symbolValueOf5) {\n            return symbolValueOf5.call(object) == symbolValueOf5.call(other);\n          }\n      }\n      return false;\n    }\n    module2.exports = equalByTag2;\n  }\n});\n\n// node_modules/lodash/_equalObjects.js\nvar require_equalObjects = __commonJS({\n  \"node_modules/lodash/_equalObjects.js\"(exports2, module2) {\n    var getAllKeys4 = require_getAllKeys();\n    var COMPARE_PARTIAL_FLAG2 = 1;\n    var objectProto5 = Object.prototype;\n    var hasOwnProperty6 = objectProto5.hasOwnProperty;\n    function equalObjects2(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2, objProps = getAllKeys4(object), objLength = objProps.length, othProps = getAllKeys4(other), othLength = othProps.length;\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index5 = objLength;\n      while (index5--) {\n        var key = objProps[index5];\n        if (!(isPartial ? key in other : hasOwnProperty6.call(other, key))) {\n          return false;\n        }\n      }\n      var objStacked = stack.get(object);\n      var othStacked = stack.get(other);\n      if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n      var skipCtor = isPartial;\n      while (++index5 < objLength) {\n        key = objProps[index5];\n        var objValue = object[key], othValue = other[key];\n        if (customizer) {\n          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n        }\n        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == \"constructor\");\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor, othCtor = other.constructor;\n        if (objCtor != othCtor && (\"constructor\" in object && \"constructor\" in other) && !(typeof objCtor == \"function\" && objCtor instanceof objCtor && typeof othCtor == \"function\" && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack[\"delete\"](object);\n      stack[\"delete\"](other);\n      return result;\n    }\n    module2.exports = equalObjects2;\n  }\n});\n\n// node_modules/lodash/_baseIsEqualDeep.js\nvar require_baseIsEqualDeep = __commonJS({\n  \"node_modules/lodash/_baseIsEqualDeep.js\"(exports2, module2) {\n    var Stack5 = require_Stack();\n    var equalArrays2 = require_equalArrays();\n    var equalByTag2 = require_equalByTag();\n    var equalObjects2 = require_equalObjects();\n    var getTag5 = require_getTag();\n    var isArray9 = require_isArray();\n    var isBuffer = require_isBuffer();\n    var isTypedArray5 = require_isTypedArray();\n    var COMPARE_PARTIAL_FLAG2 = 1;\n    var argsTag4 = \"[object Arguments]\";\n    var arrayTag4 = \"[object Array]\";\n    var objectTag4 = \"[object Object]\";\n    var objectProto5 = Object.prototype;\n    var hasOwnProperty6 = objectProto5.hasOwnProperty;\n    function baseIsEqualDeep2(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray9(object), othIsArr = isArray9(other), objTag = objIsArr ? arrayTag4 : getTag5(object), othTag = othIsArr ? arrayTag4 : getTag5(other);\n      objTag = objTag == argsTag4 ? objectTag4 : objTag;\n      othTag = othTag == argsTag4 ? objectTag4 : othTag;\n      var objIsObj = objTag == objectTag4, othIsObj = othTag == objectTag4, isSameTag = objTag == othTag;\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack5());\n        return objIsArr || isTypedArray5(object) ? equalArrays2(object, other, bitmask, customizer, equalFunc, stack) : equalByTag2(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG2)) {\n        var objIsWrapped = objIsObj && hasOwnProperty6.call(object, \"__wrapped__\"), othIsWrapped = othIsObj && hasOwnProperty6.call(other, \"__wrapped__\");\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;\n          stack || (stack = new Stack5());\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack5());\n      return equalObjects2(object, other, bitmask, customizer, equalFunc, stack);\n    }\n    module2.exports = baseIsEqualDeep2;\n  }\n});\n\n// node_modules/lodash/_baseIsEqual.js\nvar require_baseIsEqual = __commonJS({\n  \"node_modules/lodash/_baseIsEqual.js\"(exports2, module2) {\n    var baseIsEqualDeep2 = require_baseIsEqualDeep();\n    var isObjectLike5 = require_isObjectLike();\n    function baseIsEqual2(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || !isObjectLike5(value) && !isObjectLike5(other)) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep2(value, other, bitmask, customizer, baseIsEqual2, stack);\n    }\n    module2.exports = baseIsEqual2;\n  }\n});\n\n// node_modules/lodash/_baseIsMatch.js\nvar require_baseIsMatch = __commonJS({\n  \"node_modules/lodash/_baseIsMatch.js\"(exports2, module2) {\n    var Stack5 = require_Stack();\n    var baseIsEqual2 = require_baseIsEqual();\n    var COMPARE_PARTIAL_FLAG2 = 1;\n    var COMPARE_UNORDERED_FLAG2 = 2;\n    function baseIsMatch2(object, source, matchData, customizer) {\n      var index5 = matchData.length, length = index5, noCustomizer = !customizer;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index5--) {\n        var data = matchData[index5];\n        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n          return false;\n        }\n      }\n      while (++index5 < length) {\n        data = matchData[index5];\n        var key = data[0], objValue = object[key], srcValue = data[1];\n        if (noCustomizer && data[2]) {\n          if (objValue === void 0 && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack5();\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === void 0 ? baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG2 | COMPARE_UNORDERED_FLAG2, customizer, stack) : result)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    module2.exports = baseIsMatch2;\n  }\n});\n\n// node_modules/lodash/_isStrictComparable.js\nvar require_isStrictComparable = __commonJS({\n  \"node_modules/lodash/_isStrictComparable.js\"(exports2, module2) {\n    var isObject7 = require_isObject();\n    function isStrictComparable2(value) {\n      return value === value && !isObject7(value);\n    }\n    module2.exports = isStrictComparable2;\n  }\n});\n\n// node_modules/lodash/_getMatchData.js\nvar require_getMatchData = __commonJS({\n  \"node_modules/lodash/_getMatchData.js\"(exports2, module2) {\n    var isStrictComparable2 = require_isStrictComparable();\n    var keys4 = require_keys();\n    function getMatchData2(object) {\n      var result = keys4(object), length = result.length;\n      while (length--) {\n        var key = result[length], value = object[key];\n        result[length] = [key, value, isStrictComparable2(value)];\n      }\n      return result;\n    }\n    module2.exports = getMatchData2;\n  }\n});\n\n// node_modules/lodash/_matchesStrictComparable.js\nvar require_matchesStrictComparable = __commonJS({\n  \"node_modules/lodash/_matchesStrictComparable.js\"(exports2, module2) {\n    function matchesStrictComparable2(key, srcValue) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));\n      };\n    }\n    module2.exports = matchesStrictComparable2;\n  }\n});\n\n// node_modules/lodash/_baseMatches.js\nvar require_baseMatches = __commonJS({\n  \"node_modules/lodash/_baseMatches.js\"(exports2, module2) {\n    var baseIsMatch2 = require_baseIsMatch();\n    var getMatchData2 = require_getMatchData();\n    var matchesStrictComparable2 = require_matchesStrictComparable();\n    function baseMatches2(source) {\n      var matchData = getMatchData2(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable2(matchData[0][0], matchData[0][1]);\n      }\n      return function(object) {\n        return object === source || baseIsMatch2(object, source, matchData);\n      };\n    }\n    module2.exports = baseMatches2;\n  }\n});\n\n// node_modules/lodash/get.js\nvar require_get = __commonJS({\n  \"node_modules/lodash/get.js\"(exports2, module2) {\n    var baseGet2 = require_baseGet();\n    function get3(object, path, defaultValue) {\n      var result = object == null ? void 0 : baseGet2(object, path);\n      return result === void 0 ? defaultValue : result;\n    }\n    module2.exports = get3;\n  }\n});\n\n// node_modules/lodash/_baseMatchesProperty.js\nvar require_baseMatchesProperty = __commonJS({\n  \"node_modules/lodash/_baseMatchesProperty.js\"(exports2, module2) {\n    var baseIsEqual2 = require_baseIsEqual();\n    var get3 = require_get();\n    var hasIn2 = require_hasIn();\n    var isKey2 = require_isKey();\n    var isStrictComparable2 = require_isStrictComparable();\n    var matchesStrictComparable2 = require_matchesStrictComparable();\n    var toKey2 = require_toKey();\n    var COMPARE_PARTIAL_FLAG2 = 1;\n    var COMPARE_UNORDERED_FLAG2 = 2;\n    function baseMatchesProperty2(path, srcValue) {\n      if (isKey2(path) && isStrictComparable2(srcValue)) {\n        return matchesStrictComparable2(toKey2(path), srcValue);\n      }\n      return function(object) {\n        var objValue = get3(object, path);\n        return objValue === void 0 && objValue === srcValue ? hasIn2(object, path) : baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG2 | COMPARE_UNORDERED_FLAG2);\n      };\n    }\n    module2.exports = baseMatchesProperty2;\n  }\n});\n\n// node_modules/lodash/_baseProperty.js\nvar require_baseProperty = __commonJS({\n  \"node_modules/lodash/_baseProperty.js\"(exports2, module2) {\n    function baseProperty2(key) {\n      return function(object) {\n        return object == null ? void 0 : object[key];\n      };\n    }\n    module2.exports = baseProperty2;\n  }\n});\n\n// node_modules/lodash/_basePropertyDeep.js\nvar require_basePropertyDeep = __commonJS({\n  \"node_modules/lodash/_basePropertyDeep.js\"(exports2, module2) {\n    var baseGet2 = require_baseGet();\n    function basePropertyDeep2(path) {\n      return function(object) {\n        return baseGet2(object, path);\n      };\n    }\n    module2.exports = basePropertyDeep2;\n  }\n});\n\n// node_modules/lodash/property.js\nvar require_property = __commonJS({\n  \"node_modules/lodash/property.js\"(exports2, module2) {\n    var baseProperty2 = require_baseProperty();\n    var basePropertyDeep2 = require_basePropertyDeep();\n    var isKey2 = require_isKey();\n    var toKey2 = require_toKey();\n    function property2(path) {\n      return isKey2(path) ? baseProperty2(toKey2(path)) : basePropertyDeep2(path);\n    }\n    module2.exports = property2;\n  }\n});\n\n// node_modules/lodash/_baseIteratee.js\nvar require_baseIteratee = __commonJS({\n  \"node_modules/lodash/_baseIteratee.js\"(exports2, module2) {\n    var baseMatches2 = require_baseMatches();\n    var baseMatchesProperty2 = require_baseMatchesProperty();\n    var identity2 = require_identity();\n    var isArray9 = require_isArray();\n    var property2 = require_property();\n    function baseIteratee2(value) {\n      if (typeof value == \"function\") {\n        return value;\n      }\n      if (value == null) {\n        return identity2;\n      }\n      if (typeof value == \"object\") {\n        return isArray9(value) ? baseMatchesProperty2(value[0], value[1]) : baseMatches2(value);\n      }\n      return property2(value);\n    }\n    module2.exports = baseIteratee2;\n  }\n});\n\n// node_modules/lodash/_baseWhile.js\nvar require_baseWhile = __commonJS({\n  \"node_modules/lodash/_baseWhile.js\"(exports2, module2) {\n    var baseSlice2 = require_baseSlice();\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length, index5 = fromRight ? length : -1;\n      while ((fromRight ? index5-- : ++index5 < length) && predicate(array[index5], index5, array)) {\n      }\n      return isDrop ? baseSlice2(array, fromRight ? 0 : index5, fromRight ? index5 + 1 : length) : baseSlice2(array, fromRight ? index5 + 1 : 0, fromRight ? length : index5);\n    }\n    module2.exports = baseWhile;\n  }\n});\n\n// node_modules/lodash/dropRightWhile.js\nvar require_dropRightWhile = __commonJS({\n  \"node_modules/lodash/dropRightWhile.js\"(exports2, module2) {\n    var baseIteratee2 = require_baseIteratee();\n    var baseWhile = require_baseWhile();\n    function dropRightWhile2(array, predicate) {\n      return array && array.length ? baseWhile(array, baseIteratee2(predicate, 3), true, true) : [];\n    }\n    module2.exports = dropRightWhile2;\n  }\n});\n\n// node_modules/lodash/_baseRepeat.js\nvar require_baseRepeat = __commonJS({\n  \"node_modules/lodash/_baseRepeat.js\"(exports2, module2) {\n    var MAX_SAFE_INTEGER5 = 9007199254740991;\n    var nativeFloor = Math.floor;\n    function baseRepeat(string2, n8) {\n      var result = \"\";\n      if (!string2 || n8 < 1 || n8 > MAX_SAFE_INTEGER5) {\n        return result;\n      }\n      do {\n        if (n8 % 2) {\n          result += string2;\n        }\n        n8 = nativeFloor(n8 / 2);\n        if (n8) {\n          string2 += string2;\n        }\n      } while (n8);\n      return result;\n    }\n    module2.exports = baseRepeat;\n  }\n});\n\n// node_modules/lodash/_isIterateeCall.js\nvar require_isIterateeCall = __commonJS({\n  \"node_modules/lodash/_isIterateeCall.js\"(exports2, module2) {\n    var eq5 = require_eq();\n    var isArrayLike4 = require_isArrayLike();\n    var isIndex4 = require_isIndex();\n    var isObject7 = require_isObject();\n    function isIterateeCall2(value, index5, object) {\n      if (!isObject7(object)) {\n        return false;\n      }\n      var type = typeof index5;\n      if (type == \"number\" ? isArrayLike4(object) && isIndex4(index5, object.length) : type == \"string\" && index5 in object) {\n        return eq5(object[index5], value);\n      }\n      return false;\n    }\n    module2.exports = isIterateeCall2;\n  }\n});\n\n// node_modules/lodash/toFinite.js\nvar require_toFinite = __commonJS({\n  \"node_modules/lodash/toFinite.js\"(exports2, module2) {\n    var toNumber = require_toNumber();\n    var INFINITY3 = 1 / 0;\n    var MAX_INTEGER = 17976931348623157e292;\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY3 || value === -INFINITY3) {\n        var sign = value < 0 ? -1 : 1;\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n    module2.exports = toFinite;\n  }\n});\n\n// node_modules/lodash/toInteger.js\nvar require_toInteger = __commonJS({\n  \"node_modules/lodash/toInteger.js\"(exports2, module2) {\n    var toFinite = require_toFinite();\n    function toInteger(value) {\n      var result = toFinite(value), remainder = result % 1;\n      return result === result ? remainder ? result - remainder : result : 0;\n    }\n    module2.exports = toInteger;\n  }\n});\n\n// node_modules/lodash/repeat.js\nvar require_repeat = __commonJS({\n  \"node_modules/lodash/repeat.js\"(exports2, module2) {\n    var baseRepeat = require_baseRepeat();\n    var isIterateeCall2 = require_isIterateeCall();\n    var toInteger = require_toInteger();\n    var toString2 = require_toString();\n    function repeat4(string2, n8, guard) {\n      if (guard ? isIterateeCall2(string2, n8, guard) : n8 === void 0) {\n        n8 = 1;\n      } else {\n        n8 = toInteger(n8);\n      }\n      return baseRepeat(toString2(string2), n8);\n    }\n    module2.exports = repeat4;\n  }\n});\n\n// node_modules/unist-util-find/node_modules/unist-util-is/convert.js\nvar require_convert = __commonJS({\n  \"node_modules/unist-util-find/node_modules/unist-util-is/convert.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = convert;\n    function convert(test) {\n      if (typeof test === \"string\") {\n        return typeFactory(test);\n      }\n      if (test === null || test === void 0) {\n        return ok;\n      }\n      if (typeof test === \"object\") {\n        return (\"length\" in test ? anyFactory : matchesFactory)(test);\n      }\n      if (typeof test === \"function\") {\n        return test;\n      }\n      throw new Error(\"Expected function, string, or object as test\");\n    }\n    function convertAll(tests) {\n      var results = [];\n      var length = tests.length;\n      var index5 = -1;\n      while (++index5 < length) {\n        results[index5] = convert(tests[index5]);\n      }\n      return results;\n    }\n    function matchesFactory(test) {\n      return matches;\n      function matches(node) {\n        var key;\n        for (key in test) {\n          if (node[key] !== test[key]) {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n    function anyFactory(tests) {\n      var checks = convertAll(tests);\n      var length = checks.length;\n      return matches;\n      function matches() {\n        var index5 = -1;\n        while (++index5 < length) {\n          if (checks[index5].apply(this, arguments)) {\n            return true;\n          }\n        }\n        return false;\n      }\n    }\n    function typeFactory(test) {\n      return type;\n      function type(node) {\n        return Boolean(node && node.type === test);\n      }\n    }\n    function ok() {\n      return true;\n    }\n  }\n});\n\n// node_modules/unist-util-find/node_modules/unist-util-visit-parents/index.js\nvar require_unist_util_visit_parents = __commonJS({\n  \"node_modules/unist-util-find/node_modules/unist-util-visit-parents/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = visitParents;\n    var convert = require_convert();\n    var CONTINUE = true;\n    var SKIP = \"skip\";\n    var EXIT = false;\n    visitParents.CONTINUE = CONTINUE;\n    visitParents.SKIP = SKIP;\n    visitParents.EXIT = EXIT;\n    function visitParents(tree, test, visitor, reverse) {\n      var is4;\n      if (typeof test === \"function\" && typeof visitor !== \"function\") {\n        reverse = visitor;\n        visitor = test;\n        test = null;\n      }\n      is4 = convert(test);\n      one(tree, null, []);\n      function one(node, index5, parents2) {\n        var result = [];\n        var subresult;\n        if (!test || is4(node, index5, parents2[parents2.length - 1] || null)) {\n          result = toResult(visitor(node, parents2));\n          if (result[0] === EXIT) {\n            return result;\n          }\n        }\n        if (node.children && result[0] !== SKIP) {\n          subresult = toResult(all(node.children, parents2.concat(node)));\n          return subresult[0] === EXIT ? subresult : result;\n        }\n        return result;\n      }\n      function all(children, parents2) {\n        var min3 = -1;\n        var step = reverse ? -1 : 1;\n        var index5 = (reverse ? children.length : min3) + step;\n        var result;\n        while (index5 > min3 && index5 < children.length) {\n          result = one(children[index5], index5, parents2);\n          if (result[0] === EXIT) {\n            return result;\n          }\n          index5 = typeof result[1] === \"number\" ? result[1] : index5 + step;\n        }\n      }\n    }\n    function toResult(value) {\n      if (value !== null && typeof value === \"object\" && \"length\" in value) {\n        return value;\n      }\n      if (typeof value === \"number\") {\n        return [CONTINUE, value];\n      }\n      return [value];\n    }\n  }\n});\n\n// node_modules/unist-util-find/node_modules/unist-util-visit/index.js\nvar require_unist_util_visit = __commonJS({\n  \"node_modules/unist-util-find/node_modules/unist-util-visit/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = visit;\n    var visitParents = require_unist_util_visit_parents();\n    var CONTINUE = visitParents.CONTINUE;\n    var SKIP = visitParents.SKIP;\n    var EXIT = visitParents.EXIT;\n    visit.CONTINUE = CONTINUE;\n    visit.SKIP = SKIP;\n    visit.EXIT = EXIT;\n    function visit(tree, test, visitor, reverse) {\n      if (typeof test === \"function\" && typeof visitor !== \"function\") {\n        reverse = visitor;\n        visitor = test;\n        test = null;\n      }\n      visitParents(tree, test, overload, reverse);\n      function overload(node, parents2) {\n        var parent2 = parents2[parents2.length - 1];\n        var index5 = parent2 ? parent2.children.indexOf(node) : null;\n        return visitor(node, index5, parent2);\n      }\n    }\n  }\n});\n\n// node_modules/lodash.iteratee/index.js\nvar require_lodash2 = __commonJS({\n  \"node_modules/lodash.iteratee/index.js\"(exports2, module2) {\n    var LARGE_ARRAY_SIZE5 = 200;\n    var FUNC_ERROR_TEXT3 = \"Expected a function\";\n    var HASH_UNDEFINED5 = \"__lodash_hash_undefined__\";\n    var UNORDERED_COMPARE_FLAG = 1;\n    var PARTIAL_COMPARE_FLAG = 2;\n    var INFINITY3 = 1 / 0;\n    var MAX_SAFE_INTEGER5 = 9007199254740991;\n    var argsTag4 = \"[object Arguments]\";\n    var arrayTag4 = \"[object Array]\";\n    var boolTag4 = \"[object Boolean]\";\n    var dateTag4 = \"[object Date]\";\n    var errorTag4 = \"[object Error]\";\n    var funcTag5 = \"[object Function]\";\n    var genTag5 = \"[object GeneratorFunction]\";\n    var mapTag5 = \"[object Map]\";\n    var numberTag4 = \"[object Number]\";\n    var objectTag4 = \"[object Object]\";\n    var promiseTag5 = \"[object Promise]\";\n    var regexpTag4 = \"[object RegExp]\";\n    var setTag5 = \"[object Set]\";\n    var stringTag4 = \"[object String]\";\n    var symbolTag4 = \"[object Symbol]\";\n    var weakMapTag5 = \"[object WeakMap]\";\n    var arrayBufferTag4 = \"[object ArrayBuffer]\";\n    var dataViewTag5 = \"[object DataView]\";\n    var float32Tag5 = \"[object Float32Array]\";\n    var float64Tag5 = \"[object Float64Array]\";\n    var int8Tag5 = \"[object Int8Array]\";\n    var int16Tag5 = \"[object Int16Array]\";\n    var int32Tag5 = \"[object Int32Array]\";\n    var uint8Tag5 = \"[object Uint8Array]\";\n    var uint8ClampedTag5 = \"[object Uint8ClampedArray]\";\n    var uint16Tag5 = \"[object Uint16Array]\";\n    var uint32Tag5 = \"[object Uint32Array]\";\n    var reIsDeepProp2 = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\n    var reIsPlainProp2 = /^\\w*$/;\n    var reLeadingDot = /^\\./;\n    var rePropName3 = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n    var reRegExpChar5 = /[\\\\^$.*+?()[\\]{}|]/g;\n    var reEscapeChar3 = /\\\\(\\\\)?/g;\n    var reFlags4 = /\\w*$/;\n    var reIsHostCtor5 = /^\\[object .+?Constructor\\]$/;\n    var reIsUint4 = /^(?:0|[1-9]\\d*)$/;\n    var typedArrayTags5 = {};\n    typedArrayTags5[float32Tag5] = typedArrayTags5[float64Tag5] = typedArrayTags5[int8Tag5] = typedArrayTags5[int16Tag5] = typedArrayTags5[int32Tag5] = typedArrayTags5[uint8Tag5] = typedArrayTags5[uint8ClampedTag5] = typedArrayTags5[uint16Tag5] = typedArrayTags5[uint32Tag5] = true;\n    typedArrayTags5[argsTag4] = typedArrayTags5[arrayTag4] = typedArrayTags5[arrayBufferTag4] = typedArrayTags5[boolTag4] = typedArrayTags5[dataViewTag5] = typedArrayTags5[dateTag4] = typedArrayTags5[errorTag4] = typedArrayTags5[funcTag5] = typedArrayTags5[mapTag5] = typedArrayTags5[numberTag4] = typedArrayTags5[objectTag4] = typedArrayTags5[regexpTag4] = typedArrayTags5[setTag5] = typedArrayTags5[stringTag4] = typedArrayTags5[weakMapTag5] = false;\n    var cloneableTags4 = {};\n    cloneableTags4[argsTag4] = cloneableTags4[arrayTag4] = cloneableTags4[arrayBufferTag4] = cloneableTags4[dataViewTag5] = cloneableTags4[boolTag4] = cloneableTags4[dateTag4] = cloneableTags4[float32Tag5] = cloneableTags4[float64Tag5] = cloneableTags4[int8Tag5] = cloneableTags4[int16Tag5] = cloneableTags4[int32Tag5] = cloneableTags4[mapTag5] = cloneableTags4[numberTag4] = cloneableTags4[objectTag4] = cloneableTags4[regexpTag4] = cloneableTags4[setTag5] = cloneableTags4[stringTag4] = cloneableTags4[symbolTag4] = cloneableTags4[uint8Tag5] = cloneableTags4[uint8ClampedTag5] = cloneableTags4[uint16Tag5] = cloneableTags4[uint32Tag5] = true;\n    cloneableTags4[errorTag4] = cloneableTags4[funcTag5] = cloneableTags4[weakMapTag5] = false;\n    var freeGlobal5 = typeof global == \"object\" && global && global.Object === Object && global;\n    var freeSelf5 = typeof self == \"object\" && self && self.Object === Object && self;\n    var root5 = freeGlobal5 || freeSelf5 || Function(\"return this\")();\n    var freeExports = typeof exports2 == \"object\" && exports2 && !exports2.nodeType && exports2;\n    var freeModule = freeExports && typeof module2 == \"object\" && module2 && !module2.nodeType && module2;\n    var moduleExports = freeModule && freeModule.exports === freeExports;\n    var freeProcess = moduleExports && freeGlobal5.process;\n    var nodeUtil = function() {\n      try {\n        return freeProcess && freeProcess.binding(\"util\");\n      } catch (e4) {\n      }\n    }();\n    var nodeIsTypedArray5 = nodeUtil && nodeUtil.isTypedArray;\n    function addMapEntry(map2, pair) {\n      map2.set(pair[0], pair[1]);\n      return map2;\n    }\n    function addSetEntry(set4, value) {\n      set4.add(value);\n      return set4;\n    }\n    function arrayEach4(array, iteratee2) {\n      var index5 = -1, length = array ? array.length : 0;\n      while (++index5 < length) {\n        if (iteratee2(array[index5], index5, array) === false) {\n          break;\n        }\n      }\n      return array;\n    }\n    function arrayPush4(array, values2) {\n      var index5 = -1, length = values2.length, offset3 = array.length;\n      while (++index5 < length) {\n        array[offset3 + index5] = values2[index5];\n      }\n      return array;\n    }\n    function arrayReduce(array, iteratee2, accumulator, initAccum) {\n      var index5 = -1, length = array ? array.length : 0;\n      if (initAccum && length) {\n        accumulator = array[++index5];\n      }\n      while (++index5 < length) {\n        accumulator = iteratee2(accumulator, array[index5], index5, array);\n      }\n      return accumulator;\n    }\n    function arraySome2(array, predicate) {\n      var index5 = -1, length = array ? array.length : 0;\n      while (++index5 < length) {\n        if (predicate(array[index5], index5, array)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function baseProperty2(key) {\n      return function(object) {\n        return object == null ? void 0 : object[key];\n      };\n    }\n    function baseTimes4(n8, iteratee2) {\n      var index5 = -1, result = Array(n8);\n      while (++index5 < n8) {\n        result[index5] = iteratee2(index5);\n      }\n      return result;\n    }\n    function baseUnary5(func) {\n      return function(value) {\n        return func(value);\n      };\n    }\n    function getValue5(object, key) {\n      return object == null ? void 0 : object[key];\n    }\n    function isHostObject(value) {\n      var result = false;\n      if (value != null && typeof value.toString != \"function\") {\n        try {\n          result = !!(value + \"\");\n        } catch (e4) {\n        }\n      }\n      return result;\n    }\n    function mapToArray2(map2) {\n      var index5 = -1, result = Array(map2.size);\n      map2.forEach(function(value, key) {\n        result[++index5] = [key, value];\n      });\n      return result;\n    }\n    function overArg5(func, transform) {\n      return function(arg) {\n        return func(transform(arg));\n      };\n    }\n    function setToArray2(set4) {\n      var index5 = -1, result = Array(set4.size);\n      set4.forEach(function(value) {\n        result[++index5] = value;\n      });\n      return result;\n    }\n    var arrayProto5 = Array.prototype;\n    var funcProto5 = Function.prototype;\n    var objectProto5 = Object.prototype;\n    var coreJsData5 = root5[\"__core-js_shared__\"];\n    var maskSrcKey5 = function() {\n      var uid = /[^.]+$/.exec(coreJsData5 && coreJsData5.keys && coreJsData5.keys.IE_PROTO || \"\");\n      return uid ? \"Symbol(src)_1.\" + uid : \"\";\n    }();\n    var funcToString5 = funcProto5.toString;\n    var hasOwnProperty6 = objectProto5.hasOwnProperty;\n    var objectToString5 = objectProto5.toString;\n    var reIsNative5 = RegExp(\n      \"^\" + funcToString5.call(hasOwnProperty6).replace(reRegExpChar5, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n    );\n    var Buffer2 = moduleExports ? root5.Buffer : void 0;\n    var Symbol4 = root5.Symbol;\n    var Uint8Array6 = root5.Uint8Array;\n    var getPrototype4 = overArg5(Object.getPrototypeOf, Object);\n    var objectCreate4 = Object.create;\n    var propertyIsEnumerable5 = objectProto5.propertyIsEnumerable;\n    var splice5 = arrayProto5.splice;\n    var nativeGetSymbols4 = Object.getOwnPropertySymbols;\n    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;\n    var nativeKeys5 = overArg5(Object.keys, Object);\n    var DataView5 = getNative5(root5, \"DataView\");\n    var Map5 = getNative5(root5, \"Map\");\n    var Promise2 = getNative5(root5, \"Promise\");\n    var Set6 = getNative5(root5, \"Set\");\n    var WeakMap5 = getNative5(root5, \"WeakMap\");\n    var nativeCreate5 = getNative5(Object, \"create\");\n    var dataViewCtorString5 = toSource5(DataView5);\n    var mapCtorString5 = toSource5(Map5);\n    var promiseCtorString5 = toSource5(Promise2);\n    var setCtorString5 = toSource5(Set6);\n    var weakMapCtorString5 = toSource5(WeakMap5);\n    var symbolProto5 = Symbol4 ? Symbol4.prototype : void 0;\n    var symbolValueOf5 = symbolProto5 ? symbolProto5.valueOf : void 0;\n    var symbolToString3 = symbolProto5 ? symbolProto5.toString : void 0;\n    function Hash5(entries) {\n      var index5 = -1, length = entries ? entries.length : 0;\n      this.clear();\n      while (++index5 < length) {\n        var entry = entries[index5];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    function hashClear5() {\n      this.__data__ = nativeCreate5 ? nativeCreate5(null) : {};\n    }\n    function hashDelete5(key) {\n      return this.has(key) && delete this.__data__[key];\n    }\n    function hashGet5(key) {\n      var data = this.__data__;\n      if (nativeCreate5) {\n        var result = data[key];\n        return result === HASH_UNDEFINED5 ? void 0 : result;\n      }\n      return hasOwnProperty6.call(data, key) ? data[key] : void 0;\n    }\n    function hashHas5(key) {\n      var data = this.__data__;\n      return nativeCreate5 ? data[key] !== void 0 : hasOwnProperty6.call(data, key);\n    }\n    function hashSet5(key, value) {\n      var data = this.__data__;\n      data[key] = nativeCreate5 && value === void 0 ? HASH_UNDEFINED5 : value;\n      return this;\n    }\n    Hash5.prototype.clear = hashClear5;\n    Hash5.prototype[\"delete\"] = hashDelete5;\n    Hash5.prototype.get = hashGet5;\n    Hash5.prototype.has = hashHas5;\n    Hash5.prototype.set = hashSet5;\n    function ListCache5(entries) {\n      var index5 = -1, length = entries ? entries.length : 0;\n      this.clear();\n      while (++index5 < length) {\n        var entry = entries[index5];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    function listCacheClear5() {\n      this.__data__ = [];\n    }\n    function listCacheDelete5(key) {\n      var data = this.__data__, index5 = assocIndexOf5(data, key);\n      if (index5 < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index5 == lastIndex) {\n        data.pop();\n      } else {\n        splice5.call(data, index5, 1);\n      }\n      return true;\n    }\n    function listCacheGet5(key) {\n      var data = this.__data__, index5 = assocIndexOf5(data, key);\n      return index5 < 0 ? void 0 : data[index5][1];\n    }\n    function listCacheHas5(key) {\n      return assocIndexOf5(this.__data__, key) > -1;\n    }\n    function listCacheSet5(key, value) {\n      var data = this.__data__, index5 = assocIndexOf5(data, key);\n      if (index5 < 0) {\n        data.push([key, value]);\n      } else {\n        data[index5][1] = value;\n      }\n      return this;\n    }\n    ListCache5.prototype.clear = listCacheClear5;\n    ListCache5.prototype[\"delete\"] = listCacheDelete5;\n    ListCache5.prototype.get = listCacheGet5;\n    ListCache5.prototype.has = listCacheHas5;\n    ListCache5.prototype.set = listCacheSet5;\n    function MapCache5(entries) {\n      var index5 = -1, length = entries ? entries.length : 0;\n      this.clear();\n      while (++index5 < length) {\n        var entry = entries[index5];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    function mapCacheClear5() {\n      this.__data__ = {\n        \"hash\": new Hash5(),\n        \"map\": new (Map5 || ListCache5)(),\n        \"string\": new Hash5()\n      };\n    }\n    function mapCacheDelete5(key) {\n      return getMapData5(this, key)[\"delete\"](key);\n    }\n    function mapCacheGet5(key) {\n      return getMapData5(this, key).get(key);\n    }\n    function mapCacheHas5(key) {\n      return getMapData5(this, key).has(key);\n    }\n    function mapCacheSet5(key, value) {\n      getMapData5(this, key).set(key, value);\n      return this;\n    }\n    MapCache5.prototype.clear = mapCacheClear5;\n    MapCache5.prototype[\"delete\"] = mapCacheDelete5;\n    MapCache5.prototype.get = mapCacheGet5;\n    MapCache5.prototype.has = mapCacheHas5;\n    MapCache5.prototype.set = mapCacheSet5;\n    function SetCache3(values2) {\n      var index5 = -1, length = values2 ? values2.length : 0;\n      this.__data__ = new MapCache5();\n      while (++index5 < length) {\n        this.add(values2[index5]);\n      }\n    }\n    function setCacheAdd3(value) {\n      this.__data__.set(value, HASH_UNDEFINED5);\n      return this;\n    }\n    function setCacheHas3(value) {\n      return this.__data__.has(value);\n    }\n    SetCache3.prototype.add = SetCache3.prototype.push = setCacheAdd3;\n    SetCache3.prototype.has = setCacheHas3;\n    function Stack5(entries) {\n      this.__data__ = new ListCache5(entries);\n    }\n    function stackClear5() {\n      this.__data__ = new ListCache5();\n    }\n    function stackDelete5(key) {\n      return this.__data__[\"delete\"](key);\n    }\n    function stackGet5(key) {\n      return this.__data__.get(key);\n    }\n    function stackHas5(key) {\n      return this.__data__.has(key);\n    }\n    function stackSet5(key, value) {\n      var cache2 = this.__data__;\n      if (cache2 instanceof ListCache5) {\n        var pairs = cache2.__data__;\n        if (!Map5 || pairs.length < LARGE_ARRAY_SIZE5 - 1) {\n          pairs.push([key, value]);\n          return this;\n        }\n        cache2 = this.__data__ = new MapCache5(pairs);\n      }\n      cache2.set(key, value);\n      return this;\n    }\n    Stack5.prototype.clear = stackClear5;\n    Stack5.prototype[\"delete\"] = stackDelete5;\n    Stack5.prototype.get = stackGet5;\n    Stack5.prototype.has = stackHas5;\n    Stack5.prototype.set = stackSet5;\n    function arrayLikeKeys4(value, inherited) {\n      var result = isArray9(value) || isArguments5(value) ? baseTimes4(value.length, String) : [];\n      var length = result.length, skipIndexes = !!length;\n      for (var key in value) {\n        if ((inherited || hasOwnProperty6.call(value, key)) && !(skipIndexes && (key == \"length\" || isIndex4(key, length)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n    function assignValue4(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty6.call(object, key) && eq5(objValue, value)) || value === void 0 && !(key in object)) {\n        object[key] = value;\n      }\n    }\n    function assocIndexOf5(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq5(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n    function baseAssign4(object, source) {\n      return object && copyObject4(source, keys4(source), object);\n    }\n    function baseClone4(value, isDeep, isFull, customizer, key, object, stack) {\n      var result;\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== void 0) {\n        return result;\n      }\n      if (!isObject7(value)) {\n        return value;\n      }\n      var isArr = isArray9(value);\n      if (isArr) {\n        result = initCloneArray4(value);\n        if (!isDeep) {\n          return copyArray4(value, result);\n        }\n      } else {\n        var tag = getTag5(value), isFunc = tag == funcTag5 || tag == genTag5;\n        if (isBuffer(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag4 || tag == argsTag4 || isFunc && !object) {\n          if (isHostObject(value)) {\n            return object ? value : {};\n          }\n          result = initCloneObject4(isFunc ? {} : value);\n          if (!isDeep) {\n            return copySymbols4(value, baseAssign4(result, value));\n          }\n        } else {\n          if (!cloneableTags4[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag4(value, tag, baseClone4, isDeep);\n        }\n      }\n      stack || (stack = new Stack5());\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n      if (!isArr) {\n        var props = isFull ? getAllKeys4(value) : keys4(value);\n      }\n      arrayEach4(props || value, function(subValue, key2) {\n        if (props) {\n          key2 = subValue;\n          subValue = value[key2];\n        }\n        assignValue4(result, key2, baseClone4(subValue, isDeep, isFull, customizer, key2, value, stack));\n      });\n      return result;\n    }\n    function baseCreate4(proto) {\n      return isObject7(proto) ? objectCreate4(proto) : {};\n    }\n    function baseGet2(object, path) {\n      path = isKey2(path, object) ? [path] : castPath2(path);\n      var index5 = 0, length = path.length;\n      while (object != null && index5 < length) {\n        object = object[toKey2(path[index5++])];\n      }\n      return index5 && index5 == length ? object : void 0;\n    }\n    function baseGetAllKeys4(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray9(object) ? result : arrayPush4(result, symbolsFunc(object));\n    }\n    function baseGetTag5(value) {\n      return objectToString5.call(value);\n    }\n    function baseHasIn2(object, key) {\n      return object != null && key in Object(object);\n    }\n    function baseIsEqual2(value, other, customizer, bitmask, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || !isObject7(value) && !isObjectLike5(other)) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep2(value, other, baseIsEqual2, customizer, bitmask, stack);\n    }\n    function baseIsEqualDeep2(object, other, equalFunc, customizer, bitmask, stack) {\n      var objIsArr = isArray9(object), othIsArr = isArray9(other), objTag = arrayTag4, othTag = arrayTag4;\n      if (!objIsArr) {\n        objTag = getTag5(object);\n        objTag = objTag == argsTag4 ? objectTag4 : objTag;\n      }\n      if (!othIsArr) {\n        othTag = getTag5(other);\n        othTag = othTag == argsTag4 ? objectTag4 : othTag;\n      }\n      var objIsObj = objTag == objectTag4 && !isHostObject(object), othIsObj = othTag == objectTag4 && !isHostObject(other), isSameTag = objTag == othTag;\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack5());\n        return objIsArr || isTypedArray5(object) ? equalArrays2(object, other, equalFunc, customizer, bitmask, stack) : equalByTag2(object, other, objTag, equalFunc, customizer, bitmask, stack);\n      }\n      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty6.call(object, \"__wrapped__\"), othIsWrapped = othIsObj && hasOwnProperty6.call(other, \"__wrapped__\");\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;\n          stack || (stack = new Stack5());\n          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack5());\n      return equalObjects2(object, other, equalFunc, customizer, bitmask, stack);\n    }\n    function baseIsMatch2(object, source, matchData, customizer) {\n      var index5 = matchData.length, length = index5, noCustomizer = !customizer;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index5--) {\n        var data = matchData[index5];\n        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n          return false;\n        }\n      }\n      while (++index5 < length) {\n        data = matchData[index5];\n        var key = data[0], objValue = object[key], srcValue = data[1];\n        if (noCustomizer && data[2]) {\n          if (objValue === void 0 && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack5();\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === void 0 ? baseIsEqual2(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    function baseIsNative5(value) {\n      if (!isObject7(value) || isMasked5(value)) {\n        return false;\n      }\n      var pattern = isFunction6(value) || isHostObject(value) ? reIsNative5 : reIsHostCtor5;\n      return pattern.test(toSource5(value));\n    }\n    function baseIsTypedArray5(value) {\n      return isObjectLike5(value) && isLength5(value.length) && !!typedArrayTags5[objectToString5.call(value)];\n    }\n    function baseIteratee2(value) {\n      if (typeof value == \"function\") {\n        return value;\n      }\n      if (value == null) {\n        return identity2;\n      }\n      if (typeof value == \"object\") {\n        return isArray9(value) ? baseMatchesProperty2(value[0], value[1]) : baseMatches2(value);\n      }\n      return property2(value);\n    }\n    function baseKeys4(object) {\n      if (!isPrototype4(object)) {\n        return nativeKeys5(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty6.call(object, key) && key != \"constructor\") {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n    function baseMatches2(source) {\n      var matchData = getMatchData2(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable2(matchData[0][0], matchData[0][1]);\n      }\n      return function(object) {\n        return object === source || baseIsMatch2(object, source, matchData);\n      };\n    }\n    function baseMatchesProperty2(path, srcValue) {\n      if (isKey2(path) && isStrictComparable2(srcValue)) {\n        return matchesStrictComparable2(toKey2(path), srcValue);\n      }\n      return function(object) {\n        var objValue = get3(object, path);\n        return objValue === void 0 && objValue === srcValue ? hasIn2(object, path) : baseIsEqual2(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\n      };\n    }\n    function basePropertyDeep2(path) {\n      return function(object) {\n        return baseGet2(object, path);\n      };\n    }\n    function baseToString2(value) {\n      if (typeof value == \"string\") {\n        return value;\n      }\n      if (isSymbol2(value)) {\n        return symbolToString3 ? symbolToString3.call(value) : \"\";\n      }\n      var result = value + \"\";\n      return result == \"0\" && 1 / value == -INFINITY3 ? \"-0\" : result;\n    }\n    function castPath2(value) {\n      return isArray9(value) ? value : stringToPath3(value);\n    }\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var result = new buffer.constructor(buffer.length);\n      buffer.copy(result);\n      return result;\n    }\n    function cloneArrayBuffer4(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array6(result).set(new Uint8Array6(arrayBuffer));\n      return result;\n    }\n    function cloneDataView4(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer4(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n    function cloneMap(map2, isDeep, cloneFunc) {\n      var array = isDeep ? cloneFunc(mapToArray2(map2), true) : mapToArray2(map2);\n      return arrayReduce(array, addMapEntry, new map2.constructor());\n    }\n    function cloneRegExp4(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags4.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n    function cloneSet(set4, isDeep, cloneFunc) {\n      var array = isDeep ? cloneFunc(setToArray2(set4), true) : setToArray2(set4);\n      return arrayReduce(array, addSetEntry, new set4.constructor());\n    }\n    function cloneSymbol4(symbol) {\n      return symbolValueOf5 ? Object(symbolValueOf5.call(symbol)) : {};\n    }\n    function cloneTypedArray4(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer4(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n    function copyArray4(source, array) {\n      var index5 = -1, length = source.length;\n      array || (array = Array(length));\n      while (++index5 < length) {\n        array[index5] = source[index5];\n      }\n      return array;\n    }\n    function copyObject4(source, props, object, customizer) {\n      object || (object = {});\n      var index5 = -1, length = props.length;\n      while (++index5 < length) {\n        var key = props[index5];\n        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;\n        assignValue4(object, key, newValue === void 0 ? source[key] : newValue);\n      }\n      return object;\n    }\n    function copySymbols4(source, object) {\n      return copyObject4(source, getSymbols4(source), object);\n    }\n    function equalArrays2(array, other, equalFunc, customizer, bitmask, stack) {\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      var stacked = stack.get(array);\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n      var index5 = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache3() : void 0;\n      stack.set(array, other);\n      stack.set(other, array);\n      while (++index5 < arrLength) {\n        var arrValue = array[index5], othValue = other[index5];\n        if (customizer) {\n          var compared = isPartial ? customizer(othValue, arrValue, index5, other, array, stack) : customizer(arrValue, othValue, index5, array, other, stack);\n        }\n        if (compared !== void 0) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        if (seen) {\n          if (!arraySome2(other, function(othValue2, othIndex) {\n            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {\n              return seen.add(othIndex);\n            }\n          })) {\n            result = false;\n            break;\n          }\n        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n          result = false;\n          break;\n        }\n      }\n      stack[\"delete\"](array);\n      stack[\"delete\"](other);\n      return result;\n    }\n    function equalByTag2(object, other, tag, equalFunc, customizer, bitmask, stack) {\n      switch (tag) {\n        case dataViewTag5:\n          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n        case arrayBufferTag4:\n          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array6(object), new Uint8Array6(other))) {\n            return false;\n          }\n          return true;\n        case boolTag4:\n        case dateTag4:\n        case numberTag4:\n          return eq5(+object, +other);\n        case errorTag4:\n          return object.name == other.name && object.message == other.message;\n        case regexpTag4:\n        case stringTag4:\n          return object == other + \"\";\n        case mapTag5:\n          var convert = mapToArray2;\n        case setTag5:\n          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n          convert || (convert = setToArray2);\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= UNORDERED_COMPARE_FLAG;\n          stack.set(object, other);\n          var result = equalArrays2(convert(object), convert(other), equalFunc, customizer, bitmask, stack);\n          stack[\"delete\"](object);\n          return result;\n        case symbolTag4:\n          if (symbolValueOf5) {\n            return symbolValueOf5.call(object) == symbolValueOf5.call(other);\n          }\n      }\n      return false;\n    }\n    function equalObjects2(object, other, equalFunc, customizer, bitmask, stack) {\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys4(object), objLength = objProps.length, othProps = keys4(other), othLength = othProps.length;\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index5 = objLength;\n      while (index5--) {\n        var key = objProps[index5];\n        if (!(isPartial ? key in other : hasOwnProperty6.call(other, key))) {\n          return false;\n        }\n      }\n      var stacked = stack.get(object);\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n      var skipCtor = isPartial;\n      while (++index5 < objLength) {\n        key = objProps[index5];\n        var objValue = object[key], othValue = other[key];\n        if (customizer) {\n          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n        }\n        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == \"constructor\");\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor, othCtor = other.constructor;\n        if (objCtor != othCtor && (\"constructor\" in object && \"constructor\" in other) && !(typeof objCtor == \"function\" && objCtor instanceof objCtor && typeof othCtor == \"function\" && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack[\"delete\"](object);\n      stack[\"delete\"](other);\n      return result;\n    }\n    function getAllKeys4(object) {\n      return baseGetAllKeys4(object, keys4, getSymbols4);\n    }\n    function getMapData5(map2, key) {\n      var data = map2.__data__;\n      return isKeyable5(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n    }\n    function getMatchData2(object) {\n      var result = keys4(object), length = result.length;\n      while (length--) {\n        var key = result[length], value = object[key];\n        result[length] = [key, value, isStrictComparable2(value)];\n      }\n      return result;\n    }\n    function getNative5(object, key) {\n      var value = getValue5(object, key);\n      return baseIsNative5(value) ? value : void 0;\n    }\n    var getSymbols4 = nativeGetSymbols4 ? overArg5(nativeGetSymbols4, Object) : stubArray4;\n    var getTag5 = baseGetTag5;\n    if (DataView5 && getTag5(new DataView5(new ArrayBuffer(1))) != dataViewTag5 || Map5 && getTag5(new Map5()) != mapTag5 || Promise2 && getTag5(Promise2.resolve()) != promiseTag5 || Set6 && getTag5(new Set6()) != setTag5 || WeakMap5 && getTag5(new WeakMap5()) != weakMapTag5) {\n      getTag5 = function(value) {\n        var result = objectToString5.call(value), Ctor = result == objectTag4 ? value.constructor : void 0, ctorString = Ctor ? toSource5(Ctor) : void 0;\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString5:\n              return dataViewTag5;\n            case mapCtorString5:\n              return mapTag5;\n            case promiseCtorString5:\n              return promiseTag5;\n            case setCtorString5:\n              return setTag5;\n            case weakMapCtorString5:\n              return weakMapTag5;\n          }\n        }\n        return result;\n      };\n    }\n    function hasPath2(object, path, hasFunc) {\n      path = isKey2(path, object) ? [path] : castPath2(path);\n      var result, index5 = -1, length = path.length;\n      while (++index5 < length) {\n        var key = toKey2(path[index5]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result) {\n        return result;\n      }\n      var length = object ? object.length : 0;\n      return !!length && isLength5(length) && isIndex4(key, length) && (isArray9(object) || isArguments5(object));\n    }\n    function initCloneArray4(array) {\n      var length = array.length, result = array.constructor(length);\n      if (length && typeof array[0] == \"string\" && hasOwnProperty6.call(array, \"index\")) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n    function initCloneObject4(object) {\n      return typeof object.constructor == \"function\" && !isPrototype4(object) ? baseCreate4(getPrototype4(object)) : {};\n    }\n    function initCloneByTag4(object, tag, cloneFunc, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag4:\n          return cloneArrayBuffer4(object);\n        case boolTag4:\n        case dateTag4:\n          return new Ctor(+object);\n        case dataViewTag5:\n          return cloneDataView4(object, isDeep);\n        case float32Tag5:\n        case float64Tag5:\n        case int8Tag5:\n        case int16Tag5:\n        case int32Tag5:\n        case uint8Tag5:\n        case uint8ClampedTag5:\n        case uint16Tag5:\n        case uint32Tag5:\n          return cloneTypedArray4(object, isDeep);\n        case mapTag5:\n          return cloneMap(object, isDeep, cloneFunc);\n        case numberTag4:\n        case stringTag4:\n          return new Ctor(object);\n        case regexpTag4:\n          return cloneRegExp4(object);\n        case setTag5:\n          return cloneSet(object, isDeep, cloneFunc);\n        case symbolTag4:\n          return cloneSymbol4(object);\n      }\n    }\n    function isIndex4(value, length) {\n      length = length == null ? MAX_SAFE_INTEGER5 : length;\n      return !!length && (typeof value == \"number\" || reIsUint4.test(value)) && (value > -1 && value % 1 == 0 && value < length);\n    }\n    function isKey2(value, object) {\n      if (isArray9(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == \"number\" || type == \"symbol\" || type == \"boolean\" || value == null || isSymbol2(value)) {\n        return true;\n      }\n      return reIsPlainProp2.test(value) || !reIsDeepProp2.test(value) || object != null && value in Object(object);\n    }\n    function isKeyable5(value) {\n      var type = typeof value;\n      return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n    }\n    function isMasked5(func) {\n      return !!maskSrcKey5 && maskSrcKey5 in func;\n    }\n    function isPrototype4(value) {\n      var Ctor = value && value.constructor, proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto5;\n      return value === proto;\n    }\n    function isStrictComparable2(value) {\n      return value === value && !isObject7(value);\n    }\n    function matchesStrictComparable2(key, srcValue) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));\n      };\n    }\n    var stringToPath3 = memoize4(function(string2) {\n      string2 = toString2(string2);\n      var result = [];\n      if (reLeadingDot.test(string2)) {\n        result.push(\"\");\n      }\n      string2.replace(rePropName3, function(match2, number, quote, string3) {\n        result.push(quote ? string3.replace(reEscapeChar3, \"$1\") : number || match2);\n      });\n      return result;\n    });\n    function toKey2(value) {\n      if (typeof value == \"string\" || isSymbol2(value)) {\n        return value;\n      }\n      var result = value + \"\";\n      return result == \"0\" && 1 / value == -INFINITY3 ? \"-0\" : result;\n    }\n    function toSource5(func) {\n      if (func != null) {\n        try {\n          return funcToString5.call(func);\n        } catch (e4) {\n        }\n        try {\n          return func + \"\";\n        } catch (e4) {\n        }\n      }\n      return \"\";\n    }\n    function memoize4(func, resolver) {\n      if (typeof func != \"function\" || resolver && typeof resolver != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT3);\n      }\n      var memoized = function() {\n        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;\n        if (cache2.has(key)) {\n          return cache2.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache2.set(key, result);\n        return result;\n      };\n      memoized.cache = new (memoize4.Cache || MapCache5)();\n      return memoized;\n    }\n    memoize4.Cache = MapCache5;\n    function eq5(value, other) {\n      return value === other || value !== value && other !== other;\n    }\n    function isArguments5(value) {\n      return isArrayLikeObject2(value) && hasOwnProperty6.call(value, \"callee\") && (!propertyIsEnumerable5.call(value, \"callee\") || objectToString5.call(value) == argsTag4);\n    }\n    var isArray9 = Array.isArray;\n    function isArrayLike4(value) {\n      return value != null && isLength5(value.length) && !isFunction6(value);\n    }\n    function isArrayLikeObject2(value) {\n      return isObjectLike5(value) && isArrayLike4(value);\n    }\n    var isBuffer = nativeIsBuffer || stubFalse5;\n    function isFunction6(value) {\n      var tag = isObject7(value) ? objectToString5.call(value) : \"\";\n      return tag == funcTag5 || tag == genTag5;\n    }\n    function isLength5(value) {\n      return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER5;\n    }\n    function isObject7(value) {\n      var type = typeof value;\n      return !!value && (type == \"object\" || type == \"function\");\n    }\n    function isObjectLike5(value) {\n      return !!value && typeof value == \"object\";\n    }\n    function isSymbol2(value) {\n      return typeof value == \"symbol\" || isObjectLike5(value) && objectToString5.call(value) == symbolTag4;\n    }\n    var isTypedArray5 = nodeIsTypedArray5 ? baseUnary5(nodeIsTypedArray5) : baseIsTypedArray5;\n    function toString2(value) {\n      return value == null ? \"\" : baseToString2(value);\n    }\n    function get3(object, path, defaultValue) {\n      var result = object == null ? void 0 : baseGet2(object, path);\n      return result === void 0 ? defaultValue : result;\n    }\n    function hasIn2(object, path) {\n      return object != null && hasPath2(object, path, baseHasIn2);\n    }\n    function keys4(object) {\n      return isArrayLike4(object) ? arrayLikeKeys4(object) : baseKeys4(object);\n    }\n    function identity2(value) {\n      return value;\n    }\n    function iteratee(func) {\n      return baseIteratee2(typeof func == \"function\" ? func : baseClone4(func, true));\n    }\n    function property2(path) {\n      return isKey2(path) ? baseProperty2(toKey2(path)) : basePropertyDeep2(path);\n    }\n    function stubArray4() {\n      return [];\n    }\n    function stubFalse5() {\n      return false;\n    }\n    module2.exports = iteratee;\n  }\n});\n\n// node_modules/unist-util-find/index.js\nvar require_unist_util_find = __commonJS({\n  \"node_modules/unist-util-find/index.js\"(exports2, module2) {\n    \"use strict\";\n    var visit = require_unist_util_visit();\n    var iteratee = require_lodash2();\n    function find2(tree, condition) {\n      if (!tree)\n        throw new Error(\"unist-find requires a tree to search\");\n      if (!condition)\n        throw new Error(\"unist-find requires a condition\");\n      var predicate = iteratee(condition);\n      var result;\n      visit(tree, function(node) {\n        if (predicate(node)) {\n          result = node;\n          return false;\n        }\n      });\n      return result;\n    }\n    module2.exports = find2;\n  }\n});\n\n// node_modules/react-is/cjs/react-is.development.js\nvar require_react_is_development = __commonJS({\n  \"node_modules/react-is/cjs/react-is.development.js\"(exports2) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        var hasSymbol = typeof Symbol === \"function\" && Symbol.for;\n        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for(\"react.element\") : 60103;\n        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for(\"react.portal\") : 60106;\n        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for(\"react.fragment\") : 60107;\n        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for(\"react.strict_mode\") : 60108;\n        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for(\"react.profiler\") : 60114;\n        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for(\"react.provider\") : 60109;\n        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for(\"react.context\") : 60110;\n        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for(\"react.async_mode\") : 60111;\n        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for(\"react.concurrent_mode\") : 60111;\n        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for(\"react.forward_ref\") : 60112;\n        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for(\"react.suspense\") : 60113;\n        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for(\"react.suspense_list\") : 60120;\n        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for(\"react.memo\") : 60115;\n        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for(\"react.lazy\") : 60116;\n        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for(\"react.block\") : 60121;\n        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for(\"react.fundamental\") : 60117;\n        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for(\"react.responder\") : 60118;\n        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for(\"react.scope\") : 60119;\n        function isValidElementType(type) {\n          return typeof type === \"string\" || typeof type === \"function\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === \"object\" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n        }\n        function typeOf(object) {\n          if (typeof object === \"object\" && object !== null) {\n            var $$typeof = object.$$typeof;\n            switch ($$typeof) {\n              case REACT_ELEMENT_TYPE:\n                var type = object.type;\n                switch (type) {\n                  case REACT_ASYNC_MODE_TYPE:\n                  case REACT_CONCURRENT_MODE_TYPE:\n                  case REACT_FRAGMENT_TYPE:\n                  case REACT_PROFILER_TYPE:\n                  case REACT_STRICT_MODE_TYPE:\n                  case REACT_SUSPENSE_TYPE:\n                    return type;\n                  default:\n                    var $$typeofType = type && type.$$typeof;\n                    switch ($$typeofType) {\n                      case REACT_CONTEXT_TYPE:\n                      case REACT_FORWARD_REF_TYPE:\n                      case REACT_LAZY_TYPE:\n                      case REACT_MEMO_TYPE:\n                      case REACT_PROVIDER_TYPE:\n                        return $$typeofType;\n                      default:\n                        return $$typeof;\n                    }\n                }\n              case REACT_PORTAL_TYPE:\n                return $$typeof;\n            }\n          }\n          return void 0;\n        }\n        var AsyncMode = REACT_ASYNC_MODE_TYPE;\n        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\n        var ContextConsumer = REACT_CONTEXT_TYPE;\n        var ContextProvider = REACT_PROVIDER_TYPE;\n        var Element4 = REACT_ELEMENT_TYPE;\n        var ForwardRef = REACT_FORWARD_REF_TYPE;\n        var Fragment3 = REACT_FRAGMENT_TYPE;\n        var Lazy = REACT_LAZY_TYPE;\n        var Memo = REACT_MEMO_TYPE;\n        var Portal = REACT_PORTAL_TYPE;\n        var Profiler = REACT_PROFILER_TYPE;\n        var StrictMode = REACT_STRICT_MODE_TYPE;\n        var Suspense = REACT_SUSPENSE_TYPE;\n        var hasWarnedAboutDeprecatedIsAsyncMode = false;\n        function isAsyncMode(object) {\n          {\n            if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n              hasWarnedAboutDeprecatedIsAsyncMode = true;\n              console[\"warn\"](\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.\");\n            }\n          }\n          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n        }\n        function isConcurrentMode(object) {\n          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n        }\n        function isContextConsumer(object) {\n          return typeOf(object) === REACT_CONTEXT_TYPE;\n        }\n        function isContextProvider(object) {\n          return typeOf(object) === REACT_PROVIDER_TYPE;\n        }\n        function isElement7(object) {\n          return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n        }\n        function isForwardRef2(object) {\n          return typeOf(object) === REACT_FORWARD_REF_TYPE;\n        }\n        function isFragment(object) {\n          return typeOf(object) === REACT_FRAGMENT_TYPE;\n        }\n        function isLazy(object) {\n          return typeOf(object) === REACT_LAZY_TYPE;\n        }\n        function isMemo(object) {\n          return typeOf(object) === REACT_MEMO_TYPE;\n        }\n        function isPortal(object) {\n          return typeOf(object) === REACT_PORTAL_TYPE;\n        }\n        function isProfiler(object) {\n          return typeOf(object) === REACT_PROFILER_TYPE;\n        }\n        function isStrictMode(object) {\n          return typeOf(object) === REACT_STRICT_MODE_TYPE;\n        }\n        function isSuspense(object) {\n          return typeOf(object) === REACT_SUSPENSE_TYPE;\n        }\n        exports2.AsyncMode = AsyncMode;\n        exports2.ConcurrentMode = ConcurrentMode;\n        exports2.ContextConsumer = ContextConsumer;\n        exports2.ContextProvider = ContextProvider;\n        exports2.Element = Element4;\n        exports2.ForwardRef = ForwardRef;\n        exports2.Fragment = Fragment3;\n        exports2.Lazy = Lazy;\n        exports2.Memo = Memo;\n        exports2.Portal = Portal;\n        exports2.Profiler = Profiler;\n        exports2.StrictMode = StrictMode;\n        exports2.Suspense = Suspense;\n        exports2.isAsyncMode = isAsyncMode;\n        exports2.isConcurrentMode = isConcurrentMode;\n        exports2.isContextConsumer = isContextConsumer;\n        exports2.isContextProvider = isContextProvider;\n        exports2.isElement = isElement7;\n        exports2.isForwardRef = isForwardRef2;\n        exports2.isFragment = isFragment;\n        exports2.isLazy = isLazy;\n        exports2.isMemo = isMemo;\n        exports2.isPortal = isPortal;\n        exports2.isProfiler = isProfiler;\n        exports2.isStrictMode = isStrictMode;\n        exports2.isSuspense = isSuspense;\n        exports2.isValidElementType = isValidElementType;\n        exports2.typeOf = typeOf;\n      })();\n    }\n  }\n});\n\n// node_modules/react-is/index.js\nvar require_react_is = __commonJS({\n  \"node_modules/react-is/index.js\"(exports2, module2) {\n    \"use strict\";\n    if (false) {\n      module2.exports = null;\n    } else {\n      module2.exports = require_react_is_development();\n    }\n  }\n});\n\n// node_modules/shallowequal/index.js\nvar require_shallowequal = __commonJS({\n  \"node_modules/shallowequal/index.js\"(exports2, module2) {\n    module2.exports = function shallowEqual2(objA, objB, compare, compareContext) {\n      var ret = compare ? compare.call(compareContext, objA, objB) : void 0;\n      if (ret !== void 0) {\n        return !!ret;\n      }\n      if (objA === objB) {\n        return true;\n      }\n      if (typeof objA !== \"object\" || !objA || typeof objB !== \"object\" || !objB) {\n        return false;\n      }\n      var keysA = Object.keys(objA);\n      var keysB = Object.keys(objB);\n      if (keysA.length !== keysB.length) {\n        return false;\n      }\n      var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);\n      for (var idx = 0; idx < keysA.length; idx++) {\n        var key = keysA[idx];\n        if (!bHasOwnProperty(key)) {\n          return false;\n        }\n        var valueA = objA[key];\n        var valueB = objB[key];\n        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;\n        if (ret === false || ret === void 0 && valueA !== valueB) {\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n});\n\n// node_modules/@emotion/stylis/dist/stylis.browser.cjs.js\nvar require_stylis_browser_cjs = __commonJS({\n  \"node_modules/@emotion/stylis/dist/stylis.browser.cjs.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    function stylis_min(W3) {\n      function M2(d4, c5, e4, h4, a7) {\n        for (var m4 = 0, b4 = 0, v4 = 0, n8 = 0, q2, g4, x4 = 0, K = 0, k3, u5 = k3 = q2 = 0, l6 = 0, r7 = 0, I2 = 0, t6 = 0, B3 = e4.length, J = B3 - 1, y5, f5 = \"\", p6 = \"\", F3 = \"\", G3 = \"\", C3; l6 < B3; ) {\n          g4 = e4.charCodeAt(l6);\n          l6 === J && 0 !== b4 + n8 + v4 + m4 && (0 !== b4 && (g4 = 47 === b4 ? 10 : 47), n8 = v4 = m4 = 0, B3++, J++);\n          if (0 === b4 + n8 + v4 + m4) {\n            if (l6 === J && (0 < r7 && (f5 = f5.replace(N2, \"\")), 0 < f5.trim().length)) {\n              switch (g4) {\n                case 32:\n                case 9:\n                case 59:\n                case 13:\n                case 10:\n                  break;\n                default:\n                  f5 += e4.charAt(l6);\n              }\n              g4 = 59;\n            }\n            switch (g4) {\n              case 123:\n                f5 = f5.trim();\n                q2 = f5.charCodeAt(0);\n                k3 = 1;\n                for (t6 = ++l6; l6 < B3; ) {\n                  switch (g4 = e4.charCodeAt(l6)) {\n                    case 123:\n                      k3++;\n                      break;\n                    case 125:\n                      k3--;\n                      break;\n                    case 47:\n                      switch (g4 = e4.charCodeAt(l6 + 1)) {\n                        case 42:\n                        case 47:\n                          a: {\n                            for (u5 = l6 + 1; u5 < J; ++u5) {\n                              switch (e4.charCodeAt(u5)) {\n                                case 47:\n                                  if (42 === g4 && 42 === e4.charCodeAt(u5 - 1) && l6 + 2 !== u5) {\n                                    l6 = u5 + 1;\n                                    break a;\n                                  }\n                                  break;\n                                case 10:\n                                  if (47 === g4) {\n                                    l6 = u5 + 1;\n                                    break a;\n                                  }\n                              }\n                            }\n                            l6 = u5;\n                          }\n                      }\n                      break;\n                    case 91:\n                      g4++;\n                    case 40:\n                      g4++;\n                    case 34:\n                    case 39:\n                      for (; l6++ < J && e4.charCodeAt(l6) !== g4; ) {\n                      }\n                  }\n                  if (0 === k3)\n                    break;\n                  l6++;\n                }\n                k3 = e4.substring(t6, l6);\n                0 === q2 && (q2 = (f5 = f5.replace(ca, \"\").trim()).charCodeAt(0));\n                switch (q2) {\n                  case 64:\n                    0 < r7 && (f5 = f5.replace(N2, \"\"));\n                    g4 = f5.charCodeAt(1);\n                    switch (g4) {\n                      case 100:\n                      case 109:\n                      case 115:\n                      case 45:\n                        r7 = c5;\n                        break;\n                      default:\n                        r7 = O4;\n                    }\n                    k3 = M2(c5, r7, k3, g4, a7 + 1);\n                    t6 = k3.length;\n                    0 < A2 && (r7 = X2(O4, f5, I2), C3 = H3(3, k3, r7, c5, D4, z3, t6, g4, a7, h4), f5 = r7.join(\"\"), void 0 !== C3 && 0 === (t6 = (k3 = C3.trim()).length) && (g4 = 0, k3 = \"\"));\n                    if (0 < t6)\n                      switch (g4) {\n                        case 115:\n                          f5 = f5.replace(da, ea);\n                        case 100:\n                        case 109:\n                        case 45:\n                          k3 = f5 + \"{\" + k3 + \"}\";\n                          break;\n                        case 107:\n                          f5 = f5.replace(fa, \"$1 $2\");\n                          k3 = f5 + \"{\" + k3 + \"}\";\n                          k3 = 1 === w4 || 2 === w4 && L4(\"@\" + k3, 3) ? \"@-webkit-\" + k3 + \"@\" + k3 : \"@\" + k3;\n                          break;\n                        default:\n                          k3 = f5 + k3, 112 === h4 && (k3 = (p6 += k3, \"\"));\n                      }\n                    else\n                      k3 = \"\";\n                    break;\n                  default:\n                    k3 = M2(c5, X2(c5, f5, I2), k3, h4, a7 + 1);\n                }\n                F3 += k3;\n                k3 = I2 = r7 = u5 = q2 = 0;\n                f5 = \"\";\n                g4 = e4.charCodeAt(++l6);\n                break;\n              case 125:\n              case 59:\n                f5 = (0 < r7 ? f5.replace(N2, \"\") : f5).trim();\n                if (1 < (t6 = f5.length))\n                  switch (0 === u5 && (q2 = f5.charCodeAt(0), 45 === q2 || 96 < q2 && 123 > q2) && (t6 = (f5 = f5.replace(\" \", \":\")).length), 0 < A2 && void 0 !== (C3 = H3(1, f5, c5, d4, D4, z3, p6.length, h4, a7, h4)) && 0 === (t6 = (f5 = C3.trim()).length) && (f5 = \"\\0\\0\"), q2 = f5.charCodeAt(0), g4 = f5.charCodeAt(1), q2) {\n                    case 0:\n                      break;\n                    case 64:\n                      if (105 === g4 || 99 === g4) {\n                        G3 += f5 + e4.charAt(l6);\n                        break;\n                      }\n                    default:\n                      58 !== f5.charCodeAt(t6 - 1) && (p6 += P3(f5, q2, g4, f5.charCodeAt(2)));\n                  }\n                I2 = r7 = u5 = q2 = 0;\n                f5 = \"\";\n                g4 = e4.charCodeAt(++l6);\n            }\n          }\n          switch (g4) {\n            case 13:\n            case 10:\n              47 === b4 ? b4 = 0 : 0 === 1 + q2 && 107 !== h4 && 0 < f5.length && (r7 = 1, f5 += \"\\0\");\n              0 < A2 * Y2 && H3(0, f5, c5, d4, D4, z3, p6.length, h4, a7, h4);\n              z3 = 1;\n              D4++;\n              break;\n            case 59:\n            case 125:\n              if (0 === b4 + n8 + v4 + m4) {\n                z3++;\n                break;\n              }\n            default:\n              z3++;\n              y5 = e4.charAt(l6);\n              switch (g4) {\n                case 9:\n                case 32:\n                  if (0 === n8 + m4 + b4)\n                    switch (x4) {\n                      case 44:\n                      case 58:\n                      case 9:\n                      case 32:\n                        y5 = \"\";\n                        break;\n                      default:\n                        32 !== g4 && (y5 = \" \");\n                    }\n                  break;\n                case 0:\n                  y5 = \"\\\\0\";\n                  break;\n                case 12:\n                  y5 = \"\\\\f\";\n                  break;\n                case 11:\n                  y5 = \"\\\\v\";\n                  break;\n                case 38:\n                  0 === n8 + b4 + m4 && (r7 = I2 = 1, y5 = \"\\f\" + y5);\n                  break;\n                case 108:\n                  if (0 === n8 + b4 + m4 + E4 && 0 < u5)\n                    switch (l6 - u5) {\n                      case 2:\n                        112 === x4 && 58 === e4.charCodeAt(l6 - 3) && (E4 = x4);\n                      case 8:\n                        111 === K && (E4 = K);\n                    }\n                  break;\n                case 58:\n                  0 === n8 + b4 + m4 && (u5 = l6);\n                  break;\n                case 44:\n                  0 === b4 + v4 + n8 + m4 && (r7 = 1, y5 += \"\\r\");\n                  break;\n                case 34:\n                case 39:\n                  0 === b4 && (n8 = n8 === g4 ? 0 : 0 === n8 ? g4 : n8);\n                  break;\n                case 91:\n                  0 === n8 + b4 + v4 && m4++;\n                  break;\n                case 93:\n                  0 === n8 + b4 + v4 && m4--;\n                  break;\n                case 41:\n                  0 === n8 + b4 + m4 && v4--;\n                  break;\n                case 40:\n                  if (0 === n8 + b4 + m4) {\n                    if (0 === q2)\n                      switch (2 * x4 + 3 * K) {\n                        case 533:\n                          break;\n                        default:\n                          q2 = 1;\n                      }\n                    v4++;\n                  }\n                  break;\n                case 64:\n                  0 === b4 + v4 + n8 + m4 + u5 + k3 && (k3 = 1);\n                  break;\n                case 42:\n                case 47:\n                  if (!(0 < n8 + m4 + v4))\n                    switch (b4) {\n                      case 0:\n                        switch (2 * g4 + 3 * e4.charCodeAt(l6 + 1)) {\n                          case 235:\n                            b4 = 47;\n                            break;\n                          case 220:\n                            t6 = l6, b4 = 42;\n                        }\n                        break;\n                      case 42:\n                        47 === g4 && 42 === x4 && t6 + 2 !== l6 && (33 === e4.charCodeAt(t6 + 2) && (p6 += e4.substring(t6, l6 + 1)), y5 = \"\", b4 = 0);\n                    }\n              }\n              0 === b4 && (f5 += y5);\n          }\n          K = x4;\n          x4 = g4;\n          l6++;\n        }\n        t6 = p6.length;\n        if (0 < t6) {\n          r7 = c5;\n          if (0 < A2 && (C3 = H3(2, p6, r7, d4, D4, z3, t6, h4, a7, h4), void 0 !== C3 && 0 === (p6 = C3).length))\n            return G3 + p6 + F3;\n          p6 = r7.join(\",\") + \"{\" + p6 + \"}\";\n          if (0 !== w4 * E4) {\n            2 !== w4 || L4(p6, 2) || (E4 = 0);\n            switch (E4) {\n              case 111:\n                p6 = p6.replace(ha, \":-moz-$1\") + p6;\n                break;\n              case 112:\n                p6 = p6.replace(Q2, \"::-webkit-input-$1\") + p6.replace(Q2, \"::-moz-$1\") + p6.replace(Q2, \":-ms-input-$1\") + p6;\n            }\n            E4 = 0;\n          }\n        }\n        return G3 + p6 + F3;\n      }\n      function X2(d4, c5, e4) {\n        var h4 = c5.trim().split(ia);\n        c5 = h4;\n        var a7 = h4.length, m4 = d4.length;\n        switch (m4) {\n          case 0:\n          case 1:\n            var b4 = 0;\n            for (d4 = 0 === m4 ? \"\" : d4[0] + \" \"; b4 < a7; ++b4) {\n              c5[b4] = Z2(d4, c5[b4], e4).trim();\n            }\n            break;\n          default:\n            var v4 = b4 = 0;\n            for (c5 = []; b4 < a7; ++b4) {\n              for (var n8 = 0; n8 < m4; ++n8) {\n                c5[v4++] = Z2(d4[n8] + \" \", h4[b4], e4).trim();\n              }\n            }\n        }\n        return c5;\n      }\n      function Z2(d4, c5, e4) {\n        var h4 = c5.charCodeAt(0);\n        33 > h4 && (h4 = (c5 = c5.trim()).charCodeAt(0));\n        switch (h4) {\n          case 38:\n            return c5.replace(F2, \"$1\" + d4.trim());\n          case 58:\n            return d4.trim() + c5.replace(F2, \"$1\" + d4.trim());\n          default:\n            if (0 < 1 * e4 && 0 < c5.indexOf(\"\\f\"))\n              return c5.replace(F2, (58 === d4.charCodeAt(0) ? \"\" : \"$1\") + d4.trim());\n        }\n        return d4 + c5;\n      }\n      function P3(d4, c5, e4, h4) {\n        var a7 = d4 + \";\", m4 = 2 * c5 + 3 * e4 + 4 * h4;\n        if (944 === m4) {\n          d4 = a7.indexOf(\":\", 9) + 1;\n          var b4 = a7.substring(d4, a7.length - 1).trim();\n          b4 = a7.substring(0, d4).trim() + b4 + \";\";\n          return 1 === w4 || 2 === w4 && L4(b4, 1) ? \"-webkit-\" + b4 + b4 : b4;\n        }\n        if (0 === w4 || 2 === w4 && !L4(a7, 1))\n          return a7;\n        switch (m4) {\n          case 1015:\n            return 97 === a7.charCodeAt(10) ? \"-webkit-\" + a7 + a7 : a7;\n          case 951:\n            return 116 === a7.charCodeAt(3) ? \"-webkit-\" + a7 + a7 : a7;\n          case 963:\n            return 110 === a7.charCodeAt(5) ? \"-webkit-\" + a7 + a7 : a7;\n          case 1009:\n            if (100 !== a7.charCodeAt(4))\n              break;\n          case 969:\n          case 942:\n            return \"-webkit-\" + a7 + a7;\n          case 978:\n            return \"-webkit-\" + a7 + \"-moz-\" + a7 + a7;\n          case 1019:\n          case 983:\n            return \"-webkit-\" + a7 + \"-moz-\" + a7 + \"-ms-\" + a7 + a7;\n          case 883:\n            if (45 === a7.charCodeAt(8))\n              return \"-webkit-\" + a7 + a7;\n            if (0 < a7.indexOf(\"image-set(\", 11))\n              return a7.replace(ja, \"$1-webkit-$2\") + a7;\n            break;\n          case 932:\n            if (45 === a7.charCodeAt(4))\n              switch (a7.charCodeAt(5)) {\n                case 103:\n                  return \"-webkit-box-\" + a7.replace(\"-grow\", \"\") + \"-webkit-\" + a7 + \"-ms-\" + a7.replace(\"grow\", \"positive\") + a7;\n                case 115:\n                  return \"-webkit-\" + a7 + \"-ms-\" + a7.replace(\"shrink\", \"negative\") + a7;\n                case 98:\n                  return \"-webkit-\" + a7 + \"-ms-\" + a7.replace(\"basis\", \"preferred-size\") + a7;\n              }\n            return \"-webkit-\" + a7 + \"-ms-\" + a7 + a7;\n          case 964:\n            return \"-webkit-\" + a7 + \"-ms-flex-\" + a7 + a7;\n          case 1023:\n            if (99 !== a7.charCodeAt(8))\n              break;\n            b4 = a7.substring(a7.indexOf(\":\", 15)).replace(\"flex-\", \"\").replace(\"space-between\", \"justify\");\n            return \"-webkit-box-pack\" + b4 + \"-webkit-\" + a7 + \"-ms-flex-pack\" + b4 + a7;\n          case 1005:\n            return ka.test(a7) ? a7.replace(aa, \":-webkit-\") + a7.replace(aa, \":-moz-\") + a7 : a7;\n          case 1e3:\n            b4 = a7.substring(13).trim();\n            c5 = b4.indexOf(\"-\") + 1;\n            switch (b4.charCodeAt(0) + b4.charCodeAt(c5)) {\n              case 226:\n                b4 = a7.replace(G2, \"tb\");\n                break;\n              case 232:\n                b4 = a7.replace(G2, \"tb-rl\");\n                break;\n              case 220:\n                b4 = a7.replace(G2, \"lr\");\n                break;\n              default:\n                return a7;\n            }\n            return \"-webkit-\" + a7 + \"-ms-\" + b4 + a7;\n          case 1017:\n            if (-1 === a7.indexOf(\"sticky\", 9))\n              break;\n          case 975:\n            c5 = (a7 = d4).length - 10;\n            b4 = (33 === a7.charCodeAt(c5) ? a7.substring(0, c5) : a7).substring(d4.indexOf(\":\", 7) + 1).trim();\n            switch (m4 = b4.charCodeAt(0) + (b4.charCodeAt(7) | 0)) {\n              case 203:\n                if (111 > b4.charCodeAt(8))\n                  break;\n              case 115:\n                a7 = a7.replace(b4, \"-webkit-\" + b4) + \";\" + a7;\n                break;\n              case 207:\n              case 102:\n                a7 = a7.replace(b4, \"-webkit-\" + (102 < m4 ? \"inline-\" : \"\") + \"box\") + \";\" + a7.replace(b4, \"-webkit-\" + b4) + \";\" + a7.replace(b4, \"-ms-\" + b4 + \"box\") + \";\" + a7;\n            }\n            return a7 + \";\";\n          case 938:\n            if (45 === a7.charCodeAt(5))\n              switch (a7.charCodeAt(6)) {\n                case 105:\n                  return b4 = a7.replace(\"-items\", \"\"), \"-webkit-\" + a7 + \"-webkit-box-\" + b4 + \"-ms-flex-\" + b4 + a7;\n                case 115:\n                  return \"-webkit-\" + a7 + \"-ms-flex-item-\" + a7.replace(ba, \"\") + a7;\n                default:\n                  return \"-webkit-\" + a7 + \"-ms-flex-line-pack\" + a7.replace(\"align-content\", \"\").replace(ba, \"\") + a7;\n              }\n            break;\n          case 973:\n          case 989:\n            if (45 !== a7.charCodeAt(3) || 122 === a7.charCodeAt(4))\n              break;\n          case 931:\n          case 953:\n            if (true === la.test(d4))\n              return 115 === (b4 = d4.substring(d4.indexOf(\":\") + 1)).charCodeAt(0) ? P3(d4.replace(\"stretch\", \"fill-available\"), c5, e4, h4).replace(\":fill-available\", \":stretch\") : a7.replace(b4, \"-webkit-\" + b4) + a7.replace(b4, \"-moz-\" + b4.replace(\"fill-\", \"\")) + a7;\n            break;\n          case 962:\n            if (a7 = \"-webkit-\" + a7 + (102 === a7.charCodeAt(5) ? \"-ms-\" + a7 : \"\") + a7, 211 === e4 + h4 && 105 === a7.charCodeAt(13) && 0 < a7.indexOf(\"transform\", 10))\n              return a7.substring(0, a7.indexOf(\";\", 27) + 1).replace(ma, \"$1-webkit-$2\") + a7;\n        }\n        return a7;\n      }\n      function L4(d4, c5) {\n        var e4 = d4.indexOf(1 === c5 ? \":\" : \"{\"), h4 = d4.substring(0, 3 !== c5 ? e4 : 10);\n        e4 = d4.substring(e4 + 1, d4.length - 1);\n        return R3(2 !== c5 ? h4 : h4.replace(na, \"$1\"), e4, c5);\n      }\n      function ea(d4, c5) {\n        var e4 = P3(c5, c5.charCodeAt(0), c5.charCodeAt(1), c5.charCodeAt(2));\n        return e4 !== c5 + \";\" ? e4.replace(oa, \" or ($1)\").substring(4) : \"(\" + c5 + \")\";\n      }\n      function H3(d4, c5, e4, h4, a7, m4, b4, v4, n8, q2) {\n        for (var g4 = 0, x4 = c5, w5; g4 < A2; ++g4) {\n          switch (w5 = S3[g4].call(B2, d4, x4, e4, h4, a7, m4, b4, v4, n8, q2)) {\n            case void 0:\n            case false:\n            case true:\n            case null:\n              break;\n            default:\n              x4 = w5;\n          }\n        }\n        if (x4 !== c5)\n          return x4;\n      }\n      function T3(d4) {\n        switch (d4) {\n          case void 0:\n          case null:\n            A2 = S3.length = 0;\n            break;\n          default:\n            if (\"function\" === typeof d4)\n              S3[A2++] = d4;\n            else if (\"object\" === typeof d4)\n              for (var c5 = 0, e4 = d4.length; c5 < e4; ++c5) {\n                T3(d4[c5]);\n              }\n            else\n              Y2 = !!d4 | 0;\n        }\n        return T3;\n      }\n      function U2(d4) {\n        d4 = d4.prefix;\n        void 0 !== d4 && (R3 = null, d4 ? \"function\" !== typeof d4 ? w4 = 1 : (w4 = 2, R3 = d4) : w4 = 0);\n        return U2;\n      }\n      function B2(d4, c5) {\n        var e4 = d4;\n        33 > e4.charCodeAt(0) && (e4 = e4.trim());\n        V2 = e4;\n        e4 = [V2];\n        if (0 < A2) {\n          var h4 = H3(-1, c5, e4, e4, D4, z3, 0, 0, 0, 0);\n          void 0 !== h4 && \"string\" === typeof h4 && (c5 = h4);\n        }\n        var a7 = M2(O4, e4, c5, 0, 0);\n        0 < A2 && (h4 = H3(-2, a7, e4, e4, D4, z3, a7.length, 0, 0, 0), void 0 !== h4 && (a7 = h4));\n        V2 = \"\";\n        E4 = 0;\n        z3 = D4 = 1;\n        return a7;\n      }\n      var ca = /^\\0+/g, N2 = /[\\0\\r\\f]/g, aa = /: */g, ka = /zoo|gra/, ma = /([,: ])(transform)/g, ia = /,\\r+?/g, F2 = /([\\t\\r\\n ])*\\f?&/g, fa = /@(k\\w+)\\s*(\\S*)\\s*/, Q2 = /::(place)/g, ha = /:(read-only)/g, G2 = /[svh]\\w+-[tblr]{2}/, da = /\\(\\s*(.*)\\s*\\)/g, oa = /([\\s\\S]*?);/g, ba = /-self|flex-/g, na = /[^]*?(:[rp][el]a[\\w-]+)[^]*/, la = /stretch|:\\s*\\w+\\-(?:conte|avail)/, ja = /([^-])(image-set\\()/, z3 = 1, D4 = 1, E4 = 0, w4 = 1, O4 = [], S3 = [], A2 = 0, R3 = null, Y2 = 0, V2 = \"\";\n      B2.use = T3;\n      B2.set = U2;\n      void 0 !== W3 && U2(W3);\n      return B2;\n    }\n    exports2.default = stylis_min;\n  }\n});\n\n// node_modules/@emotion/unitless/dist/unitless.browser.cjs.js\nvar require_unitless_browser_cjs = __commonJS({\n  \"node_modules/@emotion/unitless/dist/unitless.browser.cjs.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var unitlessKeys = {\n      animationIterationCount: 1,\n      borderImageOutset: 1,\n      borderImageSlice: 1,\n      borderImageWidth: 1,\n      boxFlex: 1,\n      boxFlexGroup: 1,\n      boxOrdinalGroup: 1,\n      columnCount: 1,\n      columns: 1,\n      flex: 1,\n      flexGrow: 1,\n      flexPositive: 1,\n      flexShrink: 1,\n      flexNegative: 1,\n      flexOrder: 1,\n      gridRow: 1,\n      gridRowEnd: 1,\n      gridRowSpan: 1,\n      gridRowStart: 1,\n      gridColumn: 1,\n      gridColumnEnd: 1,\n      gridColumnSpan: 1,\n      gridColumnStart: 1,\n      msGridRow: 1,\n      msGridRowSpan: 1,\n      msGridColumn: 1,\n      msGridColumnSpan: 1,\n      fontWeight: 1,\n      lineHeight: 1,\n      opacity: 1,\n      order: 1,\n      orphans: 1,\n      tabSize: 1,\n      widows: 1,\n      zIndex: 1,\n      zoom: 1,\n      WebkitLineClamp: 1,\n      // SVG-related properties\n      fillOpacity: 1,\n      floodOpacity: 1,\n      stopOpacity: 1,\n      strokeDasharray: 1,\n      strokeDashoffset: 1,\n      strokeMiterlimit: 1,\n      strokeOpacity: 1,\n      strokeWidth: 1\n    };\n    exports2.default = unitlessKeys;\n  }\n});\n\n// node_modules/@emotion/memoize/dist/memoize.browser.cjs.js\nvar require_memoize_browser_cjs = __commonJS({\n  \"node_modules/@emotion/memoize/dist/memoize.browser.cjs.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    function memoize4(fn4) {\n      var cache2 = {};\n      return function(arg) {\n        if (cache2[arg] === void 0)\n          cache2[arg] = fn4(arg);\n        return cache2[arg];\n      };\n    }\n    exports2.default = memoize4;\n  }\n});\n\n// node_modules/styled-components/node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.browser.cjs.js\nvar require_emotion_is_prop_valid_browser_cjs = __commonJS({\n  \"node_modules/styled-components/node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.browser.cjs.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var memoize4 = require_memoize_browser_cjs();\n    function _interopDefault(e4) {\n      return e4 && e4.__esModule ? e4 : { \"default\": e4 };\n    }\n    var memoize__default = /* @__PURE__ */ _interopDefault(memoize4);\n    var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;\n    var isPropValid = /* @__PURE__ */ memoize__default[\"default\"](\n      function(prop) {\n        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;\n      }\n      /* Z+1 */\n    );\n    exports2.default = isPropValid;\n  }\n});\n\n// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\nvar require_hoist_non_react_statics_cjs = __commonJS({\n  \"node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\"(exports2, module2) {\n    \"use strict\";\n    var reactIs = require_react_is();\n    var REACT_STATICS = {\n      childContextTypes: true,\n      contextType: true,\n      contextTypes: true,\n      defaultProps: true,\n      displayName: true,\n      getDefaultProps: true,\n      getDerivedStateFromError: true,\n      getDerivedStateFromProps: true,\n      mixins: true,\n      propTypes: true,\n      type: true\n    };\n    var KNOWN_STATICS = {\n      name: true,\n      length: true,\n      prototype: true,\n      caller: true,\n      callee: true,\n      arguments: true,\n      arity: true\n    };\n    var FORWARD_REF_STATICS = {\n      \"$$typeof\": true,\n      render: true,\n      defaultProps: true,\n      displayName: true,\n      propTypes: true\n    };\n    var MEMO_STATICS = {\n      \"$$typeof\": true,\n      compare: true,\n      defaultProps: true,\n      displayName: true,\n      propTypes: true,\n      type: true\n    };\n    var TYPE_STATICS = {};\n    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;\n    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;\n    function getStatics(component) {\n      if (reactIs.isMemo(component)) {\n        return MEMO_STATICS;\n      }\n      return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\n    }\n    var defineProperty5 = Object.defineProperty;\n    var getOwnPropertyNames = Object.getOwnPropertyNames;\n    var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    var getPrototypeOf = Object.getPrototypeOf;\n    var objectPrototype = Object.prototype;\n    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n      if (typeof sourceComponent !== \"string\") {\n        if (objectPrototype) {\n          var inheritedComponent = getPrototypeOf(sourceComponent);\n          if (inheritedComponent && inheritedComponent !== objectPrototype) {\n            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n          }\n        }\n        var keys4 = getOwnPropertyNames(sourceComponent);\n        if (getOwnPropertySymbols) {\n          keys4 = keys4.concat(getOwnPropertySymbols(sourceComponent));\n        }\n        var targetStatics = getStatics(targetComponent);\n        var sourceStatics = getStatics(sourceComponent);\n        for (var i5 = 0; i5 < keys4.length; ++i5) {\n          var key = keys4[i5];\n          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n            try {\n              defineProperty5(targetComponent, key, descriptor);\n            } catch (e4) {\n            }\n          }\n        }\n      }\n      return targetComponent;\n    }\n    module2.exports = hoistNonReactStatics;\n  }\n});\n\n// node_modules/styled-components/dist/styled-components.browser.cjs.js\nvar require_styled_components_browser_cjs = __commonJS({\n  \"node_modules/styled-components/dist/styled-components.browser.cjs.js\"(exports2) {\n    \"use strict\";\n    function e4(e5) {\n      return e5 && \"object\" == typeof e5 && \"default\" in e5 ? e5.default : e5;\n    }\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var t6 = require_react_is();\n    var n8 = require(\"react\");\n    var r7 = e4(n8);\n    var o7 = e4(require_shallowequal());\n    var s5 = e4(require_stylis_browser_cjs());\n    var i5 = e4(require_unitless_browser_cjs());\n    var a7 = e4(require_emotion_is_prop_valid_browser_cjs());\n    var u5 = e4(require_hoist_non_react_statics_cjs());\n    function c5() {\n      return (c5 = Object.assign || function(e5) {\n        for (var t7 = 1; t7 < arguments.length; t7++) {\n          var n9 = arguments[t7];\n          for (var r8 in n9)\n            Object.prototype.hasOwnProperty.call(n9, r8) && (e5[r8] = n9[r8]);\n        }\n        return e5;\n      }).apply(this, arguments);\n    }\n    var l6 = function(e5, t7) {\n      for (var n9 = [e5[0]], r8 = 0, o8 = t7.length; r8 < o8; r8 += 1)\n        n9.push(t7[r8], e5[r8 + 1]);\n      return n9;\n    };\n    var d4 = function(e5) {\n      return null !== e5 && \"object\" == typeof e5 && \"[object Object]\" === (e5.toString ? e5.toString() : Object.prototype.toString.call(e5)) && !t6.typeOf(e5);\n    };\n    var h4 = Object.freeze([]);\n    var p6 = Object.freeze({});\n    function f5(e5) {\n      return \"function\" == typeof e5;\n    }\n    function m4(e5) {\n      return \"string\" == typeof e5 && e5 || e5.displayName || e5.name || \"Component\";\n    }\n    function y5(e5) {\n      return e5 && \"string\" == typeof e5.styledComponentId;\n    }\n    var v4 = \"undefined\" != typeof process && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || \"data-styled\";\n    var g4 = \"undefined\" != typeof window && \"HTMLElement\" in window;\n    var S3 = Boolean(\"boolean\" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : \"undefined\" != typeof process && void 0 !== process.env.REACT_APP_SC_DISABLE_SPEEDY && \"\" !== process.env.REACT_APP_SC_DISABLE_SPEEDY ? \"false\" !== process.env.REACT_APP_SC_DISABLE_SPEEDY && process.env.REACT_APP_SC_DISABLE_SPEEDY : \"undefined\" != typeof process && void 0 !== process.env.SC_DISABLE_SPEEDY && \"\" !== process.env.SC_DISABLE_SPEEDY ? \"false\" !== process.env.SC_DISABLE_SPEEDY && process.env.SC_DISABLE_SPEEDY : true);\n    var w4 = {};\n    var E4 = true ? { 1: \"Cannot create styled-component for component: %s.\\n\\n\", 2: \"Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\\n\\n- Are you trying to reuse it across renders?\\n- Are you accidentally calling collectStyles twice?\\n\\n\", 3: \"Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\\n\\n\", 4: \"The `StyleSheetManager` expects a valid target or sheet prop!\\n\\n- Does this error occur on the client and is your target falsy?\\n- Does this error occur on the server and is the sheet falsy?\\n\\n\", 5: \"The clone method cannot be used on the client!\\n\\n- Are you running in a client-like environment on the server?\\n- Are you trying to run SSR on the client?\\n\\n\", 6: \"Trying to insert a new style tag, but the given Node is unmounted!\\n\\n- Are you using a custom target that isn't mounted?\\n- Does your document not have a valid head element?\\n- Have you accidentally removed a style tag manually?\\n\\n\", 7: 'ThemeProvider: Please return an object from your \"theme\" prop function, e.g.\\n\\n```js\\ntheme={() => ({})}\\n```\\n\\n', 8: 'ThemeProvider: Please make your \"theme\" prop an object.\\n\\n', 9: \"Missing document `<head>`\\n\\n\", 10: \"Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\\n\\n\", 11: \"_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\\n\\n\", 12: \"It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\\\`\\\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\\n\\n\", 13: \"%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\\n\\n\", 14: 'ThemeProvider: \"theme\" prop is required.\\n\\n', 15: \"A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\\n\\n```js\\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\\n```\\n\\n\", 16: \"Reached the limit of how many styled components may be created at group %s.\\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\\nas for instance in your render method then you may be running into this limitation.\\n\\n\", 17: \"CSSStyleSheet could not be found on HTMLStyleElement.\\nHas styled-components' style tag been unmounted or altered by another script?\\n\" } : {};\n    function b4() {\n      for (var e5 = arguments.length <= 0 ? void 0 : arguments[0], t7 = [], n9 = 1, r8 = arguments.length; n9 < r8; n9 += 1)\n        t7.push(n9 < 0 || arguments.length <= n9 ? void 0 : arguments[n9]);\n      return t7.forEach(function(t8) {\n        e5 = e5.replace(/%[a-z]/, t8);\n      }), e5;\n    }\n    function _2(e5) {\n      for (var t7 = arguments.length, n9 = new Array(t7 > 1 ? t7 - 1 : 0), r8 = 1; r8 < t7; r8++)\n        n9[r8 - 1] = arguments[r8];\n      throw false ? new Error(\"An error occurred. See https://git.io/JUIaE#\" + e5 + \" for more information.\" + (n9.length > 0 ? \" Args: \" + n9.join(\", \") : \"\")) : new Error(b4.apply(void 0, [E4[e5]].concat(n9)).trim());\n    }\n    var N2 = function() {\n      function e5(e6) {\n        this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e6;\n      }\n      var t7 = e5.prototype;\n      return t7.indexOfGroup = function(e6) {\n        for (var t8 = 0, n9 = 0; n9 < e6; n9++)\n          t8 += this.groupSizes[n9];\n        return t8;\n      }, t7.insertRules = function(e6, t8) {\n        if (e6 >= this.groupSizes.length) {\n          for (var n9 = this.groupSizes, r8 = n9.length, o8 = r8; e6 >= o8; )\n            (o8 <<= 1) < 0 && _2(16, \"\" + e6);\n          this.groupSizes = new Uint32Array(o8), this.groupSizes.set(n9), this.length = o8;\n          for (var s6 = r8; s6 < o8; s6++)\n            this.groupSizes[s6] = 0;\n        }\n        for (var i6 = this.indexOfGroup(e6 + 1), a8 = 0, u6 = t8.length; a8 < u6; a8++)\n          this.tag.insertRule(i6, t8[a8]) && (this.groupSizes[e6]++, i6++);\n      }, t7.clearGroup = function(e6) {\n        if (e6 < this.length) {\n          var t8 = this.groupSizes[e6], n9 = this.indexOfGroup(e6), r8 = n9 + t8;\n          this.groupSizes[e6] = 0;\n          for (var o8 = n9; o8 < r8; o8++)\n            this.tag.deleteRule(n9);\n        }\n      }, t7.getGroup = function(e6) {\n        var t8 = \"\";\n        if (e6 >= this.length || 0 === this.groupSizes[e6])\n          return t8;\n        for (var n9 = this.groupSizes[e6], r8 = this.indexOfGroup(e6), o8 = r8 + n9, s6 = r8; s6 < o8; s6++)\n          t8 += this.tag.getRule(s6) + \"/*!sc*/\\n\";\n        return t8;\n      }, e5;\n    }();\n    var C3 = /* @__PURE__ */ new Map();\n    var A2 = /* @__PURE__ */ new Map();\n    var I2 = 1;\n    var P3 = function(e5) {\n      if (C3.has(e5))\n        return C3.get(e5);\n      for (; A2.has(I2); )\n        I2++;\n      var t7 = I2++;\n      return ((0 | t7) < 0 || t7 > 1 << 30) && _2(16, \"\" + t7), C3.set(e5, t7), A2.set(t7, e5), t7;\n    };\n    var x4 = function(e5) {\n      return A2.get(e5);\n    };\n    var O4 = function(e5, t7) {\n      t7 >= I2 && (I2 = t7 + 1), C3.set(e5, t7), A2.set(t7, e5);\n    };\n    var R3 = \"style[\" + v4 + '][data-styled-version=\"5.3.6\"]';\n    var D4 = new RegExp(\"^\" + v4 + '\\\\.g(\\\\d+)\\\\[id=\"([\\\\w\\\\d-]+)\"\\\\].*?\"([^\"]*)');\n    var T3 = function(e5, t7, n9) {\n      for (var r8, o8 = n9.split(\",\"), s6 = 0, i6 = o8.length; s6 < i6; s6++)\n        (r8 = o8[s6]) && e5.registerName(t7, r8);\n    };\n    var j2 = function(e5, t7) {\n      for (var n9 = (t7.textContent || \"\").split(\"/*!sc*/\\n\"), r8 = [], o8 = 0, s6 = n9.length; o8 < s6; o8++) {\n        var i6 = n9[o8].trim();\n        if (i6) {\n          var a8 = i6.match(D4);\n          if (a8) {\n            var u6 = 0 | parseInt(a8[1], 10), c6 = a8[2];\n            0 !== u6 && (O4(c6, u6), T3(e5, c6, a8[3]), e5.getTag().insertRules(u6, r8)), r8.length = 0;\n          } else\n            r8.push(i6);\n        }\n      }\n    };\n    var k3 = function() {\n      return \"undefined\" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;\n    };\n    var V2 = function(e5) {\n      var t7 = document.head, n9 = e5 || t7, r8 = document.createElement(\"style\"), o8 = function(e6) {\n        for (var t8 = e6.childNodes, n10 = t8.length; n10 >= 0; n10--) {\n          var r9 = t8[n10];\n          if (r9 && 1 === r9.nodeType && r9.hasAttribute(v4))\n            return r9;\n        }\n      }(n9), s6 = void 0 !== o8 ? o8.nextSibling : null;\n      r8.setAttribute(v4, \"active\"), r8.setAttribute(\"data-styled-version\", \"5.3.6\");\n      var i6 = k3();\n      return i6 && r8.setAttribute(\"nonce\", i6), n9.insertBefore(r8, s6), r8;\n    };\n    var M2 = function() {\n      function e5(e6) {\n        var t8 = this.element = V2(e6);\n        t8.appendChild(document.createTextNode(\"\")), this.sheet = function(e7) {\n          if (e7.sheet)\n            return e7.sheet;\n          for (var t9 = document.styleSheets, n9 = 0, r8 = t9.length; n9 < r8; n9++) {\n            var o8 = t9[n9];\n            if (o8.ownerNode === e7)\n              return o8;\n          }\n          _2(17);\n        }(t8), this.length = 0;\n      }\n      var t7 = e5.prototype;\n      return t7.insertRule = function(e6, t8) {\n        try {\n          return this.sheet.insertRule(t8, e6), this.length++, true;\n        } catch (e7) {\n          return false;\n        }\n      }, t7.deleteRule = function(e6) {\n        this.sheet.deleteRule(e6), this.length--;\n      }, t7.getRule = function(e6) {\n        var t8 = this.sheet.cssRules[e6];\n        return void 0 !== t8 && \"string\" == typeof t8.cssText ? t8.cssText : \"\";\n      }, e5;\n    }();\n    var B2 = function() {\n      function e5(e6) {\n        var t8 = this.element = V2(e6);\n        this.nodes = t8.childNodes, this.length = 0;\n      }\n      var t7 = e5.prototype;\n      return t7.insertRule = function(e6, t8) {\n        if (e6 <= this.length && e6 >= 0) {\n          var n9 = document.createTextNode(t8), r8 = this.nodes[e6];\n          return this.element.insertBefore(n9, r8 || null), this.length++, true;\n        }\n        return false;\n      }, t7.deleteRule = function(e6) {\n        this.element.removeChild(this.nodes[e6]), this.length--;\n      }, t7.getRule = function(e6) {\n        return e6 < this.length ? this.nodes[e6].textContent : \"\";\n      }, e5;\n    }();\n    var z3 = function() {\n      function e5(e6) {\n        this.rules = [], this.length = 0;\n      }\n      var t7 = e5.prototype;\n      return t7.insertRule = function(e6, t8) {\n        return e6 <= this.length && (this.rules.splice(e6, 0, t8), this.length++, true);\n      }, t7.deleteRule = function(e6) {\n        this.rules.splice(e6, 1), this.length--;\n      }, t7.getRule = function(e6) {\n        return e6 < this.length ? this.rules[e6] : \"\";\n      }, e5;\n    }();\n    var q2 = g4;\n    var G2 = { isServer: !g4, useCSSOMInjection: !S3 };\n    var L4 = function() {\n      function e5(e6, t8, n9) {\n        void 0 === e6 && (e6 = p6), void 0 === t8 && (t8 = {}), this.options = c5({}, G2, {}, e6), this.gs = t8, this.names = new Map(n9), this.server = !!e6.isServer, !this.server && g4 && q2 && (q2 = false, function(e7) {\n          for (var t9 = document.querySelectorAll(R3), n10 = 0, r8 = t9.length; n10 < r8; n10++) {\n            var o8 = t9[n10];\n            o8 && \"active\" !== o8.getAttribute(v4) && (j2(e7, o8), o8.parentNode && o8.parentNode.removeChild(o8));\n          }\n        }(this));\n      }\n      e5.registerId = function(e6) {\n        return P3(e6);\n      };\n      var t7 = e5.prototype;\n      return t7.reconstructWithOptions = function(t8, n9) {\n        return void 0 === n9 && (n9 = true), new e5(c5({}, this.options, {}, t8), this.gs, n9 && this.names || void 0);\n      }, t7.allocateGSInstance = function(e6) {\n        return this.gs[e6] = (this.gs[e6] || 0) + 1;\n      }, t7.getTag = function() {\n        return this.tag || (this.tag = (n9 = (t8 = this.options).isServer, r8 = t8.useCSSOMInjection, o8 = t8.target, e6 = n9 ? new z3(o8) : r8 ? new M2(o8) : new B2(o8), new N2(e6)));\n        var e6, t8, n9, r8, o8;\n      }, t7.hasNameForId = function(e6, t8) {\n        return this.names.has(e6) && this.names.get(e6).has(t8);\n      }, t7.registerName = function(e6, t8) {\n        if (P3(e6), this.names.has(e6))\n          this.names.get(e6).add(t8);\n        else {\n          var n9 = /* @__PURE__ */ new Set();\n          n9.add(t8), this.names.set(e6, n9);\n        }\n      }, t7.insertRules = function(e6, t8, n9) {\n        this.registerName(e6, t8), this.getTag().insertRules(P3(e6), n9);\n      }, t7.clearNames = function(e6) {\n        this.names.has(e6) && this.names.get(e6).clear();\n      }, t7.clearRules = function(e6) {\n        this.getTag().clearGroup(P3(e6)), this.clearNames(e6);\n      }, t7.clearTag = function() {\n        this.tag = void 0;\n      }, t7.toString = function() {\n        return function(e6) {\n          for (var t8 = e6.getTag(), n9 = t8.length, r8 = \"\", o8 = 0; o8 < n9; o8++) {\n            var s6 = x4(o8);\n            if (void 0 !== s6) {\n              var i6 = e6.names.get(s6), a8 = t8.getGroup(o8);\n              if (i6 && a8 && i6.size) {\n                var u6 = v4 + \".g\" + o8 + '[id=\"' + s6 + '\"]', c6 = \"\";\n                void 0 !== i6 && i6.forEach(function(e7) {\n                  e7.length > 0 && (c6 += e7 + \",\");\n                }), r8 += \"\" + a8 + u6 + '{content:\"' + c6 + '\"}/*!sc*/\\n';\n              }\n            }\n          }\n          return r8;\n        }(this);\n      }, e5;\n    }();\n    var F2 = /(a)(d)/gi;\n    var Y2 = function(e5) {\n      return String.fromCharCode(e5 + (e5 > 25 ? 39 : 97));\n    };\n    function H3(e5) {\n      var t7, n9 = \"\";\n      for (t7 = Math.abs(e5); t7 > 52; t7 = t7 / 52 | 0)\n        n9 = Y2(t7 % 52) + n9;\n      return (Y2(t7 % 52) + n9).replace(F2, \"$1-$2\");\n    }\n    var $ = function(e5, t7) {\n      for (var n9 = t7.length; n9; )\n        e5 = 33 * e5 ^ t7.charCodeAt(--n9);\n      return e5;\n    };\n    var W3 = function(e5) {\n      return $(5381, e5);\n    };\n    function U2(e5) {\n      for (var t7 = 0; t7 < e5.length; t7 += 1) {\n        var n9 = e5[t7];\n        if (f5(n9) && !y5(n9))\n          return false;\n      }\n      return true;\n    }\n    var J = W3(\"5.3.6\");\n    var X2 = function() {\n      function e5(e6, t7, n9) {\n        this.rules = e6, this.staticRulesId = \"\", this.isStatic = false, this.componentId = t7, this.baseHash = $(J, t7), this.baseStyle = n9, L4.registerId(t7);\n      }\n      return e5.prototype.generateAndInjectStyles = function(e6, t7, n9) {\n        var r8 = this.componentId, o8 = [];\n        if (this.baseStyle && o8.push(this.baseStyle.generateAndInjectStyles(e6, t7, n9)), this.isStatic && !n9.hash)\n          if (this.staticRulesId && t7.hasNameForId(r8, this.staticRulesId))\n            o8.push(this.staticRulesId);\n          else {\n            var s6 = me(this.rules, e6, t7, n9).join(\"\"), i6 = H3($(this.baseHash, s6) >>> 0);\n            if (!t7.hasNameForId(r8, i6)) {\n              var a8 = n9(s6, \".\" + i6, void 0, r8);\n              t7.insertRules(r8, i6, a8);\n            }\n            o8.push(i6), this.staticRulesId = i6;\n          }\n        else {\n          for (var u6 = this.rules.length, c6 = $(this.baseHash, n9.hash), l7 = \"\", d5 = 0; d5 < u6; d5++) {\n            var h5 = this.rules[d5];\n            if (\"string\" == typeof h5)\n              l7 += h5, c6 = $(c6, h5 + d5);\n            else if (h5) {\n              var p7 = me(h5, e6, t7, n9), f6 = Array.isArray(p7) ? p7.join(\"\") : p7;\n              c6 = $(c6, f6 + d5), l7 += f6;\n            }\n          }\n          if (l7) {\n            var m5 = H3(c6 >>> 0);\n            if (!t7.hasNameForId(r8, m5)) {\n              var y6 = n9(l7, \".\" + m5, void 0, r8);\n              t7.insertRules(r8, m5, y6);\n            }\n            o8.push(m5);\n          }\n        }\n        return o8.join(\" \");\n      }, e5;\n    }();\n    var Z2 = /^\\s*\\/\\/.*$/gm;\n    var K = [\":\", \"[\", \".\", \"#\"];\n    function Q2(e5) {\n      var t7, n9, r8, o8, i6 = void 0 === e5 ? p6 : e5, a8 = i6.options, u6 = void 0 === a8 ? p6 : a8, c6 = i6.plugins, l7 = void 0 === c6 ? h4 : c6, d5 = new s5(u6), f6 = [], m5 = function(e6) {\n        function t8(t9) {\n          if (t9)\n            try {\n              e6(t9 + \"}\");\n            } catch (e7) {\n            }\n        }\n        return function(n10, r9, o9, s6, i7, a9, u7, c7, l8, d6) {\n          switch (n10) {\n            case 1:\n              if (0 === l8 && 64 === r9.charCodeAt(0))\n                return e6(r9 + \";\"), \"\";\n              break;\n            case 2:\n              if (0 === c7)\n                return r9 + \"/*|*/\";\n              break;\n            case 3:\n              switch (c7) {\n                case 102:\n                case 112:\n                  return e6(o9[0] + r9), \"\";\n                default:\n                  return r9 + (0 === d6 ? \"/*|*/\" : \"\");\n              }\n            case -2:\n              r9.split(\"/*|*/}\").forEach(t8);\n          }\n        };\n      }(function(e6) {\n        f6.push(e6);\n      }), y6 = function(e6, r9, s6) {\n        return 0 === r9 && -1 !== K.indexOf(s6[n9.length]) || s6.match(o8) ? e6 : \".\" + t7;\n      };\n      function v5(e6, s6, i7, a9) {\n        void 0 === a9 && (a9 = \"&\");\n        var u7 = e6.replace(Z2, \"\"), c7 = s6 && i7 ? i7 + \" \" + s6 + \" { \" + u7 + \" }\" : u7;\n        return t7 = a9, n9 = s6, r8 = new RegExp(\"\\\\\" + n9 + \"\\\\b\", \"g\"), o8 = new RegExp(\"(\\\\\" + n9 + \"\\\\b){2,}\"), d5(i7 || !s6 ? \"\" : s6, c7);\n      }\n      return d5.use([].concat(l7, [function(e6, t8, o9) {\n        2 === e6 && o9.length && o9[0].lastIndexOf(n9) > 0 && (o9[0] = o9[0].replace(r8, y6));\n      }, m5, function(e6) {\n        if (-2 === e6) {\n          var t8 = f6;\n          return f6 = [], t8;\n        }\n      }])), v5.hash = l7.length ? l7.reduce(function(e6, t8) {\n        return t8.name || _2(15), $(e6, t8.name);\n      }, 5381).toString() : \"\", v5;\n    }\n    var ee = r7.createContext();\n    var te = ee.Consumer;\n    var ne = r7.createContext();\n    var re = (ne.Consumer, new L4());\n    var oe = Q2();\n    function se() {\n      return n8.useContext(ee) || re;\n    }\n    function ie() {\n      return n8.useContext(ne) || oe;\n    }\n    function ae(e5) {\n      var t7 = n8.useState(e5.stylisPlugins), s6 = t7[0], i6 = t7[1], a8 = se(), u6 = n8.useMemo(function() {\n        var t8 = a8;\n        return e5.sheet ? t8 = e5.sheet : e5.target && (t8 = t8.reconstructWithOptions({ target: e5.target }, false)), e5.disableCSSOMInjection && (t8 = t8.reconstructWithOptions({ useCSSOMInjection: false })), t8;\n      }, [e5.disableCSSOMInjection, e5.sheet, e5.target]), c6 = n8.useMemo(function() {\n        return Q2({ options: { prefix: !e5.disableVendorPrefixes }, plugins: s6 });\n      }, [e5.disableVendorPrefixes, s6]);\n      return n8.useEffect(function() {\n        o7(s6, e5.stylisPlugins) || i6(e5.stylisPlugins);\n      }, [e5.stylisPlugins]), r7.createElement(ee.Provider, { value: u6 }, r7.createElement(ne.Provider, { value: c6 }, true ? r7.Children.only(e5.children) : e5.children));\n    }\n    var ue = function() {\n      function e5(e6, t7) {\n        var n9 = this;\n        this.inject = function(e7, t8) {\n          void 0 === t8 && (t8 = oe);\n          var r8 = n9.name + t8.hash;\n          e7.hasNameForId(n9.id, r8) || e7.insertRules(n9.id, r8, t8(n9.rules, r8, \"@keyframes\"));\n        }, this.toString = function() {\n          return _2(12, String(n9.name));\n        }, this.name = e6, this.id = \"sc-keyframes-\" + e6, this.rules = t7;\n      }\n      return e5.prototype.getName = function(e6) {\n        return void 0 === e6 && (e6 = oe), this.name + e6.hash;\n      }, e5;\n    }();\n    var ce = /([A-Z])/;\n    var le = /([A-Z])/g;\n    var de = /^ms-/;\n    var he = function(e5) {\n      return \"-\" + e5.toLowerCase();\n    };\n    function pe(e5) {\n      return ce.test(e5) ? e5.replace(le, he).replace(de, \"-ms-\") : e5;\n    }\n    var fe = function(e5) {\n      return null == e5 || false === e5 || \"\" === e5;\n    };\n    function me(e5, n9, r8, o8) {\n      if (Array.isArray(e5)) {\n        for (var s6, a8 = [], u6 = 0, c6 = e5.length; u6 < c6; u6 += 1)\n          \"\" !== (s6 = me(e5[u6], n9, r8, o8)) && (Array.isArray(s6) ? a8.push.apply(a8, s6) : a8.push(s6));\n        return a8;\n      }\n      if (fe(e5))\n        return \"\";\n      if (y5(e5))\n        return \".\" + e5.styledComponentId;\n      if (f5(e5)) {\n        if (\"function\" != typeof (h5 = e5) || h5.prototype && h5.prototype.isReactComponent || !n9)\n          return e5;\n        var l7 = e5(n9);\n        return t6.isElement(l7) && console.warn(m4(e5) + \" is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\"), me(l7, n9, r8, o8);\n      }\n      var h5;\n      return e5 instanceof ue ? r8 ? (e5.inject(r8, o8), e5.getName(o8)) : e5 : d4(e5) ? function e6(t7, n10) {\n        var r9, o9, s7 = [];\n        for (var a9 in t7)\n          t7.hasOwnProperty(a9) && !fe(t7[a9]) && (Array.isArray(t7[a9]) && t7[a9].isCss || f5(t7[a9]) ? s7.push(pe(a9) + \":\", t7[a9], \";\") : d4(t7[a9]) ? s7.push.apply(s7, e6(t7[a9], a9)) : s7.push(pe(a9) + \": \" + (r9 = a9, null == (o9 = t7[a9]) || \"boolean\" == typeof o9 || \"\" === o9 ? \"\" : \"number\" != typeof o9 || 0 === o9 || r9 in i5 ? String(o9).trim() : o9 + \"px\") + \";\"));\n        return n10 ? [n10 + \" {\"].concat(s7, [\"}\"]) : s7;\n      }(e5) : e5.toString();\n    }\n    var ye = function(e5) {\n      return Array.isArray(e5) && (e5.isCss = true), e5;\n    };\n    function ve(e5) {\n      for (var t7 = arguments.length, n9 = new Array(t7 > 1 ? t7 - 1 : 0), r8 = 1; r8 < t7; r8++)\n        n9[r8 - 1] = arguments[r8];\n      return f5(e5) || d4(e5) ? ye(me(l6(h4, [e5].concat(n9)))) : 0 === n9.length && 1 === e5.length && \"string\" == typeof e5[0] ? e5 : ye(me(l6(e5, n9)));\n    }\n    var ge = /invalid hook call/i;\n    var Se = /* @__PURE__ */ new Set();\n    var we = function(e5, t7) {\n      if (true) {\n        var r8 = \"The component \" + e5 + (t7 ? ' with the id of \"' + t7 + '\"' : \"\") + \" has been created dynamically.\\nYou may see this warning because you've called styled inside another component.\\nTo resolve this only create new StyledComponents outside of any render method and function component.\", o8 = console.error;\n        try {\n          var s6 = true;\n          console.error = function(e6) {\n            if (ge.test(e6))\n              s6 = false, Se.delete(r8);\n            else {\n              for (var t8 = arguments.length, n9 = new Array(t8 > 1 ? t8 - 1 : 0), i6 = 1; i6 < t8; i6++)\n                n9[i6 - 1] = arguments[i6];\n              o8.apply(void 0, [e6].concat(n9));\n            }\n          }, n8.useRef(), s6 && !Se.has(r8) && (console.warn(r8), Se.add(r8));\n        } catch (e6) {\n          ge.test(e6.message) && Se.delete(r8);\n        } finally {\n          console.error = o8;\n        }\n      }\n    };\n    var Ee = function(e5, t7, n9) {\n      return void 0 === n9 && (n9 = p6), e5.theme !== n9.theme && e5.theme || t7 || n9.theme;\n    };\n    var be = /[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^`{|}~-]+/g;\n    var _e = /(^-|-$)/g;\n    function Ne(e5) {\n      return e5.replace(be, \"-\").replace(_e, \"\");\n    }\n    var Ce = function(e5) {\n      return H3(W3(e5) >>> 0);\n    };\n    function Ae(e5) {\n      return \"string\" == typeof e5 && e5.charAt(0) === e5.charAt(0).toLowerCase();\n    }\n    var Ie = function(e5) {\n      return \"function\" == typeof e5 || \"object\" == typeof e5 && null !== e5 && !Array.isArray(e5);\n    };\n    var Pe = function(e5) {\n      return \"__proto__\" !== e5 && \"constructor\" !== e5 && \"prototype\" !== e5;\n    };\n    function xe(e5, t7, n9) {\n      var r8 = e5[n9];\n      Ie(t7) && Ie(r8) ? Oe(r8, t7) : e5[n9] = t7;\n    }\n    function Oe(e5) {\n      for (var t7 = arguments.length, n9 = new Array(t7 > 1 ? t7 - 1 : 0), r8 = 1; r8 < t7; r8++)\n        n9[r8 - 1] = arguments[r8];\n      for (var o8 = 0, s6 = n9; o8 < s6.length; o8++) {\n        var i6 = s6[o8];\n        if (Ie(i6))\n          for (var a8 in i6)\n            Pe(a8) && xe(e5, i6[a8], a8);\n      }\n      return e5;\n    }\n    var Re = r7.createContext();\n    var De = Re.Consumer;\n    var Te = {};\n    function je(e5, t7, o8) {\n      var s6 = y5(e5), i6 = !Ae(e5), l7 = t7.attrs, d5 = void 0 === l7 ? h4 : l7, v5 = t7.componentId, g5 = void 0 === v5 ? function(e6, t8) {\n        var n9 = \"string\" != typeof e6 ? \"sc\" : Ne(e6);\n        Te[n9] = (Te[n9] || 0) + 1;\n        var r8 = n9 + \"-\" + Ce(\"5.3.6\" + n9 + Te[n9]);\n        return t8 ? t8 + \"-\" + r8 : r8;\n      }(t7.displayName, t7.parentComponentId) : v5, S4 = t7.displayName, w5 = void 0 === S4 ? function(e6) {\n        return Ae(e6) ? \"styled.\" + e6 : \"Styled(\" + m4(e6) + \")\";\n      }(e5) : S4, E5 = t7.displayName && t7.componentId ? Ne(t7.displayName) + \"-\" + t7.componentId : t7.componentId || g5, b5 = s6 && e5.attrs ? Array.prototype.concat(e5.attrs, d5).filter(Boolean) : d5, _3 = t7.shouldForwardProp;\n      s6 && e5.shouldForwardProp && (_3 = t7.shouldForwardProp ? function(n9, r8, o9) {\n        return e5.shouldForwardProp(n9, r8, o9) && t7.shouldForwardProp(n9, r8, o9);\n      } : e5.shouldForwardProp);\n      var N3, C4 = new X2(o8, E5, s6 ? e5.componentStyle : void 0), A3 = C4.isStatic && 0 === d5.length, I3 = function(e6, t8) {\n        return function(e7, t9, r8, o9) {\n          var s7 = e7.attrs, i7 = e7.componentStyle, u6 = e7.defaultProps, l8 = e7.foldedComponentIds, d6 = e7.shouldForwardProp, h5 = e7.styledComponentId, m5 = e7.target;\n          n8.useDebugValue(h5);\n          var y6 = function(e8, t10, n9) {\n            void 0 === e8 && (e8 = p6);\n            var r9 = c5({}, t10, { theme: e8 }), o10 = {};\n            return n9.forEach(function(e9) {\n              var t11, n10, s8, i8 = e9;\n              for (t11 in f5(i8) && (i8 = i8(r9)), i8)\n                r9[t11] = o10[t11] = \"className\" === t11 ? (n10 = o10[t11], s8 = i8[t11], n10 && s8 ? n10 + \" \" + s8 : n10 || s8) : i8[t11];\n            }), [r9, o10];\n          }(Ee(t9, n8.useContext(Re), u6) || p6, t9, s7), v6 = y6[0], g6 = y6[1], S5 = function(e8, t10, r9, o10) {\n            var s8 = se(), i8 = ie(), a8 = t10 ? e8.generateAndInjectStyles(p6, s8, i8) : e8.generateAndInjectStyles(r9, s8, i8);\n            return n8.useDebugValue(a8), !t10 && o10 && o10(a8), a8;\n          }(i7, o9, v6, true ? e7.warnTooManyClasses : void 0), w6 = r8, E6 = g6.$as || t9.$as || g6.as || t9.as || m5, b6 = Ae(E6), _4 = g6 !== t9 ? c5({}, t9, {}, g6) : t9, N4 = {};\n          for (var C5 in _4)\n            \"$\" !== C5[0] && \"as\" !== C5 && (\"forwardedAs\" === C5 ? N4.as = _4[C5] : (d6 ? d6(C5, a7, E6) : !b6 || a7(C5)) && (N4[C5] = _4[C5]));\n          return t9.style && g6.style !== t9.style && (N4.style = c5({}, t9.style, {}, g6.style)), N4.className = Array.prototype.concat(l8, h5, S5 !== h5 ? S5 : null, t9.className, g6.className).filter(Boolean).join(\" \"), N4.ref = w6, n8.createElement(E6, N4);\n        }(N3, e6, t8, A3);\n      };\n      return I3.displayName = w5, (N3 = r7.forwardRef(I3)).attrs = b5, N3.componentStyle = C4, N3.displayName = w5, N3.shouldForwardProp = _3, N3.foldedComponentIds = s6 ? Array.prototype.concat(e5.foldedComponentIds, e5.styledComponentId) : h4, N3.styledComponentId = E5, N3.target = s6 ? e5.target : e5, N3.withComponent = function(e6) {\n        var n9 = t7.componentId, r8 = function(e7, t8) {\n          if (null == e7)\n            return {};\n          var n10, r9, o9 = {}, s8 = Object.keys(e7);\n          for (r9 = 0; r9 < s8.length; r9++)\n            n10 = s8[r9], t8.indexOf(n10) >= 0 || (o9[n10] = e7[n10]);\n          return o9;\n        }(t7, [\"componentId\"]), s7 = n9 && n9 + \"-\" + (Ae(e6) ? e6 : Ne(m4(e6)));\n        return je(e6, c5({}, r8, { attrs: b5, componentId: s7 }), o8);\n      }, Object.defineProperty(N3, \"defaultProps\", { get: function() {\n        return this._foldedDefaultProps;\n      }, set: function(t8) {\n        this._foldedDefaultProps = s6 ? Oe({}, e5.defaultProps, t8) : t8;\n      } }), we(w5, E5), N3.warnTooManyClasses = function(e6, t8) {\n        var n9 = {}, r8 = false;\n        return function(o9) {\n          if (!r8 && (n9[o9] = true, Object.keys(n9).length >= 200)) {\n            var s7 = t8 ? ' with the id of \"' + t8 + '\"' : \"\";\n            console.warn(\"Over 200 classes were generated for component \" + e6 + s7 + \".\\nConsider using the attrs method, together with a style object for frequently changed styles.\\nExample:\\n  const Component = styled.div.attrs(props => ({\\n    style: {\\n      background: props.background,\\n    },\\n  }))`width: 100%;`\\n\\n  <Component />\"), r8 = true, n9 = {};\n          }\n        };\n      }(w5, E5), N3.toString = function() {\n        return \".\" + N3.styledComponentId;\n      }, i6 && u5(N3, e5, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true, withComponent: true }), N3;\n    }\n    var ke = function(e5) {\n      return function e6(n9, r8, o8) {\n        if (void 0 === o8 && (o8 = p6), !t6.isValidElementType(r8))\n          return _2(1, String(r8));\n        var s6 = function() {\n          return n9(r8, o8, ve.apply(void 0, arguments));\n        };\n        return s6.withConfig = function(t7) {\n          return e6(n9, r8, c5({}, o8, {}, t7));\n        }, s6.attrs = function(t7) {\n          return e6(n9, r8, c5({}, o8, { attrs: Array.prototype.concat(o8.attrs, t7).filter(Boolean) }));\n        }, s6;\n      }(je, e5);\n    };\n    [\"a\", \"abbr\", \"address\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"base\", \"bdi\", \"bdo\", \"big\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"cite\", \"code\", \"col\", \"colgroup\", \"data\", \"datalist\", \"dd\", \"del\", \"details\", \"dfn\", \"dialog\", \"div\", \"dl\", \"dt\", \"em\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"iframe\", \"img\", \"input\", \"ins\", \"kbd\", \"keygen\", \"label\", \"legend\", \"li\", \"link\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"menuitem\", \"meta\", \"meter\", \"nav\", \"noscript\", \"object\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"param\", \"picture\", \"pre\", \"progress\", \"q\", \"rp\", \"rt\", \"ruby\", \"s\", \"samp\", \"script\", \"section\", \"select\", \"small\", \"source\", \"span\", \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\", \"title\", \"tr\", \"track\", \"u\", \"ul\", \"var\", \"video\", \"wbr\", \"circle\", \"clipPath\", \"defs\", \"ellipse\", \"foreignObject\", \"g\", \"image\", \"line\", \"linearGradient\", \"marker\", \"mask\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialGradient\", \"rect\", \"stop\", \"svg\", \"text\", \"textPath\", \"tspan\"].forEach(function(e5) {\n      ke[e5] = ke(e5);\n    });\n    var Ve = function() {\n      function e5(e6, t8) {\n        this.rules = e6, this.componentId = t8, this.isStatic = U2(e6), L4.registerId(this.componentId + 1);\n      }\n      var t7 = e5.prototype;\n      return t7.createStyles = function(e6, t8, n9, r8) {\n        var o8 = r8(me(this.rules, t8, n9, r8).join(\"\"), \"\"), s6 = this.componentId + e6;\n        n9.insertRules(s6, s6, o8);\n      }, t7.removeStyles = function(e6, t8) {\n        t8.clearRules(this.componentId + e6);\n      }, t7.renderStyles = function(e6, t8, n9, r8) {\n        e6 > 2 && L4.registerId(this.componentId + e6), this.removeStyles(e6, n9), this.createStyles(e6, t8, n9, r8);\n      }, e5;\n    }();\n    var Me = function() {\n      function e5() {\n        var e6 = this;\n        this._emitSheetCSS = function() {\n          var t8 = e6.instance.toString();\n          if (!t8)\n            return \"\";\n          var n9 = k3();\n          return \"<style \" + [n9 && 'nonce=\"' + n9 + '\"', v4 + '=\"true\"', 'data-styled-version=\"5.3.6\"'].filter(Boolean).join(\" \") + \">\" + t8 + \"</style>\";\n        }, this.getStyleTags = function() {\n          return e6.sealed ? _2(2) : e6._emitSheetCSS();\n        }, this.getStyleElement = function() {\n          var t8;\n          if (e6.sealed)\n            return _2(2);\n          var n9 = ((t8 = {})[v4] = \"\", t8[\"data-styled-version\"] = \"5.3.6\", t8.dangerouslySetInnerHTML = { __html: e6.instance.toString() }, t8), o8 = k3();\n          return o8 && (n9.nonce = o8), [r7.createElement(\"style\", c5({}, n9, { key: \"sc-0-0\" }))];\n        }, this.seal = function() {\n          e6.sealed = true;\n        }, this.instance = new L4({ isServer: true }), this.sealed = false;\n      }\n      var t7 = e5.prototype;\n      return t7.collectStyles = function(e6) {\n        return this.sealed ? _2(2) : r7.createElement(ae, { sheet: this.instance }, e6);\n      }, t7.interleaveWithNodeStream = function(e6) {\n        return _2(3);\n      }, e5;\n    }();\n    var Be = { StyleSheet: L4, masterSheet: re };\n    \"undefined\" != typeof navigator && \"ReactNative\" === navigator.product && console.warn(\"It looks like you've imported 'styled-components' on React Native.\\nPerhaps you're looking to import 'styled-components/native'?\\nRead more about this at https://www.styled-components.com/docs/basics#react-native\"), \"undefined\" != typeof window && (window[\"__styled-components-init__\"] = window[\"__styled-components-init__\"] || 0, 1 === window[\"__styled-components-init__\"] && console.warn(\"It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\\n\\nSee https://s-c.sh/2BAXzed for more info.\"), window[\"__styled-components-init__\"] += 1), exports2.ServerStyleSheet = Me, exports2.StyleSheetConsumer = te, exports2.StyleSheetContext = ee, exports2.StyleSheetManager = ae, exports2.ThemeConsumer = De, exports2.ThemeContext = Re, exports2.ThemeProvider = function(e5) {\n      var t7 = n8.useContext(Re), o8 = n8.useMemo(function() {\n        return function(e6, t8) {\n          if (!e6)\n            return _2(14);\n          if (f5(e6)) {\n            var n9 = e6(t8);\n            return null !== n9 && !Array.isArray(n9) && \"object\" == typeof n9 ? n9 : _2(7);\n          }\n          return Array.isArray(e6) || \"object\" != typeof e6 ? _2(8) : t8 ? c5({}, t8, {}, e6) : e6;\n        }(e5.theme, t7);\n      }, [e5.theme, t7]);\n      return e5.children ? r7.createElement(Re.Provider, { value: o8 }, e5.children) : null;\n    }, exports2.__PRIVATE__ = Be, exports2.createGlobalStyle = function(e5) {\n      for (var t7 = arguments.length, o8 = new Array(t7 > 1 ? t7 - 1 : 0), s6 = 1; s6 < t7; s6++)\n        o8[s6 - 1] = arguments[s6];\n      var i6 = ve.apply(void 0, [e5].concat(o8)), a8 = \"sc-global-\" + Ce(JSON.stringify(i6)), u6 = new Ve(i6, a8);\n      function l7(e6) {\n        var t8 = se(), o9 = ie(), s7 = n8.useContext(Re), c6 = n8.useRef(t8.allocateGSInstance(a8)).current;\n        return r7.Children.count(e6.children) && console.warn(\"The global style component \" + a8 + \" was given child JSX. createGlobalStyle does not render children.\"), i6.some(function(e7) {\n          return \"string\" == typeof e7 && -1 !== e7.indexOf(\"@import\");\n        }) && console.warn(\"Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app.\"), t8.server && d5(c6, e6, t8, s7, o9), n8.useLayoutEffect(function() {\n          if (!t8.server)\n            return d5(c6, e6, t8, s7, o9), function() {\n              return u6.removeStyles(c6, t8);\n            };\n        }, [c6, e6, t8, s7, o9]), null;\n      }\n      function d5(e6, t8, n9, r8, o9) {\n        if (u6.isStatic)\n          u6.renderStyles(e6, w4, n9, o9);\n        else {\n          var s7 = c5({}, t8, { theme: Ee(t8, r8, l7.defaultProps) });\n          u6.renderStyles(e6, s7, n9, o9);\n        }\n      }\n      return we(a8), r7.memo(l7);\n    }, exports2.css = ve, exports2.default = ke, exports2.isStyledComponent = y5, exports2.keyframes = function(e5) {\n      \"undefined\" != typeof navigator && \"ReactNative\" === navigator.product && console.warn(\"`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.\");\n      for (var t7 = arguments.length, n9 = new Array(t7 > 1 ? t7 - 1 : 0), r8 = 1; r8 < t7; r8++)\n        n9[r8 - 1] = arguments[r8];\n      var o8 = ve.apply(void 0, [e5].concat(n9)).join(\"\"), s6 = Ce(o8);\n      return new ue(s6, o8);\n    }, exports2.useTheme = function() {\n      return n8.useContext(Re);\n    }, exports2.version = \"5.3.6\", exports2.withTheme = function(e5) {\n      var t7 = r7.forwardRef(function(t8, o8) {\n        var s6 = n8.useContext(Re), i6 = e5.defaultProps, a8 = Ee(t8, s6, i6);\n        return void 0 === a8 && console.warn('[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps in component class \"' + m4(e5) + '\"'), r7.createElement(e5, c5({}, t8, { theme: a8, ref: o8 }));\n      });\n      return u5(t7, e5), t7.displayName = \"WithTheme(\" + m4(e5) + \")\", t7;\n    };\n  }\n});\n\n// node_modules/typescript-styled-is/dist/styledIs.js\nvar require_styledIs = __commonJS({\n  \"node_modules/typescript-styled-is/dist/styledIs.js\"(exports2) {\n    \"use strict\";\n    var __makeTemplateObject = exports2 && exports2.__makeTemplateObject || function(cooked, raw) {\n      if (Object.defineProperty) {\n        Object.defineProperty(cooked, \"raw\", { value: raw });\n      } else {\n        cooked.raw = raw;\n      }\n      return cooked;\n    };\n    var __spreadArrays = exports2 && exports2.__spreadArrays || function() {\n      for (var s5 = 0, i5 = 0, il = arguments.length; i5 < il; i5++)\n        s5 += arguments[i5].length;\n      for (var r7 = Array(s5), k3 = 0, i5 = 0; i5 < il; i5++)\n        for (var a7 = arguments[i5], j2 = 0, jl = a7.length; j2 < jl; j2++, k3++)\n          r7[k3] = a7[j2];\n      return r7;\n    };\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    var styled_components_1 = require_styled_components_browser_cjs();\n    var styledIs = function(method) {\n      return function(condition) {\n        return function() {\n          var names = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n            names[_i] = arguments[_i];\n          }\n          var isValid = function(props) {\n            return names[method](function(name) {\n              return typeof name === \"string\" ? name in props ? Boolean(props[name]) === condition : !condition : name.valid(props);\n            });\n          };\n          var getCss = function() {\n            var styles2 = [];\n            for (var _i2 = 0; _i2 < arguments.length; _i2++) {\n              styles2[_i2] = arguments[_i2];\n            }\n            return function(props) {\n              var style = styles2[0], rest = styles2.slice(1);\n              return isValid(props) ? styled_components_1.css.apply(void 0, __spreadArrays([style], rest)) : styled_components_1.css(templateObject_1 || (templateObject_1 = __makeTemplateObject([\"\"], [\"\"])));\n            };\n          };\n          getCss.valid = isValid;\n          return getCss;\n        };\n      };\n    };\n    exports2.default = styledIs;\n    var templateObject_1;\n  }\n});\n\n// node_modules/typescript-styled-is/dist/index.js\nvar require_dist = __commonJS({\n  \"node_modules/typescript-styled-is/dist/index.js\"(exports2) {\n    \"use strict\";\n    var __importDefault = exports2 && exports2.__importDefault || function(mod) {\n      return mod && mod.__esModule ? mod : { \"default\": mod };\n    };\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.someNot = exports2.some = exports2.isNot = exports2.is = void 0;\n    var styledIs_1 = __importDefault(require_styledIs());\n    var styledEvery = styledIs_1.default(\"every\");\n    var is4 = styledEvery(true);\n    exports2.is = is4;\n    var isNot = styledEvery(false);\n    exports2.isNot = isNot;\n    var styledSome = styledIs_1.default(\"some\");\n    var some = styledSome(true);\n    exports2.some = some;\n    var someNot = styledSome(false);\n    exports2.someNot = someNot;\n    exports2.default = is4;\n  }\n});\n\n// node_modules/object-assign/index.js\nvar require_object_assign = __commonJS({\n  \"node_modules/object-assign/index.js\"(exports2, module2) {\n    \"use strict\";\n    var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n    var hasOwnProperty6 = Object.prototype.hasOwnProperty;\n    var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n    function toObject(val) {\n      if (val === null || val === void 0) {\n        throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n      }\n      return Object(val);\n    }\n    function shouldUseNative() {\n      try {\n        if (!Object.assign) {\n          return false;\n        }\n        var test1 = new String(\"abc\");\n        test1[5] = \"de\";\n        if (Object.getOwnPropertyNames(test1)[0] === \"5\") {\n          return false;\n        }\n        var test2 = {};\n        for (var i5 = 0; i5 < 10; i5++) {\n          test2[\"_\" + String.fromCharCode(i5)] = i5;\n        }\n        var order2 = Object.getOwnPropertyNames(test2).map(function(n8) {\n          return test2[n8];\n        });\n        if (order2.join(\"\") !== \"0123456789\") {\n          return false;\n        }\n        var test3 = {};\n        \"abcdefghijklmnopqrst\".split(\"\").forEach(function(letter) {\n          test3[letter] = letter;\n        });\n        if (Object.keys(Object.assign({}, test3)).join(\"\") !== \"abcdefghijklmnopqrst\") {\n          return false;\n        }\n        return true;\n      } catch (err) {\n        return false;\n      }\n    }\n    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {\n      var from;\n      var to = toObject(target);\n      var symbols;\n      for (var s5 = 1; s5 < arguments.length; s5++) {\n        from = Object(arguments[s5]);\n        for (var key in from) {\n          if (hasOwnProperty6.call(from, key)) {\n            to[key] = from[key];\n          }\n        }\n        if (getOwnPropertySymbols) {\n          symbols = getOwnPropertySymbols(from);\n          for (var i5 = 0; i5 < symbols.length; i5++) {\n            if (propIsEnumerable.call(from, symbols[i5])) {\n              to[symbols[i5]] = from[symbols[i5]];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n});\n\n// node_modules/prop-types/lib/ReactPropTypesSecret.js\nvar require_ReactPropTypesSecret = __commonJS({\n  \"node_modules/prop-types/lib/ReactPropTypesSecret.js\"(exports2, module2) {\n    \"use strict\";\n    var ReactPropTypesSecret = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n    module2.exports = ReactPropTypesSecret;\n  }\n});\n\n// node_modules/prop-types/lib/has.js\nvar require_has = __commonJS({\n  \"node_modules/prop-types/lib/has.js\"(exports2, module2) {\n    module2.exports = Function.call.bind(Object.prototype.hasOwnProperty);\n  }\n});\n\n// node_modules/prop-types/checkPropTypes.js\nvar require_checkPropTypes = __commonJS({\n  \"node_modules/prop-types/checkPropTypes.js\"(exports2, module2) {\n    \"use strict\";\n    var printWarning = function() {\n    };\n    if (true) {\n      ReactPropTypesSecret = require_ReactPropTypesSecret();\n      loggedTypeFailures = {};\n      has = require_has();\n      printWarning = function(text4) {\n        var message = \"Warning: \" + text4;\n        if (typeof console !== \"undefined\") {\n          console.error(message);\n        }\n        try {\n          throw new Error(message);\n        } catch (x4) {\n        }\n      };\n    }\n    var ReactPropTypesSecret;\n    var loggedTypeFailures;\n    var has;\n    function checkPropTypes(typeSpecs, values2, location, componentName, getStack) {\n      if (true) {\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error;\n            try {\n              if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                var err = Error(\n                  (componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\"\n                );\n                err.name = \"Invariant Violation\";\n                throw err;\n              }\n              error = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n            } catch (ex) {\n              error = ex;\n            }\n            if (error && !(error instanceof Error)) {\n              printWarning(\n                (componentName || \"React class\") + \": type specification of \" + location + \" `\" + typeSpecName + \"` is invalid; the type checker function must return `null` or an `Error` but returned a \" + typeof error + \". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\"\n              );\n            }\n            if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n              loggedTypeFailures[error.message] = true;\n              var stack = getStack ? getStack() : \"\";\n              printWarning(\n                \"Failed \" + location + \" type: \" + error.message + (stack != null ? stack : \"\")\n              );\n            }\n          }\n        }\n      }\n    }\n    checkPropTypes.resetWarningCache = function() {\n      if (true) {\n        loggedTypeFailures = {};\n      }\n    };\n    module2.exports = checkPropTypes;\n  }\n});\n\n// node_modules/prop-types/factoryWithTypeCheckers.js\nvar require_factoryWithTypeCheckers = __commonJS({\n  \"node_modules/prop-types/factoryWithTypeCheckers.js\"(exports2, module2) {\n    \"use strict\";\n    var ReactIs = require_react_is();\n    var assign = require_object_assign();\n    var ReactPropTypesSecret = require_ReactPropTypesSecret();\n    var has = require_has();\n    var checkPropTypes = require_checkPropTypes();\n    var printWarning = function() {\n    };\n    if (true) {\n      printWarning = function(text4) {\n        var message = \"Warning: \" + text4;\n        if (typeof console !== \"undefined\") {\n          console.error(message);\n        }\n        try {\n          throw new Error(message);\n        } catch (x4) {\n        }\n      };\n    }\n    function emptyFunctionThatReturnsNull() {\n      return null;\n    }\n    module2.exports = function(isValidElement3, throwOnDirectAccess) {\n      var ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\n      var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n      function getIteratorFn(maybeIterable) {\n        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n        if (typeof iteratorFn === \"function\") {\n          return iteratorFn;\n        }\n      }\n      var ANONYMOUS = \"<<anonymous>>\";\n      var ReactPropTypes = {\n        array: createPrimitiveTypeChecker(\"array\"),\n        bigint: createPrimitiveTypeChecker(\"bigint\"),\n        bool: createPrimitiveTypeChecker(\"boolean\"),\n        func: createPrimitiveTypeChecker(\"function\"),\n        number: createPrimitiveTypeChecker(\"number\"),\n        object: createPrimitiveTypeChecker(\"object\"),\n        string: createPrimitiveTypeChecker(\"string\"),\n        symbol: createPrimitiveTypeChecker(\"symbol\"),\n        any: createAnyTypeChecker(),\n        arrayOf: createArrayOfTypeChecker,\n        element: createElementTypeChecker(),\n        elementType: createElementTypeTypeChecker(),\n        instanceOf: createInstanceTypeChecker,\n        node: createNodeChecker(),\n        objectOf: createObjectOfTypeChecker,\n        oneOf: createEnumTypeChecker,\n        oneOfType: createUnionTypeChecker,\n        shape: createShapeTypeChecker,\n        exact: createStrictShapeTypeChecker\n      };\n      function is4(x4, y5) {\n        if (x4 === y5) {\n          return x4 !== 0 || 1 / x4 === 1 / y5;\n        } else {\n          return x4 !== x4 && y5 !== y5;\n        }\n      }\n      function PropTypeError(message, data) {\n        this.message = message;\n        this.data = data && typeof data === \"object\" ? data : {};\n        this.stack = \"\";\n      }\n      PropTypeError.prototype = Error.prototype;\n      function createChainableTypeChecker(validate) {\n        if (true) {\n          var manualPropTypeCallCache = {};\n          var manualPropTypeWarningCount = 0;\n        }\n        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n          componentName = componentName || ANONYMOUS;\n          propFullName = propFullName || propName;\n          if (secret !== ReactPropTypesSecret) {\n            if (throwOnDirectAccess) {\n              var err = new Error(\n                \"Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types\"\n              );\n              err.name = \"Invariant Violation\";\n              throw err;\n            } else if (typeof console !== \"undefined\") {\n              var cacheKey = componentName + \":\" + propName;\n              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors\n              manualPropTypeWarningCount < 3) {\n                printWarning(\n                  \"You are manually calling a React.PropTypes validation function for the `\" + propFullName + \"` prop on `\" + componentName + \"`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.\"\n                );\n                manualPropTypeCallCache[cacheKey] = true;\n                manualPropTypeWarningCount++;\n              }\n            }\n          }\n          if (props[propName] == null) {\n            if (isRequired) {\n              if (props[propName] === null) {\n                return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + (\"in `\" + componentName + \"`, but its value is `null`.\"));\n              }\n              return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required in \" + (\"`\" + componentName + \"`, but its value is `undefined`.\"));\n            }\n            return null;\n          } else {\n            return validate(props, propName, componentName, location, propFullName);\n          }\n        }\n        var chainedCheckType = checkType.bind(null, false);\n        chainedCheckType.isRequired = checkType.bind(null, true);\n        return chainedCheckType;\n      }\n      function createPrimitiveTypeChecker(expectedType) {\n        function validate(props, propName, componentName, location, propFullName, secret) {\n          var propValue = props[propName];\n          var propType = getPropType(propValue);\n          if (propType !== expectedType) {\n            var preciseType = getPreciseType(propValue);\n            return new PropTypeError(\n              \"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + preciseType + \"` supplied to `\" + componentName + \"`, expected \") + (\"`\" + expectedType + \"`.\"),\n              { expectedType }\n            );\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createAnyTypeChecker() {\n        return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n      }\n      function createArrayOfTypeChecker(typeChecker) {\n        function validate(props, propName, componentName, location, propFullName) {\n          if (typeof typeChecker !== \"function\") {\n            return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside arrayOf.\");\n          }\n          var propValue = props[propName];\n          if (!Array.isArray(propValue)) {\n            var propType = getPropType(propValue);\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an array.\"));\n          }\n          for (var i5 = 0; i5 < propValue.length; i5++) {\n            var error = typeChecker(propValue, i5, componentName, location, propFullName + \"[\" + i5 + \"]\", ReactPropTypesSecret);\n            if (error instanceof Error) {\n              return error;\n            }\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createElementTypeChecker() {\n        function validate(props, propName, componentName, location, propFullName) {\n          var propValue = props[propName];\n          if (!isValidElement3(propValue)) {\n            var propType = getPropType(propValue);\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement.\"));\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createElementTypeTypeChecker() {\n        function validate(props, propName, componentName, location, propFullName) {\n          var propValue = props[propName];\n          if (!ReactIs.isValidElementType(propValue)) {\n            var propType = getPropType(propValue);\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement type.\"));\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createInstanceTypeChecker(expectedClass) {\n        function validate(props, propName, componentName, location, propFullName) {\n          if (!(props[propName] instanceof expectedClass)) {\n            var expectedClassName = expectedClass.name || ANONYMOUS;\n            var actualClassName = getClassName(props[propName]);\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + actualClassName + \"` supplied to `\" + componentName + \"`, expected \") + (\"instance of `\" + expectedClassName + \"`.\"));\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createEnumTypeChecker(expectedValues) {\n        if (!Array.isArray(expectedValues)) {\n          if (true) {\n            if (arguments.length > 1) {\n              printWarning(\n                \"Invalid arguments supplied to oneOf, expected an array, got \" + arguments.length + \" arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\"\n              );\n            } else {\n              printWarning(\"Invalid argument supplied to oneOf, expected an array.\");\n            }\n          }\n          return emptyFunctionThatReturnsNull;\n        }\n        function validate(props, propName, componentName, location, propFullName) {\n          var propValue = props[propName];\n          for (var i5 = 0; i5 < expectedValues.length; i5++) {\n            if (is4(propValue, expectedValues[i5])) {\n              return null;\n            }\n          }\n          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n            var type = getPreciseType(value);\n            if (type === \"symbol\") {\n              return String(value);\n            }\n            return value;\n          });\n          return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of value `\" + String(propValue) + \"` \" + (\"supplied to `\" + componentName + \"`, expected one of \" + valuesString + \".\"));\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createObjectOfTypeChecker(typeChecker) {\n        function validate(props, propName, componentName, location, propFullName) {\n          if (typeof typeChecker !== \"function\") {\n            return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside objectOf.\");\n          }\n          var propValue = props[propName];\n          var propType = getPropType(propValue);\n          if (propType !== \"object\") {\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an object.\"));\n          }\n          for (var key in propValue) {\n            if (has(propValue, key)) {\n              var error = typeChecker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n              if (error instanceof Error) {\n                return error;\n              }\n            }\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createUnionTypeChecker(arrayOfTypeCheckers) {\n        if (!Array.isArray(arrayOfTypeCheckers)) {\n          true ? printWarning(\"Invalid argument supplied to oneOfType, expected an instance of array.\") : void 0;\n          return emptyFunctionThatReturnsNull;\n        }\n        for (var i5 = 0; i5 < arrayOfTypeCheckers.length; i5++) {\n          var checker = arrayOfTypeCheckers[i5];\n          if (typeof checker !== \"function\") {\n            printWarning(\n              \"Invalid argument supplied to oneOfType. Expected an array of check functions, but received \" + getPostfixForTypeWarning(checker) + \" at index \" + i5 + \".\"\n            );\n            return emptyFunctionThatReturnsNull;\n          }\n        }\n        function validate(props, propName, componentName, location, propFullName) {\n          var expectedTypes = [];\n          for (var i6 = 0; i6 < arrayOfTypeCheckers.length; i6++) {\n            var checker2 = arrayOfTypeCheckers[i6];\n            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n            if (checkerResult == null) {\n              return null;\n            }\n            if (checkerResult.data && has(checkerResult.data, \"expectedType\")) {\n              expectedTypes.push(checkerResult.data.expectedType);\n            }\n          }\n          var expectedTypesMessage = expectedTypes.length > 0 ? \", expected one of type [\" + expectedTypes.join(\", \") + \"]\" : \"\";\n          return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`\" + expectedTypesMessage + \".\"));\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createNodeChecker() {\n        function validate(props, propName, componentName, location, propFullName) {\n          if (!isNode2(props[propName])) {\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`, expected a ReactNode.\"));\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function invalidValidatorError(componentName, location, propFullName, key, type) {\n        return new PropTypeError(\n          (componentName || \"React class\") + \": \" + location + \" type `\" + propFullName + \".\" + key + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + type + \"`.\"\n        );\n      }\n      function createShapeTypeChecker(shapeTypes) {\n        function validate(props, propName, componentName, location, propFullName) {\n          var propValue = props[propName];\n          var propType = getPropType(propValue);\n          if (propType !== \"object\") {\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n          }\n          for (var key in shapeTypes) {\n            var checker = shapeTypes[key];\n            if (typeof checker !== \"function\") {\n              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n            }\n            var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n            if (error) {\n              return error;\n            }\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createStrictShapeTypeChecker(shapeTypes) {\n        function validate(props, propName, componentName, location, propFullName) {\n          var propValue = props[propName];\n          var propType = getPropType(propValue);\n          if (propType !== \"object\") {\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n          }\n          var allKeys = assign({}, props[propName], shapeTypes);\n          for (var key in allKeys) {\n            var checker = shapeTypes[key];\n            if (has(shapeTypes, key) && typeof checker !== \"function\") {\n              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n            }\n            if (!checker) {\n              return new PropTypeError(\n                \"Invalid \" + location + \" `\" + propFullName + \"` key `\" + key + \"` supplied to `\" + componentName + \"`.\\nBad object: \" + JSON.stringify(props[propName], null, \"  \") + \"\\nValid keys: \" + JSON.stringify(Object.keys(shapeTypes), null, \"  \")\n              );\n            }\n            var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n            if (error) {\n              return error;\n            }\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function isNode2(propValue) {\n        switch (typeof propValue) {\n          case \"number\":\n          case \"string\":\n          case \"undefined\":\n            return true;\n          case \"boolean\":\n            return !propValue;\n          case \"object\":\n            if (Array.isArray(propValue)) {\n              return propValue.every(isNode2);\n            }\n            if (propValue === null || isValidElement3(propValue)) {\n              return true;\n            }\n            var iteratorFn = getIteratorFn(propValue);\n            if (iteratorFn) {\n              var iterator = iteratorFn.call(propValue);\n              var step;\n              if (iteratorFn !== propValue.entries) {\n                while (!(step = iterator.next()).done) {\n                  if (!isNode2(step.value)) {\n                    return false;\n                  }\n                }\n              } else {\n                while (!(step = iterator.next()).done) {\n                  var entry = step.value;\n                  if (entry) {\n                    if (!isNode2(entry[1])) {\n                      return false;\n                    }\n                  }\n                }\n              }\n            } else {\n              return false;\n            }\n            return true;\n          default:\n            return false;\n        }\n      }\n      function isSymbol2(propType, propValue) {\n        if (propType === \"symbol\") {\n          return true;\n        }\n        if (!propValue) {\n          return false;\n        }\n        if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n          return true;\n        }\n        if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n          return true;\n        }\n        return false;\n      }\n      function getPropType(propValue) {\n        var propType = typeof propValue;\n        if (Array.isArray(propValue)) {\n          return \"array\";\n        }\n        if (propValue instanceof RegExp) {\n          return \"object\";\n        }\n        if (isSymbol2(propType, propValue)) {\n          return \"symbol\";\n        }\n        return propType;\n      }\n      function getPreciseType(propValue) {\n        if (typeof propValue === \"undefined\" || propValue === null) {\n          return \"\" + propValue;\n        }\n        var propType = getPropType(propValue);\n        if (propType === \"object\") {\n          if (propValue instanceof Date) {\n            return \"date\";\n          } else if (propValue instanceof RegExp) {\n            return \"regexp\";\n          }\n        }\n        return propType;\n      }\n      function getPostfixForTypeWarning(value) {\n        var type = getPreciseType(value);\n        switch (type) {\n          case \"array\":\n          case \"object\":\n            return \"an \" + type;\n          case \"boolean\":\n          case \"date\":\n          case \"regexp\":\n            return \"a \" + type;\n          default:\n            return type;\n        }\n      }\n      function getClassName(propValue) {\n        if (!propValue.constructor || !propValue.constructor.name) {\n          return ANONYMOUS;\n        }\n        return propValue.constructor.name;\n      }\n      ReactPropTypes.checkPropTypes = checkPropTypes;\n      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n      ReactPropTypes.PropTypes = ReactPropTypes;\n      return ReactPropTypes;\n    };\n  }\n});\n\n// node_modules/prop-types/index.js\nvar require_prop_types = __commonJS({\n  \"node_modules/prop-types/index.js\"(exports2, module2) {\n    if (true) {\n      ReactIs = require_react_is();\n      throwOnDirectAccess = true;\n      module2.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);\n    } else {\n      module2.exports = null();\n    }\n    var ReactIs;\n    var throwOnDirectAccess;\n  }\n});\n\n// node_modules/downshift/node_modules/react-is/cjs/react-is.development.js\nvar require_react_is_development2 = __commonJS({\n  \"node_modules/downshift/node_modules/react-is/cjs/react-is.development.js\"(exports2) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        var REACT_ELEMENT_TYPE = 60103;\n        var REACT_PORTAL_TYPE = 60106;\n        var REACT_FRAGMENT_TYPE = 60107;\n        var REACT_STRICT_MODE_TYPE = 60108;\n        var REACT_PROFILER_TYPE = 60114;\n        var REACT_PROVIDER_TYPE = 60109;\n        var REACT_CONTEXT_TYPE = 60110;\n        var REACT_FORWARD_REF_TYPE = 60112;\n        var REACT_SUSPENSE_TYPE = 60113;\n        var REACT_SUSPENSE_LIST_TYPE = 60120;\n        var REACT_MEMO_TYPE = 60115;\n        var REACT_LAZY_TYPE = 60116;\n        var REACT_BLOCK_TYPE = 60121;\n        var REACT_SERVER_BLOCK_TYPE = 60122;\n        var REACT_FUNDAMENTAL_TYPE = 60117;\n        var REACT_SCOPE_TYPE = 60119;\n        var REACT_OPAQUE_ID_TYPE = 60128;\n        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;\n        var REACT_OFFSCREEN_TYPE = 60130;\n        var REACT_LEGACY_HIDDEN_TYPE = 60131;\n        if (typeof Symbol === \"function\" && Symbol.for) {\n          var symbolFor = Symbol.for;\n          REACT_ELEMENT_TYPE = symbolFor(\"react.element\");\n          REACT_PORTAL_TYPE = symbolFor(\"react.portal\");\n          REACT_FRAGMENT_TYPE = symbolFor(\"react.fragment\");\n          REACT_STRICT_MODE_TYPE = symbolFor(\"react.strict_mode\");\n          REACT_PROFILER_TYPE = symbolFor(\"react.profiler\");\n          REACT_PROVIDER_TYPE = symbolFor(\"react.provider\");\n          REACT_CONTEXT_TYPE = symbolFor(\"react.context\");\n          REACT_FORWARD_REF_TYPE = symbolFor(\"react.forward_ref\");\n          REACT_SUSPENSE_TYPE = symbolFor(\"react.suspense\");\n          REACT_SUSPENSE_LIST_TYPE = symbolFor(\"react.suspense_list\");\n          REACT_MEMO_TYPE = symbolFor(\"react.memo\");\n          REACT_LAZY_TYPE = symbolFor(\"react.lazy\");\n          REACT_BLOCK_TYPE = symbolFor(\"react.block\");\n          REACT_SERVER_BLOCK_TYPE = symbolFor(\"react.server.block\");\n          REACT_FUNDAMENTAL_TYPE = symbolFor(\"react.fundamental\");\n          REACT_SCOPE_TYPE = symbolFor(\"react.scope\");\n          REACT_OPAQUE_ID_TYPE = symbolFor(\"react.opaque.id\");\n          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor(\"react.debug_trace_mode\");\n          REACT_OFFSCREEN_TYPE = symbolFor(\"react.offscreen\");\n          REACT_LEGACY_HIDDEN_TYPE = symbolFor(\"react.legacy_hidden\");\n        }\n        var enableScopeAPI = false;\n        function isValidElementType(type) {\n          if (typeof type === \"string\" || typeof type === \"function\") {\n            return true;\n          }\n          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {\n            return true;\n          }\n          if (typeof type === \"object\" && type !== null) {\n            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {\n              return true;\n            }\n          }\n          return false;\n        }\n        function typeOf(object) {\n          if (typeof object === \"object\" && object !== null) {\n            var $$typeof = object.$$typeof;\n            switch ($$typeof) {\n              case REACT_ELEMENT_TYPE:\n                var type = object.type;\n                switch (type) {\n                  case REACT_FRAGMENT_TYPE:\n                  case REACT_PROFILER_TYPE:\n                  case REACT_STRICT_MODE_TYPE:\n                  case REACT_SUSPENSE_TYPE:\n                  case REACT_SUSPENSE_LIST_TYPE:\n                    return type;\n                  default:\n                    var $$typeofType = type && type.$$typeof;\n                    switch ($$typeofType) {\n                      case REACT_CONTEXT_TYPE:\n                      case REACT_FORWARD_REF_TYPE:\n                      case REACT_LAZY_TYPE:\n                      case REACT_MEMO_TYPE:\n                      case REACT_PROVIDER_TYPE:\n                        return $$typeofType;\n                      default:\n                        return $$typeof;\n                    }\n                }\n              case REACT_PORTAL_TYPE:\n                return $$typeof;\n            }\n          }\n          return void 0;\n        }\n        var ContextConsumer = REACT_CONTEXT_TYPE;\n        var ContextProvider = REACT_PROVIDER_TYPE;\n        var Element4 = REACT_ELEMENT_TYPE;\n        var ForwardRef = REACT_FORWARD_REF_TYPE;\n        var Fragment3 = REACT_FRAGMENT_TYPE;\n        var Lazy = REACT_LAZY_TYPE;\n        var Memo = REACT_MEMO_TYPE;\n        var Portal = REACT_PORTAL_TYPE;\n        var Profiler = REACT_PROFILER_TYPE;\n        var StrictMode = REACT_STRICT_MODE_TYPE;\n        var Suspense = REACT_SUSPENSE_TYPE;\n        var hasWarnedAboutDeprecatedIsAsyncMode = false;\n        var hasWarnedAboutDeprecatedIsConcurrentMode = false;\n        function isAsyncMode(object) {\n          {\n            if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n              hasWarnedAboutDeprecatedIsAsyncMode = true;\n              console[\"warn\"](\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.\");\n            }\n          }\n          return false;\n        }\n        function isConcurrentMode(object) {\n          {\n            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {\n              hasWarnedAboutDeprecatedIsConcurrentMode = true;\n              console[\"warn\"](\"The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.\");\n            }\n          }\n          return false;\n        }\n        function isContextConsumer(object) {\n          return typeOf(object) === REACT_CONTEXT_TYPE;\n        }\n        function isContextProvider(object) {\n          return typeOf(object) === REACT_PROVIDER_TYPE;\n        }\n        function isElement7(object) {\n          return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n        }\n        function isForwardRef2(object) {\n          return typeOf(object) === REACT_FORWARD_REF_TYPE;\n        }\n        function isFragment(object) {\n          return typeOf(object) === REACT_FRAGMENT_TYPE;\n        }\n        function isLazy(object) {\n          return typeOf(object) === REACT_LAZY_TYPE;\n        }\n        function isMemo(object) {\n          return typeOf(object) === REACT_MEMO_TYPE;\n        }\n        function isPortal(object) {\n          return typeOf(object) === REACT_PORTAL_TYPE;\n        }\n        function isProfiler(object) {\n          return typeOf(object) === REACT_PROFILER_TYPE;\n        }\n        function isStrictMode(object) {\n          return typeOf(object) === REACT_STRICT_MODE_TYPE;\n        }\n        function isSuspense(object) {\n          return typeOf(object) === REACT_SUSPENSE_TYPE;\n        }\n        exports2.ContextConsumer = ContextConsumer;\n        exports2.ContextProvider = ContextProvider;\n        exports2.Element = Element4;\n        exports2.ForwardRef = ForwardRef;\n        exports2.Fragment = Fragment3;\n        exports2.Lazy = Lazy;\n        exports2.Memo = Memo;\n        exports2.Portal = Portal;\n        exports2.Profiler = Profiler;\n        exports2.StrictMode = StrictMode;\n        exports2.Suspense = Suspense;\n        exports2.isAsyncMode = isAsyncMode;\n        exports2.isConcurrentMode = isConcurrentMode;\n        exports2.isContextConsumer = isContextConsumer;\n        exports2.isContextProvider = isContextProvider;\n        exports2.isElement = isElement7;\n        exports2.isForwardRef = isForwardRef2;\n        exports2.isFragment = isFragment;\n        exports2.isLazy = isLazy;\n        exports2.isMemo = isMemo;\n        exports2.isPortal = isPortal;\n        exports2.isProfiler = isProfiler;\n        exports2.isStrictMode = isStrictMode;\n        exports2.isSuspense = isSuspense;\n        exports2.isValidElementType = isValidElementType;\n        exports2.typeOf = typeOf;\n      })();\n    }\n  }\n});\n\n// node_modules/downshift/node_modules/react-is/index.js\nvar require_react_is2 = __commonJS({\n  \"node_modules/downshift/node_modules/react-is/index.js\"(exports2, module2) {\n    \"use strict\";\n    if (false) {\n      module2.exports = null;\n    } else {\n      module2.exports = require_react_is_development2();\n    }\n  }\n});\n\n// node_modules/tw-react/dist/plugins/linonetwo/tw-react/index.js\nvar require_tw_react = __commonJS({\n  \"node_modules/tw-react/dist/plugins/linonetwo/tw-react/index.js\"(exports2, module2) {\n    \"use strict\";\n    var __defProp2 = Object.defineProperty;\n    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;\n    var __getOwnPropNames2 = Object.getOwnPropertyNames;\n    var __hasOwnProp2 = Object.prototype.hasOwnProperty;\n    var __export2 = (target, all) => {\n      for (var name in all)\n        __defProp2(target, name, { get: all[name], enumerable: true });\n    };\n    var __copyProps2 = (to, from, except, desc) => {\n      if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames2(from))\n          if (!__hasOwnProp2.call(to, key) && key !== except)\n            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });\n      }\n      return to;\n    };\n    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, \"__esModule\", { value: true }), mod);\n    var src_exports = {};\n    __export2(src_exports, {\n      ParentWidgetContext: () => ParentWidgetContext3,\n      useFilter: () => useFilter2,\n      useRenderTiddler: () => useRenderTiddler,\n      useWidget: () => useWidget2\n    });\n    module2.exports = __toCommonJS(src_exports);\n    var import_react71 = require(\"react\");\n    function useFilter2(twFilter, widget4 = $tw.rootWidget, dependencies = []) {\n      const [filterResult, setFilterResult] = (0, import_react71.useState)([]);\n      const compiledFilter = (0, import_react71.useMemo)(() => $tw.wiki.compileFilter(twFilter), [twFilter]);\n      (0, import_react71.useEffect)(() => {\n        setFilterResult(compiledFilter(void 0, widget4));\n      }, [compiledFilter, widget4, ...dependencies]);\n      return filterResult;\n    }\n    var import_react310 = require(\"react\");\n    var import_react210 = require(\"react\");\n    var ParentWidgetContext3 = (0, import_react210.createContext)(void 0);\n    function useRenderTiddler(tiddlerTitle, containerReference, options) {\n      const parentWidget = (0, import_react310.useContext)(ParentWidgetContext3);\n      (0, import_react310.useEffect)(() => {\n        const domNode = containerReference.current;\n        if (domNode === null) {\n          return;\n        }\n        if (parentWidget === void 0) {\n          throw new Error(\n            \"Your plugin have a bug: `parentWidget` is undefined, you should use `<ParentWidgetContext.Provider value={props.parentWidget}>`, see tw-react for document.\"\n          );\n        }\n        if (options?.skip === true) {\n          return;\n        }\n        const id = String(Math.random());\n        const transcludeWidgetNode = $tw.wiki.makeTranscludeWidget(tiddlerTitle, {\n          document,\n          parentWidget,\n          recursionMarker: \"yes\",\n          mode: \"block\",\n          importPageMacros: true,\n          variables: { \"use-widget-id\": id }\n        });\n        const tiddlerContainer = document.createElement(\"div\");\n        domNode.append(tiddlerContainer);\n        transcludeWidgetNode.render(tiddlerContainer, null);\n        parentWidget.children.push(transcludeWidgetNode);\n        return () => {\n          parentWidget.children = parentWidget.children.filter((child) => child.getVariable(\"use-widget-id\") !== id);\n          if (domNode === null) {\n            return;\n          }\n          domNode.textContent = \"\";\n        };\n      }, [tiddlerTitle, containerReference]);\n    }\n    var import_react410 = require(\"react\");\n    function useWidget2(parseTreeNode, containerReference, options) {\n      const parentWidget = (0, import_react410.useContext)(ParentWidgetContext3);\n      (0, import_react410.useEffect)(() => {\n        const domNode = containerReference.current;\n        if (domNode === null) {\n          return;\n        }\n        if (parentWidget === void 0) {\n          throw new Error(\n            \"Your plugin have a bug: `parentWidget` is undefined, you should use `<ParentWidgetContext.Provider value={props.parentWidget}>`, see tw-react for document.\"\n          );\n        }\n        if (options?.skip === true) {\n          return;\n        }\n        const id = String(Math.random());\n        const newWidgetNode = parentWidget.makeChildWidget(parseTreeNode, { variables: { \"use-widget-id\": id } });\n        newWidgetNode.render(domNode, null);\n        parentWidget.children.push(newWidgetNode);\n        return () => {\n          parentWidget.children = parentWidget.children.filter((child) => child.getVariable(\"use-widget-id\") !== id);\n          if (domNode === null) {\n            return;\n          }\n          domNode.textContent = \"\";\n        };\n      }, [parseTreeNode, containerReference, parentWidget, options?.skip]);\n    }\n  }\n});\n\n// src/editor/editor.tsx\nvar import_react70 = __toESM(require(\"react\"));\n\n// node_modules/jotai/esm/index.js\nvar import_react = require(\"react\");\nvar import_meta = {};\nvar SUSPENSE_PROMISE = Symbol();\nvar isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];\nvar isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;\nvar cancelSuspensePromise = (suspensePromise) => {\n  var _a;\n  const { b: basePromise, c: cancelPromise } = suspensePromise[SUSPENSE_PROMISE];\n  if (cancelPromise) {\n    cancelPromise();\n    (_a = promiseAbortMap.get(basePromise)) == null ? void 0 : _a();\n  }\n};\nvar isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {\n  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nvar createSuspensePromise = (basePromise, promise) => {\n  const suspensePromiseExtra = {\n    b: basePromise,\n    o: promise,\n    c: null\n  };\n  const suspensePromise = new Promise((resolve) => {\n    suspensePromiseExtra.c = () => {\n      suspensePromiseExtra.c = null;\n      resolve();\n    };\n    promise.finally(suspensePromiseExtra.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = suspensePromiseExtra;\n  return suspensePromise;\n};\nvar promiseAbortMap = /* @__PURE__ */ new WeakMap();\nvar hasInitialValue = (atom2) => \"init\" in atom2;\nvar READ_ATOM = \"r\";\nvar WRITE_ATOM = \"w\";\nvar COMMIT_ATOM = \"c\";\nvar SUBSCRIBE_ATOM = \"s\";\nvar RESTORE_ATOMS = \"h\";\nvar DEV_SUBSCRIBE_STATE = \"n\";\nvar DEV_GET_MOUNTED_ATOMS = \"l\";\nvar DEV_GET_ATOM_STATE = \"a\";\nvar DEV_GET_MOUNTED = \"m\";\nvar createStore = (initialValues) => {\n  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import_meta.env && import_meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  if (initialValues) {\n    for (const [atom2, value] of initialValues) {\n      const atomState = {\n        v: value,\n        r: 0,\n        y: true,\n        d: /* @__PURE__ */ new Map()\n      };\n      if ((import_meta.env && import_meta.env.MODE) !== \"production\") {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom2)) {\n          console.warn(\n            \"Found initial value for derived atom which can cause unexpected behavior\",\n            atom2\n          );\n        }\n      }\n      committedAtomStateMap.set(atom2, atomState);\n    }\n  }\n  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();\n  const addSuspensePromiseToCache = (version2, atom2, suspensePromise) => {\n    let cache2 = suspensePromiseCacheMap.get(atom2);\n    if (!cache2) {\n      cache2 = /* @__PURE__ */ new Map();\n      suspensePromiseCacheMap.set(atom2, cache2);\n    }\n    suspensePromise.then(() => {\n      if (cache2.get(version2) === suspensePromise) {\n        cache2.delete(version2);\n        if (!cache2.size) {\n          suspensePromiseCacheMap.delete(atom2);\n        }\n      }\n    });\n    cache2.set(version2, suspensePromise);\n  };\n  const cancelAllSuspensePromiseInCache = (atom2) => {\n    const versionSet = /* @__PURE__ */ new Set();\n    const cache2 = suspensePromiseCacheMap.get(atom2);\n    if (cache2) {\n      suspensePromiseCacheMap.delete(atom2);\n      cache2.forEach((suspensePromise, version2) => {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version2);\n      });\n    }\n    return versionSet;\n  };\n  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();\n  const getVersionedAtomStateMap = (version2) => {\n    let versionedAtomStateMap = versionedAtomStateMapMap.get(version2);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */ new Map();\n      versionedAtomStateMapMap.set(version2, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  const getAtomState = (version2, atom2) => {\n    if (version2) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version2);\n      let atomState = versionedAtomStateMap.get(atom2);\n      if (!atomState) {\n        atomState = getAtomState(version2.p, atom2);\n        if (atomState) {\n          versionedAtomStateMap.set(atom2, atomState);\n        }\n      }\n      return atomState;\n    }\n    return committedAtomStateMap.get(atom2);\n  };\n  const setAtomState = (version2, atom2, atomState) => {\n    if ((import_meta.env && import_meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    if (version2) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version2);\n      versionedAtomStateMap.set(atom2, atomState);\n    } else {\n      const prevAtomState = committedAtomStateMap.get(atom2);\n      committedAtomStateMap.set(atom2, atomState);\n      if (!pendingMap.has(atom2)) {\n        pendingMap.set(atom2, prevAtomState);\n      }\n    }\n  };\n  const createReadDependencies = (version2, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    const readDependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    dependencies.forEach((atom2) => {\n      var _a;\n      const revision = ((_a = getAtomState(version2, atom2)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom2, revision);\n      if (prevReadDependencies.get(atom2) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  const setAtomValue = (version2, atom2, value, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version2, atom2);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      y: true,\n      d: createReadDependencies(version2, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    let changed = !(atomState == null ? void 0 : atomState.y);\n    if (!atomState || !(\"v\" in atomState) || !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom2)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom2, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a7) => atomState.d.has(a7)))) {\n      changed = true;\n      Promise.resolve().then(() => {\n        flushPending(version2);\n      });\n    }\n    if (atomState && !changed) {\n      return atomState;\n    }\n    setAtomState(version2, atom2, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomReadError = (version2, atom2, error, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version2, atom2);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      e: error,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      d: createReadDependencies(version2, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version2, atom2, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomSuspensePromise = (version2, atom2, suspensePromise, dependencies) => {\n    const atomState = getAtomState(version2, atom2);\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise)) {\n        if (!atomState.y) {\n          return { ...atomState, y: true };\n        }\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version2, atom2, suspensePromise);\n    const nextAtomState = {\n      p: suspensePromise,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      d: createReadDependencies(version2, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version2, atom2, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomPromiseOrValue = (version2, atom2, promiseOrValue, dependencies) => {\n    if (promiseOrValue instanceof Promise) {\n      const suspensePromise = createSuspensePromise(\n        promiseOrValue,\n        promiseOrValue.then((value) => {\n          setAtomValue(version2, atom2, value, dependencies, suspensePromise);\n        }).catch((e4) => {\n          if (e4 instanceof Promise) {\n            if (isSuspensePromise(e4)) {\n              return e4.then(() => {\n                readAtomState(version2, atom2, true);\n              });\n            }\n            return e4;\n          }\n          setAtomReadError(version2, atom2, e4, dependencies, suspensePromise);\n        })\n      );\n      return setAtomSuspensePromise(\n        version2,\n        atom2,\n        suspensePromise,\n        dependencies\n      );\n    }\n    return setAtomValue(\n      version2,\n      atom2,\n      promiseOrValue,\n      dependencies\n    );\n  };\n  const setAtomInvalidated = (version2, atom2) => {\n    const atomState = getAtomState(version2, atom2);\n    if (atomState) {\n      const nextAtomState = {\n        ...atomState,\n        y: false\n      };\n      setAtomState(version2, atom2, nextAtomState);\n    } else if ((import_meta.env && import_meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom2);\n    }\n  };\n  const readAtomState = (version2, atom2, force) => {\n    if (!force) {\n      const atomState = getAtomState(version2, atom2);\n      if (atomState) {\n        if (atomState.y && \"p\" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          return atomState;\n        }\n        atomState.d.forEach((_2, a7) => {\n          if (a7 !== atom2) {\n            if (!mountedMap.has(a7)) {\n              readAtomState(version2, a7);\n            } else {\n              const aState = getAtomState(version2, a7);\n              if (aState && !aState.y) {\n                readAtomState(version2, a7);\n              }\n            }\n          }\n        });\n        if (Array.from(atomState.d).every(([a7, r7]) => {\n          const aState = getAtomState(version2, a7);\n          return aState && !(\"p\" in aState) && aState.r === r7;\n        })) {\n          if (!atomState.y) {\n            return { ...atomState, y: true };\n          }\n          return atomState;\n        }\n      }\n    }\n    const dependencies = /* @__PURE__ */ new Set();\n    try {\n      const promiseOrValue = atom2.read((a7) => {\n        dependencies.add(a7);\n        const aState = a7 === atom2 ? getAtomState(version2, a7) : readAtomState(version2, a7);\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a7)) {\n          return a7.init;\n        }\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version2, atom2, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        const suspensePromise = createSuspensePromise(\n          errorOrPromise,\n          errorOrPromise\n        );\n        return setAtomSuspensePromise(\n          version2,\n          atom2,\n          suspensePromise,\n          dependencies\n        );\n      }\n      return setAtomReadError(version2, atom2, errorOrPromise, dependencies);\n    }\n  };\n  const readAtom = (readingAtom, version2) => {\n    const atomState = readAtomState(version2, readingAtom);\n    return atomState;\n  };\n  const addAtom = (version2, addingAtom) => {\n    let mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(version2, addingAtom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom2, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom2));\n  const delAtom = (version2, deletingAtom) => {\n    const mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(version2, deletingAtom);\n    }\n  };\n  const invalidateDependents = (version2, atom2) => {\n    const mounted = mountedMap.get(atom2);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom2) {\n        setAtomInvalidated(version2, dependent);\n        invalidateDependents(version2, dependent);\n      }\n    });\n  };\n  const writeAtomState = (version2, atom2, update) => {\n    let isSync = true;\n    const writeGetter = (a7, options) => {\n      const aState = readAtomState(version2, a7);\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(\n            () => writeGetter(a7, options)\n          );\n        }\n        if ((import_meta.env && import_meta.env.MODE) !== \"production\") {\n          console.info(\n            \"Reading pending atom state in write operation. We throw a promise for now.\",\n            a7\n          );\n        }\n        throw aState.p;\n      }\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n      if ((import_meta.env && import_meta.env.MODE) !== \"production\") {\n        console.warn(\n          \"[Bug] no value found while reading atom in write operation. This is probably a bug.\",\n          a7\n        );\n      }\n      throw new Error(\"no value found\");\n    };\n    const setter = (a7, v4) => {\n      let promiseOrVoid2;\n      if (a7 === atom2) {\n        if (!hasInitialValue(a7)) {\n          throw new Error(\"atom not writable\");\n        }\n        const versionSet = cancelAllSuspensePromiseInCache(a7);\n        versionSet.forEach((cancelledVersion) => {\n          if (cancelledVersion !== version2) {\n            setAtomPromiseOrValue(cancelledVersion, a7, v4);\n          }\n        });\n        const prevAtomState = getAtomState(version2, a7);\n        const nextAtomState = setAtomPromiseOrValue(version2, a7, v4);\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version2, a7);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version2, a7, v4);\n      }\n      if (!isSync) {\n        flushPending(version2);\n      }\n      return promiseOrVoid2;\n    };\n    const promiseOrVoid = atom2.write(writeGetter, setter, update);\n    isSync = false;\n    return promiseOrVoid;\n  };\n  const writeAtom = (writingAtom, update, version2) => {\n    const promiseOrVoid = writeAtomState(version2, writingAtom, update);\n    flushPending(version2);\n    return promiseOrVoid;\n  };\n  const isActuallyWritableAtom = (atom2) => !!atom2.write;\n  const mountAtom = (version2, atom2, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom2, mounted);\n    if ((import_meta.env && import_meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom2);\n    }\n    const atomState = readAtomState(void 0, atom2);\n    atomState.d.forEach((_2, a7) => {\n      const aMounted = mountedMap.get(a7);\n      if (aMounted) {\n        aMounted.t.add(atom2);\n      } else {\n        if (a7 !== atom2) {\n          mountAtom(version2, a7, atom2);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom2) && atom2.onMount) {\n      const setAtom = (update) => writeAtom(atom2, update, version2);\n      const onUnmount = atom2.onMount(setAtom);\n      version2 = void 0;\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (version2, atom2) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom2)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom2);\n    if ((import_meta.env && import_meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom2);\n    }\n    const atomState = getAtomState(version2, atom2);\n    if (atomState) {\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n      atomState.d.forEach((_2, a7) => {\n        if (a7 !== atom2) {\n          const mounted = mountedMap.get(a7);\n          if (mounted) {\n            mounted.t.delete(atom2);\n            if (canUnmountAtom(a7, mounted)) {\n              unmountAtom(version2, a7);\n            }\n          }\n        }\n      });\n    } else if ((import_meta.env && import_meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom2);\n    }\n  };\n  const mountDependencies = (version2, atom2, atomState, prevReadDependencies) => {\n    const dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_2, a7) => {\n      if (dependencies.has(a7)) {\n        dependencies.delete(a7);\n        return;\n      }\n      const mounted = mountedMap.get(a7);\n      if (mounted) {\n        mounted.t.delete(atom2);\n        if (canUnmountAtom(a7, mounted)) {\n          unmountAtom(version2, a7);\n        }\n      }\n    });\n    dependencies.forEach((a7) => {\n      const mounted = mountedMap.get(a7);\n      if (mounted) {\n        mounted.t.add(atom2);\n      } else if (mountedMap.has(atom2)) {\n        mountAtom(version2, a7, atom2);\n      }\n    });\n  };\n  const flushPending = (version2) => {\n    if (version2) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version2);\n      versionedAtomStateMap.forEach((atomState, atom2) => {\n        const committedAtomState = committedAtomStateMap.get(atom2);\n        if (atomState !== committedAtomState) {\n          const mounted = mountedMap.get(atom2);\n          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version2));\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom2, prevAtomState]) => {\n        const atomState = getAtomState(void 0, atom2);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(void 0, atom2, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (prevAtomState && !prevAtomState.y && (atomState == null ? void 0 : atomState.y)) {\n          return;\n        }\n        const mounted = mountedMap.get(atom2);\n        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());\n      });\n    }\n    if ((import_meta.env && import_meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l6) => l6());\n    }\n  };\n  const commitVersionedAtomStateMap = (version2) => {\n    const versionedAtomStateMap = getVersionedAtomStateMap(version2);\n    versionedAtomStateMap.forEach((atomState, atom2) => {\n      const prevAtomState = committedAtomStateMap.get(atom2);\n      if (!prevAtomState || atomState.r > prevAtomState.r || atomState.y !== prevAtomState.y || atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {\n        committedAtomStateMap.set(atom2, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(version2, atom2, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  const commitAtom = (_atom, version2) => {\n    if (version2) {\n      commitVersionedAtomStateMap(version2);\n    }\n    flushPending(void 0);\n  };\n  const subscribeAtom = (atom2, callback, version2) => {\n    const mounted = addAtom(version2, atom2);\n    const listeners = mounted.l;\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      delAtom(version2, atom2);\n    };\n  };\n  const restoreAtoms = (values2, version2) => {\n    for (const [atom2, value] of values2) {\n      if (hasInitialValue(atom2)) {\n        setAtomPromiseOrValue(version2, atom2, value);\n        invalidateDependents(version2, atom2);\n      }\n    }\n    flushPending(version2);\n  };\n  if ((import_meta.env && import_meta.env.MODE) !== \"production\") {\n    return {\n      [READ_ATOM]: readAtom,\n      [WRITE_ATOM]: writeAtom,\n      [COMMIT_ATOM]: commitAtom,\n      [SUBSCRIBE_ATOM]: subscribeAtom,\n      [RESTORE_ATOMS]: restoreAtoms,\n      [DEV_SUBSCRIBE_STATE]: (l6) => {\n        stateListeners.add(l6);\n        return () => {\n          stateListeners.delete(l6);\n        };\n      },\n      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),\n      [DEV_GET_ATOM_STATE]: (a7) => committedAtomStateMap.get(a7),\n      [DEV_GET_MOUNTED]: (a7) => mountedMap.get(a7)\n    };\n  }\n  return {\n    [READ_ATOM]: readAtom,\n    [WRITE_ATOM]: writeAtom,\n    [COMMIT_ATOM]: commitAtom,\n    [SUBSCRIBE_ATOM]: subscribeAtom,\n    [RESTORE_ATOMS]: restoreAtoms\n  };\n};\nvar createScopeContainer = (initialValues, unstable_createStore) => {\n  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return { s: store };\n};\nvar ScopeContextMap = /* @__PURE__ */ new Map();\nvar getScopeContext = (scope2) => {\n  if (!ScopeContextMap.has(scope2)) {\n    ScopeContextMap.set(scope2, (0, import_react.createContext)(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope2);\n};\nvar Provider = ({\n  children,\n  initialValues,\n  scope: scope2,\n  unstable_createStore,\n  unstable_enableVersionedWrite\n}) => {\n  const [version2, setVersion] = (0, import_react.useState)({});\n  (0, import_react.useEffect)(() => {\n    const scopeContainer = scopeContainerRef.current;\n    if (scopeContainer.w) {\n      scopeContainer.s[COMMIT_ATOM](null, version2);\n      delete version2.p;\n      scopeContainer.v = version2;\n    }\n  }, [version2]);\n  const scopeContainerRef = (0, import_react.useRef)();\n  if (!scopeContainerRef.current) {\n    const scopeContainer = createScopeContainer(\n      initialValues,\n      unstable_createStore\n    );\n    if (unstable_enableVersionedWrite) {\n      let retrying = 0;\n      scopeContainer.w = (write2) => {\n        setVersion((parentVersion) => {\n          const nextVersion = retrying ? parentVersion : { p: parentVersion };\n          write2(nextVersion);\n          return nextVersion;\n        });\n      };\n      scopeContainer.v = version2;\n      scopeContainer.r = (fn4) => {\n        ++retrying;\n        fn4();\n        --retrying;\n      };\n    }\n    scopeContainerRef.current = scopeContainer;\n  }\n  const ScopeContainerContext = getScopeContext(scope2);\n  return (0, import_react.createElement)(\n    ScopeContainerContext.Provider,\n    {\n      value: scopeContainerRef.current\n    },\n    children\n  );\n};\nvar keyCount = 0;\nfunction atom(read2, write2) {\n  const key = `atom${++keyCount}`;\n  const config2 = {\n    toString: () => key\n  };\n  if (typeof read2 === \"function\") {\n    config2.read = read2;\n  } else {\n    config2.init = read2;\n    config2.read = (get3) => get3(config2);\n    config2.write = (get3, set4, update) => set4(config2, typeof update === \"function\" ? update(get3(config2)) : update);\n  }\n  if (write2) {\n    config2.write = write2;\n  }\n  return config2;\n}\nfunction useAtomValue(atom2, scope2) {\n  const ScopeContext = getScopeContext(scope2);\n  const scopeContainer = (0, import_react.useContext)(ScopeContext);\n  const { s: store, v: versionFromProvider } = scopeContainer;\n  const getAtomValue = (version22) => {\n    const atomState = store[READ_ATOM](atom2, version22);\n    if ((import_meta.env && import_meta.env.MODE) !== \"production\" && !atomState.y) {\n      throw new Error(\"should not be invalidated\");\n    }\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n    throw new Error(\"no atom value\");\n  };\n  const [[version2, valueFromReducer, atomFromReducer], rerenderIfChanged] = (0, import_react.useReducer)(\n    (prev, nextVersion) => {\n      const nextValue = getAtomValue(nextVersion);\n      if (Object.is(prev[1], nextValue) && prev[2] === atom2) {\n        return prev;\n      }\n      return [nextVersion, nextValue, atom2];\n    },\n    versionFromProvider,\n    (initialVersion) => {\n      const initialValue = getAtomValue(initialVersion);\n      return [initialVersion, initialValue, atom2];\n    }\n  );\n  let value = valueFromReducer;\n  if (atomFromReducer !== atom2) {\n    rerenderIfChanged(version2);\n    value = getAtomValue(version2);\n  }\n  (0, import_react.useEffect)(() => {\n    const { v: versionFromProvider2 } = scopeContainer;\n    if (versionFromProvider2) {\n      store[COMMIT_ATOM](atom2, versionFromProvider2);\n    }\n    const unsubscribe = store[SUBSCRIBE_ATOM](\n      atom2,\n      rerenderIfChanged,\n      versionFromProvider2\n    );\n    rerenderIfChanged(versionFromProvider2);\n    return unsubscribe;\n  }, [store, atom2, scopeContainer]);\n  (0, import_react.useEffect)(() => {\n    store[COMMIT_ATOM](atom2, version2);\n  });\n  (0, import_react.useDebugValue)(value);\n  return value;\n}\nfunction useSetAtom(atom2, scope2) {\n  const ScopeContext = getScopeContext(scope2);\n  const { s: store, w: versionedWrite } = (0, import_react.useContext)(ScopeContext);\n  const setAtom = (0, import_react.useCallback)(\n    (update) => {\n      if ((import_meta.env && import_meta.env.MODE) !== \"production\" && !(\"write\" in atom2)) {\n        throw new Error(\"not writable atom\");\n      }\n      const write2 = (version2) => store[WRITE_ATOM](atom2, update, version2);\n      return versionedWrite ? versionedWrite(write2) : write2();\n    },\n    [store, versionedWrite, atom2]\n  );\n  return setAtom;\n}\nfunction useAtom(atom2, scope2) {\n  if (\"scope\" in atom2) {\n    console.warn(\n      \"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\"\n    );\n    scope2 = atom2.scope;\n  }\n  return [\n    useAtomValue(atom2, scope2),\n    useSetAtom(atom2, scope2)\n  ];\n}\n\n// node_modules/@udecode/plate-core/dist/index.es.js\nvar import_react7 = __toESM(require(\"react\"));\n\n// node_modules/slate-react/dist/index.es.js\nvar import_direction = __toESM(require_direction());\nvar import_debounce = __toESM(require_debounce());\nvar import_throttle = __toESM(require_throttle());\nvar import_react2 = __toESM(require(\"react\"));\n\n// node_modules/compute-scroll-into-view/dist/index.module.js\nfunction t(t6) {\n  return \"object\" == typeof t6 && null != t6 && 1 === t6.nodeType;\n}\nfunction e(t6, e4) {\n  return (!e4 || \"hidden\" !== t6) && \"visible\" !== t6 && \"clip\" !== t6;\n}\nfunction n(t6, n8) {\n  if (t6.clientHeight < t6.scrollHeight || t6.clientWidth < t6.scrollWidth) {\n    var r7 = getComputedStyle(t6, null);\n    return e(r7.overflowY, n8) || e(r7.overflowX, n8) || function(t7) {\n      var e4 = function(t8) {\n        if (!t8.ownerDocument || !t8.ownerDocument.defaultView)\n          return null;\n        try {\n          return t8.ownerDocument.defaultView.frameElement;\n        } catch (t9) {\n          return null;\n        }\n      }(t7);\n      return !!e4 && (e4.clientHeight < t7.scrollHeight || e4.clientWidth < t7.scrollWidth);\n    }(t6);\n  }\n  return false;\n}\nfunction r(t6, e4, n8, r7, i5, o7, l6, d4) {\n  return o7 < t6 && l6 > e4 || o7 > t6 && l6 < e4 ? 0 : o7 <= t6 && d4 <= n8 || l6 >= e4 && d4 >= n8 ? o7 - t6 - r7 : l6 > e4 && d4 < n8 || o7 < t6 && d4 > n8 ? l6 - e4 + i5 : 0;\n}\nfunction index_module_default(e4, i5) {\n  var o7 = window, l6 = i5.scrollMode, d4 = i5.block, u5 = i5.inline, h4 = i5.boundary, a7 = i5.skipOverflowHiddenElements, c5 = \"function\" == typeof h4 ? h4 : function(t6) {\n    return t6 !== h4;\n  };\n  if (!t(e4))\n    throw new TypeError(\"Invalid target\");\n  for (var f5 = document.scrollingElement || document.documentElement, s5 = [], p6 = e4; t(p6) && c5(p6); ) {\n    if ((p6 = p6.parentElement) === f5) {\n      s5.push(p6);\n      break;\n    }\n    null != p6 && p6 === document.body && n(p6) && !n(document.documentElement) || null != p6 && n(p6, a7) && s5.push(p6);\n  }\n  for (var m4 = o7.visualViewport ? o7.visualViewport.width : innerWidth, g4 = o7.visualViewport ? o7.visualViewport.height : innerHeight, w4 = window.scrollX || pageXOffset, v4 = window.scrollY || pageYOffset, W3 = e4.getBoundingClientRect(), b4 = W3.height, H3 = W3.width, y5 = W3.top, E4 = W3.right, M2 = W3.bottom, V2 = W3.left, x4 = \"start\" === d4 || \"nearest\" === d4 ? y5 : \"end\" === d4 ? M2 : y5 + b4 / 2, I2 = \"center\" === u5 ? V2 + H3 / 2 : \"end\" === u5 ? E4 : V2, C3 = [], T3 = 0; T3 < s5.length; T3++) {\n    var k3 = s5[T3], B2 = k3.getBoundingClientRect(), D4 = B2.height, O4 = B2.width, R3 = B2.top, X2 = B2.right, Y2 = B2.bottom, L4 = B2.left;\n    if (\"if-needed\" === l6 && y5 >= 0 && V2 >= 0 && M2 <= g4 && E4 <= m4 && y5 >= R3 && M2 <= Y2 && V2 >= L4 && E4 <= X2)\n      return C3;\n    var S3 = getComputedStyle(k3), j2 = parseInt(S3.borderLeftWidth, 10), q2 = parseInt(S3.borderTopWidth, 10), z3 = parseInt(S3.borderRightWidth, 10), A2 = parseInt(S3.borderBottomWidth, 10), F2 = 0, G2 = 0, J = \"offsetWidth\" in k3 ? k3.offsetWidth - k3.clientWidth - j2 - z3 : 0, K = \"offsetHeight\" in k3 ? k3.offsetHeight - k3.clientHeight - q2 - A2 : 0;\n    if (f5 === k3)\n      F2 = \"start\" === d4 ? x4 : \"end\" === d4 ? x4 - g4 : \"nearest\" === d4 ? r(v4, v4 + g4, g4, q2, A2, v4 + x4, v4 + x4 + b4, b4) : x4 - g4 / 2, G2 = \"start\" === u5 ? I2 : \"center\" === u5 ? I2 - m4 / 2 : \"end\" === u5 ? I2 - m4 : r(w4, w4 + m4, m4, j2, z3, w4 + I2, w4 + I2 + H3, H3), F2 = Math.max(0, F2 + v4), G2 = Math.max(0, G2 + w4);\n    else {\n      F2 = \"start\" === d4 ? x4 - R3 - q2 : \"end\" === d4 ? x4 - Y2 + A2 + K : \"nearest\" === d4 ? r(R3, Y2, D4, q2, A2 + K, x4, x4 + b4, b4) : x4 - (R3 + D4 / 2) + K / 2, G2 = \"start\" === u5 ? I2 - L4 - j2 : \"center\" === u5 ? I2 - (L4 + O4 / 2) + J / 2 : \"end\" === u5 ? I2 - X2 + z3 + J : r(L4, X2, O4, j2, z3 + J, I2, I2 + H3, H3);\n      var N2 = k3.scrollLeft, P3 = k3.scrollTop;\n      x4 += P3 - (F2 = Math.max(0, Math.min(P3 + F2, k3.scrollHeight - D4 + K))), I2 += N2 - (G2 = Math.max(0, Math.min(N2 + G2, k3.scrollWidth - O4 + J)));\n    }\n    C3.push({ el: k3, top: F2, left: G2 });\n  }\n  return C3;\n}\n\n// node_modules/scroll-into-view-if-needed/es/index.js\nfunction isOptionsObject(options) {\n  return options === Object(options) && Object.keys(options).length !== 0;\n}\nfunction defaultBehavior(actions, behavior) {\n  if (behavior === void 0) {\n    behavior = \"auto\";\n  }\n  var canSmoothScroll = \"scrollBehavior\" in document.body.style;\n  actions.forEach(function(_ref) {\n    var el = _ref.el, top2 = _ref.top, left2 = _ref.left;\n    if (el.scroll && canSmoothScroll) {\n      el.scroll({\n        top: top2,\n        left: left2,\n        behavior\n      });\n    } else {\n      el.scrollTop = top2;\n      el.scrollLeft = left2;\n    }\n  });\n}\nfunction getOptions(options) {\n  if (options === false) {\n    return {\n      block: \"end\",\n      inline: \"nearest\"\n    };\n  }\n  if (isOptionsObject(options)) {\n    return options;\n  }\n  return {\n    block: \"start\",\n    inline: \"nearest\"\n  };\n}\nfunction scrollIntoView(target, options) {\n  var isTargetAttached = target.isConnected || target.ownerDocument.documentElement.contains(target);\n  if (isOptionsObject(options) && typeof options.behavior === \"function\") {\n    return options.behavior(isTargetAttached ? index_module_default(target, options) : []);\n  }\n  if (!isTargetAttached) {\n    return;\n  }\n  var computeOptions = getOptions(options);\n  return defaultBehavior(index_module_default(target, computeOptions), computeOptions.behavior);\n}\nvar es_default = scrollIntoView;\n\n// node_modules/is-plain-object/dist/is-plain-object.mjs\nfunction isObject(o7) {\n  return Object.prototype.toString.call(o7) === \"[object Object]\";\n}\nfunction isPlainObject(o7) {\n  var ctor, prot;\n  if (isObject(o7) === false)\n    return false;\n  ctor = o7.constructor;\n  if (ctor === void 0)\n    return true;\n  prot = ctor.prototype;\n  if (isObject(prot) === false)\n    return false;\n  if (prot.hasOwnProperty(\"isPrototypeOf\") === false) {\n    return false;\n  }\n  return true;\n}\n\n// node_modules/immer/dist/immer.esm.js\nfunction n2(n8) {\n  for (var r7 = arguments.length, t6 = Array(r7 > 1 ? r7 - 1 : 0), e4 = 1; e4 < r7; e4++)\n    t6[e4 - 1] = arguments[e4];\n  if (true) {\n    var i5 = Y[n8], o7 = i5 ? \"function\" == typeof i5 ? i5.apply(null, t6) : i5 : \"unknown error nr: \" + n8;\n    throw Error(\"[Immer] \" + o7);\n  }\n  throw Error(\"[Immer] minified error nr: \" + n8 + (t6.length ? \" \" + t6.map(function(n9) {\n    return \"'\" + n9 + \"'\";\n  }).join(\",\") : \"\") + \". Find the full error at: https://bit.ly/3cXEKWf\");\n}\nfunction r2(n8) {\n  return !!n8 && !!n8[Q];\n}\nfunction t2(n8) {\n  return !!n8 && (function(n9) {\n    if (!n9 || \"object\" != typeof n9)\n      return false;\n    var r7 = Object.getPrototypeOf(n9);\n    if (null === r7)\n      return true;\n    var t6 = Object.hasOwnProperty.call(r7, \"constructor\") && r7.constructor;\n    return t6 === Object || \"function\" == typeof t6 && Function.toString.call(t6) === Z;\n  }(n8) || Array.isArray(n8) || !!n8[L] || !!n8.constructor[L] || s(n8) || v(n8));\n}\nfunction i(n8, r7, t6) {\n  void 0 === t6 && (t6 = false), 0 === o(n8) ? (t6 ? Object.keys : nn)(n8).forEach(function(e4) {\n    t6 && \"symbol\" == typeof e4 || r7(e4, n8[e4], n8);\n  }) : n8.forEach(function(t7, e4) {\n    return r7(e4, t7, n8);\n  });\n}\nfunction o(n8) {\n  var r7 = n8[Q];\n  return r7 ? r7.i > 3 ? r7.i - 4 : r7.i : Array.isArray(n8) ? 1 : s(n8) ? 2 : v(n8) ? 3 : 0;\n}\nfunction u(n8, r7) {\n  return 2 === o(n8) ? n8.has(r7) : Object.prototype.hasOwnProperty.call(n8, r7);\n}\nfunction a(n8, r7) {\n  return 2 === o(n8) ? n8.get(r7) : n8[r7];\n}\nfunction f(n8, r7, t6) {\n  var e4 = o(n8);\n  2 === e4 ? n8.set(r7, t6) : 3 === e4 ? (n8.delete(r7), n8.add(t6)) : n8[r7] = t6;\n}\nfunction c(n8, r7) {\n  return n8 === r7 ? 0 !== n8 || 1 / n8 == 1 / r7 : n8 != n8 && r7 != r7;\n}\nfunction s(n8) {\n  return X && n8 instanceof Map;\n}\nfunction v(n8) {\n  return q && n8 instanceof Set;\n}\nfunction p(n8) {\n  return n8.o || n8.t;\n}\nfunction l(n8) {\n  if (Array.isArray(n8))\n    return Array.prototype.slice.call(n8);\n  var r7 = rn(n8);\n  delete r7[Q];\n  for (var t6 = nn(r7), e4 = 0; e4 < t6.length; e4++) {\n    var i5 = t6[e4], o7 = r7[i5];\n    false === o7.writable && (o7.writable = true, o7.configurable = true), (o7.get || o7.set) && (r7[i5] = { configurable: true, writable: true, enumerable: o7.enumerable, value: n8[i5] });\n  }\n  return Object.create(Object.getPrototypeOf(n8), r7);\n}\nfunction d(n8, e4) {\n  return void 0 === e4 && (e4 = false), y(n8) || r2(n8) || !t2(n8) ? n8 : (o(n8) > 1 && (n8.set = n8.add = n8.clear = n8.delete = h), Object.freeze(n8), e4 && i(n8, function(n9, r7) {\n    return d(r7, true);\n  }, true), n8);\n}\nfunction h() {\n  n2(2);\n}\nfunction y(n8) {\n  return null == n8 || \"object\" != typeof n8 || Object.isFrozen(n8);\n}\nfunction b(r7) {\n  var t6 = tn[r7];\n  return t6 || n2(18, r7), t6;\n}\nfunction m(n8, r7) {\n  tn[n8] || (tn[n8] = r7);\n}\nfunction _() {\n  return U || n2(0), U;\n}\nfunction j(n8, r7) {\n  r7 && (b(\"Patches\"), n8.u = [], n8.s = [], n8.v = r7);\n}\nfunction O(n8) {\n  g(n8), n8.p.forEach(S), n8.p = null;\n}\nfunction g(n8) {\n  n8 === U && (U = n8.l);\n}\nfunction w(n8) {\n  return U = { p: [], l: U, h: n8, m: true, _: 0 };\n}\nfunction S(n8) {\n  var r7 = n8[Q];\n  0 === r7.i || 1 === r7.i ? r7.j() : r7.O = true;\n}\nfunction P(r7, e4) {\n  e4._ = e4.p.length;\n  var i5 = e4.p[0], o7 = void 0 !== r7 && r7 !== i5;\n  return e4.h.g || b(\"ES5\").S(e4, r7, o7), o7 ? (i5[Q].P && (O(e4), n2(4)), t2(r7) && (r7 = M(e4, r7), e4.l || x(e4, r7)), e4.u && b(\"Patches\").M(i5[Q].t, r7, e4.u, e4.s)) : r7 = M(e4, i5, []), O(e4), e4.u && e4.v(e4.u, e4.s), r7 !== H ? r7 : void 0;\n}\nfunction M(n8, r7, t6) {\n  if (y(r7))\n    return r7;\n  var e4 = r7[Q];\n  if (!e4)\n    return i(r7, function(i5, o8) {\n      return A(n8, e4, r7, i5, o8, t6);\n    }, true), r7;\n  if (e4.A !== n8)\n    return r7;\n  if (!e4.P)\n    return x(n8, e4.t, true), e4.t;\n  if (!e4.I) {\n    e4.I = true, e4.A._--;\n    var o7 = 4 === e4.i || 5 === e4.i ? e4.o = l(e4.k) : e4.o;\n    i(3 === e4.i ? new Set(o7) : o7, function(r8, i5) {\n      return A(n8, e4, o7, r8, i5, t6);\n    }), x(n8, o7, false), t6 && n8.u && b(\"Patches\").R(e4, t6, n8.u, n8.s);\n  }\n  return e4.o;\n}\nfunction A(e4, i5, o7, a7, c5, s5) {\n  if (c5 === o7 && n2(5), r2(c5)) {\n    var v4 = M(e4, c5, s5 && i5 && 3 !== i5.i && !u(i5.D, a7) ? s5.concat(a7) : void 0);\n    if (f(o7, a7, v4), !r2(v4))\n      return;\n    e4.m = false;\n  }\n  if (t2(c5) && !y(c5)) {\n    if (!e4.h.F && e4._ < 1)\n      return;\n    M(e4, c5), i5 && i5.A.l || x(e4, c5);\n  }\n}\nfunction x(n8, r7, t6) {\n  void 0 === t6 && (t6 = false), n8.h.F && n8.m && d(r7, t6);\n}\nfunction z(n8, r7) {\n  var t6 = n8[Q];\n  return (t6 ? p(t6) : n8)[r7];\n}\nfunction I(n8, r7) {\n  if (r7 in n8)\n    for (var t6 = Object.getPrototypeOf(n8); t6; ) {\n      var e4 = Object.getOwnPropertyDescriptor(t6, r7);\n      if (e4)\n        return e4;\n      t6 = Object.getPrototypeOf(t6);\n    }\n}\nfunction k(n8) {\n  n8.P || (n8.P = true, n8.l && k(n8.l));\n}\nfunction E(n8) {\n  n8.o || (n8.o = l(n8.t));\n}\nfunction R(n8, r7, t6) {\n  var e4 = s(r7) ? b(\"MapSet\").N(r7, t6) : v(r7) ? b(\"MapSet\").T(r7, t6) : n8.g ? function(n9, r8) {\n    var t7 = Array.isArray(n9), e5 = { i: t7 ? 1 : 0, A: r8 ? r8.A : _(), P: false, I: false, D: {}, l: r8, t: n9, k: null, o: null, j: null, C: false }, i5 = e5, o7 = en;\n    t7 && (i5 = [e5], o7 = on);\n    var u5 = Proxy.revocable(i5, o7), a7 = u5.revoke, f5 = u5.proxy;\n    return e5.k = f5, e5.j = a7, f5;\n  }(r7, t6) : b(\"ES5\").J(r7, t6);\n  return (t6 ? t6.A : _()).p.push(e4), e4;\n}\nfunction D(e4) {\n  return r2(e4) || n2(22, e4), function n8(r7) {\n    if (!t2(r7))\n      return r7;\n    var e5, u5 = r7[Q], c5 = o(r7);\n    if (u5) {\n      if (!u5.P && (u5.i < 4 || !b(\"ES5\").K(u5)))\n        return u5.t;\n      u5.I = true, e5 = F(r7, c5), u5.I = false;\n    } else\n      e5 = F(r7, c5);\n    return i(e5, function(r8, t6) {\n      u5 && a(u5.t, r8) === t6 || f(e5, r8, n8(t6));\n    }), 3 === c5 ? new Set(e5) : e5;\n  }(e4);\n}\nfunction F(n8, r7) {\n  switch (r7) {\n    case 2:\n      return new Map(n8);\n    case 3:\n      return Array.from(n8);\n  }\n  return l(n8);\n}\nfunction C() {\n  function r7(n8, r8) {\n    function t6() {\n      this.constructor = n8;\n    }\n    a7(n8, r8), n8.prototype = (t6.prototype = r8.prototype, new t6());\n  }\n  function e4(n8) {\n    n8.o || (n8.D = /* @__PURE__ */ new Map(), n8.o = new Map(n8.t));\n  }\n  function o7(n8) {\n    n8.o || (n8.o = /* @__PURE__ */ new Set(), n8.t.forEach(function(r8) {\n      if (t2(r8)) {\n        var e5 = R(n8.A.h, r8, n8);\n        n8.p.set(r8, e5), n8.o.add(e5);\n      } else\n        n8.o.add(r8);\n    }));\n  }\n  function u5(r8) {\n    r8.O && n2(3, JSON.stringify(p(r8)));\n  }\n  var a7 = function(n8, r8) {\n    return (a7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n9, r9) {\n      n9.__proto__ = r9;\n    } || function(n9, r9) {\n      for (var t6 in r9)\n        r9.hasOwnProperty(t6) && (n9[t6] = r9[t6]);\n    })(n8, r8);\n  }, f5 = function() {\n    function n8(n9, r8) {\n      return this[Q] = { i: 2, l: r8, A: r8 ? r8.A : _(), P: false, I: false, o: void 0, D: void 0, t: n9, k: this, C: false, O: false }, this;\n    }\n    r7(n8, Map);\n    var o8 = n8.prototype;\n    return Object.defineProperty(o8, \"size\", { get: function() {\n      return p(this[Q]).size;\n    } }), o8.has = function(n9) {\n      return p(this[Q]).has(n9);\n    }, o8.set = function(n9, r8) {\n      var t6 = this[Q];\n      return u5(t6), p(t6).has(n9) && p(t6).get(n9) === r8 || (e4(t6), k(t6), t6.D.set(n9, true), t6.o.set(n9, r8), t6.D.set(n9, true)), this;\n    }, o8.delete = function(n9) {\n      if (!this.has(n9))\n        return false;\n      var r8 = this[Q];\n      return u5(r8), e4(r8), k(r8), r8.t.has(n9) ? r8.D.set(n9, false) : r8.D.delete(n9), r8.o.delete(n9), true;\n    }, o8.clear = function() {\n      var n9 = this[Q];\n      u5(n9), p(n9).size && (e4(n9), k(n9), n9.D = /* @__PURE__ */ new Map(), i(n9.t, function(r8) {\n        n9.D.set(r8, false);\n      }), n9.o.clear());\n    }, o8.forEach = function(n9, r8) {\n      var t6 = this;\n      p(this[Q]).forEach(function(e5, i5) {\n        n9.call(r8, t6.get(i5), i5, t6);\n      });\n    }, o8.get = function(n9) {\n      var r8 = this[Q];\n      u5(r8);\n      var i5 = p(r8).get(n9);\n      if (r8.I || !t2(i5))\n        return i5;\n      if (i5 !== r8.t.get(n9))\n        return i5;\n      var o9 = R(r8.A.h, i5, r8);\n      return e4(r8), r8.o.set(n9, o9), o9;\n    }, o8.keys = function() {\n      return p(this[Q]).keys();\n    }, o8.values = function() {\n      var n9, r8 = this, t6 = this.keys();\n      return (n9 = {})[V] = function() {\n        return r8.values();\n      }, n9.next = function() {\n        var n10 = t6.next();\n        return n10.done ? n10 : { done: false, value: r8.get(n10.value) };\n      }, n9;\n    }, o8.entries = function() {\n      var n9, r8 = this, t6 = this.keys();\n      return (n9 = {})[V] = function() {\n        return r8.entries();\n      }, n9.next = function() {\n        var n10 = t6.next();\n        if (n10.done)\n          return n10;\n        var e5 = r8.get(n10.value);\n        return { done: false, value: [n10.value, e5] };\n      }, n9;\n    }, o8[V] = function() {\n      return this.entries();\n    }, n8;\n  }(), c5 = function() {\n    function n8(n9, r8) {\n      return this[Q] = { i: 3, l: r8, A: r8 ? r8.A : _(), P: false, I: false, o: void 0, t: n9, k: this, p: /* @__PURE__ */ new Map(), O: false, C: false }, this;\n    }\n    r7(n8, Set);\n    var t6 = n8.prototype;\n    return Object.defineProperty(t6, \"size\", { get: function() {\n      return p(this[Q]).size;\n    } }), t6.has = function(n9) {\n      var r8 = this[Q];\n      return u5(r8), r8.o ? !!r8.o.has(n9) || !(!r8.p.has(n9) || !r8.o.has(r8.p.get(n9))) : r8.t.has(n9);\n    }, t6.add = function(n9) {\n      var r8 = this[Q];\n      return u5(r8), this.has(n9) || (o7(r8), k(r8), r8.o.add(n9)), this;\n    }, t6.delete = function(n9) {\n      if (!this.has(n9))\n        return false;\n      var r8 = this[Q];\n      return u5(r8), o7(r8), k(r8), r8.o.delete(n9) || !!r8.p.has(n9) && r8.o.delete(r8.p.get(n9));\n    }, t6.clear = function() {\n      var n9 = this[Q];\n      u5(n9), p(n9).size && (o7(n9), k(n9), n9.o.clear());\n    }, t6.values = function() {\n      var n9 = this[Q];\n      return u5(n9), o7(n9), n9.o.values();\n    }, t6.entries = function() {\n      var n9 = this[Q];\n      return u5(n9), o7(n9), n9.o.entries();\n    }, t6.keys = function() {\n      return this.values();\n    }, t6[V] = function() {\n      return this.values();\n    }, t6.forEach = function(n9, r8) {\n      for (var t7 = this.values(), e5 = t7.next(); !e5.done; )\n        n9.call(r8, e5.value, e5.value, this), e5 = t7.next();\n    }, n8;\n  }();\n  m(\"MapSet\", { N: function(n8, r8) {\n    return new f5(n8, r8);\n  }, T: function(n8, r8) {\n    return new c5(n8, r8);\n  } });\n}\nvar G;\nvar U;\nvar W = \"undefined\" != typeof Symbol && \"symbol\" == typeof Symbol(\"x\");\nvar X = \"undefined\" != typeof Map;\nvar q = \"undefined\" != typeof Set;\nvar B = \"undefined\" != typeof Proxy && void 0 !== Proxy.revocable && \"undefined\" != typeof Reflect;\nvar H = W ? Symbol.for(\"immer-nothing\") : ((G = {})[\"immer-nothing\"] = true, G);\nvar L = W ? Symbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar Q = W ? Symbol.for(\"immer-state\") : \"__$immer_state\";\nvar V = \"undefined\" != typeof Symbol && Symbol.iterator || \"@@iterator\";\nvar Y = { 0: \"Illegal state\", 1: \"Immer drafts cannot have computed properties\", 2: \"This object has been frozen and should not be mutated\", 3: function(n8) {\n  return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + n8;\n}, 4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\", 5: \"Immer forbids circular references\", 6: \"The first or second argument to `produce` must be a function\", 7: \"The third argument to `produce` must be a function or undefined\", 8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\", 9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\", 10: \"The given draft is already finalized\", 11: \"Object.defineProperty() cannot be used on an Immer draft\", 12: \"Object.setPrototypeOf() cannot be used on an Immer draft\", 13: \"Immer only supports deleting array indices\", 14: \"Immer only supports setting array indices and the 'length' property\", 15: function(n8) {\n  return \"Cannot apply patch, path doesn't resolve: \" + n8;\n}, 16: 'Sets cannot have \"replace\" patches.', 17: function(n8) {\n  return \"Unsupported patch operation: \" + n8;\n}, 18: function(n8) {\n  return \"The plugin for '\" + n8 + \"' has not been loaded into Immer. To enable the plugin, import and call `enable\" + n8 + \"()` when initializing your application.\";\n}, 20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\", 21: function(n8) {\n  return \"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\" + n8 + \"'\";\n}, 22: function(n8) {\n  return \"'current' expects a draft, got: \" + n8;\n}, 23: function(n8) {\n  return \"'original' expects a draft, got: \" + n8;\n}, 24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\" };\nvar Z = \"\" + Object.prototype.constructor;\nvar nn = \"undefined\" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n8) {\n  return Object.getOwnPropertyNames(n8).concat(Object.getOwnPropertySymbols(n8));\n} : Object.getOwnPropertyNames;\nvar rn = Object.getOwnPropertyDescriptors || function(n8) {\n  var r7 = {};\n  return nn(n8).forEach(function(t6) {\n    r7[t6] = Object.getOwnPropertyDescriptor(n8, t6);\n  }), r7;\n};\nvar tn = {};\nvar en = { get: function(n8, r7) {\n  if (r7 === Q)\n    return n8;\n  var e4 = p(n8);\n  if (!u(e4, r7))\n    return function(n9, r8, t6) {\n      var e5, i6 = I(r8, t6);\n      return i6 ? \"value\" in i6 ? i6.value : null === (e5 = i6.get) || void 0 === e5 ? void 0 : e5.call(n9.k) : void 0;\n    }(n8, e4, r7);\n  var i5 = e4[r7];\n  return n8.I || !t2(i5) ? i5 : i5 === z(n8.t, r7) ? (E(n8), n8.o[r7] = R(n8.A.h, i5, n8)) : i5;\n}, has: function(n8, r7) {\n  return r7 in p(n8);\n}, ownKeys: function(n8) {\n  return Reflect.ownKeys(p(n8));\n}, set: function(n8, r7, t6) {\n  var e4 = I(p(n8), r7);\n  if (null == e4 ? void 0 : e4.set)\n    return e4.set.call(n8.k, t6), true;\n  if (!n8.P) {\n    var i5 = z(p(n8), r7), o7 = null == i5 ? void 0 : i5[Q];\n    if (o7 && o7.t === t6)\n      return n8.o[r7] = t6, n8.D[r7] = false, true;\n    if (c(t6, i5) && (void 0 !== t6 || u(n8.t, r7)))\n      return true;\n    E(n8), k(n8);\n  }\n  return n8.o[r7] === t6 && \"number\" != typeof t6 && (void 0 !== t6 || r7 in n8.o) || (n8.o[r7] = t6, n8.D[r7] = true, true);\n}, deleteProperty: function(n8, r7) {\n  return void 0 !== z(n8.t, r7) || r7 in n8.t ? (n8.D[r7] = false, E(n8), k(n8)) : delete n8.D[r7], n8.o && delete n8.o[r7], true;\n}, getOwnPropertyDescriptor: function(n8, r7) {\n  var t6 = p(n8), e4 = Reflect.getOwnPropertyDescriptor(t6, r7);\n  return e4 ? { writable: true, configurable: 1 !== n8.i || \"length\" !== r7, enumerable: e4.enumerable, value: t6[r7] } : e4;\n}, defineProperty: function() {\n  n2(11);\n}, getPrototypeOf: function(n8) {\n  return Object.getPrototypeOf(n8.t);\n}, setPrototypeOf: function() {\n  n2(12);\n} };\nvar on = {};\ni(en, function(n8, r7) {\n  on[n8] = function() {\n    return arguments[0] = arguments[0][0], r7.apply(this, arguments);\n  };\n}), on.deleteProperty = function(r7, t6) {\n  return isNaN(parseInt(t6)) && n2(13), on.set.call(this, r7, t6, void 0);\n}, on.set = function(r7, t6, e4) {\n  return \"length\" !== t6 && isNaN(parseInt(t6)) && n2(14), en.set.call(this, r7[0], t6, e4, r7[0]);\n};\nvar un = function() {\n  function e4(r7) {\n    var e5 = this;\n    this.g = B, this.F = true, this.produce = function(r8, i6, o7) {\n      if (\"function\" == typeof r8 && \"function\" != typeof i6) {\n        var u5 = i6;\n        i6 = r8;\n        var a7 = e5;\n        return function(n8) {\n          var r9 = this;\n          void 0 === n8 && (n8 = u5);\n          for (var t6 = arguments.length, e6 = Array(t6 > 1 ? t6 - 1 : 0), o8 = 1; o8 < t6; o8++)\n            e6[o8 - 1] = arguments[o8];\n          return a7.produce(n8, function(n9) {\n            var t7;\n            return (t7 = i6).call.apply(t7, [r9, n9].concat(e6));\n          });\n        };\n      }\n      var f5;\n      if (\"function\" != typeof i6 && n2(6), void 0 !== o7 && \"function\" != typeof o7 && n2(7), t2(r8)) {\n        var c5 = w(e5), s5 = R(e5, r8, void 0), v4 = true;\n        try {\n          f5 = i6(s5), v4 = false;\n        } finally {\n          v4 ? O(c5) : g(c5);\n        }\n        return \"undefined\" != typeof Promise && f5 instanceof Promise ? f5.then(function(n8) {\n          return j(c5, o7), P(n8, c5);\n        }, function(n8) {\n          throw O(c5), n8;\n        }) : (j(c5, o7), P(f5, c5));\n      }\n      if (!r8 || \"object\" != typeof r8) {\n        if (void 0 === (f5 = i6(r8)) && (f5 = r8), f5 === H && (f5 = void 0), e5.F && d(f5, true), o7) {\n          var p6 = [], l6 = [];\n          b(\"Patches\").M(r8, f5, p6, l6), o7(p6, l6);\n        }\n        return f5;\n      }\n      n2(21, r8);\n    }, this.produceWithPatches = function(n8, r8) {\n      if (\"function\" == typeof n8)\n        return function(r9) {\n          for (var t7 = arguments.length, i7 = Array(t7 > 1 ? t7 - 1 : 0), o8 = 1; o8 < t7; o8++)\n            i7[o8 - 1] = arguments[o8];\n          return e5.produceWithPatches(r9, function(r10) {\n            return n8.apply(void 0, [r10].concat(i7));\n          });\n        };\n      var t6, i6, o7 = e5.produce(n8, r8, function(n9, r9) {\n        t6 = n9, i6 = r9;\n      });\n      return \"undefined\" != typeof Promise && o7 instanceof Promise ? o7.then(function(n9) {\n        return [n9, t6, i6];\n      }) : [o7, t6, i6];\n    }, \"boolean\" == typeof (null == r7 ? void 0 : r7.useProxies) && this.setUseProxies(r7.useProxies), \"boolean\" == typeof (null == r7 ? void 0 : r7.autoFreeze) && this.setAutoFreeze(r7.autoFreeze);\n  }\n  var i5 = e4.prototype;\n  return i5.createDraft = function(e5) {\n    t2(e5) || n2(8), r2(e5) && (e5 = D(e5));\n    var i6 = w(this), o7 = R(this, e5, void 0);\n    return o7[Q].C = true, g(i6), o7;\n  }, i5.finishDraft = function(r7, t6) {\n    var e5 = r7 && r7[Q];\n    e5 && e5.C || n2(9), e5.I && n2(10);\n    var i6 = e5.A;\n    return j(i6, t6), P(void 0, i6);\n  }, i5.setAutoFreeze = function(n8) {\n    this.F = n8;\n  }, i5.setUseProxies = function(r7) {\n    r7 && !B && n2(20), this.g = r7;\n  }, i5.applyPatches = function(n8, t6) {\n    var e5;\n    for (e5 = t6.length - 1; e5 >= 0; e5--) {\n      var i6 = t6[e5];\n      if (0 === i6.path.length && \"replace\" === i6.op) {\n        n8 = i6.value;\n        break;\n      }\n    }\n    e5 > -1 && (t6 = t6.slice(e5 + 1));\n    var o7 = b(\"Patches\").$;\n    return r2(n8) ? o7(n8, t6) : this.produce(n8, function(n9) {\n      return o7(n9, t6);\n    });\n  }, e4;\n}();\nvar an = new un();\nvar fn = an.produce;\nvar cn = an.produceWithPatches.bind(an);\nvar sn = an.setAutoFreeze.bind(an);\nvar vn = an.setUseProxies.bind(an);\nvar pn = an.applyPatches.bind(an);\nvar ln = an.createDraft.bind(an);\nvar dn = an.finishDraft.bind(an);\nvar immer_esm_default = fn;\n\n// node_modules/slate/dist/index.es.js\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar DIRTY_PATHS = /* @__PURE__ */ new WeakMap();\nvar DIRTY_PATH_KEYS = /* @__PURE__ */ new WeakMap();\nvar FLUSHING = /* @__PURE__ */ new WeakMap();\nvar NORMALIZING = /* @__PURE__ */ new WeakMap();\nvar PATH_REFS = /* @__PURE__ */ new WeakMap();\nvar POINT_REFS = /* @__PURE__ */ new WeakMap();\nvar RANGE_REFS = /* @__PURE__ */ new WeakMap();\nfunction ownKeys$9(object, enumerableOnly) {\n  var keys4 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys4.push.apply(keys4, symbols);\n  }\n  return keys4;\n}\nfunction _objectSpread$9(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    if (i5 % 2) {\n      ownKeys$9(Object(source), true).forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$9(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar createEditor = () => {\n  var editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isInline: () => false,\n    isVoid: () => false,\n    onChange: () => {\n    },\n    apply: (op) => {\n      for (var ref of Editor.pathRefs(editor)) {\n        PathRef.transform(ref, op);\n      }\n      for (var _ref of Editor.pointRefs(editor)) {\n        PointRef.transform(_ref, op);\n      }\n      for (var _ref2 of Editor.rangeRefs(editor)) {\n        RangeRef.transform(_ref2, op);\n      }\n      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n      var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || /* @__PURE__ */ new Set();\n      var dirtyPaths;\n      var dirtyPathKeys;\n      var add2 = (path2) => {\n        if (path2) {\n          var key = path2.join(\",\");\n          if (!dirtyPathKeys.has(key)) {\n            dirtyPathKeys.add(key);\n            dirtyPaths.push(path2);\n          }\n        }\n      };\n      if (Path.operationCanTransformPath(op)) {\n        dirtyPaths = [];\n        dirtyPathKeys = /* @__PURE__ */ new Set();\n        for (var path of oldDirtyPaths) {\n          var newPath = Path.transform(path, op);\n          add2(newPath);\n        }\n      } else {\n        dirtyPaths = oldDirtyPaths;\n        dirtyPathKeys = oldDirtyPathKeys;\n      }\n      var newDirtyPaths = getDirtyPaths(op);\n      for (var _path of newDirtyPaths) {\n        add2(_path);\n      }\n      DIRTY_PATHS.set(editor, dirtyPaths);\n      DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n      Transforms.transform(editor, op);\n      editor.operations.push(op);\n      Editor.normalize(editor);\n      if (op.type === \"set_selection\") {\n        editor.marks = null;\n      }\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true);\n        Promise.resolve().then(() => {\n          FLUSHING.set(editor, false);\n          editor.onChange();\n          editor.operations = [];\n        });\n      }\n    },\n    addMark: (key, value) => {\n      var {\n        selection\n      } = editor;\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.setNodes(editor, {\n            [key]: value\n          }, {\n            match: Text.isText,\n            split: true\n          });\n        } else {\n          var marks3 = _objectSpread$9(_objectSpread$9({}, Editor.marks(editor) || {}), {}, {\n            [key]: value\n          });\n          editor.marks = marks3;\n          if (!FLUSHING.get(editor)) {\n            editor.onChange();\n          }\n        }\n      }\n    },\n    deleteBackward: (unit) => {\n      var {\n        selection\n      } = editor;\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n          unit,\n          reverse: true\n        });\n      }\n    },\n    deleteForward: (unit) => {\n      var {\n        selection\n      } = editor;\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n          unit\n        });\n      }\n    },\n    deleteFragment: (direction) => {\n      var {\n        selection\n      } = editor;\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.delete(editor, {\n          reverse: direction === \"backward\"\n        });\n      }\n    },\n    getFragment: () => {\n      var {\n        selection\n      } = editor;\n      if (selection) {\n        return Node2.fragment(editor, selection);\n      }\n      return [];\n    },\n    insertBreak: () => {\n      Transforms.splitNodes(editor, {\n        always: true\n      });\n    },\n    insertSoftBreak: () => {\n      Transforms.splitNodes(editor, {\n        always: true\n      });\n    },\n    insertFragment: (fragment) => {\n      Transforms.insertFragment(editor, fragment);\n    },\n    insertNode: (node) => {\n      Transforms.insertNodes(editor, node);\n    },\n    insertText: (text4) => {\n      var {\n        selection,\n        marks: marks3\n      } = editor;\n      if (selection) {\n        if (marks3) {\n          var node = _objectSpread$9({\n            text: text4\n          }, marks3);\n          Transforms.insertNodes(editor, node);\n        } else {\n          Transforms.insertText(editor, text4);\n        }\n        editor.marks = null;\n      }\n    },\n    normalizeNode: (entry) => {\n      var [node, path] = entry;\n      if (Text.isText(node)) {\n        return;\n      }\n      if (Element2.isElement(node) && node.children.length === 0) {\n        var child = {\n          text: \"\"\n        };\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true\n        });\n        return;\n      }\n      var shouldHaveInlines = Editor.isEditor(node) ? false : Element2.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0]));\n      var n8 = 0;\n      for (var i5 = 0; i5 < node.children.length; i5++, n8++) {\n        var currentNode = Node2.get(editor, path);\n        if (Text.isText(currentNode))\n          continue;\n        var _child = node.children[i5];\n        var prev = currentNode.children[n8 - 1];\n        var isLast = i5 === node.children.length - 1;\n        var isInlineOrText = Text.isText(_child) || Element2.isElement(_child) && editor.isInline(_child);\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n8),\n            voids: true\n          });\n          n8--;\n        } else if (Element2.isElement(_child)) {\n          if (editor.isInline(_child)) {\n            if (prev == null || !Text.isText(prev)) {\n              var newChild = {\n                text: \"\"\n              };\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n8),\n                voids: true\n              });\n              n8++;\n            } else if (isLast) {\n              var _newChild = {\n                text: \"\"\n              };\n              Transforms.insertNodes(editor, _newChild, {\n                at: path.concat(n8 + 1),\n                voids: true\n              });\n              n8++;\n            }\n          }\n        } else {\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(_child, prev, {\n              loose: true\n            })) {\n              Transforms.mergeNodes(editor, {\n                at: path.concat(n8),\n                voids: true\n              });\n              n8--;\n            } else if (prev.text === \"\") {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n8 - 1),\n                voids: true\n              });\n              n8--;\n            } else if (_child.text === \"\") {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n8),\n                voids: true\n              });\n              n8--;\n            }\n          }\n        }\n      }\n    },\n    removeMark: (key) => {\n      var {\n        selection\n      } = editor;\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.unsetNodes(editor, key, {\n            match: Text.isText,\n            split: true\n          });\n        } else {\n          var marks3 = _objectSpread$9({}, Editor.marks(editor) || {});\n          delete marks3[key];\n          editor.marks = marks3;\n          if (!FLUSHING.get(editor)) {\n            editor.onChange();\n          }\n        }\n      }\n    }\n  };\n  return editor;\n};\nvar getDirtyPaths = (op) => {\n  switch (op.type) {\n    case \"insert_text\":\n    case \"remove_text\":\n    case \"set_node\": {\n      var {\n        path\n      } = op;\n      return Path.levels(path);\n    }\n    case \"insert_node\": {\n      var {\n        node,\n        path: _path2\n      } = op;\n      var levels = Path.levels(_path2);\n      var descendants = Text.isText(node) ? [] : Array.from(Node2.nodes(node), (_ref3) => {\n        var [, p7] = _ref3;\n        return _path2.concat(p7);\n      });\n      return [...levels, ...descendants];\n    }\n    case \"merge_node\": {\n      var {\n        path: _path3\n      } = op;\n      var ancestors = Path.ancestors(_path3);\n      var previousPath = Path.previous(_path3);\n      return [...ancestors, previousPath];\n    }\n    case \"move_node\": {\n      var {\n        path: _path4,\n        newPath\n      } = op;\n      if (Path.equals(_path4, newPath)) {\n        return [];\n      }\n      var oldAncestors = [];\n      var newAncestors = [];\n      for (var ancestor of Path.ancestors(_path4)) {\n        var p6 = Path.transform(ancestor, op);\n        oldAncestors.push(p6);\n      }\n      for (var _ancestor of Path.ancestors(newPath)) {\n        var _p = Path.transform(_ancestor, op);\n        newAncestors.push(_p);\n      }\n      var newParent = newAncestors[newAncestors.length - 1];\n      var newIndex = newPath[newPath.length - 1];\n      var resultPath = newParent.concat(newIndex);\n      return [...oldAncestors, ...newAncestors, resultPath];\n    }\n    case \"remove_node\": {\n      var {\n        path: _path5\n      } = op;\n      var _ancestors = Path.ancestors(_path5);\n      return [..._ancestors];\n    }\n    case \"split_node\": {\n      var {\n        path: _path6\n      } = op;\n      var _levels = Path.levels(_path6);\n      var nextPath = Path.next(_path6);\n      return [..._levels, nextPath];\n    }\n    default: {\n      return [];\n    }\n  }\n};\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null)\n    return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i5;\n  for (i5 = 0; i5 < sourceKeys.length; i5++) {\n    key = sourceKeys[i5];\n    if (excluded.indexOf(key) >= 0)\n      continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null)\n    return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i5;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i5 = 0; i5 < sourceSymbolKeys.length; i5++) {\n      key = sourceSymbolKeys[i5];\n      if (excluded.indexOf(key) >= 0)\n        continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key))\n        continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nvar getCharacterDistance = function getCharacterDistance2(str) {\n  var isRTL = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n  var isLTR = !isRTL;\n  var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n  var left2 = CodepointType.None;\n  var right2 = CodepointType.None;\n  var distance = 0;\n  var gb11 = null;\n  var gb12Or13 = null;\n  for (var char of codepoints) {\n    var code3 = char.codePointAt(0);\n    if (!code3)\n      break;\n    var type = getCodepointType(char, code3);\n    [left2, right2] = isLTR ? [right2, type] : [type, left2];\n    if (intersects(left2, CodepointType.ZWJ) && intersects(right2, CodepointType.ExtPict)) {\n      if (isLTR) {\n        gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n      } else {\n        gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n      }\n      if (!gb11)\n        break;\n    }\n    if (intersects(left2, CodepointType.RI) && intersects(right2, CodepointType.RI)) {\n      if (gb12Or13 !== null) {\n        gb12Or13 = !gb12Or13;\n      } else {\n        if (isLTR) {\n          gb12Or13 = true;\n        } else {\n          gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n        }\n      }\n      if (!gb12Or13)\n        break;\n    }\n    if (left2 !== CodepointType.None && right2 !== CodepointType.None && isBoundaryPair(left2, right2)) {\n      break;\n    }\n    distance += char.length;\n  }\n  return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\nvar getWordDistance = function getWordDistance2(text4) {\n  var isRTL = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n  var dist = 0;\n  var started = false;\n  while (text4.length > 0) {\n    var charDist = getCharacterDistance(text4, isRTL);\n    var [char, remaining] = splitByCharacterDistance(text4, charDist, isRTL);\n    if (isWordCharacter(char, remaining, isRTL)) {\n      started = true;\n      dist += charDist;\n    } else if (!started) {\n      dist += charDist;\n    } else {\n      break;\n    }\n    text4 = remaining;\n  }\n  return dist;\n};\nvar splitByCharacterDistance = (str, dist, isRTL) => {\n  if (isRTL) {\n    var at = str.length - dist;\n    return [str.slice(at, str.length), str.slice(0, at)];\n  }\n  return [str.slice(0, dist), str.slice(dist)];\n};\nvar isWordCharacter = function isWordCharacter2(char, remaining) {\n  var isRTL = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n  if (SPACE.test(char)) {\n    return false;\n  }\n  if (CHAMELEON.test(char)) {\n    var charDist = getCharacterDistance(remaining, isRTL);\n    var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);\n    if (isWordCharacter2(nextChar, nextRemaining, isRTL)) {\n      return true;\n    }\n  }\n  if (PUNCTUATION.test(char)) {\n    return false;\n  }\n  return true;\n};\nvar codepointsIteratorRTL = function* codepointsIteratorRTL2(str) {\n  var end2 = str.length - 1;\n  for (var i5 = 0; i5 < str.length; i5++) {\n    var char1 = str.charAt(end2 - i5);\n    if (isLowSurrogate(char1.charCodeAt(0))) {\n      var char2 = str.charAt(end2 - i5 - 1);\n      if (isHighSurrogate(char2.charCodeAt(0))) {\n        yield char2 + char1;\n        i5++;\n        continue;\n      }\n    }\n    yield char1;\n  }\n};\nvar isHighSurrogate = (charCode) => {\n  return charCode >= 55296 && charCode <= 56319;\n};\nvar isLowSurrogate = (charCode) => {\n  return charCode >= 56320 && charCode <= 57343;\n};\nvar CodepointType;\n(function(CodepointType2) {\n  CodepointType2[CodepointType2[\"None\"] = 0] = \"None\";\n  CodepointType2[CodepointType2[\"Extend\"] = 1] = \"Extend\";\n  CodepointType2[CodepointType2[\"ZWJ\"] = 2] = \"ZWJ\";\n  CodepointType2[CodepointType2[\"RI\"] = 4] = \"RI\";\n  CodepointType2[CodepointType2[\"Prepend\"] = 8] = \"Prepend\";\n  CodepointType2[CodepointType2[\"SpacingMark\"] = 16] = \"SpacingMark\";\n  CodepointType2[CodepointType2[\"L\"] = 32] = \"L\";\n  CodepointType2[CodepointType2[\"V\"] = 64] = \"V\";\n  CodepointType2[CodepointType2[\"T\"] = 128] = \"T\";\n  CodepointType2[CodepointType2[\"LV\"] = 256] = \"LV\";\n  CodepointType2[CodepointType2[\"LVT\"] = 512] = \"LVT\";\n  CodepointType2[CodepointType2[\"ExtPict\"] = 1024] = \"ExtPict\";\n  CodepointType2[CodepointType2[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\nvar getCodepointType = (char, code3) => {\n  var type = CodepointType.Any;\n  if (char.search(reExtend) !== -1) {\n    type |= CodepointType.Extend;\n  }\n  if (code3 === 8205) {\n    type |= CodepointType.ZWJ;\n  }\n  if (code3 >= 127462 && code3 <= 127487) {\n    type |= CodepointType.RI;\n  }\n  if (char.search(rePrepend) !== -1) {\n    type |= CodepointType.Prepend;\n  }\n  if (char.search(reSpacingMark) !== -1) {\n    type |= CodepointType.SpacingMark;\n  }\n  if (char.search(reL) !== -1) {\n    type |= CodepointType.L;\n  }\n  if (char.search(reV) !== -1) {\n    type |= CodepointType.V;\n  }\n  if (char.search(reT) !== -1) {\n    type |= CodepointType.T;\n  }\n  if (char.search(reLV) !== -1) {\n    type |= CodepointType.LV;\n  }\n  if (char.search(reLVT) !== -1) {\n    type |= CodepointType.LVT;\n  }\n  if (char.search(reExtPict) !== -1) {\n    type |= CodepointType.ExtPict;\n  }\n  return type;\n};\nfunction intersects(x4, y5) {\n  return (x4 & y5) !== 0;\n}\nvar NonBoundaryPairs = [\n  // GB6\n  [CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT],\n  // GB7\n  [CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T],\n  // GB8\n  [CodepointType.LVT | CodepointType.T, CodepointType.T],\n  // GB9\n  [CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ],\n  // GB9a\n  [CodepointType.Any, CodepointType.SpacingMark],\n  // GB9b\n  [CodepointType.Prepend, CodepointType.Any],\n  // GB11\n  [CodepointType.ZWJ, CodepointType.ExtPict],\n  // GB12 and GB13\n  [CodepointType.RI, CodepointType.RI]\n];\nfunction isBoundaryPair(left2, right2) {\n  return NonBoundaryPairs.findIndex((r7) => intersects(left2, r7[0]) && intersects(right2, r7[1])) === -1;\n}\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\nvar endsWithEmojiZWJ = (str) => {\n  return str.search(endingEmojiZWJ) !== -1;\n};\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\nvar endsWithOddNumberOfRIs = (str) => {\n  var match2 = str.match(endingRIs);\n  if (match2 === null) {\n    return false;\n  } else {\n    var numRIs = match2[0].length / 2;\n    return numRIs % 2 === 1;\n  }\n};\nvar isElement = (value) => {\n  return isPlainObject(value) && Node2.isNodeList(value.children) && !Editor.isEditor(value);\n};\nvar Element2 = {\n  /**\n   * Check if a value implements the 'Ancestor' interface.\n   */\n  isAncestor(value) {\n    return isPlainObject(value) && Node2.isNodeList(value.children);\n  },\n  /**\n   * Check if a value implements the `Element` interface.\n   */\n  isElement,\n  /**\n   * Check if a value is an array of `Element` objects.\n   */\n  isElementList(value) {\n    return Array.isArray(value) && value.every((val) => Element2.isElement(val));\n  },\n  /**\n   * Check if a set of props is a partial of Element.\n   */\n  isElementProps(props) {\n    return props.children !== void 0;\n  },\n  /**\n   * Check if a value implements the `Element` interface and has elementKey with selected value.\n   * Default it check to `type` key value\n   */\n  isElementType: function isElementType(value, elementVal) {\n    var elementKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"type\";\n    return isElement(value) && value[elementKey] === elementVal;\n  },\n  /**\n   * Check if an element matches set of properties.\n   *\n   * Note: this checks custom properties, and it does not ensure that any\n   * children are equivalent.\n   */\n  matches(element4, props) {\n    for (var key in props) {\n      if (key === \"children\") {\n        continue;\n      }\n      if (element4[key] !== props[key]) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\nvar _excluded$4 = [\"text\"];\nvar _excluded2$3 = [\"text\"];\nfunction ownKeys$8(object, enumerableOnly) {\n  var keys4 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys4.push.apply(keys4, symbols);\n  }\n  return keys4;\n}\nfunction _objectSpread$8(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    if (i5 % 2) {\n      ownKeys$8(Object(source), true).forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$8(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar IS_EDITOR_CACHE = /* @__PURE__ */ new WeakMap();\nvar Editor = {\n  /**\n   * Get the ancestor above a location in the document.\n   */\n  above(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var {\n      voids = false,\n      mode = \"lowest\",\n      at = editor.selection,\n      match: match2\n    } = options;\n    if (!at) {\n      return;\n    }\n    var path = Editor.path(editor, at);\n    var reverse = mode === \"lowest\";\n    for (var [n8, p6] of Editor.levels(editor, {\n      at: path,\n      voids,\n      match: match2,\n      reverse\n    })) {\n      if (!Text.isText(n8) && !Path.equals(path, p6)) {\n        return [n8, p6];\n      }\n    }\n  },\n  /**\n   * Add a custom property to the leaf text nodes in the current selection.\n   *\n   * If the selection is currently collapsed, the marks will be added to the\n   * `editor.marks` property instead, and applied when text is inserted next.\n   */\n  addMark(editor, key, value) {\n    editor.addMark(key, value);\n  },\n  /**\n   * Get the point after a location.\n   */\n  after(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var anchor = Editor.point(editor, at, {\n      edge: \"end\"\n    });\n    var focus = Editor.end(editor, []);\n    var range = {\n      anchor,\n      focus\n    };\n    var {\n      distance = 1\n    } = options;\n    var d4 = 0;\n    var target;\n    for (var p6 of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n      at: range\n    }))) {\n      if (d4 > distance) {\n        break;\n      }\n      if (d4 !== 0) {\n        target = p6;\n      }\n      d4++;\n    }\n    return target;\n  },\n  /**\n   * Get the point before a location.\n   */\n  before(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var anchor = Editor.start(editor, []);\n    var focus = Editor.point(editor, at, {\n      edge: \"start\"\n    });\n    var range = {\n      anchor,\n      focus\n    };\n    var {\n      distance = 1\n    } = options;\n    var d4 = 0;\n    var target;\n    for (var p6 of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n      at: range,\n      reverse: true\n    }))) {\n      if (d4 > distance) {\n        break;\n      }\n      if (d4 !== 0) {\n        target = p6;\n      }\n      d4++;\n    }\n    return target;\n  },\n  /**\n   * Delete content in the editor backward from the current selection.\n   */\n  deleteBackward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var {\n      unit = \"character\"\n    } = options;\n    editor.deleteBackward(unit);\n  },\n  /**\n   * Delete content in the editor forward from the current selection.\n   */\n  deleteForward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var {\n      unit = \"character\"\n    } = options;\n    editor.deleteForward(unit);\n  },\n  /**\n   * Delete the content in the current selection.\n   */\n  deleteFragment(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var {\n      direction = \"forward\"\n    } = options;\n    editor.deleteFragment(direction);\n  },\n  /**\n   * Get the start and end points of a location.\n   */\n  edges(editor, at) {\n    return [Editor.start(editor, at), Editor.end(editor, at)];\n  },\n  /**\n   * Get the end point of a location.\n   */\n  end(editor, at) {\n    return Editor.point(editor, at, {\n      edge: \"end\"\n    });\n  },\n  /**\n   * Get the first node at a location.\n   */\n  first(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: \"start\"\n    });\n    return Editor.node(editor, path);\n  },\n  /**\n   * Get the fragment at a location.\n   */\n  fragment(editor, at) {\n    var range = Editor.range(editor, at);\n    var fragment = Node2.fragment(editor, range);\n    return fragment;\n  },\n  /**\n   * Check if a node has block children.\n   */\n  hasBlocks(editor, element4) {\n    return element4.children.some((n8) => Editor.isBlock(editor, n8));\n  },\n  /**\n   * Check if a node has inline and text children.\n   */\n  hasInlines(editor, element4) {\n    return element4.children.some((n8) => Text.isText(n8) || Editor.isInline(editor, n8));\n  },\n  /**\n   * Check if a node has text children.\n   */\n  hasTexts(editor, element4) {\n    return element4.children.every((n8) => Text.isText(n8));\n  },\n  /**\n   * Insert a block break at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n  insertBreak(editor) {\n    editor.insertBreak();\n  },\n  /**\n   * Insert a soft break at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n  insertSoftBreak(editor) {\n    editor.insertSoftBreak();\n  },\n  /**\n   * Insert a fragment at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n  insertFragment(editor, fragment) {\n    editor.insertFragment(fragment);\n  },\n  /**\n   * Insert a node at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n  insertNode(editor, node) {\n    editor.insertNode(node);\n  },\n  /**\n   * Insert text at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n  insertText(editor, text4) {\n    editor.insertText(text4);\n  },\n  /**\n   * Check if a value is a block `Element` object.\n   */\n  isBlock(editor, value) {\n    return Element2.isElement(value) && !editor.isInline(value);\n  },\n  /**\n   * Check if a value is an `Editor` object.\n   */\n  isEditor(value) {\n    var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n    if (cachedIsEditor !== void 0) {\n      return cachedIsEditor;\n    }\n    if (!isPlainObject(value)) {\n      return false;\n    }\n    var isEditor = typeof value.addMark === \"function\" && typeof value.apply === \"function\" && typeof value.deleteBackward === \"function\" && typeof value.deleteForward === \"function\" && typeof value.deleteFragment === \"function\" && typeof value.insertBreak === \"function\" && typeof value.insertSoftBreak === \"function\" && typeof value.insertFragment === \"function\" && typeof value.insertNode === \"function\" && typeof value.insertText === \"function\" && typeof value.isInline === \"function\" && typeof value.isVoid === \"function\" && typeof value.normalizeNode === \"function\" && typeof value.onChange === \"function\" && typeof value.removeMark === \"function\" && (value.marks === null || isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node2.isNodeList(value.children) && Operation.isOperationList(value.operations);\n    IS_EDITOR_CACHE.set(value, isEditor);\n    return isEditor;\n  },\n  /**\n   * Check if a point is the end point of a location.\n   */\n  isEnd(editor, point, at) {\n    var end2 = Editor.end(editor, at);\n    return Point.equals(point, end2);\n  },\n  /**\n   * Check if a point is an edge of a location.\n   */\n  isEdge(editor, point, at) {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n  },\n  /**\n   * Check if an element is empty, accounting for void nodes.\n   */\n  isEmpty(editor, element4) {\n    var {\n      children\n    } = element4;\n    var [first] = children;\n    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === \"\" && !editor.isVoid(element4);\n  },\n  /**\n   * Check if a value is an inline `Element` object.\n   */\n  isInline(editor, value) {\n    return Element2.isElement(value) && editor.isInline(value);\n  },\n  /**\n   * Check if the editor is currently normalizing after each operation.\n   */\n  isNormalizing(editor) {\n    var isNormalizing = NORMALIZING.get(editor);\n    return isNormalizing === void 0 ? true : isNormalizing;\n  },\n  /**\n   * Check if a point is the start point of a location.\n   */\n  isStart(editor, point, at) {\n    if (point.offset !== 0) {\n      return false;\n    }\n    var start2 = Editor.start(editor, at);\n    return Point.equals(point, start2);\n  },\n  /**\n   * Check if a value is a void `Element` object.\n   */\n  isVoid(editor, value) {\n    return Element2.isElement(value) && editor.isVoid(value);\n  },\n  /**\n   * Get the last node at a location.\n   */\n  last(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: \"end\"\n    });\n    return Editor.node(editor, path);\n  },\n  /**\n   * Get the leaf text node at a location.\n   */\n  leaf(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node2.leaf(editor, path);\n    return [node, path];\n  },\n  /**\n   * Iterate through all of the levels at a location.\n   */\n  *levels(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var {\n      at = editor.selection,\n      reverse = false,\n      voids = false\n    } = options;\n    var {\n      match: match2\n    } = options;\n    if (match2 == null) {\n      match2 = () => true;\n    }\n    if (!at) {\n      return;\n    }\n    var levels = [];\n    var path = Editor.path(editor, at);\n    for (var [n8, p6] of Node2.levels(editor, path)) {\n      if (!match2(n8, p6)) {\n        continue;\n      }\n      levels.push([n8, p6]);\n      if (!voids && Editor.isVoid(editor, n8)) {\n        break;\n      }\n    }\n    if (reverse) {\n      levels.reverse();\n    }\n    yield* levels;\n  },\n  /**\n   * Get the marks that would be added to text at the current selection.\n   */\n  marks(editor) {\n    var {\n      marks: marks3,\n      selection\n    } = editor;\n    if (!selection) {\n      return null;\n    }\n    if (marks3) {\n      return marks3;\n    }\n    if (Range.isExpanded(selection)) {\n      var [match2] = Editor.nodes(editor, {\n        match: Text.isText\n      });\n      if (match2) {\n        var [_node] = match2;\n        var _rest = _objectWithoutProperties(_node, _excluded$4);\n        return _rest;\n      } else {\n        return {};\n      }\n    }\n    var {\n      anchor\n    } = selection;\n    var {\n      path\n    } = anchor;\n    var [node] = Editor.leaf(editor, path);\n    if (anchor.offset === 0) {\n      var prev = Editor.previous(editor, {\n        at: path,\n        match: Text.isText\n      });\n      var block = Editor.above(editor, {\n        match: (n8) => Editor.isBlock(editor, n8)\n      });\n      if (prev && block) {\n        var [prevNode, prevPath] = prev;\n        var [, blockPath] = block;\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode;\n        }\n      }\n    }\n    var rest = _objectWithoutProperties(node, _excluded2$3);\n    return rest;\n  },\n  /**\n   * Get the matching node in the branch of the document after a location.\n   */\n  next(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var {\n      mode = \"lowest\",\n      voids = false\n    } = options;\n    var {\n      match: match2,\n      at = editor.selection\n    } = options;\n    if (!at) {\n      return;\n    }\n    var pointAfterLocation = Editor.after(editor, at, {\n      voids\n    });\n    if (!pointAfterLocation)\n      return;\n    var [, to] = Editor.last(editor, []);\n    var span = [pointAfterLocation.path, to];\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the next node from the root node!\");\n    }\n    if (match2 == null) {\n      if (Path.isPath(at)) {\n        var [parent2] = Editor.parent(editor, at);\n        match2 = (n8) => parent2.children.includes(n8);\n      } else {\n        match2 = () => true;\n      }\n    }\n    var [next] = Editor.nodes(editor, {\n      at: span,\n      match: match2,\n      mode,\n      voids\n    });\n    return next;\n  },\n  /**\n   * Get the node at a location.\n   */\n  node(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node2.get(editor, path);\n    return [node, path];\n  },\n  /**\n   * Iterate through all of the nodes in the Editor.\n   */\n  *nodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var {\n      at = editor.selection,\n      mode = \"all\",\n      universal = false,\n      reverse = false,\n      voids = false\n    } = options;\n    var {\n      match: match2\n    } = options;\n    if (!match2) {\n      match2 = () => true;\n    }\n    if (!at) {\n      return;\n    }\n    var from;\n    var to;\n    if (Span.isSpan(at)) {\n      from = at[0];\n      to = at[1];\n    } else {\n      var first = Editor.path(editor, at, {\n        edge: \"start\"\n      });\n      var last2 = Editor.path(editor, at, {\n        edge: \"end\"\n      });\n      from = reverse ? last2 : first;\n      to = reverse ? first : last2;\n    }\n    var nodeEntries = Node2.nodes(editor, {\n      reverse,\n      from,\n      to,\n      pass: (_ref) => {\n        var [n8] = _ref;\n        return voids ? false : Editor.isVoid(editor, n8);\n      }\n    });\n    var matches = [];\n    var hit;\n    for (var [node, path] of nodeEntries) {\n      var isLower = hit && Path.compare(path, hit[1]) === 0;\n      if (mode === \"highest\" && isLower) {\n        continue;\n      }\n      if (!match2(node, path)) {\n        if (universal && !isLower && Text.isText(node)) {\n          return;\n        } else {\n          continue;\n        }\n      }\n      if (mode === \"lowest\" && isLower) {\n        hit = [node, path];\n        continue;\n      }\n      var emit2 = mode === \"lowest\" ? hit : [node, path];\n      if (emit2) {\n        if (universal) {\n          matches.push(emit2);\n        } else {\n          yield emit2;\n        }\n      }\n      hit = [node, path];\n    }\n    if (mode === \"lowest\" && hit) {\n      if (universal) {\n        matches.push(hit);\n      } else {\n        yield hit;\n      }\n    }\n    if (universal) {\n      yield* matches;\n    }\n  },\n  /**\n   * Normalize any dirty objects in the editor.\n   */\n  normalize(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var {\n      force = false\n    } = options;\n    var getDirtyPaths2 = (editor2) => {\n      return DIRTY_PATHS.get(editor2) || [];\n    };\n    var getDirtyPathKeys = (editor2) => {\n      return DIRTY_PATH_KEYS.get(editor2) || /* @__PURE__ */ new Set();\n    };\n    var popDirtyPath = (editor2) => {\n      var path = getDirtyPaths2(editor2).pop();\n      var key = path.join(\",\");\n      getDirtyPathKeys(editor2).delete(key);\n      return path;\n    };\n    if (!Editor.isNormalizing(editor)) {\n      return;\n    }\n    if (force) {\n      var allPaths = Array.from(Node2.nodes(editor), (_ref2) => {\n        var [, p6] = _ref2;\n        return p6;\n      });\n      var allPathKeys = new Set(allPaths.map((p6) => p6.join(\",\")));\n      DIRTY_PATHS.set(editor, allPaths);\n      DIRTY_PATH_KEYS.set(editor, allPathKeys);\n    }\n    if (getDirtyPaths2(editor).length === 0) {\n      return;\n    }\n    Editor.withoutNormalizing(editor, () => {\n      for (var dirtyPath of getDirtyPaths2(editor)) {\n        if (Node2.has(editor, dirtyPath)) {\n          var entry = Editor.node(editor, dirtyPath);\n          var [node, _2] = entry;\n          if (Element2.isElement(node) && node.children.length === 0) {\n            editor.normalizeNode(entry);\n          }\n        }\n      }\n      var max3 = getDirtyPaths2(editor).length * 42;\n      var m4 = 0;\n      while (getDirtyPaths2(editor).length !== 0) {\n        if (m4 > max3) {\n          throw new Error(\"\\n            Could not completely normalize the editor after \".concat(max3, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\\n          \"));\n        }\n        var _dirtyPath = popDirtyPath(editor);\n        if (Node2.has(editor, _dirtyPath)) {\n          var _entry = Editor.node(editor, _dirtyPath);\n          editor.normalizeNode(_entry);\n        }\n        m4++;\n      }\n    });\n  },\n  /**\n   * Get the parent node of a location.\n   */\n  parent(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var parentPath = Path.parent(path);\n    var entry = Editor.node(editor, parentPath);\n    return entry;\n  },\n  /**\n   * Get the path of a location.\n   */\n  path(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var {\n      depth,\n      edge\n    } = options;\n    if (Path.isPath(at)) {\n      if (edge === \"start\") {\n        var [, firstPath] = Node2.first(editor, at);\n        at = firstPath;\n      } else if (edge === \"end\") {\n        var [, lastPath] = Node2.last(editor, at);\n        at = lastPath;\n      }\n    }\n    if (Range.isRange(at)) {\n      if (edge === \"start\") {\n        at = Range.start(at);\n      } else if (edge === \"end\") {\n        at = Range.end(at);\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path);\n      }\n    }\n    if (Point.isPoint(at)) {\n      at = at.path;\n    }\n    if (depth != null) {\n      at = at.slice(0, depth);\n    }\n    return at;\n  },\n  hasPath(editor, path) {\n    return Node2.has(editor, path);\n  },\n  /**\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n  pathRef(editor, path) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var {\n      affinity = \"forward\"\n    } = options;\n    var ref = {\n      current: path,\n      affinity,\n      unref() {\n        var {\n          current\n        } = ref;\n        var pathRefs = Editor.pathRefs(editor);\n        pathRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.pathRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n  /**\n   * Get the set of currently tracked path refs of the editor.\n   */\n  pathRefs(editor) {\n    var refs = PATH_REFS.get(editor);\n    if (!refs) {\n      refs = /* @__PURE__ */ new Set();\n      PATH_REFS.set(editor, refs);\n    }\n    return refs;\n  },\n  /**\n   * Get the start or end point of a location.\n   */\n  point(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var {\n      edge = \"start\"\n    } = options;\n    if (Path.isPath(at)) {\n      var path;\n      if (edge === \"end\") {\n        var [, lastPath] = Node2.last(editor, at);\n        path = lastPath;\n      } else {\n        var [, firstPath] = Node2.first(editor, at);\n        path = firstPath;\n      }\n      var node = Node2.get(editor, path);\n      if (!Text.isText(node)) {\n        throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n      }\n      return {\n        path,\n        offset: edge === \"end\" ? node.text.length : 0\n      };\n    }\n    if (Range.isRange(at)) {\n      var [start2, end2] = Range.edges(at);\n      return edge === \"start\" ? start2 : end2;\n    }\n    return at;\n  },\n  /**\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n  pointRef(editor, point) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var {\n      affinity = \"forward\"\n    } = options;\n    var ref = {\n      current: point,\n      affinity,\n      unref() {\n        var {\n          current\n        } = ref;\n        var pointRefs = Editor.pointRefs(editor);\n        pointRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.pointRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n  /**\n   * Get the set of currently tracked point refs of the editor.\n   */\n  pointRefs(editor) {\n    var refs = POINT_REFS.get(editor);\n    if (!refs) {\n      refs = /* @__PURE__ */ new Set();\n      POINT_REFS.set(editor, refs);\n    }\n    return refs;\n  },\n  /**\n   * Return all the positions in `at` range where a `Point` can be placed.\n   *\n   * By default, moves forward by individual offsets at a time, but\n   * the `unit` option can be used to to move by character, word, line, or block.\n   *\n   * The `reverse` option can be used to change iteration direction.\n   *\n   * Note: By default void nodes are treated as a single point and iteration\n   * will not happen inside their content unless you pass in true for the\n   * `voids` option, then iteration will occur.\n   */\n  *positions(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var {\n      at = editor.selection,\n      unit = \"offset\",\n      reverse = false,\n      voids = false\n    } = options;\n    if (!at) {\n      return;\n    }\n    var range = Editor.range(editor, at);\n    var [start2, end2] = Range.edges(range);\n    var first = reverse ? end2 : start2;\n    var isNewBlock = false;\n    var blockText = \"\";\n    var distance = 0;\n    var leafTextRemaining = 0;\n    var leafTextOffset = 0;\n    for (var [node, path] of Editor.nodes(editor, {\n      at,\n      reverse,\n      voids\n    })) {\n      if (Element2.isElement(node)) {\n        if (!voids && editor.isVoid(node)) {\n          yield Editor.start(editor, path);\n          continue;\n        }\n        if (editor.isInline(node))\n          continue;\n        if (Editor.hasInlines(editor, node)) {\n          var e4 = Path.isAncestor(path, end2.path) ? end2 : Editor.end(editor, path);\n          var s5 = Path.isAncestor(path, start2.path) ? start2 : Editor.start(editor, path);\n          blockText = Editor.string(editor, {\n            anchor: s5,\n            focus: e4\n          }, {\n            voids\n          });\n          isNewBlock = true;\n        }\n      }\n      if (Text.isText(node)) {\n        var isFirst = Path.equals(path, first.path);\n        if (isFirst) {\n          leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n          leafTextOffset = first.offset;\n        } else {\n          leafTextRemaining = node.text.length;\n          leafTextOffset = reverse ? leafTextRemaining : 0;\n        }\n        if (isFirst || isNewBlock || unit === \"offset\") {\n          yield {\n            path,\n            offset: leafTextOffset\n          };\n          isNewBlock = false;\n        }\n        while (true) {\n          if (distance === 0) {\n            if (blockText === \"\")\n              break;\n            distance = calcDistance(blockText, unit, reverse);\n            blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n          }\n          leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n          leafTextRemaining = leafTextRemaining - distance;\n          if (leafTextRemaining < 0) {\n            distance = -leafTextRemaining;\n            break;\n          }\n          distance = 0;\n          yield {\n            path,\n            offset: leafTextOffset\n          };\n        }\n      }\n    }\n    function calcDistance(text4, unit2, reverse2) {\n      if (unit2 === \"character\") {\n        return getCharacterDistance(text4, reverse2);\n      } else if (unit2 === \"word\") {\n        return getWordDistance(text4, reverse2);\n      } else if (unit2 === \"line\" || unit2 === \"block\") {\n        return text4.length;\n      }\n      return 1;\n    }\n  },\n  /**\n   * Get the matching node in the branch of the document before a location.\n   */\n  previous(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var {\n      mode = \"lowest\",\n      voids = false\n    } = options;\n    var {\n      match: match2,\n      at = editor.selection\n    } = options;\n    if (!at) {\n      return;\n    }\n    var pointBeforeLocation = Editor.before(editor, at, {\n      voids\n    });\n    if (!pointBeforeLocation) {\n      return;\n    }\n    var [, to] = Editor.first(editor, []);\n    var span = [pointBeforeLocation.path, to];\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the previous node from the root node!\");\n    }\n    if (match2 == null) {\n      if (Path.isPath(at)) {\n        var [parent2] = Editor.parent(editor, at);\n        match2 = (n8) => parent2.children.includes(n8);\n      } else {\n        match2 = () => true;\n      }\n    }\n    var [previous] = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match: match2,\n      mode,\n      voids\n    });\n    return previous;\n  },\n  /**\n   * Get a range of a location.\n   */\n  range(editor, at, to) {\n    if (Range.isRange(at) && !to) {\n      return at;\n    }\n    var start2 = Editor.start(editor, at);\n    var end2 = Editor.end(editor, to || at);\n    return {\n      anchor: start2,\n      focus: end2\n    };\n  },\n  /**\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n  rangeRef(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var {\n      affinity = \"forward\"\n    } = options;\n    var ref = {\n      current: range,\n      affinity,\n      unref() {\n        var {\n          current\n        } = ref;\n        var rangeRefs = Editor.rangeRefs(editor);\n        rangeRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.rangeRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n  /**\n   * Get the set of currently tracked range refs of the editor.\n   */\n  rangeRefs(editor) {\n    var refs = RANGE_REFS.get(editor);\n    if (!refs) {\n      refs = /* @__PURE__ */ new Set();\n      RANGE_REFS.set(editor, refs);\n    }\n    return refs;\n  },\n  /**\n   * Remove a custom property from all of the leaf text nodes in the current\n   * selection.\n   *\n   * If the selection is currently collapsed, the removal will be stored on\n   * `editor.marks` and applied to the text inserted next.\n   */\n  removeMark(editor, key) {\n    editor.removeMark(key);\n  },\n  /**\n   * Manually set if the editor should currently be normalizing.\n   *\n   * Note: Using this incorrectly can leave the editor in an invalid state.\n   *\n   */\n  setNormalizing(editor, isNormalizing) {\n    NORMALIZING.set(editor, isNormalizing);\n  },\n  /**\n   * Get the start point of a location.\n   */\n  start(editor, at) {\n    return Editor.point(editor, at, {\n      edge: \"start\"\n    });\n  },\n  /**\n   * Get the text string content of a location.\n   *\n   * Note: by default the text of void nodes is considered to be an empty\n   * string, regardless of content, unless you pass in true for the voids option\n   */\n  string(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var {\n      voids = false\n    } = options;\n    var range = Editor.range(editor, at);\n    var [start2, end2] = Range.edges(range);\n    var text4 = \"\";\n    for (var [node, path] of Editor.nodes(editor, {\n      at: range,\n      match: Text.isText,\n      voids\n    })) {\n      var t6 = node.text;\n      if (Path.equals(path, end2.path)) {\n        t6 = t6.slice(0, end2.offset);\n      }\n      if (Path.equals(path, start2.path)) {\n        t6 = t6.slice(start2.offset);\n      }\n      text4 += t6;\n    }\n    return text4;\n  },\n  /**\n   * Convert a range into a non-hanging one.\n   */\n  unhangRange(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var {\n      voids = false\n    } = options;\n    var [start2, end2] = Range.edges(range);\n    if (start2.offset !== 0 || end2.offset !== 0 || Range.isCollapsed(range)) {\n      return range;\n    }\n    var endBlock = Editor.above(editor, {\n      at: end2,\n      match: (n8) => Editor.isBlock(editor, n8)\n    });\n    var blockPath = endBlock ? endBlock[1] : [];\n    var first = Editor.start(editor, start2);\n    var before = {\n      anchor: first,\n      focus: end2\n    };\n    var skip = true;\n    for (var [node, path] of Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids\n    })) {\n      if (skip) {\n        skip = false;\n        continue;\n      }\n      if (node.text !== \"\" || Path.isBefore(path, blockPath)) {\n        end2 = {\n          path,\n          offset: node.text.length\n        };\n        break;\n      }\n    }\n    return {\n      anchor: start2,\n      focus: end2\n    };\n  },\n  /**\n   * Match a void node in the current branch of the editor.\n   */\n  void(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return Editor.above(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n      match: (n8) => Editor.isVoid(editor, n8)\n    }));\n  },\n  /**\n   * Call a function, deferring normalization until after it completes.\n   */\n  withoutNormalizing(editor, fn4) {\n    var value = Editor.isNormalizing(editor);\n    Editor.setNormalizing(editor, false);\n    try {\n      fn4();\n    } finally {\n      Editor.setNormalizing(editor, value);\n    }\n    Editor.normalize(editor);\n  }\n};\nvar Span = {\n  /**\n   * Check if a value implements the `Span` interface.\n   */\n  isSpan(value) {\n    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n  }\n};\nvar _excluded$3 = [\"children\"];\nvar _excluded2$2 = [\"text\"];\nvar IS_NODE_LIST_CACHE = /* @__PURE__ */ new WeakMap();\nvar Node2 = {\n  /**\n   * Get the node at a specific path, asserting that it's an ancestor node.\n   */\n  ancestor(root5, path) {\n    var node = Node2.get(root5, path);\n    if (Text.isText(node)) {\n      throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n    }\n    return node;\n  },\n  /**\n   * Return a generator of all the ancestor nodes above a specific path.\n   *\n   * By default the order is top-down, from highest to lowest ancestor in\n   * the tree, but you can pass the `reverse: true` option to go bottom-up.\n   */\n  *ancestors(root5, path) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    for (var p6 of Path.ancestors(path, options)) {\n      var n8 = Node2.ancestor(root5, p6);\n      var entry = [n8, p6];\n      yield entry;\n    }\n  },\n  /**\n   * Get the child of a node at a specific index.\n   */\n  child(root5, index5) {\n    if (Text.isText(root5)) {\n      throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root5)));\n    }\n    var c5 = root5.children[index5];\n    if (c5 == null) {\n      throw new Error(\"Cannot get child at index `\".concat(index5, \"` in node: \").concat(Scrubber.stringify(root5)));\n    }\n    return c5;\n  },\n  /**\n   * Iterate over the children of a node at a specific path.\n   */\n  *children(root5, path) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var {\n      reverse = false\n    } = options;\n    var ancestor = Node2.ancestor(root5, path);\n    var {\n      children\n    } = ancestor;\n    var index5 = reverse ? children.length - 1 : 0;\n    while (reverse ? index5 >= 0 : index5 < children.length) {\n      var child = Node2.child(ancestor, index5);\n      var childPath = path.concat(index5);\n      yield [child, childPath];\n      index5 = reverse ? index5 - 1 : index5 + 1;\n    }\n  },\n  /**\n   * Get an entry for the common ancesetor node of two paths.\n   */\n  common(root5, path, another) {\n    var p6 = Path.common(path, another);\n    var n8 = Node2.get(root5, p6);\n    return [n8, p6];\n  },\n  /**\n   * Get the node at a specific path, asserting that it's a descendant node.\n   */\n  descendant(root5, path) {\n    var node = Node2.get(root5, path);\n    if (Editor.isEditor(node)) {\n      throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n    }\n    return node;\n  },\n  /**\n   * Return a generator of all the descendant node entries inside a root node.\n   */\n  *descendants(root5) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    for (var [node, path] of Node2.nodes(root5, options)) {\n      if (path.length !== 0) {\n        yield [node, path];\n      }\n    }\n  },\n  /**\n   * Return a generator of all the element nodes inside a root node. Each iteration\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\n   * root node is an element it will be included in the iteration as well.\n   */\n  *elements(root5) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    for (var [node, path] of Node2.nodes(root5, options)) {\n      if (Element2.isElement(node)) {\n        yield [node, path];\n      }\n    }\n  },\n  /**\n   * Extract props from a Node.\n   */\n  extractProps(node) {\n    if (Element2.isAncestor(node)) {\n      var properties = _objectWithoutProperties(node, _excluded$3);\n      return properties;\n    } else {\n      var properties = _objectWithoutProperties(node, _excluded2$2);\n      return properties;\n    }\n  },\n  /**\n   * Get the first node entry in a root node from a path.\n   */\n  first(root5, path) {\n    var p6 = path.slice();\n    var n8 = Node2.get(root5, p6);\n    while (n8) {\n      if (Text.isText(n8) || n8.children.length === 0) {\n        break;\n      } else {\n        n8 = n8.children[0];\n        p6.push(0);\n      }\n    }\n    return [n8, p6];\n  },\n  /**\n   * Get the sliced fragment represented by a range inside a root node.\n   */\n  fragment(root5, range) {\n    if (Text.isText(root5)) {\n      throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(Scrubber.stringify(root5)));\n    }\n    var newRoot = fn({\n      children: root5.children\n    }, (r7) => {\n      var [start2, end2] = Range.edges(range);\n      var nodeEntries = Node2.nodes(r7, {\n        reverse: true,\n        pass: (_ref) => {\n          var [, path2] = _ref;\n          return !Range.includes(range, path2);\n        }\n      });\n      for (var [, path] of nodeEntries) {\n        if (!Range.includes(range, path)) {\n          var parent2 = Node2.parent(r7, path);\n          var index5 = path[path.length - 1];\n          parent2.children.splice(index5, 1);\n        }\n        if (Path.equals(path, end2.path)) {\n          var leaf = Node2.leaf(r7, path);\n          leaf.text = leaf.text.slice(0, end2.offset);\n        }\n        if (Path.equals(path, start2.path)) {\n          var _leaf = Node2.leaf(r7, path);\n          _leaf.text = _leaf.text.slice(start2.offset);\n        }\n      }\n      if (Editor.isEditor(r7)) {\n        r7.selection = null;\n      }\n    });\n    return newRoot.children;\n  },\n  /**\n   * Get the descendant node referred to by a specific path. If the path is an\n   * empty array, it refers to the root node itself.\n   */\n  get(root5, path) {\n    var node = root5;\n    for (var i5 = 0; i5 < path.length; i5++) {\n      var p6 = path[i5];\n      if (Text.isText(node) || !node.children[p6]) {\n        throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root5)));\n      }\n      node = node.children[p6];\n    }\n    return node;\n  },\n  /**\n   * Check if a descendant node exists at a specific path.\n   */\n  has(root5, path) {\n    var node = root5;\n    for (var i5 = 0; i5 < path.length; i5++) {\n      var p6 = path[i5];\n      if (Text.isText(node) || !node.children[p6]) {\n        return false;\n      }\n      node = node.children[p6];\n    }\n    return true;\n  },\n  /**\n   * Check if a value implements the `Node` interface.\n   */\n  isNode(value) {\n    return Text.isText(value) || Element2.isElement(value) || Editor.isEditor(value);\n  },\n  /**\n   * Check if a value is a list of `Node` objects.\n   */\n  isNodeList(value) {\n    if (!Array.isArray(value)) {\n      return false;\n    }\n    var cachedResult = IS_NODE_LIST_CACHE.get(value);\n    if (cachedResult !== void 0) {\n      return cachedResult;\n    }\n    var isNodeList2 = value.every((val) => Node2.isNode(val));\n    IS_NODE_LIST_CACHE.set(value, isNodeList2);\n    return isNodeList2;\n  },\n  /**\n   * Get the last node entry in a root node from a path.\n   */\n  last(root5, path) {\n    var p6 = path.slice();\n    var n8 = Node2.get(root5, p6);\n    while (n8) {\n      if (Text.isText(n8) || n8.children.length === 0) {\n        break;\n      } else {\n        var i5 = n8.children.length - 1;\n        n8 = n8.children[i5];\n        p6.push(i5);\n      }\n    }\n    return [n8, p6];\n  },\n  /**\n   * Get the node at a specific path, ensuring it's a leaf text node.\n   */\n  leaf(root5, path) {\n    var node = Node2.get(root5, path);\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n    }\n    return node;\n  },\n  /**\n   * Return a generator of the in a branch of the tree, from a specific path.\n   *\n   * By default the order is top-down, from highest to lowest node in the tree,\n   * but you can pass the `reverse: true` option to go bottom-up.\n   */\n  *levels(root5, path) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    for (var p6 of Path.levels(path, options)) {\n      var n8 = Node2.get(root5, p6);\n      yield [n8, p6];\n    }\n  },\n  /**\n   * Check if a node matches a set of props.\n   */\n  matches(node, props) {\n    return Element2.isElement(node) && Element2.isElementProps(props) && Element2.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n  },\n  /**\n   * Return a generator of all the node entries of a root node. Each entry is\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\n   * position inside the root node.\n   */\n  *nodes(root5) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var {\n      pass,\n      reverse = false\n    } = options;\n    var {\n      from = [],\n      to\n    } = options;\n    var visited = /* @__PURE__ */ new Set();\n    var p6 = [];\n    var n8 = root5;\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p6, to) : Path.isAfter(p6, to))) {\n        break;\n      }\n      if (!visited.has(n8)) {\n        yield [n8, p6];\n      }\n      if (!visited.has(n8) && !Text.isText(n8) && n8.children.length !== 0 && (pass == null || pass([n8, p6]) === false)) {\n        visited.add(n8);\n        var nextIndex = reverse ? n8.children.length - 1 : 0;\n        if (Path.isAncestor(p6, from)) {\n          nextIndex = from[p6.length];\n        }\n        p6 = p6.concat(nextIndex);\n        n8 = Node2.get(root5, p6);\n        continue;\n      }\n      if (p6.length === 0) {\n        break;\n      }\n      if (!reverse) {\n        var newPath = Path.next(p6);\n        if (Node2.has(root5, newPath)) {\n          p6 = newPath;\n          n8 = Node2.get(root5, p6);\n          continue;\n        }\n      }\n      if (reverse && p6[p6.length - 1] !== 0) {\n        var _newPath = Path.previous(p6);\n        p6 = _newPath;\n        n8 = Node2.get(root5, p6);\n        continue;\n      }\n      p6 = Path.parent(p6);\n      n8 = Node2.get(root5, p6);\n      visited.add(n8);\n    }\n  },\n  /**\n   * Get the parent of a node at a specific path.\n   */\n  parent(root5, path) {\n    var parentPath = Path.parent(path);\n    var p6 = Node2.get(root5, parentPath);\n    if (Text.isText(p6)) {\n      throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n    }\n    return p6;\n  },\n  /**\n   * Get the concatenated text string of a node's content.\n   *\n   * Note that this will not include spaces or line breaks between block nodes.\n   * It is not a user-facing string, but a string for performing offset-related\n   * computations for a node.\n   */\n  string(node) {\n    if (Text.isText(node)) {\n      return node.text;\n    } else {\n      return node.children.map(Node2.string).join(\"\");\n    }\n  },\n  /**\n   * Return a generator of all leaf text nodes in a root node.\n   */\n  *texts(root5) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    for (var [node, path] of Node2.nodes(root5, options)) {\n      if (Text.isText(node)) {\n        yield [node, path];\n      }\n    }\n  }\n};\nfunction ownKeys$7(object, enumerableOnly) {\n  var keys4 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys4.push.apply(keys4, symbols);\n  }\n  return keys4;\n}\nfunction _objectSpread$7(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    if (i5 % 2) {\n      ownKeys$7(Object(source), true).forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$7(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar Operation = {\n  /**\n   * Check of a value is a `NodeOperation` object.\n   */\n  isNodeOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith(\"_node\");\n  },\n  /**\n   * Check of a value is an `Operation` object.\n   */\n  isOperation(value) {\n    if (!isPlainObject(value)) {\n      return false;\n    }\n    switch (value.type) {\n      case \"insert_node\":\n        return Path.isPath(value.path) && Node2.isNode(value.node);\n      case \"insert_text\":\n        return typeof value.offset === \"number\" && typeof value.text === \"string\" && Path.isPath(value.path);\n      case \"merge_node\":\n        return typeof value.position === \"number\" && Path.isPath(value.path) && isPlainObject(value.properties);\n      case \"move_node\":\n        return Path.isPath(value.path) && Path.isPath(value.newPath);\n      case \"remove_node\":\n        return Path.isPath(value.path) && Node2.isNode(value.node);\n      case \"remove_text\":\n        return typeof value.offset === \"number\" && typeof value.text === \"string\" && Path.isPath(value.path);\n      case \"set_node\":\n        return Path.isPath(value.path) && isPlainObject(value.properties) && isPlainObject(value.newProperties);\n      case \"set_selection\":\n        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject(value.properties) && isPlainObject(value.newProperties);\n      case \"split_node\":\n        return Path.isPath(value.path) && typeof value.position === \"number\" && isPlainObject(value.properties);\n      default:\n        return false;\n    }\n  },\n  /**\n   * Check if a value is a list of `Operation` objects.\n   */\n  isOperationList(value) {\n    return Array.isArray(value) && value.every((val) => Operation.isOperation(val));\n  },\n  /**\n   * Check of a value is a `SelectionOperation` object.\n   */\n  isSelectionOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith(\"_selection\");\n  },\n  /**\n   * Check of a value is a `TextOperation` object.\n   */\n  isTextOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith(\"_text\");\n  },\n  /**\n   * Invert an operation, returning a new operation that will exactly undo the\n   * original when applied.\n   */\n  inverse(op) {\n    switch (op.type) {\n      case \"insert_node\": {\n        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n          type: \"remove_node\"\n        });\n      }\n      case \"insert_text\": {\n        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n          type: \"remove_text\"\n        });\n      }\n      case \"merge_node\": {\n        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n          type: \"split_node\",\n          path: Path.previous(op.path)\n        });\n      }\n      case \"move_node\": {\n        var {\n          newPath,\n          path\n        } = op;\n        if (Path.equals(newPath, path)) {\n          return op;\n        }\n        if (Path.isSibling(path, newPath)) {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            path: newPath,\n            newPath: path\n          });\n        }\n        var inversePath = Path.transform(path, op);\n        var inverseNewPath = Path.transform(Path.next(path), op);\n        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n          path: inversePath,\n          newPath: inverseNewPath\n        });\n      }\n      case \"remove_node\": {\n        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n          type: \"insert_node\"\n        });\n      }\n      case \"remove_text\": {\n        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n          type: \"insert_text\"\n        });\n      }\n      case \"set_node\": {\n        var {\n          properties,\n          newProperties\n        } = op;\n        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n          properties: newProperties,\n          newProperties: properties\n        });\n      }\n      case \"set_selection\": {\n        var {\n          properties: _properties,\n          newProperties: _newProperties\n        } = op;\n        if (_properties == null) {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            properties: _newProperties,\n            newProperties: null\n          });\n        } else if (_newProperties == null) {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            properties: null,\n            newProperties: _properties\n          });\n        } else {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            properties: _newProperties,\n            newProperties: _properties\n          });\n        }\n      }\n      case \"split_node\": {\n        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n          type: \"merge_node\",\n          path: Path.next(op.path)\n        });\n      }\n    }\n  }\n};\nvar Path = {\n  /**\n   * Get a list of ancestor paths for a given path.\n   *\n   * The paths are sorted from shallowest to deepest ancestor. However, if the\n   * `reverse: true` option is passed, they are reversed.\n   */\n  ancestors(path) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var paths = Path.levels(path, options);\n    if (reverse) {\n      paths = paths.slice(1);\n    } else {\n      paths = paths.slice(0, -1);\n    }\n    return paths;\n  },\n  /**\n   * Get the common ancestor path of two paths.\n   */\n  common(path, another) {\n    var common = [];\n    for (var i5 = 0; i5 < path.length && i5 < another.length; i5++) {\n      var av = path[i5];\n      var bv = another[i5];\n      if (av !== bv) {\n        break;\n      }\n      common.push(av);\n    }\n    return common;\n  },\n  /**\n   * Compare a path to another, returning an integer indicating whether the path\n   * was before, at, or after the other.\n   *\n   * Note: Two paths of unequal length can still receive a `0` result if one is\n   * directly above or below the other. If you want exact matching, use\n   * [[Path.equals]] instead.\n   */\n  compare(path, another) {\n    var min3 = Math.min(path.length, another.length);\n    for (var i5 = 0; i5 < min3; i5++) {\n      if (path[i5] < another[i5])\n        return -1;\n      if (path[i5] > another[i5])\n        return 1;\n    }\n    return 0;\n  },\n  /**\n   * Check if a path ends after one of the indexes in another.\n   */\n  endsAfter(path, another) {\n    var i5 = path.length - 1;\n    var as = path.slice(0, i5);\n    var bs = another.slice(0, i5);\n    var av = path[i5];\n    var bv = another[i5];\n    return Path.equals(as, bs) && av > bv;\n  },\n  /**\n   * Check if a path ends at one of the indexes in another.\n   */\n  endsAt(path, another) {\n    var i5 = path.length;\n    var as = path.slice(0, i5);\n    var bs = another.slice(0, i5);\n    return Path.equals(as, bs);\n  },\n  /**\n   * Check if a path ends before one of the indexes in another.\n   */\n  endsBefore(path, another) {\n    var i5 = path.length - 1;\n    var as = path.slice(0, i5);\n    var bs = another.slice(0, i5);\n    var av = path[i5];\n    var bv = another[i5];\n    return Path.equals(as, bs) && av < bv;\n  },\n  /**\n   * Check if a path is exactly equal to another.\n   */\n  equals(path, another) {\n    return path.length === another.length && path.every((n8, i5) => n8 === another[i5]);\n  },\n  /**\n   * Check if the path of previous sibling node exists\n   */\n  hasPrevious(path) {\n    return path[path.length - 1] > 0;\n  },\n  /**\n   * Check if a path is after another.\n   */\n  isAfter(path, another) {\n    return Path.compare(path, another) === 1;\n  },\n  /**\n   * Check if a path is an ancestor of another.\n   */\n  isAncestor(path, another) {\n    return path.length < another.length && Path.compare(path, another) === 0;\n  },\n  /**\n   * Check if a path is before another.\n   */\n  isBefore(path, another) {\n    return Path.compare(path, another) === -1;\n  },\n  /**\n   * Check if a path is a child of another.\n   */\n  isChild(path, another) {\n    return path.length === another.length + 1 && Path.compare(path, another) === 0;\n  },\n  /**\n   * Check if a path is equal to or an ancestor of another.\n   */\n  isCommon(path, another) {\n    return path.length <= another.length && Path.compare(path, another) === 0;\n  },\n  /**\n   * Check if a path is a descendant of another.\n   */\n  isDescendant(path, another) {\n    return path.length > another.length && Path.compare(path, another) === 0;\n  },\n  /**\n   * Check if a path is the parent of another.\n   */\n  isParent(path, another) {\n    return path.length + 1 === another.length && Path.compare(path, another) === 0;\n  },\n  /**\n   * Check is a value implements the `Path` interface.\n   */\n  isPath(value) {\n    return Array.isArray(value) && (value.length === 0 || typeof value[0] === \"number\");\n  },\n  /**\n   * Check if a path is a sibling of another.\n   */\n  isSibling(path, another) {\n    if (path.length !== another.length) {\n      return false;\n    }\n    var as = path.slice(0, -1);\n    var bs = another.slice(0, -1);\n    var al = path[path.length - 1];\n    var bl = another[another.length - 1];\n    return al !== bl && Path.equals(as, bs);\n  },\n  /**\n   * Get a list of paths at every level down to a path. Note: this is the same\n   * as `Path.ancestors`, but including the path itself.\n   *\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\n   * true` option is passed, they are reversed.\n   */\n  levels(path) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var list = [];\n    for (var i5 = 0; i5 <= path.length; i5++) {\n      list.push(path.slice(0, i5));\n    }\n    if (reverse) {\n      list.reverse();\n    }\n    return list;\n  },\n  /**\n   * Given a path, get the path to the next sibling node.\n   */\n  next(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n    }\n    var last2 = path[path.length - 1];\n    return path.slice(0, -1).concat(last2 + 1);\n  },\n  /**\n   * Returns whether this operation can affect paths or not. Used as an\n   * optimization when updating dirty paths during normalization\n   *\n   * NOTE: This *must* be kept in sync with the implementation of 'transform'\n   * below\n   */\n  operationCanTransformPath(operation) {\n    switch (operation.type) {\n      case \"insert_node\":\n      case \"remove_node\":\n      case \"merge_node\":\n      case \"split_node\":\n      case \"move_node\":\n        return true;\n      default:\n        return false;\n    }\n  },\n  /**\n   * Given a path, return a new path referring to the parent node above it.\n   */\n  parent(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n    }\n    return path.slice(0, -1);\n  },\n  /**\n   * Given a path, get the path to the previous sibling node.\n   */\n  previous(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n    }\n    var last2 = path[path.length - 1];\n    if (last2 <= 0) {\n      throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n    }\n    return path.slice(0, -1).concat(last2 - 1);\n  },\n  /**\n   * Get a path relative to an ancestor.\n   */\n  relative(path, ancestor) {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n    }\n    return path.slice(ancestor.length);\n  },\n  /**\n   * Transform a path by an operation.\n   */\n  transform(path, operation) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return fn(path, (p6) => {\n      var {\n        affinity = \"forward\"\n      } = options;\n      if (!path || (path === null || path === void 0 ? void 0 : path.length) === 0) {\n        return;\n      }\n      if (p6 === null) {\n        return null;\n      }\n      switch (operation.type) {\n        case \"insert_node\": {\n          var {\n            path: op\n          } = operation;\n          if (Path.equals(op, p6) || Path.endsBefore(op, p6) || Path.isAncestor(op, p6)) {\n            p6[op.length - 1] += 1;\n          }\n          break;\n        }\n        case \"remove_node\": {\n          var {\n            path: _op\n          } = operation;\n          if (Path.equals(_op, p6) || Path.isAncestor(_op, p6)) {\n            return null;\n          } else if (Path.endsBefore(_op, p6)) {\n            p6[_op.length - 1] -= 1;\n          }\n          break;\n        }\n        case \"merge_node\": {\n          var {\n            path: _op2,\n            position\n          } = operation;\n          if (Path.equals(_op2, p6) || Path.endsBefore(_op2, p6)) {\n            p6[_op2.length - 1] -= 1;\n          } else if (Path.isAncestor(_op2, p6)) {\n            p6[_op2.length - 1] -= 1;\n            p6[_op2.length] += position;\n          }\n          break;\n        }\n        case \"split_node\": {\n          var {\n            path: _op3,\n            position: _position\n          } = operation;\n          if (Path.equals(_op3, p6)) {\n            if (affinity === \"forward\") {\n              p6[p6.length - 1] += 1;\n            } else if (affinity === \"backward\")\n              ;\n            else {\n              return null;\n            }\n          } else if (Path.endsBefore(_op3, p6)) {\n            p6[_op3.length - 1] += 1;\n          } else if (Path.isAncestor(_op3, p6) && path[_op3.length] >= _position) {\n            p6[_op3.length - 1] += 1;\n            p6[_op3.length] -= _position;\n          }\n          break;\n        }\n        case \"move_node\": {\n          var {\n            path: _op4,\n            newPath: onp\n          } = operation;\n          if (Path.equals(_op4, onp)) {\n            return;\n          }\n          if (Path.isAncestor(_op4, p6) || Path.equals(_op4, p6)) {\n            var copy = onp.slice();\n            if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n              copy[_op4.length - 1] -= 1;\n            }\n            return copy.concat(p6.slice(_op4.length));\n          } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p6) || Path.equals(onp, p6))) {\n            if (Path.endsBefore(_op4, p6)) {\n              p6[_op4.length - 1] -= 1;\n            } else {\n              p6[_op4.length - 1] += 1;\n            }\n          } else if (Path.endsBefore(onp, p6) || Path.equals(onp, p6) || Path.isAncestor(onp, p6)) {\n            if (Path.endsBefore(_op4, p6)) {\n              p6[_op4.length - 1] -= 1;\n            }\n            p6[onp.length - 1] += 1;\n          } else if (Path.endsBefore(_op4, p6)) {\n            if (Path.equals(onp, p6)) {\n              p6[onp.length - 1] += 1;\n            }\n            p6[_op4.length - 1] -= 1;\n          }\n          break;\n        }\n      }\n    });\n  }\n};\nvar PathRef = {\n  /**\n   * Transform the path ref's current value by an operation.\n   */\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n    if (current == null) {\n      return;\n    }\n    var path = Path.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\nfunction ownKeys$6(object, enumerableOnly) {\n  var keys4 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys4.push.apply(keys4, symbols);\n  }\n  return keys4;\n}\nfunction _objectSpread$6(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    if (i5 % 2) {\n      ownKeys$6(Object(source), true).forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$6(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar Point = {\n  /**\n   * Compare a point to another, returning an integer indicating whether the\n   * point was before, at, or after the other.\n   */\n  compare(point, another) {\n    var result = Path.compare(point.path, another.path);\n    if (result === 0) {\n      if (point.offset < another.offset)\n        return -1;\n      if (point.offset > another.offset)\n        return 1;\n      return 0;\n    }\n    return result;\n  },\n  /**\n   * Check if a point is after another.\n   */\n  isAfter(point, another) {\n    return Point.compare(point, another) === 1;\n  },\n  /**\n   * Check if a point is before another.\n   */\n  isBefore(point, another) {\n    return Point.compare(point, another) === -1;\n  },\n  /**\n   * Check if a point is exactly equal to another.\n   */\n  equals(point, another) {\n    return point.offset === another.offset && Path.equals(point.path, another.path);\n  },\n  /**\n   * Check if a value implements the `Point` interface.\n   */\n  isPoint(value) {\n    return isPlainObject(value) && typeof value.offset === \"number\" && Path.isPath(value.path);\n  },\n  /**\n   * Transform a point by an operation.\n   */\n  transform(point, op) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return fn(point, (p6) => {\n      if (p6 === null) {\n        return null;\n      }\n      var {\n        affinity = \"forward\"\n      } = options;\n      var {\n        path,\n        offset: offset3\n      } = p6;\n      switch (op.type) {\n        case \"insert_node\":\n        case \"move_node\": {\n          p6.path = Path.transform(path, op, options);\n          break;\n        }\n        case \"insert_text\": {\n          if (Path.equals(op.path, path) && (op.offset < offset3 || op.offset === offset3 && affinity === \"forward\")) {\n            p6.offset += op.text.length;\n          }\n          break;\n        }\n        case \"merge_node\": {\n          if (Path.equals(op.path, path)) {\n            p6.offset += op.position;\n          }\n          p6.path = Path.transform(path, op, options);\n          break;\n        }\n        case \"remove_text\": {\n          if (Path.equals(op.path, path) && op.offset <= offset3) {\n            p6.offset -= Math.min(offset3 - op.offset, op.text.length);\n          }\n          break;\n        }\n        case \"remove_node\": {\n          if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n            return null;\n          }\n          p6.path = Path.transform(path, op, options);\n          break;\n        }\n        case \"split_node\": {\n          if (Path.equals(op.path, path)) {\n            if (op.position === offset3 && affinity == null) {\n              return null;\n            } else if (op.position < offset3 || op.position === offset3 && affinity === \"forward\") {\n              p6.offset -= op.position;\n              p6.path = Path.transform(path, op, _objectSpread$6(_objectSpread$6({}, options), {}, {\n                affinity: \"forward\"\n              }));\n            }\n          } else {\n            p6.path = Path.transform(path, op, options);\n          }\n          break;\n        }\n      }\n    });\n  }\n};\nvar PointRef = {\n  /**\n   * Transform the point ref's current value by an operation.\n   */\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n    if (current == null) {\n      return;\n    }\n    var point = Point.transform(current, op, {\n      affinity\n    });\n    ref.current = point;\n    if (point == null) {\n      ref.unref();\n    }\n  }\n};\nvar _excluded$2 = [\"anchor\", \"focus\"];\nfunction ownKeys$5(object, enumerableOnly) {\n  var keys4 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys4.push.apply(keys4, symbols);\n  }\n  return keys4;\n}\nfunction _objectSpread$5(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    if (i5 % 2) {\n      ownKeys$5(Object(source), true).forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$5(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar Range = {\n  /**\n   * Get the start and end points of a range, in the order in which they appear\n   * in the document.\n   */\n  edges(range) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var {\n      anchor,\n      focus\n    } = range;\n    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];\n  },\n  /**\n   * Get the end point of a range.\n   */\n  end(range) {\n    var [, end2] = Range.edges(range);\n    return end2;\n  },\n  /**\n   * Check if a range is exactly equal to another.\n   */\n  equals(range, another) {\n    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n  },\n  /**\n   * Check if a range includes a path, a point or part of another range.\n   */\n  includes(range, target) {\n    if (Range.isRange(target)) {\n      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n        return true;\n      }\n      var [rs, re] = Range.edges(range);\n      var [ts, te] = Range.edges(target);\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n    }\n    var [start2, end2] = Range.edges(range);\n    var isAfterStart = false;\n    var isBeforeEnd = false;\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start2) >= 0;\n      isBeforeEnd = Point.compare(target, end2) <= 0;\n    } else {\n      isAfterStart = Path.compare(target, start2.path) >= 0;\n      isBeforeEnd = Path.compare(target, end2.path) <= 0;\n    }\n    return isAfterStart && isBeforeEnd;\n  },\n  /**\n   * Get the intersection of a range with another.\n   */\n  intersection(range, another) {\n    var rest = _objectWithoutProperties(range, _excluded$2);\n    var [s1, e1] = Range.edges(range);\n    var [s22, e22] = Range.edges(another);\n    var start2 = Point.isBefore(s1, s22) ? s22 : s1;\n    var end2 = Point.isBefore(e1, e22) ? e1 : e22;\n    if (Point.isBefore(end2, start2)) {\n      return null;\n    } else {\n      return _objectSpread$5({\n        anchor: start2,\n        focus: end2\n      }, rest);\n    }\n  },\n  /**\n   * Check if a range is backward, meaning that its anchor point appears in the\n   * document _after_ its focus point.\n   */\n  isBackward(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.isAfter(anchor, focus);\n  },\n  /**\n   * Check if a range is collapsed, meaning that both its anchor and focus\n   * points refer to the exact same position in the document.\n   */\n  isCollapsed(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.equals(anchor, focus);\n  },\n  /**\n   * Check if a range is expanded.\n   *\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\n   */\n  isExpanded(range) {\n    return !Range.isCollapsed(range);\n  },\n  /**\n   * Check if a range is forward.\n   *\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\n   */\n  isForward(range) {\n    return !Range.isBackward(range);\n  },\n  /**\n   * Check if a value implements the [[Range]] interface.\n   */\n  isRange(value) {\n    return isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n  },\n  /**\n   * Iterate through all of the point entries in a range.\n   */\n  *points(range) {\n    yield [range.anchor, \"anchor\"];\n    yield [range.focus, \"focus\"];\n  },\n  /**\n   * Get the start point of a range.\n   */\n  start(range) {\n    var [start2] = Range.edges(range);\n    return start2;\n  },\n  /**\n   * Transform a range by an operation.\n   */\n  transform(range, op) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return fn(range, (r7) => {\n      if (r7 === null) {\n        return null;\n      }\n      var {\n        affinity = \"inward\"\n      } = options;\n      var affinityAnchor;\n      var affinityFocus;\n      if (affinity === \"inward\") {\n        var isCollapsed2 = Range.isCollapsed(r7);\n        if (Range.isForward(r7)) {\n          affinityAnchor = \"forward\";\n          affinityFocus = isCollapsed2 ? affinityAnchor : \"backward\";\n        } else {\n          affinityAnchor = \"backward\";\n          affinityFocus = isCollapsed2 ? affinityAnchor : \"forward\";\n        }\n      } else if (affinity === \"outward\") {\n        if (Range.isForward(r7)) {\n          affinityAnchor = \"backward\";\n          affinityFocus = \"forward\";\n        } else {\n          affinityAnchor = \"forward\";\n          affinityFocus = \"backward\";\n        }\n      } else {\n        affinityAnchor = affinity;\n        affinityFocus = affinity;\n      }\n      var anchor = Point.transform(r7.anchor, op, {\n        affinity: affinityAnchor\n      });\n      var focus = Point.transform(r7.focus, op, {\n        affinity: affinityFocus\n      });\n      if (!anchor || !focus) {\n        return null;\n      }\n      r7.anchor = anchor;\n      r7.focus = focus;\n    });\n  }\n};\nvar RangeRef = {\n  /**\n   * Transform the range ref's current value by an operation.\n   */\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n    if (current == null) {\n      return;\n    }\n    var path = Range.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\nvar _scrubber = void 0;\nvar Scrubber = {\n  setScrubber(scrubber) {\n    _scrubber = scrubber;\n  },\n  stringify(value) {\n    return JSON.stringify(value, _scrubber);\n  }\n};\nvar isDeepEqual = (node, another) => {\n  for (var key in node) {\n    var a7 = node[key];\n    var b4 = another[key];\n    if (isPlainObject(a7) && isPlainObject(b4)) {\n      if (!isDeepEqual(a7, b4))\n        return false;\n    } else if (Array.isArray(a7) && Array.isArray(b4)) {\n      if (a7.length !== b4.length)\n        return false;\n      for (var i5 = 0; i5 < a7.length; i5++) {\n        if (a7[i5] !== b4[i5])\n          return false;\n      }\n    } else if (a7 !== b4) {\n      return false;\n    }\n  }\n  for (var _key in another) {\n    if (node[_key] === void 0 && another[_key] !== void 0) {\n      return false;\n    }\n  }\n  return true;\n};\nvar _excluded$1 = [\"text\"];\nvar _excluded2$1 = [\"anchor\", \"focus\"];\nfunction ownKeys$4(object, enumerableOnly) {\n  var keys4 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys4.push.apply(keys4, symbols);\n  }\n  return keys4;\n}\nfunction _objectSpread$4(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    if (i5 % 2) {\n      ownKeys$4(Object(source), true).forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$4(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar Text = {\n  /**\n   * Check if two text nodes are equal.\n   *\n   * When loose is set, the text is not compared. This is\n   * used to check whether sibling text nodes can be merged.\n   */\n  equals(text4, another) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var {\n      loose = false\n    } = options;\n    function omitText(obj) {\n      var rest = _objectWithoutProperties(obj, _excluded$1);\n      return rest;\n    }\n    return isDeepEqual(loose ? omitText(text4) : text4, loose ? omitText(another) : another);\n  },\n  /**\n   * Check if a value implements the `Text` interface.\n   */\n  isText(value) {\n    return isPlainObject(value) && typeof value.text === \"string\";\n  },\n  /**\n   * Check if a value is a list of `Text` objects.\n   */\n  isTextList(value) {\n    return Array.isArray(value) && value.every((val) => Text.isText(val));\n  },\n  /**\n   * Check if some props are a partial of Text.\n   */\n  isTextProps(props) {\n    return props.text !== void 0;\n  },\n  /**\n   * Check if an text matches set of properties.\n   *\n   * Note: this is for matching custom properties, and it does not ensure that\n   * the `text` property are two nodes equal.\n   */\n  matches(text4, props) {\n    for (var key in props) {\n      if (key === \"text\") {\n        continue;\n      }\n      if (!text4.hasOwnProperty(key) || text4[key] !== props[key]) {\n        return false;\n      }\n    }\n    return true;\n  },\n  /**\n   * Get the leaves for a text node given decorations.\n   */\n  decorations(node, decorations) {\n    var leaves = [_objectSpread$4({}, node)];\n    for (var dec of decorations) {\n      var rest = _objectWithoutProperties(dec, _excluded2$1);\n      var [start2, end2] = Range.edges(dec);\n      var next = [];\n      var leafEnd = 0;\n      var decorationStart = start2.offset;\n      var decorationEnd = end2.offset;\n      for (var leaf of leaves) {\n        var {\n          length\n        } = leaf.text;\n        var leafStart = leafEnd;\n        leafEnd += length;\n        if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n          Object.assign(leaf, rest);\n          next.push(leaf);\n          continue;\n        }\n        if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n          next.push(leaf);\n          continue;\n        }\n        var middle = leaf;\n        var before = void 0;\n        var after = void 0;\n        if (decorationEnd < leafEnd) {\n          var off2 = decorationEnd - leafStart;\n          after = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n            text: middle.text.slice(off2)\n          });\n          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n            text: middle.text.slice(0, off2)\n          });\n        }\n        if (decorationStart > leafStart) {\n          var _off = decorationStart - leafStart;\n          before = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n            text: middle.text.slice(0, _off)\n          });\n          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n            text: middle.text.slice(_off)\n          });\n        }\n        Object.assign(middle, rest);\n        if (before) {\n          next.push(before);\n        }\n        next.push(middle);\n        if (after) {\n          next.push(after);\n        }\n      }\n      leaves = next;\n    }\n    return leaves;\n  }\n};\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys4 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys4.push.apply(keys4, symbols);\n  }\n  return keys4;\n}\nfunction _objectSpread$3(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    if (i5 % 2) {\n      ownKeys$3(Object(source), true).forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$3(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar applyToDraft = (editor, selection, op) => {\n  switch (op.type) {\n    case \"insert_node\": {\n      var {\n        path,\n        node\n      } = op;\n      var parent2 = Node2.parent(editor, path);\n      var index5 = path[path.length - 1];\n      if (index5 > parent2.children.length) {\n        throw new Error('Cannot apply an \"insert_node\" operation at path ['.concat(path, \"] because the destination is past the end of the node.\"));\n      }\n      parent2.children.splice(index5, 0, node);\n      if (selection) {\n        for (var [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op);\n        }\n      }\n      break;\n    }\n    case \"insert_text\": {\n      var {\n        path: _path,\n        offset: offset3,\n        text: text4\n      } = op;\n      if (text4.length === 0)\n        break;\n      var _node = Node2.leaf(editor, _path);\n      var before = _node.text.slice(0, offset3);\n      var after = _node.text.slice(offset3);\n      _node.text = before + text4 + after;\n      if (selection) {\n        for (var [_point, _key] of Range.points(selection)) {\n          selection[_key] = Point.transform(_point, op);\n        }\n      }\n      break;\n    }\n    case \"merge_node\": {\n      var {\n        path: _path2\n      } = op;\n      var _node2 = Node2.get(editor, _path2);\n      var prevPath = Path.previous(_path2);\n      var prev = Node2.get(editor, prevPath);\n      var _parent2 = Node2.parent(editor, _path2);\n      var _index = _path2[_path2.length - 1];\n      if (Text.isText(_node2) && Text.isText(prev)) {\n        prev.text += _node2.text;\n      } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n        prev.children.push(..._node2.children);\n      } else {\n        throw new Error('Cannot apply a \"merge_node\" operation at path ['.concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(_node2), \" \").concat(Scrubber.stringify(prev)));\n      }\n      _parent2.children.splice(_index, 1);\n      if (selection) {\n        for (var [_point2, _key2] of Range.points(selection)) {\n          selection[_key2] = Point.transform(_point2, op);\n        }\n      }\n      break;\n    }\n    case \"move_node\": {\n      var {\n        path: _path3,\n        newPath\n      } = op;\n      if (Path.isAncestor(_path3, newPath)) {\n        throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n      }\n      var _node3 = Node2.get(editor, _path3);\n      var _parent22 = Node2.parent(editor, _path3);\n      var _index2 = _path3[_path3.length - 1];\n      _parent22.children.splice(_index2, 1);\n      var truePath = Path.transform(_path3, op);\n      var newParent = Node2.get(editor, Path.parent(truePath));\n      var newIndex = truePath[truePath.length - 1];\n      newParent.children.splice(newIndex, 0, _node3);\n      if (selection) {\n        for (var [_point3, _key3] of Range.points(selection)) {\n          selection[_key3] = Point.transform(_point3, op);\n        }\n      }\n      break;\n    }\n    case \"remove_node\": {\n      var {\n        path: _path4\n      } = op;\n      var _index3 = _path4[_path4.length - 1];\n      var _parent3 = Node2.parent(editor, _path4);\n      _parent3.children.splice(_index3, 1);\n      if (selection) {\n        for (var [_point4, _key4] of Range.points(selection)) {\n          var result = Point.transform(_point4, op);\n          if (selection != null && result != null) {\n            selection[_key4] = result;\n          } else {\n            var _prev = void 0;\n            var next = void 0;\n            for (var [n8, p6] of Node2.texts(editor)) {\n              if (Path.compare(p6, _path4) === -1) {\n                _prev = [n8, p6];\n              } else {\n                next = [n8, p6];\n                break;\n              }\n            }\n            var preferNext = false;\n            if (_prev && next) {\n              if (Path.equals(next[1], _path4)) {\n                preferNext = !Path.hasPrevious(next[1]);\n              } else {\n                preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;\n              }\n            }\n            if (_prev && !preferNext) {\n              _point4.path = _prev[1];\n              _point4.offset = _prev[0].text.length;\n            } else if (next) {\n              _point4.path = next[1];\n              _point4.offset = 0;\n            } else {\n              selection = null;\n            }\n          }\n        }\n      }\n      break;\n    }\n    case \"remove_text\": {\n      var {\n        path: _path5,\n        offset: _offset,\n        text: _text\n      } = op;\n      if (_text.length === 0)\n        break;\n      var _node4 = Node2.leaf(editor, _path5);\n      var _before = _node4.text.slice(0, _offset);\n      var _after = _node4.text.slice(_offset + _text.length);\n      _node4.text = _before + _after;\n      if (selection) {\n        for (var [_point5, _key5] of Range.points(selection)) {\n          selection[_key5] = Point.transform(_point5, op);\n        }\n      }\n      break;\n    }\n    case \"set_node\": {\n      var {\n        path: _path6,\n        properties,\n        newProperties\n      } = op;\n      if (_path6.length === 0) {\n        throw new Error(\"Cannot set properties on the root node!\");\n      }\n      var _node5 = Node2.get(editor, _path6);\n      for (var _key6 in newProperties) {\n        if (_key6 === \"children\" || _key6 === \"text\") {\n          throw new Error('Cannot set the \"'.concat(_key6, '\" property of nodes!'));\n        }\n        var value = newProperties[_key6];\n        if (value == null) {\n          delete _node5[_key6];\n        } else {\n          _node5[_key6] = value;\n        }\n      }\n      for (var _key7 in properties) {\n        if (!newProperties.hasOwnProperty(_key7)) {\n          delete _node5[_key7];\n        }\n      }\n      break;\n    }\n    case \"set_selection\": {\n      var {\n        newProperties: _newProperties\n      } = op;\n      if (_newProperties == null) {\n        selection = _newProperties;\n      } else {\n        if (selection == null) {\n          if (!Range.isRange(_newProperties)) {\n            throw new Error('Cannot apply an incomplete \"set_selection\" operation properties '.concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n          }\n          selection = _objectSpread$3({}, _newProperties);\n        }\n        for (var _key8 in _newProperties) {\n          var _value = _newProperties[_key8];\n          if (_value == null) {\n            if (_key8 === \"anchor\" || _key8 === \"focus\") {\n              throw new Error('Cannot remove the \"'.concat(_key8, '\" selection property'));\n            }\n            delete selection[_key8];\n          } else {\n            selection[_key8] = _value;\n          }\n        }\n      }\n      break;\n    }\n    case \"split_node\": {\n      var {\n        path: _path7,\n        position,\n        properties: _properties\n      } = op;\n      if (_path7.length === 0) {\n        throw new Error('Cannot apply a \"split_node\" operation at path ['.concat(_path7, \"] because the root node cannot be split.\"));\n      }\n      var _node6 = Node2.get(editor, _path7);\n      var _parent4 = Node2.parent(editor, _path7);\n      var _index4 = _path7[_path7.length - 1];\n      var newNode;\n      if (Text.isText(_node6)) {\n        var _before2 = _node6.text.slice(0, position);\n        var _after2 = _node6.text.slice(position);\n        _node6.text = _before2;\n        newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n          text: _after2\n        });\n      } else {\n        var _before3 = _node6.children.slice(0, position);\n        var _after3 = _node6.children.slice(position);\n        _node6.children = _before3;\n        newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n          children: _after3\n        });\n      }\n      _parent4.children.splice(_index4 + 1, 0, newNode);\n      if (selection) {\n        for (var [_point6, _key9] of Range.points(selection)) {\n          selection[_key9] = Point.transform(_point6, op);\n        }\n      }\n      break;\n    }\n  }\n  return selection;\n};\nvar GeneralTransforms = {\n  /**\n   * Transform the editor by an operation.\n   */\n  transform(editor, op) {\n    editor.children = ln(editor.children);\n    var selection = editor.selection && ln(editor.selection);\n    try {\n      selection = applyToDraft(editor, selection, op);\n    } finally {\n      editor.children = dn(editor.children);\n      if (selection) {\n        editor.selection = r2(selection) ? dn(selection) : selection;\n      } else {\n        editor.selection = null;\n      }\n    }\n  }\n};\nvar _excluded = [\"text\"];\nvar _excluded2 = [\"children\"];\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys4 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys4.push.apply(keys4, symbols);\n  }\n  return keys4;\n}\nfunction _objectSpread$2(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    if (i5 % 2) {\n      ownKeys$2(Object(source), true).forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$2(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar NodeTransforms = {\n  /**\n   * Insert nodes at a specific location in the Editor.\n   */\n  insertNodes(editor, nodes) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        hanging = false,\n        voids = false,\n        mode = \"lowest\"\n      } = options;\n      var {\n        at,\n        match: match2,\n        select: select2\n      } = options;\n      if (Node2.isNode(nodes)) {\n        nodes = [nodes];\n      }\n      if (nodes.length === 0) {\n        return;\n      }\n      var [node] = nodes;\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection;\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, []);\n        } else {\n          at = [0];\n        }\n        select2 = true;\n      }\n      if (select2 == null) {\n        select2 = false;\n      }\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at);\n        }\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var [, end2] = Range.edges(at);\n          var pointRef = Editor.pointRef(editor, end2);\n          Transforms.delete(editor, {\n            at\n          });\n          at = pointRef.unref();\n        }\n      }\n      if (Point.isPoint(at)) {\n        if (match2 == null) {\n          if (Text.isText(node)) {\n            match2 = (n8) => Text.isText(n8);\n          } else if (editor.isInline(node)) {\n            match2 = (n8) => Text.isText(n8) || Editor.isInline(editor, n8);\n          } else {\n            match2 = (n8) => Editor.isBlock(editor, n8);\n          }\n        }\n        var [entry] = Editor.nodes(editor, {\n          at: at.path,\n          match: match2,\n          mode,\n          voids\n        });\n        if (entry) {\n          var [, _matchPath] = entry;\n          var pathRef = Editor.pathRef(editor, _matchPath);\n          var isAtEnd = Editor.isEnd(editor, at, _matchPath);\n          Transforms.splitNodes(editor, {\n            at,\n            match: match2,\n            mode,\n            voids\n          });\n          var path = pathRef.unref();\n          at = isAtEnd ? Path.next(path) : path;\n        } else {\n          return;\n        }\n      }\n      var parentPath = Path.parent(at);\n      var index5 = at[at.length - 1];\n      if (!voids && Editor.void(editor, {\n        at: parentPath\n      })) {\n        return;\n      }\n      for (var _node of nodes) {\n        var _path = parentPath.concat(index5);\n        index5++;\n        editor.apply({\n          type: \"insert_node\",\n          path: _path,\n          node: _node\n        });\n        at = Path.next(at);\n      }\n      at = Path.previous(at);\n      if (select2) {\n        var point = Editor.end(editor, at);\n        if (point) {\n          Transforms.select(editor, point);\n        }\n      }\n    });\n  },\n  /**\n   * Lift nodes at a specific location upwards in the document tree, splitting\n   * their parent in two if necessary.\n   */\n  liftNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        at = editor.selection,\n        mode = \"lowest\",\n        voids = false\n      } = options;\n      var {\n        match: match2\n      } = options;\n      if (match2 == null) {\n        match2 = Path.isPath(at) ? matchPath(editor, at) : (n8) => Editor.isBlock(editor, n8);\n      }\n      if (!at) {\n        return;\n      }\n      var matches = Editor.nodes(editor, {\n        at,\n        match: match2,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(matches, (_ref) => {\n        var [, p6] = _ref;\n        return Editor.pathRef(editor, p6);\n      });\n      for (var pathRef of pathRefs) {\n        var path = pathRef.unref();\n        if (path.length < 2) {\n          throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n        }\n        var parentNodeEntry = Editor.node(editor, Path.parent(path));\n        var [parent2, parentPath] = parentNodeEntry;\n        var index5 = path[path.length - 1];\n        var {\n          length\n        } = parent2.children;\n        if (length === 1) {\n          var toPath = Path.next(parentPath);\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: toPath,\n            voids\n          });\n          Transforms.removeNodes(editor, {\n            at: parentPath,\n            voids\n          });\n        } else if (index5 === 0) {\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: parentPath,\n            voids\n          });\n        } else if (index5 === length - 1) {\n          var _toPath = Path.next(parentPath);\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath,\n            voids\n          });\n        } else {\n          var splitPath = Path.next(path);\n          var _toPath2 = Path.next(parentPath);\n          Transforms.splitNodes(editor, {\n            at: splitPath,\n            voids\n          });\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath2,\n            voids\n          });\n        }\n      }\n    });\n  },\n  /**\n   * Merge a node at a location with the previous node of the same depth,\n   * removing any empty containing nodes after the merge if necessary.\n   */\n  mergeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        match: match2,\n        at = editor.selection\n      } = options;\n      var {\n        hanging = false,\n        voids = false,\n        mode = \"lowest\"\n      } = options;\n      if (!at) {\n        return;\n      }\n      if (match2 == null) {\n        if (Path.isPath(at)) {\n          var [parent2] = Editor.parent(editor, at);\n          match2 = (n8) => parent2.children.includes(n8);\n        } else {\n          match2 = (n8) => Editor.isBlock(editor, n8);\n        }\n      }\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var [, end2] = Range.edges(at);\n          var pointRef = Editor.pointRef(editor, end2);\n          Transforms.delete(editor, {\n            at\n          });\n          at = pointRef.unref();\n          if (options.at == null) {\n            Transforms.select(editor, at);\n          }\n        }\n      }\n      var [current] = Editor.nodes(editor, {\n        at,\n        match: match2,\n        voids,\n        mode\n      });\n      var prev = Editor.previous(editor, {\n        at,\n        match: match2,\n        voids,\n        mode\n      });\n      if (!current || !prev) {\n        return;\n      }\n      var [node, path] = current;\n      var [prevNode, prevPath] = prev;\n      if (path.length === 0 || prevPath.length === 0) {\n        return;\n      }\n      var newPath = Path.next(prevPath);\n      var commonPath = Path.common(path, prevPath);\n      var isPreviousSibling = Path.isSibling(path, prevPath);\n      var levels = Array.from(Editor.levels(editor, {\n        at: path\n      }), (_ref2) => {\n        var [n8] = _ref2;\n        return n8;\n      }).slice(commonPath.length).slice(0, -1);\n      var emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: \"highest\",\n        match: (n8) => levels.includes(n8) && hasSingleChildNest(editor, n8)\n      });\n      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n      var properties;\n      var position;\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        var rest = _objectWithoutProperties(node, _excluded);\n        position = prevNode.text.length;\n        properties = rest;\n      } else if (Element2.isElement(node) && Element2.isElement(prevNode)) {\n        var rest = _objectWithoutProperties(node, _excluded2);\n        position = prevNode.children.length;\n        properties = rest;\n      } else {\n        throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n      }\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: newPath,\n          voids\n        });\n      }\n      if (emptyRef) {\n        Transforms.removeNodes(editor, {\n          at: emptyRef.current,\n          voids\n        });\n      }\n      if (Element2.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === \"\" && prevPath[prevPath.length - 1] !== 0) {\n        Transforms.removeNodes(editor, {\n          at: prevPath,\n          voids\n        });\n      } else {\n        editor.apply({\n          type: \"merge_node\",\n          path: newPath,\n          position,\n          properties\n        });\n      }\n      if (emptyRef) {\n        emptyRef.unref();\n      }\n    });\n  },\n  /**\n   * Move the nodes at a location to a new location.\n   */\n  moveNodes(editor, options) {\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        to,\n        at = editor.selection,\n        mode = \"lowest\",\n        voids = false\n      } = options;\n      var {\n        match: match2\n      } = options;\n      if (!at) {\n        return;\n      }\n      if (match2 == null) {\n        match2 = Path.isPath(at) ? matchPath(editor, at) : (n8) => Editor.isBlock(editor, n8);\n      }\n      var toRef = Editor.pathRef(editor, to);\n      var targets = Editor.nodes(editor, {\n        at,\n        match: match2,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(targets, (_ref3) => {\n        var [, p6] = _ref3;\n        return Editor.pathRef(editor, p6);\n      });\n      for (var pathRef of pathRefs) {\n        var path = pathRef.unref();\n        var newPath = toRef.current;\n        if (path.length !== 0) {\n          editor.apply({\n            type: \"move_node\",\n            path,\n            newPath\n          });\n        }\n        if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n          toRef.current = Path.next(toRef.current);\n        }\n      }\n      toRef.unref();\n    });\n  },\n  /**\n   * Remove the nodes at a specific location in the document.\n   */\n  removeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        hanging = false,\n        voids = false,\n        mode = \"lowest\"\n      } = options;\n      var {\n        at = editor.selection,\n        match: match2\n      } = options;\n      if (!at) {\n        return;\n      }\n      if (match2 == null) {\n        match2 = Path.isPath(at) ? matchPath(editor, at) : (n8) => Editor.isBlock(editor, n8);\n      }\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n      var depths = Editor.nodes(editor, {\n        at,\n        match: match2,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(depths, (_ref4) => {\n        var [, p6] = _ref4;\n        return Editor.pathRef(editor, p6);\n      });\n      for (var pathRef of pathRefs) {\n        var path = pathRef.unref();\n        if (path) {\n          var [node] = Editor.node(editor, path);\n          editor.apply({\n            type: \"remove_node\",\n            path,\n            node\n          });\n        }\n      }\n    });\n  },\n  /**\n   * Set new properties on the nodes at a location.\n   */\n  setNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        match: match2,\n        at = editor.selection,\n        compare,\n        merge: merge2\n      } = options;\n      var {\n        hanging = false,\n        mode = \"lowest\",\n        split = false,\n        voids = false\n      } = options;\n      if (!at) {\n        return;\n      }\n      if (match2 == null) {\n        match2 = Path.isPath(at) ? matchPath(editor, at) : (n8) => Editor.isBlock(editor, n8);\n      }\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n      if (split && Range.isRange(at)) {\n        if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n          return;\n        }\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: \"inward\"\n        });\n        var [start2, end2] = Range.edges(at);\n        var splitMode = mode === \"lowest\" ? \"lowest\" : \"highest\";\n        var endAtEndOfNode = Editor.isEnd(editor, end2, end2.path);\n        Transforms.splitNodes(editor, {\n          at: end2,\n          match: match2,\n          mode: splitMode,\n          voids,\n          always: !endAtEndOfNode\n        });\n        var startAtStartOfNode = Editor.isStart(editor, start2, start2.path);\n        Transforms.splitNodes(editor, {\n          at: start2,\n          match: match2,\n          mode: splitMode,\n          voids,\n          always: !startAtStartOfNode\n        });\n        at = rangeRef.unref();\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n      if (!compare) {\n        compare = (prop, nodeProp) => prop !== nodeProp;\n      }\n      for (var [node, path] of Editor.nodes(editor, {\n        at,\n        match: match2,\n        mode,\n        voids\n      })) {\n        var properties = {};\n        var newProperties = {};\n        if (path.length === 0) {\n          continue;\n        }\n        var hasChanges = false;\n        for (var k3 in props) {\n          if (k3 === \"children\" || k3 === \"text\") {\n            continue;\n          }\n          if (compare(props[k3], node[k3])) {\n            hasChanges = true;\n            if (node.hasOwnProperty(k3))\n              properties[k3] = node[k3];\n            if (merge2) {\n              if (props[k3] != null)\n                newProperties[k3] = merge2(node[k3], props[k3]);\n            } else {\n              if (props[k3] != null)\n                newProperties[k3] = props[k3];\n            }\n          }\n        }\n        if (hasChanges) {\n          editor.apply({\n            type: \"set_node\",\n            path,\n            properties,\n            newProperties\n          });\n        }\n      }\n    });\n  },\n  /**\n   * Split the nodes at a specific location.\n   */\n  splitNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        mode = \"lowest\",\n        voids = false\n      } = options;\n      var {\n        match: match2,\n        at = editor.selection,\n        height = 0,\n        always = false\n      } = options;\n      if (match2 == null) {\n        match2 = (n8) => Editor.isBlock(editor, n8);\n      }\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at);\n      }\n      if (Path.isPath(at)) {\n        var path = at;\n        var point = Editor.point(editor, path);\n        var [parent2] = Editor.parent(editor, path);\n        match2 = (n8) => n8 === parent2;\n        height = point.path.length - path.length + 1;\n        at = point;\n        always = true;\n      }\n      if (!at) {\n        return;\n      }\n      var beforeRef = Editor.pointRef(editor, at, {\n        affinity: \"backward\"\n      });\n      var afterRef;\n      try {\n        var [highest] = Editor.nodes(editor, {\n          at,\n          match: match2,\n          mode,\n          voids\n        });\n        if (!highest) {\n          return;\n        }\n        var voidMatch = Editor.void(editor, {\n          at,\n          mode: \"highest\"\n        });\n        var nudge = 0;\n        if (!voids && voidMatch) {\n          var [voidNode, voidPath] = voidMatch;\n          if (Element2.isElement(voidNode) && editor.isInline(voidNode)) {\n            var after = Editor.after(editor, voidPath);\n            if (!after) {\n              var text4 = {\n                text: \"\"\n              };\n              var afterPath = Path.next(voidPath);\n              Transforms.insertNodes(editor, text4, {\n                at: afterPath,\n                voids\n              });\n              after = Editor.point(editor, afterPath);\n            }\n            at = after;\n            always = true;\n          }\n          var siblingHeight = at.path.length - voidPath.length;\n          height = siblingHeight + 1;\n          always = true;\n        }\n        afterRef = Editor.pointRef(editor, at);\n        var depth = at.path.length - height;\n        var [, highestPath] = highest;\n        var lowestPath = at.path.slice(0, depth);\n        var position = height === 0 ? at.offset : at.path[depth] + nudge;\n        for (var [node, _path2] of Editor.levels(editor, {\n          at: lowestPath,\n          reverse: true,\n          voids\n        })) {\n          var split = false;\n          if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Editor.isVoid(editor, node)) {\n            break;\n          }\n          var _point = beforeRef.current;\n          var isEnd = Editor.isEnd(editor, _point, _path2);\n          if (always || !beforeRef || !Editor.isEdge(editor, _point, _path2)) {\n            split = true;\n            var properties = Node2.extractProps(node);\n            editor.apply({\n              type: \"split_node\",\n              path: _path2,\n              position,\n              properties\n            });\n          }\n          position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);\n        }\n        if (options.at == null) {\n          var _point2 = afterRef.current || Editor.end(editor, []);\n          Transforms.select(editor, _point2);\n        }\n      } finally {\n        var _afterRef;\n        beforeRef.unref();\n        (_afterRef = afterRef) === null || _afterRef === void 0 ? void 0 : _afterRef.unref();\n      }\n    });\n  },\n  /**\n   * Unset properties on the nodes at a location.\n   */\n  unsetNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    if (!Array.isArray(props)) {\n      props = [props];\n    }\n    var obj = {};\n    for (var key of props) {\n      obj[key] = null;\n    }\n    Transforms.setNodes(editor, obj, options);\n  },\n  /**\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\n   * necessary to ensure that only the content in the range is unwrapped.\n   */\n  unwrapNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        mode = \"lowest\",\n        split = false,\n        voids = false\n      } = options;\n      var {\n        at = editor.selection,\n        match: match2\n      } = options;\n      if (!at) {\n        return;\n      }\n      if (match2 == null) {\n        match2 = Path.isPath(at) ? matchPath(editor, at) : (n8) => Editor.isBlock(editor, n8);\n      }\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n      var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n      var matches = Editor.nodes(editor, {\n        at,\n        match: match2,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(\n        matches,\n        (_ref5) => {\n          var [, p6] = _ref5;\n          return Editor.pathRef(editor, p6);\n        }\n        // unwrapNode will call liftNode which does not support splitting the node when nested.\n        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks\n        // that wrap target node. So we reverse the order.\n      ).reverse();\n      var _loop = function _loop2(pathRef2) {\n        var path = pathRef2.unref();\n        var [node] = Editor.node(editor, path);\n        var range = Editor.range(editor, path);\n        if (split && rangeRef) {\n          range = Range.intersection(rangeRef.current, range);\n        }\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: (n8) => Element2.isAncestor(node) && node.children.includes(n8),\n          voids\n        });\n      };\n      for (var pathRef of pathRefs) {\n        _loop(pathRef);\n      }\n      if (rangeRef) {\n        rangeRef.unref();\n      }\n    });\n  },\n  /**\n   * Wrap the nodes at a location in a new container node, splitting the edges\n   * of the range first to ensure that only the content in the range is wrapped.\n   */\n  wrapNodes(editor, element4) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        mode = \"lowest\",\n        split = false,\n        voids = false\n      } = options;\n      var {\n        match: match2,\n        at = editor.selection\n      } = options;\n      if (!at) {\n        return;\n      }\n      if (match2 == null) {\n        if (Path.isPath(at)) {\n          match2 = matchPath(editor, at);\n        } else if (editor.isInline(element4)) {\n          match2 = (n8) => Editor.isInline(editor, n8) || Text.isText(n8);\n        } else {\n          match2 = (n8) => Editor.isBlock(editor, n8);\n        }\n      }\n      if (split && Range.isRange(at)) {\n        var [start2, end2] = Range.edges(at);\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: \"inward\"\n        });\n        Transforms.splitNodes(editor, {\n          at: end2,\n          match: match2,\n          voids\n        });\n        Transforms.splitNodes(editor, {\n          at: start2,\n          match: match2,\n          voids\n        });\n        at = rangeRef.unref();\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n      var roots = Array.from(Editor.nodes(editor, {\n        at,\n        match: editor.isInline(element4) ? (n8) => Editor.isBlock(editor, n8) : (n8) => Editor.isEditor(n8),\n        mode: \"lowest\",\n        voids\n      }));\n      for (var [, rootPath] of roots) {\n        var a7 = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n        if (!a7) {\n          continue;\n        }\n        var matches = Array.from(Editor.nodes(editor, {\n          at: a7,\n          match: match2,\n          mode,\n          voids\n        }));\n        if (matches.length > 0) {\n          var _ret = function() {\n            var [first] = matches;\n            var last2 = matches[matches.length - 1];\n            var [, firstPath] = first;\n            var [, lastPath] = last2;\n            if (firstPath.length === 0 && lastPath.length === 0) {\n              return \"continue\";\n            }\n            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n            var range = Editor.range(editor, firstPath, lastPath);\n            var commonNodeEntry = Editor.node(editor, commonPath);\n            var [commonNode] = commonNodeEntry;\n            var depth = commonPath.length + 1;\n            var wrapperPath = Path.next(lastPath.slice(0, depth));\n            var wrapper = _objectSpread$2(_objectSpread$2({}, element4), {}, {\n              children: []\n            });\n            Transforms.insertNodes(editor, wrapper, {\n              at: wrapperPath,\n              voids\n            });\n            Transforms.moveNodes(editor, {\n              at: range,\n              match: (n8) => Element2.isAncestor(commonNode) && commonNode.children.includes(n8),\n              to: wrapperPath.concat(0),\n              voids\n            });\n          }();\n          if (_ret === \"continue\")\n            continue;\n        }\n      }\n    });\n  }\n};\nvar hasSingleChildNest = (editor, node) => {\n  if (Element2.isElement(node)) {\n    var element4 = node;\n    if (Editor.isVoid(editor, node)) {\n      return true;\n    } else if (element4.children.length === 1) {\n      return hasSingleChildNest(editor, element4.children[0]);\n    } else {\n      return false;\n    }\n  } else if (Editor.isEditor(node)) {\n    return false;\n  } else {\n    return true;\n  }\n};\nvar deleteRange = (editor, range) => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor;\n  } else {\n    var [, end2] = Range.edges(range);\n    var pointRef = Editor.pointRef(editor, end2);\n    Transforms.delete(editor, {\n      at: range\n    });\n    return pointRef.unref();\n  }\n};\nvar matchPath = (editor, path) => {\n  var [node] = Editor.node(editor, path);\n  return (n8) => n8 === node;\n};\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys4 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys4.push.apply(keys4, symbols);\n  }\n  return keys4;\n}\nfunction _objectSpread$1(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    if (i5 % 2) {\n      ownKeys$1(Object(source), true).forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$1(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar SelectionTransforms = {\n  /**\n   * Collapse the selection.\n   */\n  collapse(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var {\n      edge = \"anchor\"\n    } = options;\n    var {\n      selection\n    } = editor;\n    if (!selection) {\n      return;\n    } else if (edge === \"anchor\") {\n      Transforms.select(editor, selection.anchor);\n    } else if (edge === \"focus\") {\n      Transforms.select(editor, selection.focus);\n    } else if (edge === \"start\") {\n      var [start2] = Range.edges(selection);\n      Transforms.select(editor, start2);\n    } else if (edge === \"end\") {\n      var [, end2] = Range.edges(selection);\n      Transforms.select(editor, end2);\n    }\n  },\n  /**\n   * Unset the selection.\n   */\n  deselect(editor) {\n    var {\n      selection\n    } = editor;\n    if (selection) {\n      editor.apply({\n        type: \"set_selection\",\n        properties: selection,\n        newProperties: null\n      });\n    }\n  },\n  /**\n   * Move the selection's point forward or backward.\n   */\n  move(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var {\n      selection\n    } = editor;\n    var {\n      distance = 1,\n      unit = \"character\",\n      reverse = false\n    } = options;\n    var {\n      edge = null\n    } = options;\n    if (!selection) {\n      return;\n    }\n    if (edge === \"start\") {\n      edge = Range.isBackward(selection) ? \"focus\" : \"anchor\";\n    }\n    if (edge === \"end\") {\n      edge = Range.isBackward(selection) ? \"anchor\" : \"focus\";\n    }\n    var {\n      anchor,\n      focus\n    } = selection;\n    var opts = {\n      distance,\n      unit\n    };\n    var props = {};\n    if (edge == null || edge === \"anchor\") {\n      var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n      if (point) {\n        props.anchor = point;\n      }\n    }\n    if (edge == null || edge === \"focus\") {\n      var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n      if (_point) {\n        props.focus = _point;\n      }\n    }\n    Transforms.setSelection(editor, props);\n  },\n  /**\n   * Set the selection to a new value.\n   */\n  select(editor, target) {\n    var {\n      selection\n    } = editor;\n    target = Editor.range(editor, target);\n    if (selection) {\n      Transforms.setSelection(editor, target);\n      return;\n    }\n    if (!Range.isRange(target)) {\n      throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n    }\n    editor.apply({\n      type: \"set_selection\",\n      properties: selection,\n      newProperties: target\n    });\n  },\n  /**\n   * Set new properties on one of the selection's points.\n   */\n  setPoint(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var {\n      selection\n    } = editor;\n    var {\n      edge = \"both\"\n    } = options;\n    if (!selection) {\n      return;\n    }\n    if (edge === \"start\") {\n      edge = Range.isBackward(selection) ? \"focus\" : \"anchor\";\n    }\n    if (edge === \"end\") {\n      edge = Range.isBackward(selection) ? \"anchor\" : \"focus\";\n    }\n    var {\n      anchor,\n      focus\n    } = selection;\n    var point = edge === \"anchor\" ? anchor : focus;\n    Transforms.setSelection(editor, {\n      [edge === \"anchor\" ? \"anchor\" : \"focus\"]: _objectSpread$1(_objectSpread$1({}, point), props)\n    });\n  },\n  /**\n   * Set new properties on the selection.\n   */\n  setSelection(editor, props) {\n    var {\n      selection\n    } = editor;\n    var oldProps = {};\n    var newProps = {};\n    if (!selection) {\n      return;\n    }\n    for (var k3 in props) {\n      if (k3 === \"anchor\" && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k3 === \"focus\" && props.focus != null && !Point.equals(props.focus, selection.focus) || k3 !== \"anchor\" && k3 !== \"focus\" && props[k3] !== selection[k3]) {\n        oldProps[k3] = selection[k3];\n        newProps[k3] = props[k3];\n      }\n    }\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: \"set_selection\",\n        properties: oldProps,\n        newProperties: newProps\n      });\n    }\n  }\n};\nvar TextTransforms = {\n  /**\n   * Delete content in the editor.\n   */\n  delete(editor) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        reverse = false,\n        unit = \"character\",\n        distance = 1,\n        voids = false\n      } = options;\n      var {\n        at = editor.selection,\n        hanging = false\n      } = options;\n      if (!at) {\n        return;\n      }\n      var isCollapsed2 = false;\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        isCollapsed2 = true;\n        at = at.anchor;\n      }\n      if (Point.isPoint(at)) {\n        var furthestVoid = Editor.void(editor, {\n          at,\n          mode: \"highest\"\n        });\n        if (!voids && furthestVoid) {\n          var [, voidPath] = furthestVoid;\n          at = voidPath;\n        } else {\n          var opts = {\n            unit,\n            distance\n          };\n          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n          at = {\n            anchor: at,\n            focus: target\n          };\n          hanging = true;\n        }\n      }\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, {\n          at,\n          voids\n        });\n        return;\n      }\n      if (Range.isCollapsed(at)) {\n        return;\n      }\n      if (!hanging) {\n        var [, _end] = Range.edges(at);\n        var endOfDoc = Editor.end(editor, []);\n        if (!Point.equals(_end, endOfDoc)) {\n          at = Editor.unhangRange(editor, at, {\n            voids\n          });\n        }\n      }\n      var [start2, end2] = Range.edges(at);\n      var startBlock = Editor.above(editor, {\n        match: (n8) => Editor.isBlock(editor, n8),\n        at: start2,\n        voids\n      });\n      var endBlock = Editor.above(editor, {\n        match: (n8) => Editor.isBlock(editor, n8),\n        at: end2,\n        voids\n      });\n      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n      var isSingleText = Path.equals(start2.path, end2.path);\n      var startVoid = voids ? null : Editor.void(editor, {\n        at: start2,\n        mode: \"highest\"\n      });\n      var endVoid = voids ? null : Editor.void(editor, {\n        at: end2,\n        mode: \"highest\"\n      });\n      if (startVoid) {\n        var before = Editor.before(editor, start2);\n        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n          start2 = before;\n        }\n      }\n      if (endVoid) {\n        var after = Editor.after(editor, end2);\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end2 = after;\n        }\n      }\n      var matches = [];\n      var lastPath;\n      for (var entry of Editor.nodes(editor, {\n        at,\n        voids\n      })) {\n        var [node, path] = entry;\n        if (lastPath && Path.compare(path, lastPath) === 0) {\n          continue;\n        }\n        if (!voids && Editor.isVoid(editor, node) || !Path.isCommon(path, start2.path) && !Path.isCommon(path, end2.path)) {\n          matches.push(entry);\n          lastPath = path;\n        }\n      }\n      var pathRefs = Array.from(matches, (_ref) => {\n        var [, p6] = _ref;\n        return Editor.pathRef(editor, p6);\n      });\n      var startRef = Editor.pointRef(editor, start2);\n      var endRef = Editor.pointRef(editor, end2);\n      var removedText = \"\";\n      if (!isSingleText && !startVoid) {\n        var _point = startRef.current;\n        var [_node] = Editor.leaf(editor, _point);\n        var {\n          path: _path\n        } = _point;\n        var {\n          offset: offset3\n        } = start2;\n        var text4 = _node.text.slice(offset3);\n        if (text4.length > 0) {\n          editor.apply({\n            type: \"remove_text\",\n            path: _path,\n            offset: offset3,\n            text: text4\n          });\n          removedText = text4;\n        }\n      }\n      for (var pathRef of pathRefs) {\n        var _path2 = pathRef.unref();\n        Transforms.removeNodes(editor, {\n          at: _path2,\n          voids\n        });\n      }\n      if (!endVoid) {\n        var _point2 = endRef.current;\n        var [_node2] = Editor.leaf(editor, _point2);\n        var {\n          path: _path3\n        } = _point2;\n        var _offset = isSingleText ? start2.offset : 0;\n        var _text = _node2.text.slice(_offset, end2.offset);\n        if (_text.length > 0) {\n          editor.apply({\n            type: \"remove_text\",\n            path: _path3,\n            offset: _offset,\n            text: _text\n          });\n          removedText = _text;\n        }\n      }\n      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids\n        });\n      }\n      if (isCollapsed2 && reverse && unit === \"character\" && removedText.length > 1 && removedText.match(/[\\u0E00-\\u0E7F]+/)) {\n        Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n      }\n      var startUnref = startRef.unref();\n      var endUnref = endRef.unref();\n      var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n      if (options.at == null && point) {\n        Transforms.select(editor, point);\n      }\n    });\n  },\n  /**\n   * Insert a fragment at a specific location in the editor.\n   */\n  insertFragment(editor, fragment) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        hanging = false,\n        voids = false\n      } = options;\n      var {\n        at = editor.selection\n      } = options;\n      if (!fragment.length) {\n        return;\n      }\n      if (!at) {\n        return;\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at);\n        }\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var [, end2] = Range.edges(at);\n          if (!voids && Editor.void(editor, {\n            at: end2\n          })) {\n            return;\n          }\n          var pointRef = Editor.pointRef(editor, end2);\n          Transforms.delete(editor, {\n            at\n          });\n          at = pointRef.unref();\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at);\n      }\n      if (!voids && Editor.void(editor, {\n        at\n      })) {\n        return;\n      }\n      var inlineElementMatch = Editor.above(editor, {\n        at,\n        match: (n8) => Editor.isInline(editor, n8),\n        mode: \"highest\",\n        voids\n      });\n      if (inlineElementMatch) {\n        var [, _inlinePath] = inlineElementMatch;\n        if (Editor.isEnd(editor, at, _inlinePath)) {\n          var after = Editor.after(editor, _inlinePath);\n          at = after;\n        } else if (Editor.isStart(editor, at, _inlinePath)) {\n          var before = Editor.before(editor, _inlinePath);\n          at = before;\n        }\n      }\n      var blockMatch = Editor.above(editor, {\n        match: (n8) => Editor.isBlock(editor, n8),\n        at,\n        voids\n      });\n      var [, blockPath] = blockMatch;\n      var isBlockStart = Editor.isStart(editor, at, blockPath);\n      var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n      var isBlockEmpty = isBlockStart && isBlockEnd;\n      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n      var mergeEnd = !isBlockEnd;\n      var [, firstPath] = Node2.first({\n        children: fragment\n      }, []);\n      var [, lastPath] = Node2.last({\n        children: fragment\n      }, []);\n      var matches = [];\n      var matcher = (_ref2) => {\n        var [n8, p6] = _ref2;\n        var isRoot = p6.length === 0;\n        if (isRoot) {\n          return false;\n        }\n        if (isBlockEmpty) {\n          return true;\n        }\n        if (mergeStart && Path.isAncestor(p6, firstPath) && Element2.isElement(n8) && !editor.isVoid(n8) && !editor.isInline(n8)) {\n          return false;\n        }\n        if (mergeEnd && Path.isAncestor(p6, lastPath) && Element2.isElement(n8) && !editor.isVoid(n8) && !editor.isInline(n8)) {\n          return false;\n        }\n        return true;\n      };\n      for (var entry of Node2.nodes({\n        children: fragment\n      }, {\n        pass: matcher\n      })) {\n        if (matcher(entry)) {\n          matches.push(entry);\n        }\n      }\n      var starts = [];\n      var middles = [];\n      var ends = [];\n      var starting = true;\n      var hasBlocks = false;\n      for (var [node] of matches) {\n        if (Element2.isElement(node) && !editor.isInline(node)) {\n          starting = false;\n          hasBlocks = true;\n          middles.push(node);\n        } else if (starting) {\n          starts.push(node);\n        } else {\n          ends.push(node);\n        }\n      }\n      var [inlineMatch] = Editor.nodes(editor, {\n        at,\n        match: (n8) => Text.isText(n8) || Editor.isInline(editor, n8),\n        mode: \"highest\",\n        voids\n      });\n      var [, inlinePath] = inlineMatch;\n      var isInlineStart = Editor.isStart(editor, at, inlinePath);\n      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n      var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.splitNodes(editor, {\n        at,\n        match: (n8) => hasBlocks ? Editor.isBlock(editor, n8) : Text.isText(n8) || Editor.isInline(editor, n8),\n        mode: hasBlocks ? \"lowest\" : \"highest\",\n        always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n        voids\n      });\n      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current,\n        match: (n8) => Text.isText(n8) || Editor.isInline(editor, n8),\n        mode: \"highest\",\n        voids\n      });\n      if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n        Transforms.delete(editor, {\n          at: blockPath,\n          voids\n        });\n      }\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current,\n        match: (n8) => Editor.isBlock(editor, n8),\n        mode: \"lowest\",\n        voids\n      });\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current,\n        match: (n8) => Text.isText(n8) || Editor.isInline(editor, n8),\n        mode: \"highest\",\n        voids\n      });\n      if (!options.at) {\n        var path;\n        if (ends.length > 0 && endRef.current) {\n          path = Path.previous(endRef.current);\n        } else if (middles.length > 0 && middleRef.current) {\n          path = Path.previous(middleRef.current);\n        } else if (startRef.current) {\n          path = Path.previous(startRef.current);\n        }\n        if (path) {\n          var _end2 = Editor.end(editor, path);\n          Transforms.select(editor, _end2);\n        }\n      }\n      startRef.unref();\n      middleRef.unref();\n      endRef.unref();\n    });\n  },\n  /**\n   * Insert a string of text in the Editor.\n   */\n  insertText(editor, text4) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        voids = false\n      } = options;\n      var {\n        at = editor.selection\n      } = options;\n      if (!at) {\n        return;\n      }\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var end2 = Range.end(at);\n          if (!voids && Editor.void(editor, {\n            at: end2\n          })) {\n            return;\n          }\n          var start2 = Range.start(at);\n          var startRef = Editor.pointRef(editor, start2);\n          var endRef = Editor.pointRef(editor, end2);\n          Transforms.delete(editor, {\n            at,\n            voids\n          });\n          var startPoint = startRef.unref();\n          var endPoint = endRef.unref();\n          at = startPoint || endPoint;\n          Transforms.setSelection(editor, {\n            anchor: at,\n            focus: at\n          });\n        }\n      }\n      if (!voids && Editor.void(editor, {\n        at\n      })) {\n        return;\n      }\n      var {\n        path,\n        offset: offset3\n      } = at;\n      if (text4.length > 0)\n        editor.apply({\n          type: \"insert_text\",\n          path,\n          offset: offset3,\n          text: text4\n        });\n    });\n  }\n};\nfunction ownKeys(object, enumerableOnly) {\n  var keys4 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys4.push.apply(keys4, symbols);\n  }\n  return keys4;\n}\nfunction _objectSpread(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    if (i5 % 2) {\n      ownKeys(Object(source), true).forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar Transforms = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\n\n// node_modules/slate-react/dist/index.es.js\nvar import_is_hotkey = __toESM(require_lib());\nvar import_react_dom = __toESM(require(\"react-dom\"));\nfunction _defineProperty2(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _objectWithoutPropertiesLoose2(source, excluded) {\n  if (source == null)\n    return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i5;\n  for (i5 = 0; i5 < sourceKeys.length; i5++) {\n    key = sourceKeys[i5];\n    if (excluded.indexOf(key) >= 0)\n      continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _objectWithoutProperties2(source, excluded) {\n  if (source == null)\n    return {};\n  var target = _objectWithoutPropertiesLoose2(source, excluded);\n  var key, i5;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i5 = 0; i5 < sourceSymbolKeys.length; i5++) {\n      key = sourceSymbolKeys[i5];\n      if (excluded.indexOf(key) >= 0)\n        continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key))\n        continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nvar n3 = 0;\nvar Key = class {\n  constructor() {\n    this.id = \"\".concat(n3++);\n  }\n};\nvar NODE_TO_INDEX = /* @__PURE__ */ new WeakMap();\nvar NODE_TO_PARENT = /* @__PURE__ */ new WeakMap();\nvar EDITOR_TO_WINDOW = /* @__PURE__ */ new WeakMap();\nvar EDITOR_TO_ELEMENT = /* @__PURE__ */ new WeakMap();\nvar EDITOR_TO_PLACEHOLDER_ELEMENT = /* @__PURE__ */ new WeakMap();\nvar ELEMENT_TO_NODE = /* @__PURE__ */ new WeakMap();\nvar NODE_TO_ELEMENT = /* @__PURE__ */ new WeakMap();\nvar NODE_TO_KEY = /* @__PURE__ */ new WeakMap();\nvar EDITOR_TO_KEY_TO_ELEMENT = /* @__PURE__ */ new WeakMap();\nvar IS_READ_ONLY = /* @__PURE__ */ new WeakMap();\nvar IS_FOCUSED = /* @__PURE__ */ new WeakMap();\nvar IS_COMPOSING = /* @__PURE__ */ new WeakMap();\nvar EDITOR_TO_USER_SELECTION = /* @__PURE__ */ new WeakMap();\nvar EDITOR_TO_ON_CHANGE = /* @__PURE__ */ new WeakMap();\nvar EDITOR_TO_SCHEDULE_FLUSH = /* @__PURE__ */ new WeakMap();\nvar EDITOR_TO_PENDING_INSERTION_MARKS = /* @__PURE__ */ new WeakMap();\nvar EDITOR_TO_USER_MARKS = /* @__PURE__ */ new WeakMap();\nvar EDITOR_TO_PENDING_DIFFS = /* @__PURE__ */ new WeakMap();\nvar EDITOR_TO_PENDING_ACTION = /* @__PURE__ */ new WeakMap();\nvar EDITOR_TO_PENDING_SELECTION = /* @__PURE__ */ new WeakMap();\nvar EDITOR_TO_FORCE_RENDER = /* @__PURE__ */ new WeakMap();\nvar PLACEHOLDER_SYMBOL = Symbol(\"placeholder\");\nvar MARK_PLACEHOLDER_SYMBOL = Symbol(\"mark-placeholder\");\nvar getDefaultView = (value) => {\n  return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\nvar isDOMComment = (value) => {\n  return isDOMNode(value) && value.nodeType === 8;\n};\nvar isDOMElement = (value) => {\n  return isDOMNode(value) && value.nodeType === 1;\n};\nvar isDOMNode = (value) => {\n  var window2 = getDefaultView(value);\n  return !!window2 && value instanceof window2.Node;\n};\nvar isDOMSelection = (value) => {\n  var window2 = value && value.anchorNode && getDefaultView(value.anchorNode);\n  return !!window2 && value instanceof window2.Selection;\n};\nvar isDOMText = (value) => {\n  return isDOMNode(value) && value.nodeType === 3;\n};\nvar isPlainTextOnlyPaste = (event) => {\n  return event.clipboardData && event.clipboardData.getData(\"text/plain\") !== \"\" && event.clipboardData.types.length === 1;\n};\nvar normalizeDOMPoint = (domPoint) => {\n  var [node, offset3] = domPoint;\n  if (isDOMElement(node) && node.childNodes.length) {\n    var isLast = offset3 === node.childNodes.length;\n    var index5 = isLast ? offset3 - 1 : offset3;\n    [node, index5] = getEditableChildAndIndex(node, index5, isLast ? \"backward\" : \"forward\");\n    isLast = index5 < offset3;\n    while (isDOMElement(node) && node.childNodes.length) {\n      var i5 = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i5, isLast ? \"backward\" : \"forward\");\n    }\n    offset3 = isLast && node.textContent != null ? node.textContent.length : 0;\n  }\n  return [node, offset3];\n};\nvar hasShadowRoot = () => {\n  return !!(window.document.activeElement && window.document.activeElement.shadowRoot);\n};\nvar getEditableChildAndIndex = (parent2, index5, direction) => {\n  var {\n    childNodes\n  } = parent2;\n  var child = childNodes[index5];\n  var i5 = index5;\n  var triedForward = false;\n  var triedBackward = false;\n  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute(\"contenteditable\") === \"false\") {\n    if (triedForward && triedBackward) {\n      break;\n    }\n    if (i5 >= childNodes.length) {\n      triedForward = true;\n      i5 = index5 - 1;\n      direction = \"backward\";\n      continue;\n    }\n    if (i5 < 0) {\n      triedBackward = true;\n      i5 = index5 + 1;\n      direction = \"forward\";\n      continue;\n    }\n    child = childNodes[i5];\n    index5 = i5;\n    i5 += direction === \"forward\" ? 1 : -1;\n  }\n  return [child, index5];\n};\nvar getEditableChild = (parent2, index5, direction) => {\n  var [child] = getEditableChildAndIndex(parent2, index5, direction);\n  return child;\n};\nvar getPlainText = (domNode) => {\n  var text4 = \"\";\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue;\n  }\n  if (isDOMElement(domNode)) {\n    for (var childNode of Array.from(domNode.childNodes)) {\n      text4 += getPlainText(childNode);\n    }\n    var display = getComputedStyle(domNode).getPropertyValue(\"display\");\n    if (display === \"block\" || display === \"list\" || domNode.tagName === \"BR\") {\n      text4 += \"\\n\";\n    }\n  }\n  return text4;\n};\nvar catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m;\nvar getSlateFragmentAttribute = (dataTransfer) => {\n  var htmlData = dataTransfer.getData(\"text/html\");\n  var [, fragment] = htmlData.match(catchSlateFragment) || [];\n  return fragment;\n};\nvar isTrackedMutation = (editor, mutation, batch) => {\n  var {\n    target\n  } = mutation;\n  if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n    return false;\n  }\n  var {\n    document: document2\n  } = ReactEditor.getWindow(editor);\n  if (document2.contains(target)) {\n    return ReactEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  }\n  var parentMutation = batch.find((_ref) => {\n    var {\n      addedNodes,\n      removedNodes\n    } = _ref;\n    for (var node of addedNodes) {\n      if (node === target || node.contains(target)) {\n        return true;\n      }\n    }\n    for (var _node of removedNodes) {\n      if (_node === target || _node.contains(target)) {\n        return true;\n      }\n    }\n  });\n  if (!parentMutation || parentMutation === mutation) {\n    return false;\n  }\n  return isTrackedMutation(editor, parentMutation, batch);\n};\nvar IS_REACT_VERSION_17_OR_ABOVE = parseInt(import_react2.default.version.split(\".\")[0], 10) >= 17;\nvar IS_IOS = typeof navigator !== \"undefined\" && typeof window !== \"undefined\" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nvar IS_APPLE = typeof navigator !== \"undefined\" && /Mac OS X/.test(navigator.userAgent);\nvar IS_ANDROID = typeof navigator !== \"undefined\" && /Android/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== \"undefined\" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_SAFARI = typeof navigator !== \"undefined\" && /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent);\nvar IS_EDGE_LEGACY = typeof navigator !== \"undefined\" && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== \"undefined\" && /Chrome/i.test(navigator.userAgent);\nvar IS_CHROME_LEGACY = typeof navigator !== \"undefined\" && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent);\nvar IS_FIREFOX_LEGACY = typeof navigator !== \"undefined\" && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent);\nvar IS_QQBROWSER = typeof navigator !== \"undefined\" && /.*QQBrowser/.test(navigator.userAgent);\nvar IS_UC_MOBILE = typeof navigator !== \"undefined\" && /.*UCBrowser/.test(navigator.userAgent);\nvar IS_WECHATBROWSER = typeof navigator !== \"undefined\" && /.*Wechat/.test(navigator.userAgent);\nvar CAN_USE_DOM = !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\nvar HAS_BEFORE_INPUT_SUPPORT = !IS_CHROME_LEGACY && !IS_EDGE_LEGACY && // globalThis is undefined in older browsers\ntypeof globalThis !== \"undefined\" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.\ntypeof globalThis.InputEvent.prototype.getTargetRanges === \"function\";\nvar ReactEditor = {\n  /**\n   * Check if the user is currently composing inside the editor.\n   */\n  isComposing(editor) {\n    return !!IS_COMPOSING.get(editor);\n  },\n  /**\n   * Return the host window of the current editor.\n   */\n  getWindow(editor) {\n    var window2 = EDITOR_TO_WINDOW.get(editor);\n    if (!window2) {\n      throw new Error(\"Unable to find a host window element for this editor\");\n    }\n    return window2;\n  },\n  /**\n   * Find a key for a Slate node.\n   */\n  findKey(editor, node) {\n    var key = NODE_TO_KEY.get(node);\n    if (!key) {\n      key = new Key();\n      NODE_TO_KEY.set(node, key);\n    }\n    return key;\n  },\n  /**\n   * Find the path of Slate node.\n   */\n  findPath(editor, node) {\n    var path = [];\n    var child = node;\n    while (true) {\n      var parent2 = NODE_TO_PARENT.get(child);\n      if (parent2 == null) {\n        if (Editor.isEditor(child)) {\n          return path;\n        } else {\n          break;\n        }\n      }\n      var i5 = NODE_TO_INDEX.get(child);\n      if (i5 == null) {\n        break;\n      }\n      path.unshift(i5);\n      child = parent2;\n    }\n    throw new Error(\"Unable to find the path for Slate node: \".concat(Scrubber.stringify(node)));\n  },\n  /**\n   * Find the DOM node that implements DocumentOrShadowRoot for the editor.\n   */\n  findDocumentOrShadowRoot(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root5 = el.getRootNode();\n    if ((root5 instanceof Document || root5 instanceof ShadowRoot) && root5.getSelection != null) {\n      return root5;\n    }\n    return el.ownerDocument;\n  },\n  /**\n   * Check if the editor is focused.\n   */\n  isFocused(editor) {\n    return !!IS_FOCUSED.get(editor);\n  },\n  /**\n   * Check if the editor is in read-only mode.\n   */\n  isReadOnly(editor) {\n    return !!IS_READ_ONLY.get(editor);\n  },\n  /**\n   * Blur the editor.\n   */\n  blur(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root5 = ReactEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, false);\n    if (root5.activeElement === el) {\n      el.blur();\n    }\n  },\n  /**\n   * Focus the editor.\n   */\n  focus(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root5 = ReactEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, true);\n    if (root5.activeElement !== el) {\n      el.focus({\n        preventScroll: true\n      });\n    }\n  },\n  /**\n   * Deselect the editor.\n   */\n  deselect(editor) {\n    ReactEditor.toDOMNode(editor, editor);\n    var {\n      selection\n    } = editor;\n    var root5 = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = root5.getSelection();\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges();\n    }\n    if (selection) {\n      Transforms.deselect(editor);\n    }\n  },\n  /**\n   * Check if a DOM node is within the editor.\n   */\n  hasDOMNode(editor, target) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var {\n      editable = false\n    } = options;\n    var editorEl = ReactEditor.toDOMNode(editor, editor);\n    var targetEl;\n    try {\n      targetEl = isDOMElement(target) ? target : target.parentElement;\n    } catch (err) {\n      if (!err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err;\n      }\n    }\n    if (!targetEl) {\n      return false;\n    }\n    return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === \"boolean\" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n    targetEl.closest('[contenteditable=\"false\"]') === editorEl || !!targetEl.getAttribute(\"data-slate-zero-width\"));\n  },\n  /**\n   * Insert data from a `DataTransfer` into the editor.\n   */\n  insertData(editor, data) {\n    editor.insertData(data);\n  },\n  /**\n   * Insert fragment data from a `DataTransfer` into the editor.\n   */\n  insertFragmentData(editor, data) {\n    return editor.insertFragmentData(data);\n  },\n  /**\n   * Insert text data from a `DataTransfer` into the editor.\n   */\n  insertTextData(editor, data) {\n    return editor.insertTextData(data);\n  },\n  /**\n   * Sets data from the currently selected fragment on a `DataTransfer`.\n   */\n  setFragmentData(editor, data, originEvent) {\n    editor.setFragmentData(data, originEvent);\n  },\n  /**\n   * Find the native DOM element from a Slate node.\n   */\n  toDOMNode(editor, node) {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    var domNode = Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node));\n    if (!domNode) {\n      throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(Scrubber.stringify(node)));\n    }\n    return domNode;\n  },\n  /**\n   * Find a native DOM selection point from a Slate point.\n   */\n  toDOMPoint(editor, point) {\n    var [node] = Editor.node(editor, point.path);\n    var el = ReactEditor.toDOMNode(editor, node);\n    var domPoint;\n    if (Editor.void(editor, {\n      at: point\n    })) {\n      point = {\n        path: point.path,\n        offset: 0\n      };\n    }\n    var selector = \"[data-slate-string], [data-slate-zero-width]\";\n    var texts = Array.from(el.querySelectorAll(selector));\n    var start2 = 0;\n    for (var i5 = 0; i5 < texts.length; i5++) {\n      var text4 = texts[i5];\n      var domNode = text4.childNodes[0];\n      if (domNode == null || domNode.textContent == null) {\n        continue;\n      }\n      var {\n        length\n      } = domNode.textContent;\n      var attr = text4.getAttribute(\"data-slate-length\");\n      var trueLength = attr == null ? length : parseInt(attr, 10);\n      var end2 = start2 + trueLength;\n      var nextText = texts[i5 + 1];\n      if (point.offset === end2 && nextText !== null && nextText !== void 0 && nextText.hasAttribute(\"data-slate-mark-placeholder\")) {\n        var _nextText$textContent;\n        domPoint = [nextText, (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith(\"\\uFEFF\") ? 1 : 0];\n        break;\n      }\n      if (point.offset <= end2) {\n        var offset3 = Math.min(length, Math.max(0, point.offset - start2));\n        domPoint = [domNode, offset3];\n        break;\n      }\n      start2 = end2;\n    }\n    if (!domPoint) {\n      throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(Scrubber.stringify(point)));\n    }\n    return domPoint;\n  },\n  /**\n   * Find a native DOM range from a Slate `range`.\n   *\n   * Notice: the returned range will always be ordinal regardless of the direction of Slate `range` due to DOM API limit.\n   *\n   * there is no way to create a reverse DOM Range using Range.setStart/setEnd\n   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.\n   */\n  toDOMRange(editor, range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    var isBackward = Range.isBackward(range);\n    var domAnchor = ReactEditor.toDOMPoint(editor, anchor);\n    var domFocus = Range.isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus);\n    var window2 = ReactEditor.getWindow(editor);\n    var domRange = window2.document.createRange();\n    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;\n    var [endNode, endOffset] = isBackward ? domAnchor : domFocus;\n    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n    var isStartAtZeroWidth = !!startEl.getAttribute(\"data-slate-zero-width\");\n    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n    var isEndAtZeroWidth = !!endEl.getAttribute(\"data-slate-zero-width\");\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n    return domRange;\n  },\n  /**\n   * Find a Slate node from a native DOM `element`.\n   */\n  toSlateNode(editor, domNode) {\n    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n    if (domEl && !domEl.hasAttribute(\"data-slate-node\")) {\n      domEl = domEl.closest(\"[data-slate-node]\");\n    }\n    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n    if (!node) {\n      throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n    }\n    return node;\n  },\n  /**\n   * Get the target range from a DOM `event`.\n   */\n  findEventRange(editor, event) {\n    if (\"nativeEvent\" in event) {\n      event = event.nativeEvent;\n    }\n    var {\n      clientX: x4,\n      clientY: y5,\n      target\n    } = event;\n    if (x4 == null || y5 == null) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n    var node = ReactEditor.toSlateNode(editor, event.target);\n    var path = ReactEditor.findPath(editor, node);\n    if (Editor.isVoid(editor, node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrev = editor.isInline(node) ? x4 - rect.left < rect.left + rect.width - x4 : y5 - rect.top < rect.top + rect.height - y5;\n      var edge = Editor.point(editor, path, {\n        edge: isPrev ? \"start\" : \"end\"\n      });\n      var point = isPrev ? Editor.before(editor, edge) : Editor.after(editor, edge);\n      if (point) {\n        var _range = Editor.range(editor, point);\n        return _range;\n      }\n    }\n    var domRange;\n    var {\n      document: document2\n    } = ReactEditor.getWindow(editor);\n    if (document2.caretRangeFromPoint) {\n      domRange = document2.caretRangeFromPoint(x4, y5);\n    } else {\n      var position = document2.caretPositionFromPoint(x4, y5);\n      if (position) {\n        domRange = document2.createRange();\n        domRange.setStart(position.offsetNode, position.offset);\n        domRange.setEnd(position.offsetNode, position.offset);\n      }\n    }\n    if (!domRange) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n    var range = ReactEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      suppressThrow: false\n    });\n    return range;\n  },\n  /**\n   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.\n   */\n  toSlatePoint(editor, domPoint, options) {\n    var {\n      exactMatch,\n      suppressThrow\n    } = options;\n    var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);\n    var parentNode = nearestNode.parentNode;\n    var textNode = null;\n    var offset3 = 0;\n    if (parentNode) {\n      var _domNode$textContent, _domNode$textContent2;\n      var editorEl = ReactEditor.toDOMNode(editor, editor);\n      var potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]');\n      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;\n      var leafNode = parentNode.closest(\"[data-slate-leaf]\");\n      var domNode = null;\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]');\n        if (textNode) {\n          var window2 = ReactEditor.getWindow(editor);\n          var range = window2.document.createRange();\n          range.setStart(textNode, 0);\n          range.setEnd(nearestNode, nearestOffset);\n          var contents = range.cloneContents();\n          var removals = [...Array.prototype.slice.call(contents.querySelectorAll(\"[data-slate-zero-width]\")), ...Array.prototype.slice.call(contents.querySelectorAll(\"[contenteditable=false]\"))];\n          removals.forEach((el) => {\n            if (IS_ANDROID && !exactMatch && el.hasAttribute(\"data-slate-zero-width\") && el.textContent.length > 0 && el.textContext !== \"\\uFEFF\") {\n              if (el.textContent.startsWith(\"\\uFEFF\")) {\n                el.textContent = el.textContent.slice(1);\n              }\n              return;\n            }\n            el.parentNode.removeChild(el);\n          });\n          offset3 = contents.textContent.length;\n          domNode = textNode;\n        }\n      } else if (voidNode) {\n        var leafNodes = voidNode.querySelectorAll(\"[data-slate-leaf]\");\n        for (var index5 = 0; index5 < leafNodes.length; index5++) {\n          var current = leafNodes[index5];\n          if (ReactEditor.hasDOMNode(editor, current)) {\n            leafNode = current;\n            break;\n          }\n        }\n        if (!leafNode) {\n          offset3 = 1;\n        } else {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          offset3 = domNode.textContent.length;\n          domNode.querySelectorAll(\"[data-slate-zero-width]\").forEach((el) => {\n            offset3 -= el.textContent.length;\n          });\n        }\n      }\n      if (domNode && offset3 === domNode.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,\n      // and we don't add it for line-breaks.\n      IS_ANDROID && domNode.getAttribute(\"data-slate-zero-width\") === \"z\" && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith(\"\\uFEFF\") && (parentNode.hasAttribute(\"data-slate-zero-width\") || IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith(\"\\n\\n\"))) {\n        offset3--;\n      }\n    }\n    if (IS_ANDROID && !textNode && !exactMatch) {\n      var node = parentNode.hasAttribute(\"data-slate-node\") ? parentNode : parentNode.closest(\"[data-slate-node]\");\n      if (node && ReactEditor.hasDOMNode(editor, node, {\n        editable: true\n      })) {\n        var _slateNode = ReactEditor.toSlateNode(editor, node);\n        var {\n          path: _path,\n          offset: _offset\n        } = Editor.start(editor, ReactEditor.findPath(editor, _slateNode));\n        if (!node.querySelector(\"[data-slate-leaf]\")) {\n          _offset = nearestOffset;\n        }\n        return {\n          path: _path,\n          offset: _offset\n        };\n      }\n    }\n    if (!textNode) {\n      if (suppressThrow) {\n        return null;\n      }\n      throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n    }\n    var slateNode2 = ReactEditor.toSlateNode(editor, textNode);\n    var path = ReactEditor.findPath(editor, slateNode2);\n    return {\n      path,\n      offset: offset3\n    };\n  },\n  /**\n   * Find a Slate range from a DOM range or selection.\n   */\n  toSlateRange(editor, domRange, options) {\n    var {\n      exactMatch,\n      suppressThrow\n    } = options;\n    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n    var anchorNode;\n    var anchorOffset;\n    var focusNode;\n    var focusOffset;\n    var isCollapsed2;\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        anchorNode = domRange.anchorNode;\n        anchorOffset = domRange.anchorOffset;\n        focusNode = domRange.focusNode;\n        focusOffset = domRange.focusOffset;\n        if (IS_CHROME && hasShadowRoot()) {\n          isCollapsed2 = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n        } else {\n          isCollapsed2 = domRange.isCollapsed;\n        }\n      } else {\n        anchorNode = domRange.startContainer;\n        anchorOffset = domRange.startOffset;\n        focusNode = domRange.endContainer;\n        focusOffset = domRange.endOffset;\n        isCollapsed2 = domRange.collapsed;\n      }\n    }\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n    }\n    var anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {\n      exactMatch,\n      suppressThrow\n    });\n    if (!anchor) {\n      return null;\n    }\n    var focus = isCollapsed2 ? anchor : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset], {\n      exactMatch,\n      suppressThrow\n    });\n    if (!focus) {\n      return null;\n    }\n    var range = {\n      anchor,\n      focus\n    };\n    if (Range.isExpanded(range) && Range.isForward(range) && isDOMElement(focusNode) && Editor.void(editor, {\n      at: range.focus,\n      mode: \"highest\"\n    })) {\n      range = Editor.unhangRange(editor, range, {\n        voids: true\n      });\n    }\n    return range;\n  },\n  hasRange(editor, range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Editor.hasPath(editor, anchor.path) && Editor.hasPath(editor, focus.path);\n  },\n  /**\n   * Experimental and android specific: Flush all pending diffs and cancel composition at the next possible time.\n   */\n  androidScheduleFlush(editor) {\n    var _EDITOR_TO_SCHEDULE_F;\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n  },\n  /**\n   * Experimental and android specific: Get pending diffs\n   */\n  androidPendingDiffs(editor) {\n    return EDITOR_TO_PENDING_DIFFS.get(editor);\n  }\n};\nvar useIsomorphicLayoutEffect = CAN_USE_DOM ? import_react2.useLayoutEffect : import_react2.useEffect;\nvar _excluded$32 = [\"anchor\", \"focus\"];\nvar _excluded2$12 = [\"anchor\", \"focus\"];\nvar shallowCompare = (obj1, obj2) => Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every((key) => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);\nvar isDecoratorRangeListEqual = (list, another) => {\n  if (list.length !== another.length) {\n    return false;\n  }\n  for (var i5 = 0; i5 < list.length; i5++) {\n    var range = list[i5];\n    var other = another[i5];\n    var rangeOwnProps = _objectWithoutProperties2(range, _excluded$32);\n    var otherOwnProps = _objectWithoutProperties2(other, _excluded2$12);\n    if (!Range.equals(range, other) || range[PLACEHOLDER_SYMBOL] !== other[PLACEHOLDER_SYMBOL] || !shallowCompare(rangeOwnProps, otherOwnProps)) {\n      return false;\n    }\n  }\n  return true;\n};\nvar String2 = (props) => {\n  var {\n    isLast,\n    leaf,\n    parent: parent2,\n    text: text4\n  } = props;\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, text4);\n  var parentPath = Path.parent(path);\n  var isMarkPlaceholder = leaf[MARK_PLACEHOLDER_SYMBOL] === true;\n  if (editor.isVoid(parent2)) {\n    return /* @__PURE__ */ import_react2.default.createElement(ZeroWidthString, {\n      length: Node2.string(parent2).length\n    });\n  }\n  if (leaf.text === \"\" && parent2.children[parent2.children.length - 1] === text4 && !editor.isInline(parent2) && Editor.string(editor, parentPath) === \"\") {\n    return /* @__PURE__ */ import_react2.default.createElement(ZeroWidthString, {\n      isLineBreak: true,\n      isMarkPlaceholder\n    });\n  }\n  if (leaf.text === \"\") {\n    return /* @__PURE__ */ import_react2.default.createElement(ZeroWidthString, {\n      isMarkPlaceholder\n    });\n  }\n  if (isLast && leaf.text.slice(-1) === \"\\n\") {\n    return /* @__PURE__ */ import_react2.default.createElement(TextString, {\n      isTrailing: true,\n      text: leaf.text\n    });\n  }\n  return /* @__PURE__ */ import_react2.default.createElement(TextString, {\n    text: leaf.text\n  });\n};\nvar TextString = (props) => {\n  var {\n    text: text4,\n    isTrailing = false\n  } = props;\n  var ref = (0, import_react2.useRef)(null);\n  var getTextContent = () => {\n    return \"\".concat(text4 !== null && text4 !== void 0 ? text4 : \"\").concat(isTrailing ? \"\\n\" : \"\");\n  };\n  useIsomorphicLayoutEffect(() => {\n    var textWithTrailing = getTextContent();\n    if (ref.current && ref.current.textContent !== textWithTrailing) {\n      ref.current.textContent = textWithTrailing;\n    }\n  });\n  if (!ref.current) {\n    return /* @__PURE__ */ import_react2.default.createElement(\"span\", {\n      \"data-slate-string\": true,\n      ref\n    }, getTextContent());\n  }\n  return /* @__PURE__ */ import_react2.default.createElement(\"span\", {\n    \"data-slate-string\": true,\n    ref\n  });\n};\nvar ZeroWidthString = (props) => {\n  var {\n    length = 0,\n    isLineBreak = false,\n    isMarkPlaceholder = false\n  } = props;\n  var attributes = {\n    \"data-slate-zero-width\": isLineBreak ? \"n\" : \"z\",\n    \"data-slate-length\": length\n  };\n  if (isMarkPlaceholder) {\n    attributes[\"data-slate-mark-placeholder\"] = true;\n  }\n  return /* @__PURE__ */ import_react2.default.createElement(\"span\", Object.assign({}, attributes), !IS_ANDROID || !isLineBreak ? \"\\uFEFF\" : null, isLineBreak ? /* @__PURE__ */ import_react2.default.createElement(\"br\", null) : null);\n};\nvar EditorContext = /* @__PURE__ */ (0, import_react2.createContext)(null);\nvar useSlateStatic = () => {\n  var editor = (0, import_react2.useContext)(EditorContext);\n  if (!editor) {\n    throw new Error(\"The `useSlateStatic` hook must be used inside the <Slate> component's context.\");\n  }\n  return editor;\n};\nvar Leaf = (props) => {\n  var {\n    leaf,\n    isLast,\n    text: text4,\n    parent: parent2,\n    renderPlaceholder,\n    renderLeaf = (props2) => /* @__PURE__ */ import_react2.default.createElement(DefaultLeaf, Object.assign({}, props2))\n  } = props;\n  var placeholderRef = (0, import_react2.useRef)(null);\n  var editor = useSlateStatic();\n  (0, import_react2.useEffect)(() => {\n    var placeholderEl = placeholderRef === null || placeholderRef === void 0 ? void 0 : placeholderRef.current;\n    var editorEl = document.querySelector('[data-slate-editor=\"true\"]');\n    if (!placeholderEl || !editorEl) {\n      return;\n    }\n    editorEl.style.minHeight = \"\".concat(placeholderEl.clientHeight, \"px\");\n    EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);\n    return () => {\n      editorEl.style.minHeight = \"auto\";\n      EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);\n    };\n  }, [placeholderRef, leaf]);\n  var children = /* @__PURE__ */ import_react2.default.createElement(String2, {\n    isLast,\n    leaf,\n    parent: parent2,\n    text: text4\n  });\n  if (leaf[PLACEHOLDER_SYMBOL]) {\n    var placeholderProps = {\n      children: leaf.placeholder,\n      attributes: {\n        \"data-slate-placeholder\": true,\n        style: {\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          width: \"100%\",\n          maxWidth: \"100%\",\n          display: \"block\",\n          opacity: \"0.333\",\n          userSelect: \"none\",\n          textDecoration: \"none\"\n        },\n        contentEditable: false,\n        ref: placeholderRef\n      }\n    };\n    children = /* @__PURE__ */ import_react2.default.createElement(import_react2.default.Fragment, null, renderPlaceholder(placeholderProps), children);\n  }\n  var attributes = {\n    \"data-slate-leaf\": true\n  };\n  return renderLeaf({\n    attributes,\n    children,\n    leaf,\n    text: text4\n  });\n};\nvar MemoizedLeaf = /* @__PURE__ */ import_react2.default.memo(Leaf, (prev, next) => {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && Text.equals(next.leaf, prev.leaf) && next.leaf[PLACEHOLDER_SYMBOL] === prev.leaf[PLACEHOLDER_SYMBOL];\n});\nvar DefaultLeaf = (props) => {\n  var {\n    attributes,\n    children\n  } = props;\n  return /* @__PURE__ */ import_react2.default.createElement(\"span\", Object.assign({}, attributes), children);\n};\nvar Text2 = (props) => {\n  var {\n    decorations,\n    isLast,\n    parent: parent2,\n    renderPlaceholder,\n    renderLeaf,\n    text: text4\n  } = props;\n  var editor = useSlateStatic();\n  var ref = (0, import_react2.useRef)(null);\n  var leaves = Text.decorations(text4, decorations);\n  var key = ReactEditor.findKey(editor, text4);\n  var children = [];\n  for (var i5 = 0; i5 < leaves.length; i5++) {\n    var leaf = leaves[i5];\n    children.push(/* @__PURE__ */ import_react2.default.createElement(MemoizedLeaf, {\n      isLast: isLast && i5 === leaves.length - 1,\n      key: \"\".concat(key.id, \"-\").concat(i5),\n      renderPlaceholder,\n      leaf,\n      text: text4,\n      parent: parent2,\n      renderLeaf\n    }));\n  }\n  useIsomorphicLayoutEffect(() => {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    if (ref.current) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref.current);\n      NODE_TO_ELEMENT.set(text4, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, text4);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);\n      NODE_TO_ELEMENT.delete(text4);\n    }\n  });\n  return /* @__PURE__ */ import_react2.default.createElement(\"span\", {\n    \"data-slate-node\": \"text\",\n    ref\n  }, children);\n};\nvar MemoizedText = /* @__PURE__ */ import_react2.default.memo(Text2, (prev, next) => {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.text === prev.text && isDecoratorRangeListEqual(next.decorations, prev.decorations);\n});\nvar Element3 = (props) => {\n  var {\n    decorations,\n    element: element4,\n    renderElement = (p6) => /* @__PURE__ */ import_react2.default.createElement(DefaultElement, Object.assign({}, p6)),\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  } = props;\n  var ref = (0, import_react2.useRef)(null);\n  var editor = useSlateStatic();\n  var readOnly = useReadOnly();\n  var isInline2 = editor.isInline(element4);\n  var key = ReactEditor.findKey(editor, element4);\n  var children = useChildren({\n    decorations,\n    node: element4,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  });\n  var attributes = {\n    \"data-slate-node\": \"element\",\n    ref\n  };\n  if (isInline2) {\n    attributes[\"data-slate-inline\"] = true;\n  }\n  if (!isInline2 && Editor.hasInlines(editor, element4)) {\n    var text4 = Node2.string(element4);\n    var dir = (0, import_direction.default)(text4);\n    if (dir === \"rtl\") {\n      attributes.dir = dir;\n    }\n  }\n  if (Editor.isVoid(editor, element4)) {\n    attributes[\"data-slate-void\"] = true;\n    if (!readOnly && isInline2) {\n      attributes.contentEditable = false;\n    }\n    var Tag = isInline2 ? \"span\" : \"div\";\n    var [[_text]] = Node2.texts(element4);\n    children = /* @__PURE__ */ import_react2.default.createElement(Tag, {\n      \"data-slate-spacer\": true,\n      style: {\n        height: \"0\",\n        color: \"transparent\",\n        outline: \"none\",\n        position: \"absolute\"\n      }\n    }, /* @__PURE__ */ import_react2.default.createElement(MemoizedText, {\n      renderPlaceholder,\n      decorations: [],\n      isLast: false,\n      parent: element4,\n      text: _text\n    }));\n    NODE_TO_INDEX.set(_text, 0);\n    NODE_TO_PARENT.set(_text, element4);\n  }\n  useIsomorphicLayoutEffect(() => {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    if (ref.current) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref.current);\n      NODE_TO_ELEMENT.set(element4, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, element4);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);\n      NODE_TO_ELEMENT.delete(element4);\n    }\n  });\n  return renderElement({\n    attributes,\n    children,\n    element: element4\n  });\n};\nvar MemoizedElement = /* @__PURE__ */ import_react2.default.memo(Element3, (prev, next) => {\n  return prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && isDecoratorRangeListEqual(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && Range.equals(prev.selection, next.selection));\n});\nvar DefaultElement = (props) => {\n  var {\n    attributes,\n    children,\n    element: element4\n  } = props;\n  var editor = useSlateStatic();\n  var Tag = editor.isInline(element4) ? \"span\" : \"div\";\n  return /* @__PURE__ */ import_react2.default.createElement(Tag, Object.assign({}, attributes, {\n    style: {\n      position: \"relative\"\n    }\n  }), children);\n};\nvar DecorateContext = /* @__PURE__ */ (0, import_react2.createContext)(() => []);\nvar useDecorate = () => {\n  return (0, import_react2.useContext)(DecorateContext);\n};\nvar SelectedContext = /* @__PURE__ */ (0, import_react2.createContext)(false);\nvar useSelected = () => {\n  return (0, import_react2.useContext)(SelectedContext);\n};\nvar useChildren = (props) => {\n  var {\n    decorations,\n    node,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  } = props;\n  var decorate = useDecorate();\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, node);\n  var children = [];\n  var isLeafBlock = Element2.isElement(node) && !editor.isInline(node) && Editor.hasInlines(editor, node);\n  for (var i5 = 0; i5 < node.children.length; i5++) {\n    var p6 = path.concat(i5);\n    var n8 = node.children[i5];\n    var key = ReactEditor.findKey(editor, n8);\n    var range = Editor.range(editor, p6);\n    var sel = selection && Range.intersection(range, selection);\n    var ds = decorate([n8, p6]);\n    for (var dec of decorations) {\n      var d4 = Range.intersection(dec, range);\n      if (d4) {\n        ds.push(d4);\n      }\n    }\n    if (Element2.isElement(n8)) {\n      children.push(/* @__PURE__ */ import_react2.default.createElement(SelectedContext.Provider, {\n        key: \"provider-\".concat(key.id),\n        value: !!sel\n      }, /* @__PURE__ */ import_react2.default.createElement(MemoizedElement, {\n        decorations: ds,\n        element: n8,\n        key: key.id,\n        renderElement,\n        renderPlaceholder,\n        renderLeaf,\n        selection: sel\n      })));\n    } else {\n      children.push(/* @__PURE__ */ import_react2.default.createElement(MemoizedText, {\n        decorations: ds,\n        key: key.id,\n        isLast: isLeafBlock && i5 === node.children.length - 1,\n        parent: node,\n        renderPlaceholder,\n        renderLeaf,\n        text: n8\n      }));\n    }\n    NODE_TO_INDEX.set(n8, i5);\n    NODE_TO_PARENT.set(n8, node);\n  }\n  return children;\n};\nvar ReadOnlyContext = /* @__PURE__ */ (0, import_react2.createContext)(false);\nvar useReadOnly = () => {\n  return (0, import_react2.useContext)(ReadOnlyContext);\n};\nvar SlateContext = /* @__PURE__ */ (0, import_react2.createContext)(null);\nvar useSlate = () => {\n  var context = (0, import_react2.useContext)(SlateContext);\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n  }\n  var {\n    editor\n  } = context;\n  return editor;\n};\nvar TRIPLE_CLICK = 3;\nvar HOTKEYS = {\n  bold: \"mod+b\",\n  compose: [\"down\", \"left\", \"right\", \"up\", \"backspace\", \"enter\"],\n  moveBackward: \"left\",\n  moveForward: \"right\",\n  moveWordBackward: \"ctrl+left\",\n  moveWordForward: \"ctrl+right\",\n  deleteBackward: \"shift?+backspace\",\n  deleteForward: \"shift?+delete\",\n  extendBackward: \"shift+left\",\n  extendForward: \"shift+right\",\n  italic: \"mod+i\",\n  insertSoftBreak: \"shift+enter\",\n  splitBlock: \"enter\",\n  undo: \"mod+z\"\n};\nvar APPLE_HOTKEYS = {\n  moveLineBackward: \"opt+up\",\n  moveLineForward: \"opt+down\",\n  moveWordBackward: \"opt+left\",\n  moveWordForward: \"opt+right\",\n  deleteBackward: [\"ctrl+backspace\", \"ctrl+h\"],\n  deleteForward: [\"ctrl+delete\", \"ctrl+d\"],\n  deleteLineBackward: \"cmd+shift?+backspace\",\n  deleteLineForward: [\"cmd+shift?+delete\", \"ctrl+k\"],\n  deleteWordBackward: \"opt+shift?+backspace\",\n  deleteWordForward: \"opt+shift?+delete\",\n  extendLineBackward: \"opt+shift+up\",\n  extendLineForward: \"opt+shift+down\",\n  redo: \"cmd+shift+z\",\n  transposeCharacter: \"ctrl+t\"\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: \"ctrl+shift?+backspace\",\n  deleteWordForward: \"ctrl+shift?+delete\",\n  redo: [\"ctrl+y\", \"ctrl+shift+z\"]\n};\nvar create = (key) => {\n  var generic = HOTKEYS[key];\n  var apple = APPLE_HOTKEYS[key];\n  var windows = WINDOWS_HOTKEYS[key];\n  var isGeneric = generic && (0, import_is_hotkey.isKeyHotkey)(generic);\n  var isApple = apple && (0, import_is_hotkey.isKeyHotkey)(apple);\n  var isWindows = windows && (0, import_is_hotkey.isKeyHotkey)(windows);\n  return (event) => {\n    if (isGeneric && isGeneric(event))\n      return true;\n    if (IS_APPLE && isApple && isApple(event))\n      return true;\n    if (!IS_APPLE && isWindows && isWindows(event))\n      return true;\n    return false;\n  };\n};\nvar Hotkeys = {\n  isBold: create(\"bold\"),\n  isCompose: create(\"compose\"),\n  isMoveBackward: create(\"moveBackward\"),\n  isMoveForward: create(\"moveForward\"),\n  isDeleteBackward: create(\"deleteBackward\"),\n  isDeleteForward: create(\"deleteForward\"),\n  isDeleteLineBackward: create(\"deleteLineBackward\"),\n  isDeleteLineForward: create(\"deleteLineForward\"),\n  isDeleteWordBackward: create(\"deleteWordBackward\"),\n  isDeleteWordForward: create(\"deleteWordForward\"),\n  isExtendBackward: create(\"extendBackward\"),\n  isExtendForward: create(\"extendForward\"),\n  isExtendLineBackward: create(\"extendLineBackward\"),\n  isExtendLineForward: create(\"extendLineForward\"),\n  isItalic: create(\"italic\"),\n  isMoveLineBackward: create(\"moveLineBackward\"),\n  isMoveLineForward: create(\"moveLineForward\"),\n  isMoveWordBackward: create(\"moveWordBackward\"),\n  isMoveWordForward: create(\"moveWordForward\"),\n  isRedo: create(\"redo\"),\n  isSoftBreak: create(\"insertSoftBreak\"),\n  isSplitBlock: create(\"splitBlock\"),\n  isTransposeCharacter: create(\"transposeCharacter\"),\n  isUndo: create(\"undo\")\n};\nvar createRestoreDomManager = (editor, receivedUserInput) => {\n  var bufferedMutations = [];\n  var clear = () => {\n    bufferedMutations = [];\n  };\n  var registerMutations = (mutations) => {\n    if (!receivedUserInput.current) {\n      return;\n    }\n    var trackedMutations = mutations.filter((mutation) => isTrackedMutation(editor, mutation, mutations));\n    bufferedMutations.push(...trackedMutations);\n  };\n  function restoreDOM() {\n    bufferedMutations.reverse().forEach((mutation) => {\n      if (mutation.type === \"characterData\") {\n        mutation.target.textContent = mutation.oldValue;\n        return;\n      }\n      mutation.removedNodes.forEach((node) => {\n        mutation.target.insertBefore(node, mutation.nextSibling);\n      });\n      mutation.addedNodes.forEach((node) => {\n        mutation.target.removeChild(node);\n      });\n    });\n    clear();\n  }\n  return {\n    registerMutations,\n    restoreDOM,\n    clear\n  };\n};\nvar MUTATION_OBSERVER_CONFIG$1 = {\n  subtree: true,\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true\n};\nvar RestoreDOMComponent = class extends import_react2.Component {\n  constructor() {\n    super(...arguments);\n    this.context = null;\n    this.manager = null;\n    this.mutationObserver = null;\n  }\n  observe() {\n    var _this$mutationObserve;\n    var {\n      node\n    } = this.props;\n    if (!node.current) {\n      throw new Error(\"Failed to attach MutationObserver, `node` is undefined\");\n    }\n    (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 ? void 0 : _this$mutationObserve.observe(node.current, MUTATION_OBSERVER_CONFIG$1);\n  }\n  componentDidMount() {\n    var {\n      receivedUserInput\n    } = this.props;\n    var editor = this.context;\n    this.manager = createRestoreDomManager(editor, receivedUserInput);\n    this.mutationObserver = new MutationObserver(this.manager.registerMutations);\n    this.observe();\n  }\n  getSnapshotBeforeUpdate() {\n    var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;\n    var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();\n    if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {\n      var _this$manager;\n      (_this$manager = this.manager) === null || _this$manager === void 0 ? void 0 : _this$manager.registerMutations(pendingMutations);\n    }\n    (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 ? void 0 : _this$mutationObserve3.disconnect();\n    (_this$manager2 = this.manager) === null || _this$manager2 === void 0 ? void 0 : _this$manager2.restoreDOM();\n    return null;\n  }\n  componentDidUpdate() {\n    var _this$manager3;\n    (_this$manager3 = this.manager) === null || _this$manager3 === void 0 ? void 0 : _this$manager3.clear();\n    this.observe();\n  }\n  componentWillUnmount() {\n    var _this$mutationObserve4;\n    (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 ? void 0 : _this$mutationObserve4.disconnect();\n  }\n  render() {\n    return this.props.children;\n  }\n};\nRestoreDOMComponent.contextType = EditorContext;\nvar RestoreDOM = IS_ANDROID ? RestoreDOMComponent : (_ref) => {\n  var {\n    children\n  } = _ref;\n  return /* @__PURE__ */ import_react2.default.createElement(import_react2.default.Fragment, null, children);\n};\nfunction verifyDiffState(editor, textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n  if (!Editor.hasPath(editor, path)) {\n    return false;\n  }\n  var node = Node2.get(editor, path);\n  if (!Text.isText(node)) {\n    return false;\n  }\n  if (diff.start !== node.text.length || diff.text.length === 0) {\n    return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;\n  }\n  var nextPath = Path.next(path);\n  if (!Editor.hasPath(editor, nextPath)) {\n    return false;\n  }\n  var nextNode = Node2.get(editor, nextPath);\n  return Text.isText(nextNode) && nextNode.text.startsWith(diff.text);\n}\nfunction applyStringDiff(text4) {\n  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    diffs[_key - 1] = arguments[_key];\n  }\n  return diffs.reduce((text5, diff) => text5.slice(0, diff.start) + diff.text + text5.slice(diff.end), text4);\n}\nfunction longestCommonPrefixLength(str, another) {\n  var length = Math.min(str.length, another.length);\n  for (var i5 = 0; i5 < length; i5++) {\n    if (str.charAt(i5) !== another.charAt(i5)) {\n      return i5;\n    }\n  }\n  return length;\n}\nfunction longestCommonSuffixLength(str, another, max3) {\n  var length = Math.min(str.length, another.length, max3);\n  for (var i5 = 0; i5 < length; i5++) {\n    if (str.charAt(str.length - i5 - 1) !== another.charAt(another.length - i5 - 1)) {\n      return i5;\n    }\n  }\n  return length;\n}\nfunction normalizeStringDiff(targetText, diff) {\n  var {\n    start: start2,\n    end: end2,\n    text: text4\n  } = diff;\n  var removedText = targetText.slice(start2, end2);\n  var prefixLength = longestCommonPrefixLength(removedText, text4);\n  var max3 = Math.min(removedText.length - prefixLength, text4.length - prefixLength);\n  var suffixLength = longestCommonSuffixLength(removedText, text4, max3);\n  var normalized = {\n    start: start2 + prefixLength,\n    end: end2 - suffixLength,\n    text: text4.slice(prefixLength, text4.length - suffixLength)\n  };\n  if (normalized.start === normalized.end && normalized.text.length === 0) {\n    return null;\n  }\n  return normalized;\n}\nfunction mergeStringDiffs(targetText, a7, b4) {\n  var start2 = Math.min(a7.start, b4.start);\n  var overlap = Math.max(0, Math.min(a7.start + a7.text.length, b4.end) - b4.start);\n  var applied = applyStringDiff(targetText, a7, b4);\n  var sliceEnd = Math.max(b4.start + b4.text.length, a7.start + a7.text.length + (a7.start + a7.text.length > b4.start ? b4.text.length : 0) - overlap);\n  var text4 = applied.slice(start2, sliceEnd);\n  var end2 = Math.max(a7.end, b4.end - a7.text.length + (a7.end - a7.start));\n  return normalizeStringDiff(targetText, {\n    start: start2,\n    end: end2,\n    text: text4\n  });\n}\nfunction targetRange(textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n  return {\n    anchor: {\n      path,\n      offset: diff.start\n    },\n    focus: {\n      path,\n      offset: diff.end\n    }\n  };\n}\nfunction normalizePoint(editor, point) {\n  var {\n    path,\n    offset: offset3\n  } = point;\n  if (!Editor.hasPath(editor, path)) {\n    return null;\n  }\n  var leaf = Node2.get(editor, path);\n  if (!Text.isText(leaf)) {\n    return null;\n  }\n  var parentBlock = Editor.above(editor, {\n    match: (n8) => Editor.isBlock(editor, n8),\n    at: path\n  });\n  if (!parentBlock) {\n    return null;\n  }\n  while (offset3 > leaf.text.length) {\n    var entry = Editor.next(editor, {\n      at: path,\n      match: Text.isText\n    });\n    if (!entry || !Path.isDescendant(entry[1], parentBlock[1])) {\n      return null;\n    }\n    offset3 -= leaf.text.length;\n    leaf = entry[0];\n    path = entry[1];\n  }\n  return {\n    path,\n    offset: offset3\n  };\n}\nfunction normalizeRange(editor, range) {\n  var anchor = normalizePoint(editor, range.anchor);\n  if (!anchor) {\n    return null;\n  }\n  if (Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n  var focus = normalizePoint(editor, range.focus);\n  if (!focus) {\n    return null;\n  }\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformPendingPoint(editor, point, op) {\n  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((_ref) => {\n    var {\n      path\n    } = _ref;\n    return Path.equals(path, point.path);\n  });\n  if (!textDiff || point.offset <= textDiff.diff.start) {\n    return Point.transform(point, op, {\n      affinity: \"backward\"\n    });\n  }\n  var {\n    diff\n  } = textDiff;\n  if (point.offset <= diff.start + diff.text.length) {\n    var _anchor = {\n      path: point.path,\n      offset: diff.start\n    };\n    var _transformed = Point.transform(_anchor, op, {\n      affinity: \"backward\"\n    });\n    if (!_transformed) {\n      return null;\n    }\n    return {\n      path: _transformed.path,\n      offset: _transformed.offset + point.offset - diff.start\n    };\n  }\n  var anchor = {\n    path: point.path,\n    offset: point.offset - diff.text.length + diff.end - diff.start\n  };\n  var transformed = Point.transform(anchor, op, {\n    affinity: \"backward\"\n  });\n  if (!transformed) {\n    return null;\n  }\n  if (op.type === \"split_node\" && Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {\n    return transformed;\n  }\n  return {\n    path: transformed.path,\n    offset: transformed.offset + diff.text.length - diff.end + diff.start\n  };\n}\nfunction transformPendingRange(editor, range, op) {\n  var anchor = transformPendingPoint(editor, range.anchor, op);\n  if (!anchor) {\n    return null;\n  }\n  if (Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n  var focus = transformPendingPoint(editor, range.focus, op);\n  if (!focus) {\n    return null;\n  }\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformTextDiff(textDiff, op) {\n  var {\n    path,\n    diff,\n    id\n  } = textDiff;\n  switch (op.type) {\n    case \"insert_text\": {\n      if (!Path.equals(op.path, path) || op.offset >= diff.end) {\n        return textDiff;\n      }\n      if (op.offset <= diff.start) {\n        return {\n          diff: {\n            start: op.text.length + diff.start,\n            end: op.text.length + diff.end,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n      return {\n        diff: {\n          start: diff.start,\n          end: diff.end + op.text.length,\n          text: diff.text\n        },\n        id,\n        path\n      };\n    }\n    case \"remove_text\": {\n      if (!Path.equals(op.path, path) || op.offset >= diff.end) {\n        return textDiff;\n      }\n      if (op.offset + op.text.length <= diff.start) {\n        return {\n          diff: {\n            start: diff.start - op.text.length,\n            end: diff.end - op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n      return {\n        diff: {\n          start: diff.start,\n          end: diff.end - op.text.length,\n          text: diff.text\n        },\n        id,\n        path\n      };\n    }\n    case \"split_node\": {\n      if (!Path.equals(op.path, path) || op.position >= diff.end) {\n        return {\n          diff,\n          id,\n          path: Path.transform(path, op, {\n            affinity: \"backward\"\n          })\n        };\n      }\n      if (op.position > diff.start) {\n        return {\n          diff: {\n            start: diff.start,\n            end: Math.min(op.position, diff.end),\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n      return {\n        diff: {\n          start: diff.start - op.position,\n          end: diff.end - op.position,\n          text: diff.text\n        },\n        id,\n        path: Path.transform(path, op, {\n          affinity: \"forward\"\n        })\n      };\n    }\n    case \"merge_node\": {\n      if (!Path.equals(op.path, path)) {\n        return {\n          diff,\n          id,\n          path: Path.transform(path, op)\n        };\n      }\n      return {\n        diff: {\n          start: diff.start + op.position,\n          end: diff.end + op.position,\n          text: diff.text\n        },\n        id,\n        path: Path.transform(path, op)\n      };\n    }\n  }\n  var newPath = Path.transform(path, op);\n  if (!newPath) {\n    return null;\n  }\n  return {\n    diff,\n    path: newPath,\n    id\n  };\n}\nfunction ownKeys$32(object, enumerableOnly) {\n  var keys4 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys4.push.apply(keys4, symbols);\n  }\n  return keys4;\n}\nfunction _objectSpread$32(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    if (i5 % 2) {\n      ownKeys$32(Object(source), true).forEach(function(key) {\n        _defineProperty2(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$32(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar RESOLVE_DELAY = 25;\nvar FLUSH_DELAY = 200;\nvar debug = function debug2() {\n};\nfunction forceSwiftKeyUpdate(editor) {\n  var _div$parentElement;\n  var {\n    document: document2\n  } = ReactEditor.getWindow(editor);\n  var div3 = document2.createElement(\"div\");\n  div3.setAttribute(\"contenteditable\", \"true\");\n  div3.setAttribute(\"display\", \"none\");\n  div3.setAttribute(\"position\", \"absolute\");\n  div3.setAttribute(\"top\", \"0\");\n  div3.setAttribute(\"left\", \"0\");\n  div3.textContent = \" \";\n  document2.body.appendChild(div3);\n  var range = document2.createRange();\n  range.selectNodeContents(div3);\n  var selection = window.getSelection();\n  selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();\n  selection === null || selection === void 0 ? void 0 : selection.addRange(range);\n  (_div$parentElement = div3.parentElement) === null || _div$parentElement === void 0 ? void 0 : _div$parentElement.removeChild(div3);\n  ReactEditor.focus(editor);\n}\nfunction createAndroidInputManager(_ref) {\n  var {\n    editor,\n    scheduleOnDOMSelectionChange,\n    onDOMSelectionChange\n  } = _ref;\n  var flushing = false;\n  var compositionEndTimeoutId = null;\n  var flushTimeoutId = null;\n  var actionTimeoutId = null;\n  var idCounter3 = 0;\n  var isInsertAfterMarkPlaceholder = false;\n  var applyPendingSelection = () => {\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(editor);\n    EDITOR_TO_PENDING_SELECTION.delete(editor);\n    if (pendingSelection) {\n      var {\n        selection\n      } = editor;\n      var normalized = normalizeRange(editor, pendingSelection);\n      if (normalized && (!selection || !Range.equals(normalized, selection))) {\n        Transforms.select(editor, normalized);\n      }\n    }\n  };\n  var performAction = () => {\n    var action = EDITOR_TO_PENDING_ACTION.get(editor);\n    EDITOR_TO_PENDING_ACTION.delete(editor);\n    if (!action) {\n      return;\n    }\n    var target = Point.isPoint(action.at) ? normalizePoint(editor, action.at) : normalizeRange(editor, action.at);\n    if (!target) {\n      return;\n    }\n    var targetRange2 = Editor.range(editor, target);\n    if (!editor.selection || !Range.equals(editor.selection, targetRange2)) {\n      Transforms.select(editor, target);\n    }\n    action.run();\n  };\n  var flush = () => {\n    var _EDITOR_TO_PENDING_DI;\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n    if (actionTimeoutId) {\n      clearTimeout(actionTimeoutId);\n      actionTimeoutId = null;\n    }\n    if (!hasPendingDiffs() && !hasPendingAction()) {\n      applyPendingSelection();\n      return;\n    }\n    if (!flushing) {\n      flushing = true;\n      setTimeout(() => flushing = false);\n    }\n    if (hasPendingAction()) {\n      flushing = \"action\";\n    }\n    var selectionRef = editor.selection && Editor.rangeRef(editor, editor.selection, {\n      affinity: \"forward\"\n    });\n    EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n    debug(\"flush\", EDITOR_TO_PENDING_ACTION.get(editor), EDITOR_TO_PENDING_DIFFS.get(editor));\n    var scheduleSelectionChange = !!((_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length);\n    var diff;\n    while (diff = (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2[0]) {\n      var _EDITOR_TO_PENDING_DI2, _EDITOR_TO_PENDING_DI3;\n      var pendingMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n      if (pendingMarks !== void 0) {\n        EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n        editor.marks = pendingMarks;\n      }\n      if (pendingMarks) {\n        isInsertAfterMarkPlaceholder = true;\n      }\n      var range = targetRange(diff);\n      if (!editor.selection || !Range.equals(editor.selection, range)) {\n        Transforms.select(editor, range);\n      }\n      if (diff.diff.text) {\n        Editor.insertText(editor, diff.diff.text);\n      } else {\n        Editor.deleteFragment(editor);\n      }\n      EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI3 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI3 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI3.filter((_ref2) => {\n        var {\n          id\n        } = _ref2;\n        return id !== diff.id;\n      }));\n      if (!verifyDiffState(editor, diff)) {\n        scheduleSelectionChange = false;\n        EDITOR_TO_PENDING_ACTION.delete(editor);\n        EDITOR_TO_USER_MARKS.delete(editor);\n        flushing = \"action\";\n        EDITOR_TO_PENDING_SELECTION.delete(editor);\n        scheduleOnDOMSelectionChange.cancel();\n        onDOMSelectionChange.cancel();\n        selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n      }\n    }\n    var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n    if (selection && (!editor.selection || !Range.equals(selection, editor.selection))) {\n      Transforms.select(editor, selection);\n    }\n    if (hasPendingAction()) {\n      performAction();\n      return;\n    }\n    if (scheduleSelectionChange) {\n      scheduleOnDOMSelectionChange();\n    }\n    scheduleOnDOMSelectionChange.flush();\n    onDOMSelectionChange.flush();\n    applyPendingSelection();\n    var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n    EDITOR_TO_USER_MARKS.delete(editor);\n    if (userMarks !== void 0) {\n      editor.marks = userMarks;\n    }\n  };\n  var handleCompositionEnd = (_event) => {\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n    }\n    compositionEndTimeoutId = setTimeout(() => {\n      IS_COMPOSING.set(editor, false);\n      flush();\n    }, RESOLVE_DELAY);\n  };\n  var handleCompositionStart = (_event) => {\n    IS_COMPOSING.set(editor, true);\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n      compositionEndTimeoutId = null;\n    }\n  };\n  var updatePlaceholderVisibility = () => {\n    var placeholderElement = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);\n    if (!placeholderElement) {\n      return;\n    }\n    if (hasPendingDiffs()) {\n      placeholderElement.style.visibility = \"hidden\";\n      return;\n    }\n    placeholderElement.style.removeProperty(\"visibility\");\n  };\n  var storeDiff = (path, diff) => {\n    var _EDITOR_TO_PENDING_DI4;\n    var pendingDiffs = (_EDITOR_TO_PENDING_DI4 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 ? _EDITOR_TO_PENDING_DI4 : [];\n    EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);\n    var target = Node2.leaf(editor, path);\n    var idx = pendingDiffs.findIndex((change) => Path.equals(change.path, path));\n    if (idx < 0) {\n      var normalized = normalizeStringDiff(target.text, diff);\n      if (normalized) {\n        pendingDiffs.push({\n          path,\n          diff,\n          id: idCounter3++\n        });\n      }\n      updatePlaceholderVisibility();\n      return;\n    }\n    var merged = mergeStringDiffs(target.text, pendingDiffs[idx].diff, diff);\n    if (!merged) {\n      pendingDiffs.splice(idx, 1);\n      updatePlaceholderVisibility();\n      return;\n    }\n    pendingDiffs[idx] = _objectSpread$32(_objectSpread$32({}, pendingDiffs[idx]), {}, {\n      diff: merged\n    });\n  };\n  var scheduleAction = (at, run) => {\n    EDITOR_TO_PENDING_SELECTION.delete(editor);\n    scheduleOnDOMSelectionChange.cancel();\n    onDOMSelectionChange.cancel();\n    if (hasPendingAction()) {\n      flush();\n    }\n    EDITOR_TO_PENDING_ACTION.set(editor, {\n      at,\n      run\n    });\n    actionTimeoutId = setTimeout(flush);\n  };\n  var handleDOMBeforeInput = (event) => {\n    var _targetRange;\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n    var {\n      inputType: type\n    } = event;\n    var targetRange2 = null;\n    var data = event.dataTransfer || event.data || void 0;\n    var [nativeTargetRange] = event.getTargetRanges();\n    if (nativeTargetRange) {\n      targetRange2 = ReactEditor.toSlateRange(editor, nativeTargetRange, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    }\n    var window2 = ReactEditor.getWindow(editor);\n    var domSelection = window2.getSelection();\n    if (!targetRange2 && domSelection) {\n      nativeTargetRange = domSelection;\n      targetRange2 = ReactEditor.toSlateRange(editor, domSelection, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    }\n    targetRange2 = (_targetRange = targetRange2) !== null && _targetRange !== void 0 ? _targetRange : editor.selection;\n    if (!targetRange2) {\n      return;\n    }\n    if (Range.isExpanded(targetRange2) && type.startsWith(\"delete\")) {\n      var [start2, end2] = Range.edges(targetRange2);\n      var leaf = Node2.leaf(editor, start2.path);\n      if (leaf.text.length === start2.offset && end2.offset === 0) {\n        var next = Editor.next(editor, {\n          at: start2.path,\n          match: Text.isText\n        });\n        if (next && Path.equals(next[1], end2.path)) {\n          targetRange2 = {\n            anchor: end2,\n            focus: end2\n          };\n        }\n      }\n    }\n    if (Range.isExpanded(targetRange2) && type.startsWith(\"delete\")) {\n      if (Path.equals(targetRange2.anchor.path, targetRange2.focus.path)) {\n        var [_start, _end] = Range.edges(targetRange2);\n        return storeDiff(targetRange2.anchor.path, {\n          text: \"\",\n          end: _end.offset,\n          start: _start.offset\n        });\n      }\n      var direction = type.endsWith(\"Backward\") ? \"backward\" : \"forward\";\n      return scheduleAction(targetRange2, () => Editor.deleteFragment(editor, {\n        direction\n      }));\n    }\n    switch (type) {\n      case \"deleteByComposition\":\n      case \"deleteByCut\":\n      case \"deleteByDrag\": {\n        return scheduleAction(targetRange2, () => Editor.deleteFragment(editor));\n      }\n      case \"deleteContent\":\n      case \"deleteContentForward\": {\n        var {\n          anchor\n        } = targetRange2;\n        if (Range.isCollapsed(targetRange2)) {\n          var targetNode = Node2.leaf(editor, anchor.path);\n          if (anchor.offset < targetNode.text.length) {\n            return storeDiff(anchor.path, {\n              text: \"\",\n              start: anchor.offset,\n              end: anchor.offset + 1\n            });\n          }\n        }\n        return scheduleAction(targetRange2, () => Editor.deleteForward(editor));\n      }\n      case \"deleteContentBackward\": {\n        var _nativeTargetRange;\n        var {\n          anchor: _anchor\n        } = targetRange2;\n        var nativeCollapsed = isDOMSelection(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);\n        if (nativeCollapsed && Range.isCollapsed(targetRange2) && _anchor.offset > 0) {\n          return storeDiff(_anchor.path, {\n            text: \"\",\n            start: _anchor.offset - 1,\n            end: _anchor.offset\n          });\n        }\n        return scheduleAction(targetRange2, () => Editor.deleteBackward(editor));\n      }\n      case \"deleteEntireSoftLine\": {\n        return scheduleAction(targetRange2, () => {\n          Editor.deleteBackward(editor, {\n            unit: \"line\"\n          });\n          Editor.deleteForward(editor, {\n            unit: \"line\"\n          });\n        });\n      }\n      case \"deleteHardLineBackward\": {\n        return scheduleAction(targetRange2, () => Editor.deleteBackward(editor, {\n          unit: \"block\"\n        }));\n      }\n      case \"deleteSoftLineBackward\": {\n        return scheduleAction(targetRange2, () => Editor.deleteBackward(editor, {\n          unit: \"line\"\n        }));\n      }\n      case \"deleteHardLineForward\": {\n        return scheduleAction(targetRange2, () => Editor.deleteForward(editor, {\n          unit: \"block\"\n        }));\n      }\n      case \"deleteSoftLineForward\": {\n        return scheduleAction(targetRange2, () => Editor.deleteForward(editor, {\n          unit: \"line\"\n        }));\n      }\n      case \"deleteWordBackward\": {\n        return scheduleAction(targetRange2, () => Editor.deleteBackward(editor, {\n          unit: \"word\"\n        }));\n      }\n      case \"deleteWordForward\": {\n        return scheduleAction(targetRange2, () => Editor.deleteForward(editor, {\n          unit: \"word\"\n        }));\n      }\n      case \"insertLineBreak\": {\n        return scheduleAction(targetRange2, () => Editor.insertSoftBreak(editor));\n      }\n      case \"insertParagraph\": {\n        return scheduleAction(targetRange2, () => Editor.insertBreak(editor));\n      }\n      case \"insertCompositionText\":\n      case \"deleteCompositionText\":\n      case \"insertFromComposition\":\n      case \"insertFromDrop\":\n      case \"insertFromPaste\":\n      case \"insertFromYank\":\n      case \"insertReplacementText\":\n      case \"insertText\": {\n        if ((data === null || data === void 0 ? void 0 : data.constructor.name) === \"DataTransfer\") {\n          return scheduleAction(targetRange2, () => ReactEditor.insertData(editor, data));\n        }\n        if (typeof data === \"string\" && data.includes(\"\\n\")) {\n          return scheduleAction(Range.end(targetRange2), () => Editor.insertSoftBreak(editor));\n        }\n        var text4 = data !== null && data !== void 0 ? data : \"\";\n        if (EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {\n          text4 = text4.replace(\"\\uFEFF\", \"\");\n        }\n        if (Path.equals(targetRange2.anchor.path, targetRange2.focus.path)) {\n          if (text4.endsWith(\" \") && isInsertAfterMarkPlaceholder) {\n            isInsertAfterMarkPlaceholder = false;\n            forceSwiftKeyUpdate(editor);\n            return scheduleAction(targetRange2, () => Editor.insertText(editor, text4));\n          }\n          var [_start2, _end2] = Range.edges(targetRange2);\n          return storeDiff(_start2.path, {\n            start: _start2.offset,\n            end: _end2.offset,\n            text: text4\n          });\n        }\n        return scheduleAction(targetRange2, () => Editor.insertText(editor, text4));\n      }\n    }\n  };\n  var hasPendingAction = () => {\n    return !!EDITOR_TO_PENDING_ACTION.get(editor) || !!actionTimeoutId;\n  };\n  var hasPendingDiffs = () => {\n    var _EDITOR_TO_PENDING_DI5;\n    return !!((_EDITOR_TO_PENDING_DI5 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI5 !== void 0 && _EDITOR_TO_PENDING_DI5.length);\n  };\n  var isFlushing = () => {\n    return flushing;\n  };\n  var handleUserSelect = (range) => {\n    EDITOR_TO_PENDING_SELECTION.set(editor, range);\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n    var pathChanged = range && (!editor.selection || !Path.equals(editor.selection.anchor.path, range === null || range === void 0 ? void 0 : range.anchor.path));\n    if (pathChanged) {\n      isInsertAfterMarkPlaceholder = false;\n    }\n    if (pathChanged || !hasPendingDiffs()) {\n      flushTimeoutId = setTimeout(flush, FLUSH_DELAY);\n    }\n  };\n  var handleInput = () => {\n    if (hasPendingAction() || !hasPendingDiffs()) {\n      flush();\n    }\n  };\n  var scheduleFlush = () => {\n    if (!hasPendingAction()) {\n      actionTimeoutId = setTimeout(flush);\n    }\n  };\n  var handleDomMutations = (mutations) => {\n    if (hasPendingDiffs() || hasPendingAction()) {\n      return;\n    }\n    if (mutations.some((mutation) => isTrackedMutation(editor, mutation, mutations))) {\n      var _EDITOR_TO_FORCE_REND;\n      (_EDITOR_TO_FORCE_REND = EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 ? void 0 : _EDITOR_TO_FORCE_REND();\n    }\n  };\n  return {\n    flush,\n    scheduleFlush,\n    hasPendingDiffs,\n    hasPendingAction,\n    isFlushing,\n    handleUserSelect,\n    handleCompositionEnd,\n    handleCompositionStart,\n    handleDOMBeforeInput,\n    handleDomMutations,\n    handleInput\n  };\n}\nfunction useIsMounted() {\n  var isMountedRef = (0, import_react2.useRef)(false);\n  (0, import_react2.useEffect)(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  return isMountedRef.current;\n}\nfunction useMutationObserver(node, callback, options) {\n  var [mutationObserver] = (0, import_react2.useState)(() => new MutationObserver(callback));\n  useIsomorphicLayoutEffect(() => {\n    mutationObserver.takeRecords();\n  });\n  (0, import_react2.useEffect)(() => {\n    if (!node.current) {\n      throw new Error(\"Failed to attach MutationObserver, `node` is undefined\");\n    }\n    mutationObserver.observe(node.current, options);\n    return () => mutationObserver.disconnect();\n  }, []);\n}\nvar _excluded$22 = [\"node\"];\nfunction ownKeys$22(object, enumerableOnly) {\n  var keys4 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys4.push.apply(keys4, symbols);\n  }\n  return keys4;\n}\nfunction _objectSpread$22(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    if (i5 % 2) {\n      ownKeys$22(Object(source), true).forEach(function(key) {\n        _defineProperty2(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$22(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar MUTATION_OBSERVER_CONFIG = {\n  subtree: true,\n  childList: true,\n  characterData: true\n};\nfunction useAndroidInputManager(_ref) {\n  var {\n    node\n  } = _ref, options = _objectWithoutProperties2(_ref, _excluded$22);\n  if (!IS_ANDROID) {\n    return null;\n  }\n  var editor = useSlateStatic();\n  var isMounted = useIsMounted();\n  var [inputManager] = (0, import_react2.useState)(() => createAndroidInputManager(_objectSpread$22({\n    editor\n  }, options)));\n  useMutationObserver(node, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG);\n  EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);\n  if (isMounted) {\n    inputManager.flush();\n  }\n  return inputManager;\n}\nfunction useTrackUserInput() {\n  var editor = useSlateStatic();\n  var receivedUserInput = (0, import_react2.useRef)(false);\n  var animationFrameIdRef = (0, import_react2.useRef)(0);\n  var onUserInput = (0, import_react2.useCallback)(() => {\n    if (receivedUserInput.current) {\n      return;\n    }\n    receivedUserInput.current = true;\n    var window2 = ReactEditor.getWindow(editor);\n    window2.cancelAnimationFrame(animationFrameIdRef.current);\n    animationFrameIdRef.current = window2.requestAnimationFrame(() => {\n      receivedUserInput.current = false;\n    });\n  }, []);\n  (0, import_react2.useEffect)(() => () => cancelAnimationFrame(animationFrameIdRef.current), []);\n  return {\n    receivedUserInput,\n    onUserInput\n  };\n}\nvar _excluded$12 = [\"autoFocus\", \"decorate\", \"onDOMBeforeInput\", \"placeholder\", \"readOnly\", \"renderElement\", \"renderLeaf\", \"renderPlaceholder\", \"scrollSelectionIntoView\", \"style\", \"as\"];\nvar _excluded22 = [\"text\"];\nfunction ownKeys$12(object, enumerableOnly) {\n  var keys4 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys4.push.apply(keys4, symbols);\n  }\n  return keys4;\n}\nfunction _objectSpread$12(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    if (i5 % 2) {\n      ownKeys$12(Object(source), true).forEach(function(key) {\n        _defineProperty2(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$12(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar Children = (props) => /* @__PURE__ */ import_react2.default.createElement(import_react2.default.Fragment, null, useChildren(props));\nvar Editable = (props) => {\n  var {\n    autoFocus,\n    decorate = defaultDecorate,\n    onDOMBeforeInput: propsOnDOMBeforeInput,\n    placeholder,\n    readOnly = false,\n    renderElement,\n    renderLeaf,\n    renderPlaceholder = (props2) => /* @__PURE__ */ import_react2.default.createElement(DefaultPlaceholder, Object.assign({}, props2)),\n    scrollSelectionIntoView = defaultScrollSelectionIntoView,\n    style = {},\n    as: Component3 = \"div\"\n  } = props, attributes = _objectWithoutProperties2(props, _excluded$12);\n  var editor = useSlate();\n  var [isComposing2, setIsComposing] = (0, import_react2.useState)(false);\n  var ref = (0, import_react2.useRef)(null);\n  var deferredOperations = (0, import_react2.useRef)([]);\n  var {\n    onUserInput,\n    receivedUserInput\n  } = useTrackUserInput();\n  var [, forceRender] = (0, import_react2.useReducer)((s5) => s5 + 1, 0);\n  EDITOR_TO_FORCE_RENDER.set(editor, forceRender);\n  IS_READ_ONLY.set(editor, readOnly);\n  var state = (0, import_react2.useMemo)(() => ({\n    isDraggingInternally: false,\n    isUpdatingSelection: false,\n    latestElement: null,\n    hasMarkPlaceholder: false\n  }), []);\n  (0, import_react2.useEffect)(() => {\n    if (ref.current && autoFocus) {\n      ref.current.focus();\n    }\n  }, [autoFocus]);\n  var onDOMSelectionChange = (0, import_react2.useCallback)((0, import_throttle.default)(() => {\n    if ((IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {\n      var root5 = ReactEditor.findDocumentOrShadowRoot(editor);\n      var {\n        activeElement\n      } = root5;\n      var el = ReactEditor.toDOMNode(editor, editor);\n      var domSelection = root5.getSelection();\n      if (activeElement === el) {\n        state.latestElement = activeElement;\n        IS_FOCUSED.set(editor, true);\n      } else {\n        IS_FOCUSED.delete(editor);\n      }\n      if (!domSelection) {\n        return Transforms.deselect(editor);\n      }\n      var {\n        anchorNode,\n        focusNode\n      } = domSelection;\n      var anchorNodeSelectable = hasEditableTarget(editor, anchorNode) || isTargetInsideNonReadonlyVoid(editor, anchorNode);\n      var focusNodeSelectable = hasEditableTarget(editor, focusNode) || isTargetInsideNonReadonlyVoid(editor, focusNode);\n      if (anchorNodeSelectable && focusNodeSelectable) {\n        var range = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true\n        });\n        if (range) {\n          if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingDiffs()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {\n            Transforms.select(editor, range);\n          } else {\n            androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleUserSelect(range);\n          }\n        }\n      }\n    }\n  }, 100), [readOnly]);\n  var scheduleOnDOMSelectionChange = (0, import_react2.useMemo)(() => (0, import_debounce.default)(onDOMSelectionChange, 0), [onDOMSelectionChange]);\n  var androidInputManager = useAndroidInputManager({\n    node: ref,\n    onDOMSelectionChange,\n    scheduleOnDOMSelectionChange\n  });\n  useIsomorphicLayoutEffect(() => {\n    var window2;\n    if (ref.current && (window2 = getDefaultView(ref.current))) {\n      EDITOR_TO_WINDOW.set(editor, window2);\n      EDITOR_TO_ELEMENT.set(editor, ref.current);\n      NODE_TO_ELEMENT.set(editor, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, editor);\n    } else {\n      NODE_TO_ELEMENT.delete(editor);\n    }\n    var {\n      selection\n    } = editor;\n    var root5 = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = root5.getSelection();\n    if (!domSelection || !ReactEditor.isFocused(editor) || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingAction()) {\n      return;\n    }\n    var setDomSelection = (forceChange) => {\n      var hasDomSelection = domSelection.type !== \"None\";\n      if (!selection && !hasDomSelection) {\n        return;\n      }\n      var editorElement = EDITOR_TO_ELEMENT.get(editor);\n      var hasDomSelectionInEditor = false;\n      if (editorElement.contains(domSelection.anchorNode) && editorElement.contains(domSelection.focusNode)) {\n        hasDomSelectionInEditor = true;\n      }\n      if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {\n        var slateRange = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: true,\n          // domSelection is not necessarily a valid Slate range\n          // (e.g. when clicking on contentEditable:false element)\n          suppressThrow: true\n        });\n        if (slateRange && Range.equals(slateRange, selection)) {\n          var _anchorNode$parentEle;\n          if (!state.hasMarkPlaceholder) {\n            return;\n          }\n          var {\n            anchorNode\n          } = domSelection;\n          if (anchorNode !== null && anchorNode !== void 0 && (_anchorNode$parentEle = anchorNode.parentElement) !== null && _anchorNode$parentEle !== void 0 && _anchorNode$parentEle.hasAttribute(\"data-slate-mark-placeholder\")) {\n            return;\n          }\n        }\n      }\n      if (selection && !ReactEditor.hasRange(editor, selection)) {\n        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true\n        });\n        return;\n      }\n      state.isUpdatingSelection = true;\n      var newDomRange2 = selection && ReactEditor.toDOMRange(editor, selection);\n      if (newDomRange2) {\n        if (Range.isBackward(selection)) {\n          domSelection.setBaseAndExtent(newDomRange2.endContainer, newDomRange2.endOffset, newDomRange2.startContainer, newDomRange2.startOffset);\n        } else {\n          domSelection.setBaseAndExtent(newDomRange2.startContainer, newDomRange2.startOffset, newDomRange2.endContainer, newDomRange2.endOffset);\n        }\n        scrollSelectionIntoView(editor, newDomRange2);\n      } else {\n        domSelection.removeAllRanges();\n      }\n      return newDomRange2;\n    };\n    var newDomRange = setDomSelection();\n    var ensureSelection = (androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.isFlushing()) === \"action\";\n    if (!IS_ANDROID || !ensureSelection) {\n      setTimeout(() => {\n        if (newDomRange && IS_FIREFOX) {\n          var el = ReactEditor.toDOMNode(editor, editor);\n          el.focus();\n        }\n        state.isUpdatingSelection = false;\n      });\n      return;\n    }\n    var timeoutId = null;\n    var animationFrameId = requestAnimationFrame(() => {\n      if (ensureSelection) {\n        var ensureDomSelection = (forceChange) => {\n          try {\n            var el = ReactEditor.toDOMNode(editor, editor);\n            el.focus();\n            setDomSelection(forceChange);\n          } catch (e4) {\n          }\n        };\n        ensureDomSelection();\n        timeoutId = setTimeout(() => {\n          ensureDomSelection(true);\n          state.isUpdatingSelection = false;\n        });\n      }\n    });\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n  });\n  var onDOMBeforeInput = (0, import_react2.useCallback)((event) => {\n    onUserInput();\n    if (!readOnly && hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {\n      var _EDITOR_TO_USER_SELEC;\n      if (androidInputManager) {\n        return androidInputManager.handleDOMBeforeInput(event);\n      }\n      scheduleOnDOMSelectionChange.flush();\n      onDOMSelectionChange.flush();\n      var {\n        selection\n      } = editor;\n      var {\n        inputType: type\n      } = event;\n      var data = event.dataTransfer || event.data || void 0;\n      var isCompositionChange = type === \"insertCompositionText\" || type === \"deleteCompositionText\";\n      if (isCompositionChange && ReactEditor.isComposing(editor)) {\n        return;\n      }\n      var native = false;\n      if (type === \"insertText\" && selection && Range.isCollapsed(selection) && // Only use native character insertion for single characters a-z or space for now.\n      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise\n      // causes duplicate inserts.\n      event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405\n      // When there is an inline element, e.g. a link, and you select\n      // right after it (the start of the next node).\n      selection.anchor.offset !== 0) {\n        var _node$parentElement, _window$getComputedSt;\n        native = true;\n        if (editor.marks) {\n          native = false;\n        }\n        var {\n          anchor: anchor2\n        } = selection;\n        var [node, offset3] = ReactEditor.toDOMPoint(editor, anchor2);\n        var anchorNode = (_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest(\"a\");\n        var window2 = ReactEditor.getWindow(editor);\n        if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {\n          var _lastText$textContent;\n          var lastText = window2 === null || window2 === void 0 ? void 0 : window2.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();\n          if (lastText === node && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset3) {\n            native = false;\n          }\n        }\n        if (native && node.parentElement && (window2 === null || window2 === void 0 ? void 0 : (_window$getComputedSt = window2.getComputedStyle(node.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === \"pre\") {\n          var block = Editor.above(editor, {\n            at: anchor2.path,\n            match: (n8) => Editor.isBlock(editor, n8)\n          });\n          if (block && Node2.string(block[0]).includes(\"\t\")) {\n            native = false;\n          }\n        }\n      }\n      if (!type.startsWith(\"delete\") || type.startsWith(\"deleteBy\")) {\n        var [targetRange2] = event.getTargetRanges();\n        if (targetRange2) {\n          var range = ReactEditor.toSlateRange(editor, targetRange2, {\n            exactMatch: false,\n            suppressThrow: false\n          });\n          if (!selection || !Range.equals(selection, range)) {\n            native = false;\n            var selectionRef = !isCompositionChange && editor.selection && Editor.rangeRef(editor, editor.selection);\n            Transforms.select(editor, range);\n            if (selectionRef) {\n              EDITOR_TO_USER_SELECTION.set(editor, selectionRef);\n            }\n          }\n        }\n      }\n      if (isCompositionChange) {\n        return;\n      }\n      if (!native) {\n        event.preventDefault();\n      }\n      if (selection && Range.isExpanded(selection) && type.startsWith(\"delete\")) {\n        var direction = type.endsWith(\"Backward\") ? \"backward\" : \"forward\";\n        Editor.deleteFragment(editor, {\n          direction\n        });\n        return;\n      }\n      switch (type) {\n        case \"deleteByComposition\":\n        case \"deleteByCut\":\n        case \"deleteByDrag\": {\n          Editor.deleteFragment(editor);\n          break;\n        }\n        case \"deleteContent\":\n        case \"deleteContentForward\": {\n          Editor.deleteForward(editor);\n          break;\n        }\n        case \"deleteContentBackward\": {\n          Editor.deleteBackward(editor);\n          break;\n        }\n        case \"deleteEntireSoftLine\": {\n          Editor.deleteBackward(editor, {\n            unit: \"line\"\n          });\n          Editor.deleteForward(editor, {\n            unit: \"line\"\n          });\n          break;\n        }\n        case \"deleteHardLineBackward\": {\n          Editor.deleteBackward(editor, {\n            unit: \"block\"\n          });\n          break;\n        }\n        case \"deleteSoftLineBackward\": {\n          Editor.deleteBackward(editor, {\n            unit: \"line\"\n          });\n          break;\n        }\n        case \"deleteHardLineForward\": {\n          Editor.deleteForward(editor, {\n            unit: \"block\"\n          });\n          break;\n        }\n        case \"deleteSoftLineForward\": {\n          Editor.deleteForward(editor, {\n            unit: \"line\"\n          });\n          break;\n        }\n        case \"deleteWordBackward\": {\n          Editor.deleteBackward(editor, {\n            unit: \"word\"\n          });\n          break;\n        }\n        case \"deleteWordForward\": {\n          Editor.deleteForward(editor, {\n            unit: \"word\"\n          });\n          break;\n        }\n        case \"insertLineBreak\":\n          Editor.insertSoftBreak(editor);\n          break;\n        case \"insertParagraph\": {\n          Editor.insertBreak(editor);\n          break;\n        }\n        case \"insertFromComposition\":\n        case \"insertFromDrop\":\n        case \"insertFromPaste\":\n        case \"insertFromYank\":\n        case \"insertReplacementText\":\n        case \"insertText\": {\n          var {\n            selection: _selection\n          } = editor;\n          if (_selection) {\n            if (Range.isExpanded(_selection)) {\n              Editor.deleteFragment(editor);\n            }\n          }\n          if (type === \"insertFromComposition\") {\n            if (ReactEditor.isComposing(editor)) {\n              setIsComposing(false);\n              IS_COMPOSING.set(editor, false);\n            }\n          }\n          if ((data === null || data === void 0 ? void 0 : data.constructor.name) === \"DataTransfer\") {\n            ReactEditor.insertData(editor, data);\n          } else if (typeof data === \"string\") {\n            if (native) {\n              deferredOperations.current.push(() => Editor.insertText(editor, data));\n            } else {\n              Editor.insertText(editor, data);\n            }\n          }\n          break;\n        }\n      }\n      var toRestore = (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n      EDITOR_TO_USER_SELECTION.delete(editor);\n      if (toRestore && (!editor.selection || !Range.equals(editor.selection, toRestore))) {\n        Transforms.select(editor, toRestore);\n      }\n    }\n  }, [readOnly, propsOnDOMBeforeInput]);\n  useIsomorphicLayoutEffect(() => {\n    if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n      ref.current.addEventListener(\"beforeinput\", onDOMBeforeInput);\n    }\n    return () => {\n      if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n        ref.current.removeEventListener(\"beforeinput\", onDOMBeforeInput);\n      }\n    };\n  }, [onDOMBeforeInput]);\n  useIsomorphicLayoutEffect(() => {\n    var window2 = ReactEditor.getWindow(editor);\n    window2.document.addEventListener(\"selectionchange\", scheduleOnDOMSelectionChange);\n    return () => {\n      window2.document.removeEventListener(\"selectionchange\", scheduleOnDOMSelectionChange);\n    };\n  }, [scheduleOnDOMSelectionChange]);\n  var decorations = decorate([editor, []]);\n  if (placeholder && editor.children.length === 1 && Array.from(Node2.texts(editor)).length === 1 && Node2.string(editor) === \"\" && !isComposing2) {\n    var start2 = Editor.start(editor, []);\n    decorations.push({\n      [PLACEHOLDER_SYMBOL]: true,\n      placeholder,\n      anchor: start2,\n      focus: start2\n    });\n  }\n  var {\n    marks: marks3\n  } = editor;\n  state.hasMarkPlaceholder = false;\n  if (editor.selection && Range.isCollapsed(editor.selection) && marks3) {\n    var {\n      anchor\n    } = editor.selection;\n    var _Node$leaf = Node2.leaf(editor, anchor.path), rest = _objectWithoutProperties2(_Node$leaf, _excluded22);\n    if (!Text.equals(rest, marks3, {\n      loose: true\n    })) {\n      state.hasMarkPlaceholder = true;\n      var unset = Object.fromEntries(Object.keys(rest).map((mark) => [mark, null]));\n      decorations.push(_objectSpread$12(_objectSpread$12(_objectSpread$12({\n        [MARK_PLACEHOLDER_SYMBOL]: true\n      }, unset), marks3), {}, {\n        anchor,\n        focus: anchor\n      }));\n    }\n  }\n  (0, import_react2.useEffect)(() => {\n    setTimeout(() => {\n      if (marks3) {\n        EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks3);\n      } else {\n        EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n      }\n    });\n  });\n  return /* @__PURE__ */ import_react2.default.createElement(ReadOnlyContext.Provider, {\n    value: readOnly\n  }, /* @__PURE__ */ import_react2.default.createElement(DecorateContext.Provider, {\n    value: decorate\n  }, /* @__PURE__ */ import_react2.default.createElement(RestoreDOM, {\n    node: ref,\n    receivedUserInput\n  }, /* @__PURE__ */ import_react2.default.createElement(Component3, Object.assign({\n    role: readOnly ? void 0 : \"textbox\"\n  }, attributes, {\n    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd\n    // have to use hacks to make these replacement-based features work.\n    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop\n    // mismatch warning app moves to browser. Pass-through consumer props when\n    // not CAN_USE_DOM (SSR) and default to falsy value\n    spellCheck: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.spellCheck : false,\n    autoCorrect: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCorrect : \"false\",\n    autoCapitalize: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCapitalize : \"false\",\n    \"data-slate-editor\": true,\n    \"data-slate-node\": \"value\",\n    // explicitly set this\n    contentEditable: !readOnly,\n    // in some cases, a decoration needs access to the range / selection to decorate a text node,\n    // then you will select the whole text node when you select part the of text\n    // this magic zIndex=\"-1\" will fix it\n    zindex: -1,\n    suppressContentEditableWarning: true,\n    ref,\n    style: _objectSpread$12({\n      // Allow positioning relative to the editable element.\n      position: \"relative\",\n      // Prevent the default outline styles.\n      outline: \"none\",\n      // Preserve adjacent whitespace and new lines.\n      whiteSpace: \"pre-wrap\",\n      // Allow words to break if they are too long.\n      wordWrap: \"break-word\"\n    }, style),\n    onBeforeInput: (0, import_react2.useCallback)((event) => {\n      if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && hasEditableTarget(editor, event.target)) {\n        event.preventDefault();\n        if (!ReactEditor.isComposing(editor)) {\n          var _text = event.data;\n          Editor.insertText(editor, _text);\n        }\n      }\n    }, [readOnly]),\n    onInput: (0, import_react2.useCallback)((event) => {\n      if (androidInputManager) {\n        androidInputManager.handleInput();\n        return;\n      }\n      for (var op of deferredOperations.current) {\n        op();\n      }\n      deferredOperations.current = [];\n    }, []),\n    onBlur: (0, import_react2.useCallback)((event) => {\n      if (readOnly || state.isUpdatingSelection || !hasEditableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {\n        return;\n      }\n      var root5 = ReactEditor.findDocumentOrShadowRoot(editor);\n      if (state.latestElement === root5.activeElement) {\n        return;\n      }\n      var {\n        relatedTarget\n      } = event;\n      var el = ReactEditor.toDOMNode(editor, editor);\n      if (relatedTarget === el) {\n        return;\n      }\n      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute(\"data-slate-spacer\")) {\n        return;\n      }\n      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {\n        var node = ReactEditor.toSlateNode(editor, relatedTarget);\n        if (Element2.isElement(node) && !editor.isVoid(node)) {\n          return;\n        }\n      }\n      if (IS_SAFARI) {\n        var domSelection = root5.getSelection();\n        domSelection === null || domSelection === void 0 ? void 0 : domSelection.removeAllRanges();\n      }\n      IS_FOCUSED.delete(editor);\n    }, [readOnly, attributes.onBlur]),\n    onClick: (0, import_react2.useCallback)((event) => {\n      if (hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node);\n        if (!Editor.hasPath(editor, path) || Node2.get(editor, path) !== node) {\n          return;\n        }\n        if (event.detail === TRIPLE_CLICK && path.length >= 1) {\n          var blockPath = path;\n          if (!Editor.isBlock(editor, node)) {\n            var _block$;\n            var block = Editor.above(editor, {\n              match: (n8) => Editor.isBlock(editor, n8),\n              at: path\n            });\n            blockPath = (_block$ = block === null || block === void 0 ? void 0 : block[1]) !== null && _block$ !== void 0 ? _block$ : path.slice(0, 1);\n          }\n          var range = Editor.range(editor, blockPath);\n          Transforms.select(editor, range);\n          return;\n        }\n        if (readOnly) {\n          return;\n        }\n        var _start = Editor.start(editor, path);\n        var end2 = Editor.end(editor, path);\n        var startVoid = Editor.void(editor, {\n          at: _start\n        });\n        var endVoid = Editor.void(editor, {\n          at: end2\n        });\n        if (startVoid && endVoid && Path.equals(startVoid[1], endVoid[1])) {\n          var _range = Editor.range(editor, _start);\n          Transforms.select(editor, _range);\n        }\n      }\n    }, [readOnly, attributes.onClick]),\n    onCompositionEnd: (0, import_react2.useCallback)((event) => {\n      if (hasEditableTarget(editor, event.target)) {\n        if (ReactEditor.isComposing(editor)) {\n          setIsComposing(false);\n          IS_COMPOSING.set(editor, false);\n        }\n        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleCompositionEnd(event);\n        if (isEventHandled(event, attributes.onCompositionEnd) || IS_ANDROID) {\n          return;\n        }\n        if (!IS_SAFARI && !IS_FIREFOX_LEGACY && !IS_IOS && !IS_QQBROWSER && !IS_WECHATBROWSER && !IS_UC_MOBILE && event.data) {\n          var placeholderMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n          EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n          if (placeholderMarks !== void 0) {\n            EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n            editor.marks = placeholderMarks;\n          }\n          Editor.insertText(editor, event.data);\n          var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n          EDITOR_TO_USER_MARKS.delete(editor);\n          if (userMarks !== void 0) {\n            editor.marks = userMarks;\n          }\n        }\n      }\n    }, [attributes.onCompositionEnd]),\n    onCompositionUpdate: (0, import_react2.useCallback)((event) => {\n      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {\n        if (!ReactEditor.isComposing(editor)) {\n          setIsComposing(true);\n          IS_COMPOSING.set(editor, true);\n        }\n      }\n    }, [attributes.onCompositionUpdate]),\n    onCompositionStart: (0, import_react2.useCallback)((event) => {\n      if (hasEditableTarget(editor, event.target)) {\n        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleCompositionStart(event);\n        if (isEventHandled(event, attributes.onCompositionStart) || IS_ANDROID) {\n          return;\n        }\n        setIsComposing(true);\n        var {\n          selection\n        } = editor;\n        if (selection) {\n          if (Range.isExpanded(selection)) {\n            Editor.deleteFragment(editor);\n            return;\n          }\n          var inline = Editor.above(editor, {\n            match: (n8) => Editor.isInline(editor, n8),\n            mode: \"highest\"\n          });\n          if (inline) {\n            var [, inlinePath] = inline;\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              var point = Editor.after(editor, inlinePath);\n              Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point\n              });\n            }\n          }\n        }\n      }\n    }, [attributes.onCompositionStart]),\n    onCopy: (0, import_react2.useCallback)((event) => {\n      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, \"copy\");\n      }\n    }, [attributes.onCopy]),\n    onCut: (0, import_react2.useCallback)((event) => {\n      if (!readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, \"cut\");\n        var {\n          selection\n        } = editor;\n        if (selection) {\n          if (Range.isExpanded(selection)) {\n            Editor.deleteFragment(editor);\n          } else {\n            var node = Node2.parent(editor, selection.anchor.path);\n            if (Editor.isVoid(editor, node)) {\n              Transforms.delete(editor);\n            }\n          }\n        }\n      }\n    }, [readOnly, attributes.onCut]),\n    onDragOver: (0, import_react2.useCallback)((event) => {\n      if (hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        if (Editor.isVoid(editor, node)) {\n          event.preventDefault();\n        }\n      }\n    }, [attributes.onDragOver]),\n    onDragStart: (0, import_react2.useCallback)((event) => {\n      if (!readOnly && hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node);\n        var voidMatch = Editor.isVoid(editor, node) || Editor.void(editor, {\n          at: path,\n          voids: true\n        });\n        if (voidMatch) {\n          var range = Editor.range(editor, path);\n          Transforms.select(editor, range);\n        }\n        state.isDraggingInternally = true;\n        ReactEditor.setFragmentData(editor, event.dataTransfer, \"drag\");\n      }\n    }, [readOnly, attributes.onDragStart]),\n    onDrop: (0, import_react2.useCallback)((event) => {\n      if (!readOnly && hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {\n        event.preventDefault();\n        var draggedRange = editor.selection;\n        var range = ReactEditor.findEventRange(editor, event);\n        var data = event.dataTransfer;\n        Transforms.select(editor, range);\n        if (state.isDraggingInternally) {\n          if (draggedRange && !Range.equals(draggedRange, range) && !Editor.void(editor, {\n            at: range,\n            voids: true\n          })) {\n            Transforms.delete(editor, {\n              at: draggedRange\n            });\n          }\n        }\n        ReactEditor.insertData(editor, data);\n        if (!ReactEditor.isFocused(editor)) {\n          ReactEditor.focus(editor);\n        }\n      }\n      state.isDraggingInternally = false;\n    }, [readOnly, attributes.onDrop]),\n    onDragEnd: (0, import_react2.useCallback)((event) => {\n      if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && hasTarget(editor, event.target)) {\n        attributes.onDragEnd(event);\n      }\n      state.isDraggingInternally = false;\n    }, [readOnly, attributes.onDragEnd]),\n    onFocus: (0, import_react2.useCallback)((event) => {\n      if (!readOnly && !state.isUpdatingSelection && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root5 = ReactEditor.findDocumentOrShadowRoot(editor);\n        state.latestElement = root5.activeElement;\n        if (IS_FIREFOX && event.target !== el) {\n          el.focus();\n          return;\n        }\n        IS_FOCUSED.set(editor, true);\n      }\n    }, [readOnly, attributes.onFocus]),\n    onKeyDown: (0, import_react2.useCallback)((event) => {\n      if (!readOnly && hasEditableTarget(editor, event.target)) {\n        var {\n          nativeEvent\n        } = event;\n        if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {\n          IS_COMPOSING.set(editor, false);\n          setIsComposing(false);\n        }\n        if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {\n          return;\n        }\n        var {\n          selection\n        } = editor;\n        var element4 = editor.children[selection !== null ? selection.focus.path[0] : 0];\n        var isRTL = (0, import_direction.default)(Node2.string(element4)) === \"rtl\";\n        if (Hotkeys.isRedo(nativeEvent)) {\n          event.preventDefault();\n          var maybeHistoryEditor = editor;\n          if (typeof maybeHistoryEditor.redo === \"function\") {\n            maybeHistoryEditor.redo();\n          }\n          return;\n        }\n        if (Hotkeys.isUndo(nativeEvent)) {\n          event.preventDefault();\n          var _maybeHistoryEditor = editor;\n          if (typeof _maybeHistoryEditor.undo === \"function\") {\n            _maybeHistoryEditor.undo();\n          }\n          return;\n        }\n        if (Hotkeys.isMoveLineBackward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: \"line\",\n            reverse: true\n          });\n          return;\n        }\n        if (Hotkeys.isMoveLineForward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: \"line\"\n          });\n          return;\n        }\n        if (Hotkeys.isExtendLineBackward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: \"line\",\n            edge: \"focus\",\n            reverse: true\n          });\n          return;\n        }\n        if (Hotkeys.isExtendLineForward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: \"line\",\n            edge: \"focus\"\n          });\n          return;\n        }\n        if (Hotkeys.isMoveBackward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && Range.isCollapsed(selection)) {\n            Transforms.move(editor, {\n              reverse: !isRTL\n            });\n          } else {\n            Transforms.collapse(editor, {\n              edge: \"start\"\n            });\n          }\n          return;\n        }\n        if (Hotkeys.isMoveForward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && Range.isCollapsed(selection)) {\n            Transforms.move(editor, {\n              reverse: isRTL\n            });\n          } else {\n            Transforms.collapse(editor, {\n              edge: \"end\"\n            });\n          }\n          return;\n        }\n        if (Hotkeys.isMoveWordBackward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && Range.isExpanded(selection)) {\n            Transforms.collapse(editor, {\n              edge: \"focus\"\n            });\n          }\n          Transforms.move(editor, {\n            unit: \"word\",\n            reverse: !isRTL\n          });\n          return;\n        }\n        if (Hotkeys.isMoveWordForward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && Range.isExpanded(selection)) {\n            Transforms.collapse(editor, {\n              edge: \"focus\"\n            });\n          }\n          Transforms.move(editor, {\n            unit: \"word\",\n            reverse: isRTL\n          });\n          return;\n        }\n        if (!HAS_BEFORE_INPUT_SUPPORT) {\n          if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {\n            event.preventDefault();\n            return;\n          }\n          if (Hotkeys.isSoftBreak(nativeEvent)) {\n            event.preventDefault();\n            Editor.insertSoftBreak(editor);\n            return;\n          }\n          if (Hotkeys.isSplitBlock(nativeEvent)) {\n            event.preventDefault();\n            Editor.insertBreak(editor);\n            return;\n          }\n          if (Hotkeys.isDeleteBackward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: \"backward\"\n              });\n            } else {\n              Editor.deleteBackward(editor);\n            }\n            return;\n          }\n          if (Hotkeys.isDeleteForward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: \"forward\"\n              });\n            } else {\n              Editor.deleteForward(editor);\n            }\n            return;\n          }\n          if (Hotkeys.isDeleteLineBackward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: \"backward\"\n              });\n            } else {\n              Editor.deleteBackward(editor, {\n                unit: \"line\"\n              });\n            }\n            return;\n          }\n          if (Hotkeys.isDeleteLineForward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: \"forward\"\n              });\n            } else {\n              Editor.deleteForward(editor, {\n                unit: \"line\"\n              });\n            }\n            return;\n          }\n          if (Hotkeys.isDeleteWordBackward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: \"backward\"\n              });\n            } else {\n              Editor.deleteBackward(editor, {\n                unit: \"word\"\n              });\n            }\n            return;\n          }\n          if (Hotkeys.isDeleteWordForward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: \"forward\"\n              });\n            } else {\n              Editor.deleteForward(editor, {\n                unit: \"word\"\n              });\n            }\n            return;\n          }\n        } else {\n          if (IS_CHROME || IS_SAFARI) {\n            if (selection && (Hotkeys.isDeleteBackward(nativeEvent) || Hotkeys.isDeleteForward(nativeEvent)) && Range.isCollapsed(selection)) {\n              var currentNode = Node2.parent(editor, selection.anchor.path);\n              if (Element2.isElement(currentNode) && Editor.isVoid(editor, currentNode) && Editor.isInline(editor, currentNode)) {\n                event.preventDefault();\n                Editor.deleteBackward(editor, {\n                  unit: \"block\"\n                });\n                return;\n              }\n            }\n          }\n        }\n      }\n    }, [readOnly, attributes.onKeyDown]),\n    onPaste: (0, import_react2.useCallback)((event) => {\n      if (!readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {\n        if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent)) {\n          event.preventDefault();\n          ReactEditor.insertData(editor, event.clipboardData);\n        }\n      }\n    }, [readOnly, attributes.onPaste])\n  }), /* @__PURE__ */ import_react2.default.createElement(Children, {\n    decorations,\n    node: editor,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection: editor.selection\n  })))));\n};\nvar DefaultPlaceholder = (_ref) => {\n  var {\n    attributes,\n    children\n  } = _ref;\n  return /* @__PURE__ */ import_react2.default.createElement(\"span\", Object.assign({}, attributes), children);\n};\nvar defaultDecorate = () => [];\nvar defaultScrollSelectionIntoView = (editor, domRange) => {\n  if (!editor.selection || editor.selection && Range.isCollapsed(editor.selection)) {\n    var leafEl = domRange.startContainer.parentElement;\n    leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);\n    es_default(leafEl, {\n      scrollMode: \"if-needed\"\n    });\n    delete leafEl.getBoundingClientRect;\n  }\n};\nvar hasTarget = (editor, target) => {\n  return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target);\n};\nvar hasEditableTarget = (editor, target) => {\n  return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {\n    editable: true\n  });\n};\nvar isTargetInsideNonReadonlyVoid = (editor, target) => {\n  if (IS_READ_ONLY.get(editor))\n    return false;\n  var slateNode2 = hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);\n  return Editor.isVoid(editor, slateNode2);\n};\nvar isEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  }\n  var shouldTreatEventAsHandled = handler(event);\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n  return event.isDefaultPrevented() || event.isPropagationStopped();\n};\nvar isDOMEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  }\n  var shouldTreatEventAsHandled = handler(event);\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n  return event.defaultPrevented;\n};\nvar FocusedContext = /* @__PURE__ */ (0, import_react2.createContext)(false);\nvar useFocused = () => {\n  return (0, import_react2.useContext)(FocusedContext);\n};\nvar SlateSelectorContext = /* @__PURE__ */ (0, import_react2.createContext)({});\nfunction getSelectorContext(editor) {\n  var eventListeners = (0, import_react2.useRef)([]).current;\n  var slateRef = (0, import_react2.useRef)({\n    editor\n  }).current;\n  var onChange = (0, import_react2.useCallback)((editor2) => {\n    slateRef.editor = editor2;\n    eventListeners.forEach((listener) => listener(editor2));\n  }, []);\n  var selectorContext = (0, import_react2.useMemo)(() => {\n    return {\n      getSlate: () => slateRef.editor,\n      addEventListener: (callback) => {\n        eventListeners.push(callback);\n        return () => {\n          eventListeners.splice(eventListeners.indexOf(callback), 1);\n        };\n      }\n    };\n  }, [eventListeners, slateRef]);\n  return {\n    selectorContext,\n    onChange\n  };\n}\nvar _excluded3 = [\"editor\", \"children\", \"onChange\", \"value\"];\nvar Slate = (props) => {\n  var {\n    editor,\n    children,\n    onChange,\n    value\n  } = props, rest = _objectWithoutProperties2(props, _excluded3);\n  var unmountRef = (0, import_react2.useRef)(false);\n  var [context, setContext] = import_react2.default.useState(() => {\n    if (!Node2.isNodeList(value)) {\n      throw new Error(\"[Slate] value is invalid! Expected a list of elements\" + \"but got: \".concat(Scrubber.stringify(value)));\n    }\n    if (!Editor.isEditor(editor)) {\n      throw new Error(\"[Slate] editor is invalid! you passed:\" + \"\".concat(Scrubber.stringify(editor)));\n    }\n    editor.children = value;\n    Object.assign(editor, rest);\n    return {\n      v: 0,\n      editor\n    };\n  });\n  var {\n    selectorContext,\n    onChange: handleSelectorChange\n  } = getSelectorContext(editor);\n  var onContextChange = (0, import_react2.useCallback)(() => {\n    if (onChange) {\n      onChange(editor.children);\n    }\n    setContext((prevContext) => ({\n      v: prevContext.v + 1,\n      editor\n    }));\n    handleSelectorChange(editor);\n  }, [onChange]);\n  EDITOR_TO_ON_CHANGE.set(editor, onContextChange);\n  (0, import_react2.useEffect)(() => {\n    return () => {\n      EDITOR_TO_ON_CHANGE.set(editor, () => {\n      });\n      unmountRef.current = true;\n    };\n  }, []);\n  var [isFocused, setIsFocused] = (0, import_react2.useState)(ReactEditor.isFocused(editor));\n  (0, import_react2.useEffect)(() => {\n    setIsFocused(ReactEditor.isFocused(editor));\n  });\n  useIsomorphicLayoutEffect(() => {\n    var fn4 = () => setIsFocused(ReactEditor.isFocused(editor));\n    if (IS_REACT_VERSION_17_OR_ABOVE) {\n      document.addEventListener(\"focusin\", fn4);\n      document.addEventListener(\"focusout\", fn4);\n      return () => {\n        document.removeEventListener(\"focusin\", fn4);\n        document.removeEventListener(\"focusout\", fn4);\n      };\n    } else {\n      document.addEventListener(\"focus\", fn4, true);\n      document.addEventListener(\"blur\", fn4, true);\n      return () => {\n        document.removeEventListener(\"focus\", fn4, true);\n        document.removeEventListener(\"blur\", fn4, true);\n      };\n    }\n  }, []);\n  return /* @__PURE__ */ import_react2.default.createElement(SlateSelectorContext.Provider, {\n    value: selectorContext\n  }, /* @__PURE__ */ import_react2.default.createElement(SlateContext.Provider, {\n    value: context\n  }, /* @__PURE__ */ import_react2.default.createElement(EditorContext.Provider, {\n    value: editor\n  }, /* @__PURE__ */ import_react2.default.createElement(FocusedContext.Provider, {\n    value: isFocused\n  }, children))));\n};\nvar doRectsIntersect = (rect, compareRect) => {\n  var middle = (compareRect.top + compareRect.bottom) / 2;\n  return rect.top <= middle && rect.bottom >= middle;\n};\nvar areRangesSameLine = (editor, range1, range2) => {\n  var rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect();\n  var rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect();\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\nvar findCurrentLineRange = (editor, parentRange) => {\n  var parentRangeBoundary = Editor.range(editor, Range.end(parentRange));\n  var positions = Array.from(Editor.positions(editor, {\n    at: parentRange\n  }));\n  var left2 = 0;\n  var right2 = positions.length;\n  var middle = Math.floor(right2 / 2);\n  if (areRangesSameLine(editor, Editor.range(editor, positions[left2]), parentRangeBoundary)) {\n    return Editor.range(editor, positions[left2], parentRangeBoundary);\n  }\n  if (positions.length < 2) {\n    return Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n  }\n  while (middle !== positions.length && middle !== left2) {\n    if (areRangesSameLine(editor, Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right2 = middle;\n    } else {\n      left2 = middle;\n    }\n    middle = Math.floor((left2 + right2) / 2);\n  }\n  return Editor.range(editor, positions[right2], parentRangeBoundary);\n};\nfunction ownKeys2(object, enumerableOnly) {\n  var keys4 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys4.push.apply(keys4, symbols);\n  }\n  return keys4;\n}\nfunction _objectSpread2(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    if (i5 % 2) {\n      ownKeys2(Object(source), true).forEach(function(key) {\n        _defineProperty2(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys2(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar withReact = (editor) => {\n  var e4 = editor;\n  var {\n    apply: apply2,\n    onChange,\n    deleteBackward: deleteBackward2,\n    addMark,\n    removeMark: removeMark2\n  } = e4;\n  EDITOR_TO_KEY_TO_ELEMENT.set(e4, /* @__PURE__ */ new WeakMap());\n  e4.addMark = (key, value) => {\n    var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e4)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e4) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e4)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e4, null);\n    }\n    EDITOR_TO_USER_MARKS.delete(editor);\n    addMark(key, value);\n  };\n  e4.removeMark = (key) => {\n    var _EDITOR_TO_PENDING_DI2;\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e4) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e4)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e4, null);\n    }\n    EDITOR_TO_USER_MARKS.delete(editor);\n    removeMark2(key);\n  };\n  e4.deleteBackward = (unit) => {\n    if (unit !== \"line\") {\n      return deleteBackward2(unit);\n    }\n    if (editor.selection && Range.isCollapsed(editor.selection)) {\n      var parentBlockEntry = Editor.above(editor, {\n        match: (n8) => Editor.isBlock(editor, n8),\n        at: editor.selection\n      });\n      if (parentBlockEntry) {\n        var [, parentBlockPath] = parentBlockEntry;\n        var parentElementRange = Editor.range(editor, parentBlockPath, editor.selection.anchor);\n        var currentLineRange = findCurrentLineRange(e4, parentElementRange);\n        if (!Range.isCollapsed(currentLineRange)) {\n          Transforms.delete(editor, {\n            at: currentLineRange\n          });\n        }\n      }\n    }\n  };\n  e4.apply = (op) => {\n    var matches = [];\n    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n    if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {\n      var transformed = pendingDiffs.map((textDiff) => transformTextDiff(textDiff, op)).filter(Boolean);\n      EDITOR_TO_PENDING_DIFFS.set(editor, transformed);\n    }\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(editor);\n    if (pendingSelection) {\n      EDITOR_TO_PENDING_SELECTION.set(editor, transformPendingRange(editor, pendingSelection, op));\n    }\n    var pendingAction = EDITOR_TO_PENDING_ACTION.get(editor);\n    if (pendingAction) {\n      var at = Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(editor, pendingAction.at, op) : transformPendingRange(editor, pendingAction.at, op);\n      EDITOR_TO_PENDING_ACTION.set(editor, at ? _objectSpread2(_objectSpread2({}, pendingAction), {}, {\n        at\n      }) : null);\n    }\n    switch (op.type) {\n      case \"insert_text\":\n      case \"remove_text\":\n      case \"set_node\":\n      case \"split_node\": {\n        matches.push(...getMatches(e4, op.path));\n        break;\n      }\n      case \"set_selection\": {\n        var _EDITOR_TO_USER_SELEC;\n        (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n        EDITOR_TO_USER_SELECTION.delete(editor);\n        break;\n      }\n      case \"insert_node\":\n      case \"remove_node\": {\n        matches.push(...getMatches(e4, Path.parent(op.path)));\n        break;\n      }\n      case \"merge_node\": {\n        var prevPath = Path.previous(op.path);\n        matches.push(...getMatches(e4, prevPath));\n        break;\n      }\n      case \"move_node\": {\n        var commonPath = Path.common(Path.parent(op.path), Path.parent(op.newPath));\n        matches.push(...getMatches(e4, commonPath));\n        break;\n      }\n    }\n    apply2(op);\n    for (var [path, key] of matches) {\n      var [node] = Editor.node(e4, path);\n      NODE_TO_KEY.set(node, key);\n    }\n  };\n  e4.setFragmentData = (data) => {\n    var {\n      selection\n    } = e4;\n    if (!selection) {\n      return;\n    }\n    var [start2, end2] = Range.edges(selection);\n    var startVoid = Editor.void(e4, {\n      at: start2.path\n    });\n    var endVoid = Editor.void(e4, {\n      at: end2.path\n    });\n    if (Range.isCollapsed(selection) && !startVoid) {\n      return;\n    }\n    var domRange = ReactEditor.toDOMRange(e4, selection);\n    var contents = domRange.cloneContents();\n    var attach = contents.childNodes[0];\n    contents.childNodes.forEach((node) => {\n      if (node.textContent && node.textContent.trim() !== \"\") {\n        attach = node;\n      }\n    });\n    if (endVoid) {\n      var [voidNode] = endVoid;\n      var r7 = domRange.cloneRange();\n      var domNode = ReactEditor.toDOMNode(e4, voidNode);\n      r7.setEndAfter(domNode);\n      contents = r7.cloneContents();\n    }\n    if (startVoid) {\n      attach = contents.querySelector(\"[data-slate-spacer]\");\n    }\n    Array.from(contents.querySelectorAll(\"[data-slate-zero-width]\")).forEach((zw) => {\n      var isNewline = zw.getAttribute(\"data-slate-zero-width\") === \"n\";\n      zw.textContent = isNewline ? \"\\n\" : \"\";\n    });\n    if (isDOMText(attach)) {\n      var span = attach.ownerDocument.createElement(\"span\");\n      span.style.whiteSpace = \"pre\";\n      span.appendChild(attach);\n      contents.appendChild(span);\n      attach = span;\n    }\n    var fragment = e4.getFragment();\n    var string2 = JSON.stringify(fragment);\n    var encoded = window.btoa(encodeURIComponent(string2));\n    attach.setAttribute(\"data-slate-fragment\", encoded);\n    data.setData(\"application/x-slate-fragment\", encoded);\n    var div3 = contents.ownerDocument.createElement(\"div\");\n    div3.appendChild(contents);\n    div3.setAttribute(\"hidden\", \"true\");\n    contents.ownerDocument.body.appendChild(div3);\n    data.setData(\"text/html\", div3.innerHTML);\n    data.setData(\"text/plain\", getPlainText(div3));\n    contents.ownerDocument.body.removeChild(div3);\n    return data;\n  };\n  e4.insertData = (data) => {\n    if (!e4.insertFragmentData(data)) {\n      e4.insertTextData(data);\n    }\n  };\n  e4.insertFragmentData = (data) => {\n    var fragment = data.getData(\"application/x-slate-fragment\") || getSlateFragmentAttribute(data);\n    if (fragment) {\n      var decoded = decodeURIComponent(window.atob(fragment));\n      var parsed = JSON.parse(decoded);\n      e4.insertFragment(parsed);\n      return true;\n    }\n    return false;\n  };\n  e4.insertTextData = (data) => {\n    var text4 = data.getData(\"text/plain\");\n    if (text4) {\n      var lines = text4.split(/\\r\\n|\\r|\\n/);\n      var split = false;\n      for (var line of lines) {\n        if (split) {\n          Transforms.splitNodes(e4, {\n            always: true\n          });\n        }\n        e4.insertText(line);\n        split = true;\n      }\n      return true;\n    }\n    return false;\n  };\n  e4.onChange = () => {\n    import_react_dom.default.unstable_batchedUpdates(() => {\n      var onContextChange = EDITOR_TO_ON_CHANGE.get(e4);\n      if (onContextChange) {\n        onContextChange();\n      }\n      onChange();\n    });\n  };\n  return e4;\n};\nvar getMatches = (e4, path) => {\n  var matches = [];\n  for (var [n8, p6] of Editor.levels(e4, {\n    at: path\n  })) {\n    var key = ReactEditor.findKey(e4, n8);\n    matches.push([p6, key]);\n  }\n  return matches;\n};\n\n// node_modules/hotkeys-js/dist/hotkeys.esm.js\nvar isff = typeof navigator !== \"undefined\" ? navigator.userAgent.toLowerCase().indexOf(\"firefox\") > 0 : false;\nfunction addEvent(object, event, method, useCapture) {\n  if (object.addEventListener) {\n    object.addEventListener(event, method, useCapture);\n  } else if (object.attachEvent) {\n    object.attachEvent(\"on\".concat(event), function() {\n      method(window.event);\n    });\n  }\n}\nfunction getMods(modifier, key) {\n  var mods = key.slice(0, key.length - 1);\n  for (var i5 = 0; i5 < mods.length; i5++) {\n    mods[i5] = modifier[mods[i5].toLowerCase()];\n  }\n  return mods;\n}\nfunction getKeys(key) {\n  if (typeof key !== \"string\")\n    key = \"\";\n  key = key.replace(/\\s/g, \"\");\n  var keys4 = key.split(\",\");\n  var index5 = keys4.lastIndexOf(\"\");\n  for (; index5 >= 0; ) {\n    keys4[index5 - 1] += \",\";\n    keys4.splice(index5, 1);\n    index5 = keys4.lastIndexOf(\"\");\n  }\n  return keys4;\n}\nfunction compareArray(a1, a22) {\n  var arr1 = a1.length >= a22.length ? a1 : a22;\n  var arr2 = a1.length >= a22.length ? a22 : a1;\n  var isIndex4 = true;\n  for (var i5 = 0; i5 < arr1.length; i5++) {\n    if (arr2.indexOf(arr1[i5]) === -1)\n      isIndex4 = false;\n  }\n  return isIndex4;\n}\nvar _keyMap = {\n  backspace: 8,\n  tab: 9,\n  clear: 12,\n  enter: 13,\n  return: 13,\n  esc: 27,\n  escape: 27,\n  space: 32,\n  left: 37,\n  up: 38,\n  right: 39,\n  down: 40,\n  del: 46,\n  delete: 46,\n  ins: 45,\n  insert: 45,\n  home: 36,\n  end: 35,\n  pageup: 33,\n  pagedown: 34,\n  capslock: 20,\n  num_0: 96,\n  num_1: 97,\n  num_2: 98,\n  num_3: 99,\n  num_4: 100,\n  num_5: 101,\n  num_6: 102,\n  num_7: 103,\n  num_8: 104,\n  num_9: 105,\n  num_multiply: 106,\n  num_add: 107,\n  num_enter: 108,\n  num_subtract: 109,\n  num_decimal: 110,\n  num_divide: 111,\n  \"\\u21EA\": 20,\n  \",\": 188,\n  \".\": 190,\n  \"/\": 191,\n  \"`\": 192,\n  \"-\": isff ? 173 : 189,\n  \"=\": isff ? 61 : 187,\n  \";\": isff ? 59 : 186,\n  \"'\": 222,\n  \"[\": 219,\n  \"]\": 221,\n  \"\\\\\": 220\n};\nvar _modifier = {\n  // shiftKey\n  \"\\u21E7\": 16,\n  shift: 16,\n  // altKey\n  \"\\u2325\": 18,\n  alt: 18,\n  option: 18,\n  // ctrlKey\n  \"\\u2303\": 17,\n  ctrl: 17,\n  control: 17,\n  // metaKey\n  \"\\u2318\": 91,\n  cmd: 91,\n  command: 91\n};\nvar modifierMap = {\n  16: \"shiftKey\",\n  18: \"altKey\",\n  17: \"ctrlKey\",\n  91: \"metaKey\",\n  shiftKey: 16,\n  ctrlKey: 17,\n  altKey: 18,\n  metaKey: 91\n};\nvar _mods = {\n  16: false,\n  18: false,\n  17: false,\n  91: false\n};\nvar _handlers = {};\nfor (k3 = 1; k3 < 20; k3++) {\n  _keyMap[\"f\".concat(k3)] = 111 + k3;\n}\nvar k3;\nvar _downKeys = [];\nvar winListendFocus = false;\nvar _scope = \"all\";\nvar elementHasBindEvent = [];\nvar code = function code2(x4) {\n  return _keyMap[x4.toLowerCase()] || _modifier[x4.toLowerCase()] || x4.toUpperCase().charCodeAt(0);\n};\nfunction setScope(scope2) {\n  _scope = scope2 || \"all\";\n}\nfunction getScope() {\n  return _scope || \"all\";\n}\nfunction getPressedKeyCodes() {\n  return _downKeys.slice(0);\n}\nfunction filter(event) {\n  var target = event.target || event.srcElement;\n  var tagName = target.tagName;\n  var flag = true;\n  if (target.isContentEditable || (tagName === \"INPUT\" || tagName === \"TEXTAREA\" || tagName === \"SELECT\") && !target.readOnly) {\n    flag = false;\n  }\n  return flag;\n}\nfunction isPressed(keyCode) {\n  if (typeof keyCode === \"string\") {\n    keyCode = code(keyCode);\n  }\n  return _downKeys.indexOf(keyCode) !== -1;\n}\nfunction deleteScope(scope2, newScope) {\n  var handlers;\n  var i5;\n  if (!scope2)\n    scope2 = getScope();\n  for (var key in _handlers) {\n    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {\n      handlers = _handlers[key];\n      for (i5 = 0; i5 < handlers.length; ) {\n        if (handlers[i5].scope === scope2)\n          handlers.splice(i5, 1);\n        else\n          i5++;\n      }\n    }\n  }\n  if (getScope() === scope2)\n    setScope(newScope || \"all\");\n}\nfunction clearModifier(event) {\n  var key = event.keyCode || event.which || event.charCode;\n  var i5 = _downKeys.indexOf(key);\n  if (i5 >= 0) {\n    _downKeys.splice(i5, 1);\n  }\n  if (event.key && event.key.toLowerCase() === \"meta\") {\n    _downKeys.splice(0, _downKeys.length);\n  }\n  if (key === 93 || key === 224)\n    key = 91;\n  if (key in _mods) {\n    _mods[key] = false;\n    for (var k3 in _modifier) {\n      if (_modifier[k3] === key)\n        hotkeys[k3] = false;\n    }\n  }\n}\nfunction unbind(keysInfo) {\n  if (typeof keysInfo === \"undefined\") {\n    Object.keys(_handlers).forEach(function(key) {\n      return delete _handlers[key];\n    });\n  } else if (Array.isArray(keysInfo)) {\n    keysInfo.forEach(function(info) {\n      if (info.key)\n        eachUnbind(info);\n    });\n  } else if (typeof keysInfo === \"object\") {\n    if (keysInfo.key)\n      eachUnbind(keysInfo);\n  } else if (typeof keysInfo === \"string\") {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    var scope2 = args[0], method = args[1];\n    if (typeof scope2 === \"function\") {\n      method = scope2;\n      scope2 = \"\";\n    }\n    eachUnbind({\n      key: keysInfo,\n      scope: scope2,\n      method,\n      splitKey: \"+\"\n    });\n  }\n}\nvar eachUnbind = function eachUnbind2(_ref) {\n  var key = _ref.key, scope2 = _ref.scope, method = _ref.method, _ref$splitKey = _ref.splitKey, splitKey = _ref$splitKey === void 0 ? \"+\" : _ref$splitKey;\n  var multipleKeys = getKeys(key);\n  multipleKeys.forEach(function(originKey) {\n    var unbindKeys = originKey.split(splitKey);\n    var len = unbindKeys.length;\n    var lastKey = unbindKeys[len - 1];\n    var keyCode = lastKey === \"*\" ? \"*\" : code(lastKey);\n    if (!_handlers[keyCode])\n      return;\n    if (!scope2)\n      scope2 = getScope();\n    var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];\n    _handlers[keyCode] = _handlers[keyCode].filter(function(record) {\n      var isMatchingMethod = method ? record.method === method : true;\n      return !(isMatchingMethod && record.scope === scope2 && compareArray(record.mods, mods));\n    });\n  });\n};\nfunction eventHandler(event, handler, scope2, element4) {\n  if (handler.element !== element4) {\n    return;\n  }\n  var modifiersMatch;\n  if (handler.scope === scope2 || handler.scope === \"all\") {\n    modifiersMatch = handler.mods.length > 0;\n    for (var y5 in _mods) {\n      if (Object.prototype.hasOwnProperty.call(_mods, y5)) {\n        if (!_mods[y5] && handler.mods.indexOf(+y5) > -1 || _mods[y5] && handler.mods.indexOf(+y5) === -1) {\n          modifiersMatch = false;\n        }\n      }\n    }\n    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === \"*\") {\n      if (handler.method(event, handler) === false) {\n        if (event.preventDefault)\n          event.preventDefault();\n        else\n          event.returnValue = false;\n        if (event.stopPropagation)\n          event.stopPropagation();\n        if (event.cancelBubble)\n          event.cancelBubble = true;\n      }\n    }\n  }\n}\nfunction dispatch(event, element4) {\n  var asterisk = _handlers[\"*\"];\n  var key = event.keyCode || event.which || event.charCode;\n  if (!hotkeys.filter.call(this, event))\n    return;\n  if (key === 93 || key === 224)\n    key = 91;\n  if (_downKeys.indexOf(key) === -1 && key !== 229)\n    _downKeys.push(key);\n  [\"ctrlKey\", \"altKey\", \"shiftKey\", \"metaKey\"].forEach(function(keyName) {\n    var keyNum = modifierMap[keyName];\n    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {\n      _downKeys.push(keyNum);\n    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {\n      _downKeys.splice(_downKeys.indexOf(keyNum), 1);\n    } else if (keyName === \"metaKey\" && event[keyName] && _downKeys.length === 3) {\n      if (!(event.ctrlKey || event.shiftKey || event.altKey)) {\n        _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));\n      }\n    }\n  });\n  if (key in _mods) {\n    _mods[key] = true;\n    for (var k3 in _modifier) {\n      if (_modifier[k3] === key)\n        hotkeys[k3] = true;\n    }\n    if (!asterisk)\n      return;\n  }\n  for (var e4 in _mods) {\n    if (Object.prototype.hasOwnProperty.call(_mods, e4)) {\n      _mods[e4] = event[modifierMap[e4]];\n    }\n  }\n  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState(\"AltGraph\")) {\n    if (_downKeys.indexOf(17) === -1) {\n      _downKeys.push(17);\n    }\n    if (_downKeys.indexOf(18) === -1) {\n      _downKeys.push(18);\n    }\n    _mods[17] = true;\n    _mods[18] = true;\n  }\n  var scope2 = getScope();\n  if (asterisk) {\n    for (var i5 = 0; i5 < asterisk.length; i5++) {\n      if (asterisk[i5].scope === scope2 && (event.type === \"keydown\" && asterisk[i5].keydown || event.type === \"keyup\" && asterisk[i5].keyup)) {\n        eventHandler(event, asterisk[i5], scope2, element4);\n      }\n    }\n  }\n  if (!(key in _handlers))\n    return;\n  for (var _i = 0; _i < _handlers[key].length; _i++) {\n    if (event.type === \"keydown\" && _handlers[key][_i].keydown || event.type === \"keyup\" && _handlers[key][_i].keyup) {\n      if (_handlers[key][_i].key) {\n        var record = _handlers[key][_i];\n        var splitKey = record.splitKey;\n        var keyShortcut = record.key.split(splitKey);\n        var _downKeysCurrent = [];\n        for (var a7 = 0; a7 < keyShortcut.length; a7++) {\n          _downKeysCurrent.push(code(keyShortcut[a7]));\n        }\n        if (_downKeysCurrent.sort().join(\"\") === _downKeys.sort().join(\"\")) {\n          eventHandler(event, record, scope2, element4);\n        }\n      }\n    }\n  }\n}\nfunction isElementBind(element4) {\n  return elementHasBindEvent.indexOf(element4) > -1;\n}\nfunction hotkeys(key, option, method) {\n  _downKeys = [];\n  var keys4 = getKeys(key);\n  var mods = [];\n  var scope2 = \"all\";\n  var element4 = document;\n  var i5 = 0;\n  var keyup = false;\n  var keydown = true;\n  var splitKey = \"+\";\n  var capture = false;\n  if (method === void 0 && typeof option === \"function\") {\n    method = option;\n  }\n  if (Object.prototype.toString.call(option) === \"[object Object]\") {\n    if (option.scope)\n      scope2 = option.scope;\n    if (option.element)\n      element4 = option.element;\n    if (option.keyup)\n      keyup = option.keyup;\n    if (option.keydown !== void 0)\n      keydown = option.keydown;\n    if (option.capture !== void 0)\n      capture = option.capture;\n    if (typeof option.splitKey === \"string\")\n      splitKey = option.splitKey;\n  }\n  if (typeof option === \"string\")\n    scope2 = option;\n  for (; i5 < keys4.length; i5++) {\n    key = keys4[i5].split(splitKey);\n    mods = [];\n    if (key.length > 1)\n      mods = getMods(_modifier, key);\n    key = key[key.length - 1];\n    key = key === \"*\" ? \"*\" : code(key);\n    if (!(key in _handlers))\n      _handlers[key] = [];\n    _handlers[key].push({\n      keyup,\n      keydown,\n      scope: scope2,\n      mods,\n      shortcut: keys4[i5],\n      method,\n      key: keys4[i5],\n      splitKey,\n      element: element4\n    });\n  }\n  if (typeof element4 !== \"undefined\" && !isElementBind(element4) && window) {\n    elementHasBindEvent.push(element4);\n    addEvent(element4, \"keydown\", function(e4) {\n      dispatch(e4, element4);\n    }, capture);\n    if (!winListendFocus) {\n      winListendFocus = true;\n      addEvent(window, \"focus\", function() {\n        _downKeys = [];\n      }, capture);\n    }\n    addEvent(element4, \"keyup\", function(e4) {\n      dispatch(e4, element4);\n      clearModifier(e4);\n    }, capture);\n  }\n}\nfunction trigger(shortcut) {\n  var scope2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"all\";\n  Object.keys(_handlers).forEach(function(key) {\n    var data = _handlers[key].find(function(item) {\n      return item.scope === scope2 && item.shortcut === shortcut;\n    });\n    if (data && data.method) {\n      data.method();\n    }\n  });\n}\nvar _api = {\n  setScope,\n  getScope,\n  deleteScope,\n  getPressedKeyCodes,\n  isPressed,\n  filter,\n  trigger,\n  unbind,\n  keyMap: _keyMap,\n  modifier: _modifier,\n  modifierMap\n};\nfor (a7 in _api) {\n  if (Object.prototype.hasOwnProperty.call(_api, a7)) {\n    hotkeys[a7] = _api[a7];\n  }\n}\nvar a7;\nif (typeof window !== \"undefined\") {\n  _hotkeys = window.hotkeys;\n  hotkeys.noConflict = function(deep) {\n    if (deep && window.hotkeys === hotkeys) {\n      window.hotkeys = _hotkeys;\n    }\n    return hotkeys;\n  };\n  window.hotkeys = hotkeys;\n}\nvar _hotkeys;\n\n// node_modules/react-hotkeys-hook/dist/react-hotkeys-hook.esm.js\nvar import_react3 = require(\"react\");\nhotkeys.filter = function() {\n  return true;\n};\nvar tagFilter = function tagFilter2(_ref, enableOnTags) {\n  var target = _ref.target;\n  var targetTagName = target && target.tagName;\n  return Boolean(targetTagName && enableOnTags && enableOnTags.includes(targetTagName));\n};\nvar isKeyboardEventTriggeredByInput = function isKeyboardEventTriggeredByInput2(ev) {\n  return tagFilter(ev, [\"INPUT\", \"TEXTAREA\", \"SELECT\"]);\n};\nfunction useHotkeys(keys4, callback, options, deps) {\n  if (options instanceof Array) {\n    deps = options;\n    options = void 0;\n  }\n  var _ref2 = options || {}, enableOnTags = _ref2.enableOnTags, filter3 = _ref2.filter, keyup = _ref2.keyup, keydown = _ref2.keydown, _ref2$filterPreventDe = _ref2.filterPreventDefault, filterPreventDefault = _ref2$filterPreventDe === void 0 ? true : _ref2$filterPreventDe, _ref2$enabled = _ref2.enabled, enabled = _ref2$enabled === void 0 ? true : _ref2$enabled, _ref2$enableOnContent = _ref2.enableOnContentEditable, enableOnContentEditable = _ref2$enableOnContent === void 0 ? false : _ref2$enableOnContent;\n  var ref = (0, import_react3.useRef)(null);\n  var memoisedCallback = (0, import_react3.useCallback)(function(keyboardEvent, hotkeysEvent) {\n    var _keyboardEvent$target, _ref$current;\n    if (filter3 && !filter3(keyboardEvent)) {\n      return !filterPreventDefault;\n    }\n    if (isKeyboardEventTriggeredByInput(keyboardEvent) && !tagFilter(keyboardEvent, enableOnTags) || (_keyboardEvent$target = keyboardEvent.target) != null && _keyboardEvent$target.isContentEditable && !enableOnContentEditable) {\n      return true;\n    }\n    if (ref.current === null || document.activeElement === ref.current || (_ref$current = ref.current) != null && _ref$current.contains(document.activeElement)) {\n      callback(keyboardEvent, hotkeysEvent);\n      return true;\n    }\n    return false;\n  }, deps ? [ref, enableOnTags, filter3].concat(deps) : [ref, enableOnTags, filter3]);\n  (0, import_react3.useEffect)(function() {\n    if (!enabled) {\n      hotkeys.unbind(keys4, memoisedCallback);\n      return;\n    }\n    if (keyup && keydown !== true) {\n      options.keydown = false;\n    }\n    hotkeys(keys4, options || {}, memoisedCallback);\n    return function() {\n      return hotkeys.unbind(keys4, memoisedCallback);\n    };\n  }, [memoisedCallback, keys4, enabled]);\n  return ref;\n}\nvar isHotkeyPressed = hotkeys.isPressed;\n\n// node_modules/react-tracked/dist/index.modern.js\nvar import_react4 = require(\"react\");\n\n// node_modules/proxy-compare/dist/index.modern.js\nvar e2 = Symbol();\nvar t3 = Symbol();\nvar r3 = Symbol();\nvar n4 = (e4, t6) => new Proxy(e4, t6);\nvar o2 = Object.getPrototypeOf;\nvar s2 = /* @__PURE__ */ new WeakMap();\nvar c2 = (e4) => e4 && (s2.has(e4) ? s2.get(e4) : o2(e4) === Object.prototype || o2(e4) === Array.prototype);\nvar l2 = (e4) => \"object\" == typeof e4 && null !== e4;\nvar a2 = /* @__PURE__ */ new WeakMap();\nvar f2 = (e4) => e4[r3] || e4;\nvar i2 = (s5, l6, p6) => {\n  if (!c2(s5))\n    return s5;\n  const y5 = f2(s5), u5 = ((e4) => Object.isFrozen(e4) || Object.values(Object.getOwnPropertyDescriptors(e4)).some((e5) => !e5.writable))(y5);\n  let g4 = p6 && p6.get(y5);\n  return g4 && g4[1].f === u5 || (g4 = ((n8, o7) => {\n    const s6 = { f: o7 };\n    let c5 = false;\n    const l7 = (t6, r7) => {\n      if (!c5) {\n        let o8 = s6.a.get(n8);\n        o8 || (o8 = /* @__PURE__ */ new Set(), s6.a.set(n8, o8)), r7 && o8.has(e2) || o8.add(t6);\n      }\n    }, a7 = { get: (e4, t6) => t6 === r3 ? n8 : (l7(t6), i2(e4[t6], s6.a, s6.c)), has: (e4, r7) => r7 === t3 ? (c5 = true, s6.a.delete(n8), true) : (l7(r7), r7 in e4), getOwnPropertyDescriptor: (e4, t6) => (l7(t6, true), Object.getOwnPropertyDescriptor(e4, t6)), ownKeys: (t6) => (l7(e2), Reflect.ownKeys(t6)) };\n    return o7 && (a7.set = a7.deleteProperty = () => false), [a7, s6];\n  })(y5, u5), g4[1].p = n4(u5 ? ((e4) => {\n    let t6 = a2.get(e4);\n    if (!t6) {\n      if (Array.isArray(e4))\n        t6 = Array.from(e4);\n      else {\n        const r7 = Object.getOwnPropertyDescriptors(e4);\n        Object.values(r7).forEach((e5) => {\n          e5.configurable = true;\n        }), t6 = Object.create(o2(e4), r7);\n      }\n      a2.set(e4, t6);\n    }\n    return t6;\n  })(y5) : y5, g4[0]), p6 && p6.set(y5, g4)), g4[1].a = l6, g4[1].c = p6, g4[1].p;\n};\nvar p2 = (e4, t6) => {\n  const r7 = Reflect.ownKeys(e4), n8 = Reflect.ownKeys(t6);\n  return r7.length !== n8.length || r7.some((e5, t7) => e5 !== n8[t7]);\n};\nvar y2 = (t6, r7, n8, o7) => {\n  if (Object.is(t6, r7))\n    return false;\n  if (!l2(t6) || !l2(r7))\n    return true;\n  const s5 = n8.get(f2(t6));\n  if (!s5)\n    return true;\n  if (o7) {\n    const e4 = o7.get(t6);\n    if (e4 && e4.n === r7)\n      return e4.g;\n    o7.set(t6, { n: r7, g: false });\n  }\n  let c5 = null;\n  for (const l6 of s5) {\n    const s6 = l6 === e2 ? p2(t6, r7) : y2(t6[l6], r7[l6], n8, o7);\n    if (true !== s6 && false !== s6 || (c5 = s6), c5)\n      break;\n  }\n  return null === c5 && (c5 = true), o7 && o7.set(t6, { n: r7, g: c5 }), c5;\n};\nvar O2 = (e4, t6) => {\n  const r7 = [], n8 = /* @__PURE__ */ new WeakSet(), o7 = (e5, s5) => {\n    if (n8.has(e5))\n      return;\n    l2(e5) && n8.add(e5);\n    const c5 = l2(e5) && t6.get(f2(e5));\n    c5 ? c5.forEach((t7) => {\n      o7(e5[t7], s5 ? [...s5, t7] : [t7]);\n    }) : s5 && r7.push(s5);\n  };\n  return o7(e4), r7;\n};\n\n// node_modules/react-tracked/dist/index.modern.js\nvar useAffectedDebugValue = (state, affected) => {\n  const pathList = (0, import_react4.useRef)();\n  (0, import_react4.useEffect)(() => {\n    pathList.current = O2(state, affected);\n  });\n  (0, import_react4.useDebugValue)(state);\n};\nvar createTrackedSelector = (useSelector) => {\n  const useTrackedSelector = () => {\n    const [, forceUpdate] = (0, import_react4.useReducer)((c5) => c5 + 1, 0);\n    const affected = /* @__PURE__ */ new WeakMap();\n    const lastAffected = (0, import_react4.useRef)();\n    const prevState = (0, import_react4.useRef)();\n    const lastState = (0, import_react4.useRef)();\n    (0, import_react4.useEffect)(() => {\n      lastAffected.current = affected;\n      if (prevState.current !== lastState.current && y2(prevState.current, lastState.current, affected, /* @__PURE__ */ new WeakMap())) {\n        prevState.current = lastState.current;\n        forceUpdate();\n      }\n    });\n    const selector = (0, import_react4.useCallback)((nextState) => {\n      lastState.current = nextState;\n      if (prevState.current && prevState.current !== nextState && lastAffected.current && !y2(prevState.current, nextState, lastAffected.current, /* @__PURE__ */ new WeakMap())) {\n        return prevState.current;\n      }\n      prevState.current = nextState;\n      return nextState;\n    }, []);\n    const state = useSelector(selector);\n    if (typeof process === \"object\" && true) {\n      useAffectedDebugValue(state, affected);\n    }\n    const proxyCache = (0, import_react4.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);\n    return i2(state, affected, proxyCache);\n  };\n  return useTrackedSelector;\n};\n\n// node_modules/zustand/esm/vanilla.mjs\nvar createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\") ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState2 = () => state;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => listeners.clear();\n  const api = { setState, getState: getState2, subscribe, destroy };\n  state = createState(setState, getState2, api);\n  return api;\n};\nvar createStore2 = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\n\n// node_modules/zustand/esm/index.mjs\nvar import_react5 = require(\"react\");\nvar import_with_selector = __toESM(require_with_selector(), 1);\nvar { useSyncExternalStoreWithSelector } = import_with_selector.default;\nfunction useStore(api, selector = api.getState, equalityFn) {\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getState,\n    selector,\n    equalityFn\n  );\n  (0, import_react5.useDebugValue)(slice);\n  return slice;\n}\nvar createImpl = (createState) => {\n  const api = typeof createState === \"function\" ? createStore2(createState) : createState;\n  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nvar create2 = (createState) => createState ? createImpl(createState) : createImpl;\n\n// node_modules/zustand/esm/middleware.mjs\nvar import_meta2 = {};\nvar trackedConnections = /* @__PURE__ */ new Map();\nvar getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api)\n    return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nvar extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === void 0) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nvar devtoolsImpl = (fn4, devtoolsOptions = {}) => (set4, get3, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import_meta2.env && import_meta2.env.MODE) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e4) {\n  }\n  if (!extensionConnector) {\n    if ((import_meta2.env && import_meta2.env.MODE) !== \"production\" && enabled) {\n      console.warn(\n        \"[zustand devtools middleware] Please install/enable Redux devtools extension\"\n      );\n    }\n    return fn4(set4, get3, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r7 = set4(state, replace);\n    if (!isRecording)\n      return r7;\n    const action = nameOrAction === void 0 ? { type: anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === void 0) {\n      connection == null ? void 0 : connection.send(action, get3());\n      return r7;\n    }\n    connection == null ? void 0 : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r7;\n  };\n  const setStateFromDevtools = (...a7) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set4(...a7);\n    isRecording = originalIsRecording;\n  };\n  const initialState3 = fn4(api.setState, get3, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? void 0 : connection.init(initialState3);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? void 0 : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState3 : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...a7) => {\n      if ((import_meta2.env && import_meta2.env.MODE) !== \"production\" && a7[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...a7);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === void 0) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format. \n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools)\n              return;\n            if (typeof api.dispatch !== \"function\")\n              return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState3);\n            if (store === void 0) {\n              return connection == null ? void 0 : connection.init(api.getState());\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === void 0) {\n              connection == null ? void 0 : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                connection == null ? void 0 : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n            if (!lastComputedState)\n              return;\n            if (store === void 0) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? void 0 : connection.send(\n              null,\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState3;\n};\nvar devtools = devtoolsImpl;\nvar parseJsonThen = (stringified, f5) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e4) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e4\n    );\n  }\n  if (parsed !== void 0)\n    f5(parsed);\n};\nfunction createJSONStorage(getStorage) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (e4) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(name, JSON.stringify(newValue)),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nvar toThenable = (fn4) => (input) => {\n  try {\n    const result = fn4(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e4) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e4);\n      }\n    };\n  }\n};\nvar oldImpl = (config2, baseOptions) => (set4, get3, api) => {\n  let options = {\n    getStorage: () => localStorage,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage;\n  try {\n    storage = options.getStorage();\n  } catch (e4) {\n  }\n  if (!storage) {\n    return config2(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set4(...args);\n      },\n      get3,\n      api\n    );\n  }\n  const thenableSerialize = toThenable(options.serialize);\n  const setItem = () => {\n    const state = options.partialize({ ...get3() });\n    let errorInSync;\n    const thenable = thenableSerialize({ state, version: options.version }).then(\n      (serializedValue) => storage.setItem(options.name, serializedValue)\n    ).catch((e4) => {\n      errorInSync = e4;\n    });\n    if (errorInSync) {\n      throw errorInSync;\n    }\n    return thenable;\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config2(\n    (...args) => {\n      set4(...args);\n      void setItem();\n    },\n    get3,\n    api\n  );\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a;\n    if (!storage)\n      return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => cb(get3()));\n    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get3())) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {\n      if (storageValue) {\n        return options.deserialize(storageValue);\n      }\n    }).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get3()) != null ? _a2 : configResult\n      );\n      set4(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e4) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e4);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.getStorage) {\n        storage = newOptions.getStorage();\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  hydrate();\n  return stateFromStorage || configResult;\n};\nvar newImpl = (config2, baseOptions) => (set4, get3, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config2(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set4(...args);\n      },\n      get3,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get3() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config2(\n    (...args) => {\n      set4(...args);\n      void setItem();\n    },\n    get3,\n    api\n  );\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a;\n    if (!storage)\n      return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => cb(get3()));\n    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get3())) || void 0;\n    return Promise.resolve(storage.getItem.bind(storage)(options.name)).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get3()) != null ? _a2 : configResult\n      );\n      set4(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e4) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e4);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  hydrate();\n  return stateFromStorage || configResult;\n};\nvar persistImpl = (config2, baseOptions) => {\n  if (\"getStorage\" in baseOptions || \"serialize\" in baseOptions || \"deserialize\" in baseOptions) {\n    console.warn(\n      \"[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Please use `storage` option instead.\"\n    );\n    return oldImpl(config2, baseOptions);\n  }\n  return newImpl(config2, baseOptions);\n};\nvar persist = persistImpl;\n\n// node_modules/@udecode/zustood/dist/index.es.js\nvar generateStateActions = (store, storeName) => {\n  const actions = {};\n  Object.keys(store.getState()).forEach((key) => {\n    actions[key] = (value) => {\n      const prevValue = store.getState()[key];\n      if (prevValue === value)\n        return;\n      const actionKey = key.replace(/^\\S/, (s5) => s5.toUpperCase());\n      store.setState((draft) => {\n        draft[key] = value;\n      }, `@@${storeName}/set${actionKey}`);\n    };\n  });\n  return actions;\n};\nvar extendActions = (builder, api) => {\n  const actions = builder(api.set, api.get, api);\n  return {\n    ...api,\n    set: {\n      ...api.set,\n      ...actions\n    }\n  };\n};\nvar extendSelectors = (builder, api) => {\n  const use = {\n    ...api.use\n  };\n  const useTracked = {\n    ...api.useTracked\n  };\n  const get3 = {\n    ...api.get\n  };\n  Object.keys(builder(api.store.getState(), api.get, api)).forEach((key) => {\n    use[key] = (...args) => api.useStore((state) => {\n      const selectors = builder(state, api.get, api);\n      const selector = selectors[key];\n      return selector(...args);\n    });\n    useTracked[key] = (...args) => {\n      const trackedState = api.useTrackedStore();\n      const selectors = builder(trackedState, api.get, api);\n      const selector = selectors[key];\n      return selector(...args);\n    };\n    get3[key] = (...args) => {\n      const selectors = builder(api.store.getState(), api.get, api);\n      const selector = selectors[key];\n      return selector(...args);\n    };\n  });\n  return {\n    ...api,\n    get: get3,\n    use,\n    useTracked\n  };\n};\nvar storeFactory = (api) => {\n  return {\n    ...api,\n    extendSelectors: (builder) => storeFactory(extendSelectors(builder, api)),\n    extendActions: (builder) => storeFactory(extendActions(builder, api))\n  };\n};\nvar generateStateGetSelectors = (store) => {\n  const selectors = {};\n  Object.keys(store.getState()).forEach((key) => {\n    selectors[key] = () => store.getState()[key];\n  });\n  return selectors;\n};\nvar generateStateHookSelectors = (store) => {\n  const selectors = {};\n  Object.keys(store.getState()).forEach((key) => {\n    selectors[key] = (equalityFn) => {\n      return store((state) => state[key], equalityFn);\n    };\n  });\n  return selectors;\n};\nvar generateStateTrackedHooksSelectors = (store, trackedStore) => {\n  const selectors = {};\n  Object.keys(store.getState()).forEach((key) => {\n    selectors[key] = () => {\n      return trackedStore()[key];\n    };\n  });\n  return selectors;\n};\nvar immerMiddleware = (config2) => (set4, get3, api) => {\n  const setState = (fn4, actionName) => set4(immer_esm_default(fn4), true, actionName);\n  api.setState = setState;\n  return config2(setState, get3, api);\n};\nfunction pipe(x4, ...fns) {\n  return fns.reduce((y5, fn4) => fn4(y5), x4);\n}\nvar createStore3 = (name) => (initialState3, options = {}) => {\n  var _immer$enabledAutoFre;\n  const {\n    middlewares: _middlewares = [],\n    devtools: devtools$1,\n    persist: persist$1,\n    immer\n  } = options;\n  sn((_immer$enabledAutoFre = immer === null || immer === void 0 ? void 0 : immer.enabledAutoFreeze) !== null && _immer$enabledAutoFre !== void 0 ? _immer$enabledAutoFre : false);\n  if (immer !== null && immer !== void 0 && immer.enableMapSet) {\n    C();\n  }\n  const middlewares = [immerMiddleware, ..._middlewares];\n  if (persist$1 !== null && persist$1 !== void 0 && persist$1.enabled) {\n    middlewares.push((config2) => persist(config2, {\n      ...persist$1,\n      name\n    }));\n  }\n  if (devtools$1 !== null && devtools$1 !== void 0 && devtools$1.enabled) {\n    middlewares.push((config2) => devtools(config2, {\n      ...devtools$1,\n      name\n    }));\n  }\n  middlewares.push(createStore2);\n  const createStore5 = (createState) => pipe(createState, ...middlewares);\n  const store = createStore5(() => initialState3);\n  const useStore2 = create2(store);\n  const stateActions = generateStateActions(useStore2, name);\n  const mergeState = (state, actionName) => {\n    store.setState((draft) => {\n      Object.assign(draft, state);\n    }, actionName || `@@${name}/mergeState`);\n  };\n  const setState = (fn4, actionName) => {\n    store.setState(fn4, actionName || `@@${name}/setState`);\n  };\n  const hookSelectors = generateStateHookSelectors(useStore2);\n  const getterSelectors = generateStateGetSelectors(useStore2);\n  const useTrackedStore = createTrackedSelector(useStore2);\n  const trackedHooksSelectors = generateStateTrackedHooksSelectors(useStore2, useTrackedStore);\n  const api = {\n    get: {\n      state: store.getState,\n      ...getterSelectors\n    },\n    name,\n    set: {\n      state: setState,\n      mergeState,\n      ...stateActions\n    },\n    store,\n    use: hookSelectors,\n    useTracked: trackedHooksSelectors,\n    useStore: useStore2,\n    useTrackedStore,\n    extendSelectors: () => api,\n    extendActions: () => api\n  };\n  return storeFactory(api);\n};\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nfunction createCommonjsModule(fn4, module2) {\n  return module2 = { exports: {} }, fn4(module2, module2.exports), module2.exports;\n}\nvar freeGlobal = typeof commonjsGlobal == \"object\" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\nvar _freeGlobal = freeGlobal;\nvar freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\nvar root = _freeGlobal || freeSelf || Function(\"return this\")();\nvar _root = root;\nvar Symbol2 = _root.Symbol;\nvar _Symbol = Symbol2;\nvar objectProto$b = Object.prototype;\nvar hasOwnProperty$8 = objectProto$b.hasOwnProperty;\nvar nativeObjectToString$1 = objectProto$b.toString;\nvar symToStringTag$1 = _Symbol ? _Symbol.toStringTag : void 0;\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty$8.call(value, symToStringTag$1), tag = value[symToStringTag$1];\n  try {\n    value[symToStringTag$1] = void 0;\n    var unmasked = true;\n  } catch (e4) {\n  }\n  var result = nativeObjectToString$1.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$1] = tag;\n    } else {\n      delete value[symToStringTag$1];\n    }\n  }\n  return result;\n}\nvar _getRawTag = getRawTag;\nvar objectProto$a = Object.prototype;\nvar nativeObjectToString = objectProto$a.toString;\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\nvar _objectToString = objectToString;\nvar nullTag = \"[object Null]\";\nvar undefinedTag = \"[object Undefined]\";\nvar symToStringTag = _Symbol ? _Symbol.toStringTag : void 0;\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === void 0 ? undefinedTag : nullTag;\n  }\n  return symToStringTag && symToStringTag in Object(value) ? _getRawTag(value) : _objectToString(value);\n}\nvar _baseGetTag = baseGetTag;\nfunction isObject2(value) {\n  var type = typeof value;\n  return value != null && (type == \"object\" || type == \"function\");\n}\nvar isObject_1 = isObject2;\nvar asyncTag = \"[object AsyncFunction]\";\nvar funcTag$1 = \"[object Function]\";\nvar genTag = \"[object GeneratorFunction]\";\nvar proxyTag = \"[object Proxy]\";\nfunction isFunction(value) {\n  if (!isObject_1(value)) {\n    return false;\n  }\n  var tag = _baseGetTag(value);\n  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\nvar isFunction_1 = isFunction;\nvar coreJsData = _root[\"__core-js_shared__\"];\nvar _coreJsData = coreJsData;\nvar maskSrcKey = function() {\n  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || \"\");\n  return uid ? \"Symbol(src)_1.\" + uid : \"\";\n}();\nfunction isMasked(func) {\n  return !!maskSrcKey && maskSrcKey in func;\n}\nvar _isMasked = isMasked;\nvar funcProto$1 = Function.prototype;\nvar funcToString$1 = funcProto$1.toString;\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString$1.call(func);\n    } catch (e4) {\n    }\n    try {\n      return func + \"\";\n    } catch (e4) {\n    }\n  }\n  return \"\";\n}\nvar _toSource = toSource;\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\nvar funcProto = Function.prototype;\nvar objectProto$9 = Object.prototype;\nvar funcToString = funcProto.toString;\nvar hasOwnProperty$7 = objectProto$9.hasOwnProperty;\nvar reIsNative = RegExp(\n  \"^\" + funcToString.call(hasOwnProperty$7).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n);\nfunction baseIsNative(value) {\n  if (!isObject_1(value) || _isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(_toSource(value));\n}\nvar _baseIsNative = baseIsNative;\nfunction getValue(object, key) {\n  return object == null ? void 0 : object[key];\n}\nvar _getValue = getValue;\nfunction getNative(object, key) {\n  var value = _getValue(object, key);\n  return _baseIsNative(value) ? value : void 0;\n}\nvar _getNative = getNative;\nvar defineProperty = function() {\n  try {\n    var func = _getNative(Object, \"defineProperty\");\n    func({}, \"\", {});\n    return func;\n  } catch (e4) {\n  }\n}();\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index5 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;\n    while (length--) {\n      var key = props[fromRight ? length : ++index5];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\nvar _createBaseFor = createBaseFor;\nvar baseFor = _createBaseFor();\nfunction isObjectLike(value) {\n  return value != null && typeof value == \"object\";\n}\nvar isObjectLike_1 = isObjectLike;\nvar argsTag$2 = \"[object Arguments]\";\nfunction baseIsArguments(value) {\n  return isObjectLike_1(value) && _baseGetTag(value) == argsTag$2;\n}\nvar _baseIsArguments = baseIsArguments;\nvar objectProto$8 = Object.prototype;\nvar hasOwnProperty$6 = objectProto$8.hasOwnProperty;\nvar propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;\nvar isArguments = _baseIsArguments(function() {\n  return arguments;\n}()) ? _baseIsArguments : function(value) {\n  return isObjectLike_1(value) && hasOwnProperty$6.call(value, \"callee\") && !propertyIsEnumerable$1.call(value, \"callee\");\n};\nvar isArray = Array.isArray;\nfunction stubFalse() {\n  return false;\n}\nvar stubFalse_1 = stubFalse;\nvar isBuffer_1 = createCommonjsModule(function(module2, exports2) {\n  var freeExports = exports2 && !exports2.nodeType && exports2;\n  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n  var Buffer2 = moduleExports ? _root.Buffer : void 0;\n  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;\n  var isBuffer = nativeIsBuffer || stubFalse_1;\n  module2.exports = isBuffer;\n});\nvar MAX_SAFE_INTEGER = 9007199254740991;\nfunction isLength(value) {\n  return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\nvar isLength_1 = isLength;\nvar argsTag$1 = \"[object Arguments]\";\nvar arrayTag$1 = \"[object Array]\";\nvar boolTag$1 = \"[object Boolean]\";\nvar dateTag$1 = \"[object Date]\";\nvar errorTag$1 = \"[object Error]\";\nvar funcTag = \"[object Function]\";\nvar mapTag$2 = \"[object Map]\";\nvar numberTag$1 = \"[object Number]\";\nvar objectTag$2 = \"[object Object]\";\nvar regexpTag$1 = \"[object RegExp]\";\nvar setTag$2 = \"[object Set]\";\nvar stringTag$1 = \"[object String]\";\nvar weakMapTag$1 = \"[object WeakMap]\";\nvar arrayBufferTag$1 = \"[object ArrayBuffer]\";\nvar dataViewTag$2 = \"[object DataView]\";\nvar float32Tag = \"[object Float32Array]\";\nvar float64Tag = \"[object Float64Array]\";\nvar int8Tag = \"[object Int8Array]\";\nvar int16Tag = \"[object Int16Array]\";\nvar int32Tag = \"[object Int32Array]\";\nvar uint8Tag = \"[object Uint8Array]\";\nvar uint8ClampedTag = \"[object Uint8ClampedArray]\";\nvar uint16Tag = \"[object Uint16Array]\";\nvar uint32Tag = \"[object Uint32Array]\";\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;\nfunction baseIsTypedArray(value) {\n  return isObjectLike_1(value) && isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];\n}\nvar _baseIsTypedArray = baseIsTypedArray;\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\nvar _baseUnary = baseUnary;\nvar _nodeUtil = createCommonjsModule(function(module2, exports2) {\n  var freeExports = exports2 && !exports2.nodeType && exports2;\n  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n  var freeProcess = moduleExports && _freeGlobal.process;\n  var nodeUtil = function() {\n    try {\n      var types = freeModule && freeModule.require && freeModule.require(\"util\").types;\n      if (types) {\n        return types;\n      }\n      return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n    } catch (e4) {\n    }\n  }();\n  module2.exports = nodeUtil;\n});\nvar nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;\nvar isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;\nvar objectProto$7 = Object.prototype;\nvar hasOwnProperty$5 = objectProto$7.hasOwnProperty;\nvar objectProto$6 = Object.prototype;\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\nvar _overArg = overArg;\nvar nativeKeys = _overArg(Object.keys, Object);\nvar objectProto$5 = Object.prototype;\nvar hasOwnProperty$4 = objectProto$5.hasOwnProperty;\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\nvar _listCacheClear = listCacheClear;\nfunction eq(value, other) {\n  return value === other || value !== value && other !== other;\n}\nvar eq_1 = eq;\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq_1(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\nvar _assocIndexOf = assocIndexOf;\nvar arrayProto = Array.prototype;\nvar splice = arrayProto.splice;\nfunction listCacheDelete(key) {\n  var data = this.__data__, index5 = _assocIndexOf(data, key);\n  if (index5 < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index5 == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index5, 1);\n  }\n  --this.size;\n  return true;\n}\nvar _listCacheDelete = listCacheDelete;\nfunction listCacheGet(key) {\n  var data = this.__data__, index5 = _assocIndexOf(data, key);\n  return index5 < 0 ? void 0 : data[index5][1];\n}\nvar _listCacheGet = listCacheGet;\nfunction listCacheHas(key) {\n  return _assocIndexOf(this.__data__, key) > -1;\n}\nvar _listCacheHas = listCacheHas;\nfunction listCacheSet(key, value) {\n  var data = this.__data__, index5 = _assocIndexOf(data, key);\n  if (index5 < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index5][1] = value;\n  }\n  return this;\n}\nvar _listCacheSet = listCacheSet;\nfunction ListCache(entries) {\n  var index5 = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index5 < length) {\n    var entry = entries[index5];\n    this.set(entry[0], entry[1]);\n  }\n}\nListCache.prototype.clear = _listCacheClear;\nListCache.prototype[\"delete\"] = _listCacheDelete;\nListCache.prototype.get = _listCacheGet;\nListCache.prototype.has = _listCacheHas;\nListCache.prototype.set = _listCacheSet;\nvar _ListCache = ListCache;\nfunction stackClear() {\n  this.__data__ = new _ListCache();\n  this.size = 0;\n}\nvar _stackClear = stackClear;\nfunction stackDelete(key) {\n  var data = this.__data__, result = data[\"delete\"](key);\n  this.size = data.size;\n  return result;\n}\nvar _stackDelete = stackDelete;\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\nvar _stackGet = stackGet;\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\nvar _stackHas = stackHas;\nvar Map2 = _getNative(_root, \"Map\");\nvar _Map = Map2;\nvar nativeCreate = _getNative(Object, \"create\");\nvar _nativeCreate = nativeCreate;\nfunction hashClear() {\n  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};\n  this.size = 0;\n}\nvar _hashClear = hashClear;\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\nvar _hashDelete = hashDelete;\nvar HASH_UNDEFINED$2 = \"__lodash_hash_undefined__\";\nvar objectProto$4 = Object.prototype;\nvar hasOwnProperty$3 = objectProto$4.hasOwnProperty;\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (_nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED$2 ? void 0 : result;\n  }\n  return hasOwnProperty$3.call(data, key) ? data[key] : void 0;\n}\nvar _hashGet = hashGet;\nvar objectProto$3 = Object.prototype;\nvar hasOwnProperty$2 = objectProto$3.hasOwnProperty;\nfunction hashHas(key) {\n  var data = this.__data__;\n  return _nativeCreate ? data[key] !== void 0 : hasOwnProperty$2.call(data, key);\n}\nvar _hashHas = hashHas;\nvar HASH_UNDEFINED$1 = \"__lodash_hash_undefined__\";\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = _nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;\n  return this;\n}\nvar _hashSet = hashSet;\nfunction Hash(entries) {\n  var index5 = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index5 < length) {\n    var entry = entries[index5];\n    this.set(entry[0], entry[1]);\n  }\n}\nHash.prototype.clear = _hashClear;\nHash.prototype[\"delete\"] = _hashDelete;\nHash.prototype.get = _hashGet;\nHash.prototype.has = _hashHas;\nHash.prototype.set = _hashSet;\nvar _Hash = Hash;\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    \"hash\": new _Hash(),\n    \"map\": new (_Map || _ListCache)(),\n    \"string\": new _Hash()\n  };\n}\nvar _mapCacheClear = mapCacheClear;\nfunction isKeyable(value) {\n  var type = typeof value;\n  return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n}\nvar _isKeyable = isKeyable;\nfunction getMapData(map2, key) {\n  var data = map2.__data__;\n  return _isKeyable(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n}\nvar _getMapData = getMapData;\nfunction mapCacheDelete(key) {\n  var result = _getMapData(this, key)[\"delete\"](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\nvar _mapCacheDelete = mapCacheDelete;\nfunction mapCacheGet(key) {\n  return _getMapData(this, key).get(key);\n}\nvar _mapCacheGet = mapCacheGet;\nfunction mapCacheHas(key) {\n  return _getMapData(this, key).has(key);\n}\nvar _mapCacheHas = mapCacheHas;\nfunction mapCacheSet(key, value) {\n  var data = _getMapData(this, key), size = data.size;\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\nvar _mapCacheSet = mapCacheSet;\nfunction MapCache(entries) {\n  var index5 = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index5 < length) {\n    var entry = entries[index5];\n    this.set(entry[0], entry[1]);\n  }\n}\nMapCache.prototype.clear = _mapCacheClear;\nMapCache.prototype[\"delete\"] = _mapCacheDelete;\nMapCache.prototype.get = _mapCacheGet;\nMapCache.prototype.has = _mapCacheHas;\nMapCache.prototype.set = _mapCacheSet;\nvar _MapCache = MapCache;\nvar LARGE_ARRAY_SIZE = 200;\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof _ListCache) {\n    var pairs = data.__data__;\n    if (!_Map || pairs.length < LARGE_ARRAY_SIZE - 1) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new _MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\nvar _stackSet = stackSet;\nfunction Stack(entries) {\n  var data = this.__data__ = new _ListCache(entries);\n  this.size = data.size;\n}\nStack.prototype.clear = _stackClear;\nStack.prototype[\"delete\"] = _stackDelete;\nStack.prototype.get = _stackGet;\nStack.prototype.has = _stackHas;\nStack.prototype.set = _stackSet;\nvar HASH_UNDEFINED = \"__lodash_hash_undefined__\";\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\nvar _setCacheAdd = setCacheAdd;\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\nvar _setCacheHas = setCacheHas;\nfunction SetCache(values2) {\n  var index5 = -1, length = values2 == null ? 0 : values2.length;\n  this.__data__ = new _MapCache();\n  while (++index5 < length) {\n    this.add(values2[index5]);\n  }\n}\nSetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;\nSetCache.prototype.has = _setCacheHas;\nvar Uint8Array2 = _root.Uint8Array;\nvar symbolProto$1 = _Symbol ? _Symbol.prototype : void 0;\nvar symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;\nvar objectProto$2 = Object.prototype;\nvar propertyIsEnumerable = objectProto$2.propertyIsEnumerable;\nvar objectProto$1 = Object.prototype;\nvar hasOwnProperty$1 = objectProto$1.hasOwnProperty;\nvar DataView = _getNative(_root, \"DataView\");\nvar _DataView = DataView;\nvar Promise$1 = _getNative(_root, \"Promise\");\nvar _Promise = Promise$1;\nvar Set2 = _getNative(_root, \"Set\");\nvar _Set = Set2;\nvar WeakMap2 = _getNative(_root, \"WeakMap\");\nvar _WeakMap = WeakMap2;\nvar mapTag = \"[object Map]\";\nvar objectTag$1 = \"[object Object]\";\nvar promiseTag = \"[object Promise]\";\nvar setTag = \"[object Set]\";\nvar weakMapTag = \"[object WeakMap]\";\nvar dataViewTag = \"[object DataView]\";\nvar dataViewCtorString = _toSource(_DataView);\nvar mapCtorString = _toSource(_Map);\nvar promiseCtorString = _toSource(_Promise);\nvar setCtorString = _toSource(_Set);\nvar weakMapCtorString = _toSource(_WeakMap);\nvar getTag = _baseGetTag;\nif (_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag || _Map && getTag(new _Map()) != mapTag || _Promise && getTag(_Promise.resolve()) != promiseTag || _Set && getTag(new _Set()) != setTag || _WeakMap && getTag(new _WeakMap()) != weakMapTag) {\n  getTag = function(value) {\n    var result = _baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? _toSource(Ctor) : \"\";\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString:\n          return dataViewTag;\n        case mapCtorString:\n          return mapTag;\n        case promiseCtorString:\n          return promiseTag;\n        case setCtorString:\n          return setTag;\n        case weakMapCtorString:\n          return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\nvar objectProto = Object.prototype;\nvar hasOwnProperty = objectProto.hasOwnProperty;\nvar FUNC_ERROR_TEXT = \"Expected a function\";\nfunction memoize(func, resolver) {\n  if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;\n    if (cache2.has(key)) {\n      return cache2.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache2.set(key, result) || cache2;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || _MapCache)();\n  return memoized;\n}\nmemoize.Cache = _MapCache;\nvar memoize_1 = memoize;\nvar MAX_MEMOIZE_SIZE = 500;\nfunction memoizeCapped(func) {\n  var result = memoize_1(func, function(key) {\n    if (cache2.size === MAX_MEMOIZE_SIZE) {\n      cache2.clear();\n    }\n    return key;\n  });\n  var cache2 = result.cache;\n  return result;\n}\nvar _memoizeCapped = memoizeCapped;\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g;\nvar stringToPath = _memoizeCapped(function(string2) {\n  var result = [];\n  if (string2.charCodeAt(0) === 46) {\n    result.push(\"\");\n  }\n  string2.replace(rePropName, function(match2, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, \"$1\") : number || match2);\n  });\n  return result;\n});\nvar INFINITY$1 = 1 / 0;\nvar symbolProto = _Symbol ? _Symbol.prototype : void 0;\nvar symbolToString = symbolProto ? symbolProto.toString : void 0;\nvar INFINITY = 1 / 0;\n\n// node_modules/slate-history/dist/index.es.js\nvar History = {\n  /**\n   * Check if a value is a `History` object.\n   */\n  isHistory(value) {\n    return isPlainObject(value) && Array.isArray(value.redos) && Array.isArray(value.undos) && (value.redos.length === 0 || Operation.isOperationList(value.redos[0])) && (value.undos.length === 0 || Operation.isOperationList(value.undos[0]));\n  }\n};\nvar SAVING = /* @__PURE__ */ new WeakMap();\nvar MERGING = /* @__PURE__ */ new WeakMap();\nvar HistoryEditor = {\n  /**\n   * Check if a value is a `HistoryEditor` object.\n   */\n  isHistoryEditor(value) {\n    return History.isHistory(value.history) && Editor.isEditor(value);\n  },\n  /**\n   * Get the merge flag's current value.\n   */\n  isMerging(editor) {\n    return MERGING.get(editor);\n  },\n  /**\n   * Get the saving flag's current value.\n   */\n  isSaving(editor) {\n    return SAVING.get(editor);\n  },\n  /**\n   * Redo to the previous saved state.\n   */\n  redo(editor) {\n    editor.redo();\n  },\n  /**\n   * Undo to the previous saved state.\n   */\n  undo(editor) {\n    editor.undo();\n  },\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\n   * the new operations into previous save point in the history.\n   */\n  withoutMerging(editor, fn4) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, false);\n    fn4();\n    MERGING.set(editor, prev);\n  },\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\n   * their operations into the history.\n   */\n  withoutSaving(editor, fn4) {\n    var prev = HistoryEditor.isSaving(editor);\n    SAVING.set(editor, false);\n    fn4();\n    SAVING.set(editor, prev);\n  }\n};\nvar withHistory = (editor) => {\n  var e4 = editor;\n  var {\n    apply: apply2\n  } = e4;\n  e4.history = {\n    undos: [],\n    redos: []\n  };\n  e4.redo = () => {\n    var {\n      history\n    } = e4;\n    var {\n      redos\n    } = history;\n    if (redos.length > 0) {\n      var batch = redos[redos.length - 1];\n      HistoryEditor.withoutSaving(e4, () => {\n        Editor.withoutNormalizing(e4, () => {\n          for (var op of batch) {\n            e4.apply(op);\n          }\n        });\n      });\n      history.redos.pop();\n      history.undos.push(batch);\n    }\n  };\n  e4.undo = () => {\n    var {\n      history\n    } = e4;\n    var {\n      undos\n    } = history;\n    if (undos.length > 0) {\n      var batch = undos[undos.length - 1];\n      HistoryEditor.withoutSaving(e4, () => {\n        Editor.withoutNormalizing(e4, () => {\n          var inverseOps = batch.map(Operation.inverse).reverse();\n          for (var op of inverseOps) {\n            e4.apply(op);\n          }\n        });\n      });\n      history.redos.push(batch);\n      history.undos.pop();\n    }\n  };\n  e4.apply = (op) => {\n    var {\n      operations,\n      history\n    } = e4;\n    var {\n      undos\n    } = history;\n    var lastBatch = undos[undos.length - 1];\n    var lastOp = lastBatch && lastBatch[lastBatch.length - 1];\n    var overwrite = shouldOverwrite(op, lastOp);\n    var save = HistoryEditor.isSaving(e4);\n    var merge2 = HistoryEditor.isMerging(e4);\n    if (save == null) {\n      save = shouldSave(op);\n    }\n    if (save) {\n      if (merge2 == null) {\n        if (lastBatch == null) {\n          merge2 = false;\n        } else if (operations.length !== 0) {\n          merge2 = true;\n        } else {\n          merge2 = shouldMerge(op, lastOp) || overwrite;\n        }\n      }\n      if (lastBatch && merge2) {\n        if (overwrite) {\n          lastBatch.pop();\n        }\n        lastBatch.push(op);\n      } else {\n        var batch = [op];\n        undos.push(batch);\n      }\n      while (undos.length > 100) {\n        undos.shift();\n      }\n      if (shouldClear(op)) {\n        history.redos = [];\n      }\n    }\n    apply2(op);\n  };\n  return e4;\n};\nvar shouldMerge = (op, prev) => {\n  if (op.type === \"set_selection\") {\n    return true;\n  }\n  if (prev && op.type === \"insert_text\" && prev.type === \"insert_text\" && op.offset === prev.offset + prev.text.length && Path.equals(op.path, prev.path)) {\n    return true;\n  }\n  if (prev && op.type === \"remove_text\" && prev.type === \"remove_text\" && op.offset + op.text.length === prev.offset && Path.equals(op.path, prev.path)) {\n    return true;\n  }\n  return false;\n};\nvar shouldSave = (op, prev) => {\n  if (op.type === \"set_selection\" && (op.properties == null || op.newProperties == null)) {\n    return false;\n  }\n  return true;\n};\nvar shouldOverwrite = (op, prev) => {\n  if (prev && op.type === \"set_selection\" && prev.type === \"set_selection\") {\n    return true;\n  }\n  return false;\n};\nvar shouldClear = (op) => {\n  if (op.type === \"set_selection\") {\n    return false;\n  }\n  return true;\n};\n\n// node_modules/use-deep-compare/dist-web/index.js\nvar import_react6 = __toESM(require(\"react\"));\n\n// node_modules/use-deep-compare/node_modules/dequal/dist/dequal.mjs\nfunction dequal(foo, bar) {\n  var ctor, len;\n  if (foo === bar)\n    return true;\n  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {\n    if (ctor === Date)\n      return foo.getTime() === bar.getTime();\n    if (ctor === RegExp)\n      return foo.toString() === bar.toString();\n    if (ctor === Array && (len = foo.length) === bar.length) {\n      while (len-- && dequal(foo[len], bar[len]))\n        ;\n      return len === -1;\n    }\n    if (ctor === Object) {\n      if (Object.keys(foo).length !== Object.keys(bar).length)\n        return false;\n      for (len in foo)\n        if (!(len in bar) || !dequal(foo[len], bar[len]))\n          return false;\n      return true;\n    }\n  }\n  return foo !== foo && bar !== bar;\n}\n\n// node_modules/use-deep-compare/dist-web/index.js\nfunction checkDeps(deps, name) {\n  const reactHookName = `React.${name.replace(/DeepCompare/, \"\")}`;\n  if (!deps || deps.length === 0) {\n    throw new Error(`${name} should not be used with no dependencies. Use ${reactHookName} instead.`);\n  }\n}\nfunction useDeepCompareMemoize(value) {\n  const ref = import_react6.default.useRef([]);\n  if (!dequal(value, ref.current)) {\n    ref.current = value;\n  }\n  return ref.current;\n}\nfunction useDeepCompareEffect(effect5, dependencies) {\n  if (true) {\n    checkDeps(dependencies, \"useDeepCompareEffect\");\n  }\n  import_react6.default.useEffect(effect5, useDeepCompareMemoize(dependencies));\n}\nfunction useDeepCompareMemo(factory, dependencies) {\n  if (true) {\n    checkDeps(dependencies, \"useDeepCompareMemo\");\n  }\n  return import_react6.default.useMemo(factory, useDeepCompareMemoize(dependencies));\n}\n\n// node_modules/clsx/dist/clsx.m.js\nfunction r4(e4) {\n  var t6, f5, n8 = \"\";\n  if (\"string\" == typeof e4 || \"number\" == typeof e4)\n    n8 += e4;\n  else if (\"object\" == typeof e4)\n    if (Array.isArray(e4))\n      for (t6 = 0; t6 < e4.length; t6++)\n        e4[t6] && (f5 = r4(e4[t6])) && (n8 && (n8 += \" \"), n8 += f5);\n    else\n      for (t6 in e4)\n        e4[t6] && (n8 && (n8 += \" \"), n8 += t6);\n  return n8;\n}\nfunction clsx() {\n  for (var e4, t6, f5 = 0, n8 = \"\"; f5 < arguments.length; )\n    (e4 = arguments[f5++]) && (t6 = r4(e4)) && (n8 && (n8 += \" \"), n8 += t6);\n  return n8;\n}\nvar clsx_m_default = clsx;\n\n// node_modules/@radix-ui/react-compose-refs/dist/index.module.js\nvar o3 = __toESM(require(\"react\"));\nfunction composeRefs(...o7) {\n  return (e4) => o7.forEach((o8) => function(o9, e5) {\n    \"function\" == typeof o9 ? o9(e5) : null != o9 && (o9.current = e5);\n  }(o8, e4));\n}\n\n// node_modules/@radix-ui/react-slot/dist/index.module.js\nvar t4 = __toESM(require(\"react\"));\n\n// node_modules/@babel/runtime/helpers/esm/extends.js\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i5 = 1; i5 < arguments.length; i5++) {\n      var source = arguments[i5];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// node_modules/@radix-ui/react-slot/dist/index.module.js\nvar Slot = /* @__PURE__ */ t4.forwardRef((e4, o7) => {\n  const { children: a7, ...s5 } = e4;\n  return t4.Children.toArray(a7).some(l3) ? /* @__PURE__ */ t4.createElement(t4.Fragment, null, t4.Children.map(a7, (e5) => l3(e5) ? /* @__PURE__ */ t4.createElement(n5, _extends({}, s5, { ref: o7 }), e5.props.children) : e5)) : /* @__PURE__ */ t4.createElement(n5, _extends({}, s5, { ref: o7 }), a7);\n});\nSlot.displayName = \"Slot\";\nvar n5 = /* @__PURE__ */ t4.forwardRef((r7, n8) => {\n  const { children: l6, ...a7 } = r7;\n  return t4.isValidElement(l6) ? /* @__PURE__ */ t4.cloneElement(l6, { ...o4(a7, l6.props), ref: composeRefs(n8, l6.ref) }) : t4.Children.count(l6) > 1 ? t4.Children.only(null) : null;\n});\nn5.displayName = \"SlotClone\";\nvar Slottable = ({ children: e4 }) => /* @__PURE__ */ t4.createElement(t4.Fragment, null, e4);\nfunction l3(e4) {\n  return t4.isValidElement(e4) && e4.type === Slottable;\n}\nfunction o4(e4, t6) {\n  const r7 = { ...t6 };\n  for (const n8 in t6) {\n    const l6 = e4[n8], o7 = t6[n8];\n    /^on[A-Z]/.test(n8) ? r7[n8] = (...e5) => {\n      null == o7 || o7(...e5), null == l6 || l6(...e5);\n    } : \"style\" === n8 ? r7[n8] = { ...l6, ...o7 } : \"className\" === n8 && (r7[n8] = [l6, o7].filter(Boolean).join(\" \"));\n  }\n  return { ...e4, ...r7 };\n}\n\n// node_modules/@udecode/plate-core/dist/index.es.js\nvar capitalizeFirstLetter = (str = \"\") => str.length ? str[0].toUpperCase() + str.slice(1) : \"\";\nvar getStoreIndex = (name = \"\") => name.length ? `${name}Store` : \"store\";\nvar getUseStoreIndex = (name = \"\") => `use${capitalizeFirstLetter(name)}Store`;\nvar createAtomStore = (initialState3, {\n  scope: storeScope,\n  initialStore,\n  name = \"\"\n} = {}) => {\n  const useInitialStoreIndex = getUseStoreIndex(initialStore === null || initialStore === void 0 ? void 0 : initialStore.name);\n  const initialStoreIndex = getStoreIndex(initialStore === null || initialStore === void 0 ? void 0 : initialStore.name);\n  const useStoreIndex = getUseStoreIndex(name);\n  const storeIndex = getStoreIndex(name);\n  const getAtoms = initialStore ? initialStore[useInitialStoreIndex]().get : {};\n  const setAtoms = initialStore ? initialStore[useInitialStoreIndex]().set : {};\n  const useAtoms = initialStore ? initialStore[useInitialStoreIndex]().use : {};\n  const atoms = initialStore ? initialStore[initialStoreIndex].atom : {};\n  Object.keys(initialState3).forEach((key) => {\n    const atomConfig = atom(initialState3[key]);\n    atoms[key] = atomConfig;\n    getAtoms[key] = (scope2) => {\n      return useAtomValue(atomConfig, scope2 !== null && scope2 !== void 0 ? scope2 : storeScope);\n    };\n    setAtoms[key] = (scope2) => {\n      return useSetAtom(atomConfig, scope2 !== null && scope2 !== void 0 ? scope2 : storeScope);\n    };\n    useAtoms[key] = (scope2) => {\n      return useAtom(atomConfig, scope2 !== null && scope2 !== void 0 ? scope2 : storeScope);\n    };\n  });\n  const api = {\n    [useStoreIndex]: () => ({\n      get: getAtoms,\n      set: setAtoms,\n      use: useAtoms\n    }),\n    [storeIndex]: {\n      atom: atoms\n    },\n    name\n  };\n  return {\n    ...api,\n    [storeIndex]: {\n      ...api[storeIndex],\n      scope: storeScope,\n      extend: (extendedState, options) => createAtomStore(extendedState, {\n        scope: storeScope,\n        initialStore: api,\n        ...options\n      })\n    }\n  };\n};\nfunction _extends2() {\n  _extends2 = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i5 = 1; i5 < arguments.length; i5++) {\n      var source = arguments[i5];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends2.apply(this, arguments);\n}\nvar DOM_HANDLERS = [\n  // Clipboard Events\n  \"onCopy\",\n  \"onCopyCapture\",\n  \"onCut\",\n  \"onCutCapture\",\n  \"onPaste\",\n  \"onPasteCapture\",\n  // Composition Events\n  \"onCompositionEnd\",\n  \"onCompositionEndCapture\",\n  \"onCompositionStart\",\n  \"onCompositionStartCapture\",\n  \"onCompositionUpdate\",\n  \"onCompositionUpdateCapture\",\n  // Focus Events\n  \"onFocus\",\n  \"onFocusCapture\",\n  \"onBlur\",\n  \"onBlurCapture\",\n  // Form Events\n  \"onDOMBeforeInput\",\n  \"onBeforeInput\",\n  \"onBeforeInputCapture\",\n  \"onInput\",\n  \"onInputCapture\",\n  \"onReset\",\n  \"onResetCapture\",\n  \"onSubmit\",\n  \"onSubmitCapture\",\n  \"onInvalid\",\n  \"onInvalidCapture\",\n  // Image Events\n  \"onLoad\",\n  \"onLoadCapture\",\n  // Keyboard Events\n  \"onKeyDown\",\n  \"onKeyDownCapture\",\n  \"onKeyPress\",\n  \"onKeyPressCapture\",\n  \"onKeyUp\",\n  \"onKeyUpCapture\",\n  // Media Events\n  \"onAbort\",\n  \"onAbortCapture\",\n  \"onCanPlay\",\n  \"onCanPlayCapture\",\n  \"onCanPlayThrough\",\n  \"onCanPlayThroughCapture\",\n  \"onDurationChange\",\n  \"onDurationChangeCapture\",\n  \"onEmptied\",\n  \"onEmptiedCapture\",\n  \"onEncrypted\",\n  \"onEncryptedCapture\",\n  \"onEnded\",\n  \"onEndedCapture\",\n  \"onLoadedData\",\n  \"onLoadedDataCapture\",\n  \"onLoadedMetadata\",\n  \"onLoadedMetadataCapture\",\n  \"onLoadStart\",\n  \"onLoadStartCapture\",\n  \"onPause\",\n  \"onPauseCapture\",\n  \"onPlay\",\n  \"onPlayCapture\",\n  \"onPlaying\",\n  \"onPlayingCapture\",\n  \"onProgress\",\n  \"onProgressCapture\",\n  \"onRateChange\",\n  \"onRateChangeCapture\",\n  \"onSeeked\",\n  \"onSeekedCapture\",\n  \"onSeeking\",\n  \"onSeekingCapture\",\n  \"onStalled\",\n  \"onStalledCapture\",\n  \"onSuspend\",\n  \"onSuspendCapture\",\n  \"onTimeUpdate\",\n  \"onTimeUpdateCapture\",\n  \"onVolumeChange\",\n  \"onVolumeChangeCapture\",\n  \"onWaiting\",\n  \"onWaitingCapture\",\n  // MouseEvents\n  \"onAuxClick\",\n  \"onAuxClickCapture\",\n  \"onClick\",\n  \"onClickCapture\",\n  \"onContextMenu\",\n  \"onContextMenuCapture\",\n  \"onDoubleClick\",\n  \"onDoubleClickCapture\",\n  \"onDrag\",\n  \"onDragCapture\",\n  \"onDragEnd\",\n  \"onDragEndCapture\",\n  \"onDragEnter\",\n  \"onDragEnterCapture\",\n  \"onDragExit\",\n  \"onDragExitCapture\",\n  \"onDragLeave\",\n  \"onDragLeaveCapture\",\n  \"onDragOver\",\n  \"onDragOverCapture\",\n  \"onDragStart\",\n  \"onDragStartCapture\",\n  \"onDrop\",\n  \"onDropCapture\",\n  \"onMouseDown\",\n  \"onMouseDownCapture\",\n  \"onMouseEnter\",\n  \"onMouseLeave\",\n  \"onMouseMove\",\n  \"onMouseMoveCapture\",\n  \"onMouseOut\",\n  \"onMouseOutCapture\",\n  \"onMouseOver\",\n  \"onMouseOverCapture\",\n  \"onMouseUp\",\n  \"onMouseUpCapture\",\n  // Selection Events\n  \"onSelect\",\n  \"onSelectCapture\",\n  // Touch Events\n  \"onTouchCancel\",\n  \"onTouchCancelCapture\",\n  \"onTouchEnd\",\n  \"onTouchEndCapture\",\n  \"onTouchMove\",\n  \"onTouchMoveCapture\",\n  \"onTouchStart\",\n  \"onTouchStartCapture\",\n  // Pointer Events\n  \"onPointerDown\",\n  \"onPointerDownCapture\",\n  \"onPointerMove\",\n  \"onPointerMoveCapture\",\n  \"onPointerUp\",\n  \"onPointerUpCapture\",\n  \"onPointerCancel\",\n  \"onPointerCancelCapture\",\n  \"onPointerEnter\",\n  \"onPointerEnterCapture\",\n  \"onPointerLeave\",\n  \"onPointerLeaveCapture\",\n  \"onPointerOver\",\n  \"onPointerOverCapture\",\n  \"onPointerOut\",\n  \"onPointerOutCapture\",\n  \"onGotPointerCapture\",\n  \"onGotPointerCaptureCapture\",\n  \"onLostPointerCapture\",\n  \"onLostPointerCaptureCapture\",\n  // UI Events\n  \"onScroll\",\n  \"onScrollCapture\",\n  // Wheel Events\n  \"onWheel\",\n  \"onWheelCapture\",\n  // Animation Events\n  \"onAnimationStart\",\n  \"onAnimationStartCapture\",\n  \"onAnimationEnd\",\n  \"onAnimationEndCapture\",\n  \"onAnimationIteration\",\n  \"onAnimationIterationCapture\",\n  // Transition Events\n  \"onTransitionEnd\",\n  \"onTransitionEndCapture\"\n];\nvar IS_APPLE2 = typeof navigator !== \"undefined\" && /Mac OS X/.test(navigator.userAgent);\nvar escapeRegExp = (text4) => {\n  return text4.replace(/[-[\\]{}()*+?.,\\\\^$|#\\\\s]/g, \"\\\\$&\");\n};\nvar findHtmlParentElement = (el, nodeName) => {\n  if (!el || el.nodeName === nodeName) {\n    return el;\n  }\n  return findHtmlParentElement(el.parentElement, nodeName);\n};\nvar getHandler = (cb, ...args) => () => {\n  cb === null || cb === void 0 ? void 0 : cb(...args);\n};\nvar getSlateClass = (type) => `slate-${type}`;\nvar commonjsGlobal2 = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nfunction unwrapExports(x4) {\n  return x4 && x4.__esModule && Object.prototype.hasOwnProperty.call(x4, \"default\") ? x4[\"default\"] : x4;\n}\nfunction createCommonjsModule2(fn4, module2) {\n  return module2 = { exports: {} }, fn4(module2, module2.exports), module2.exports;\n}\nvar lib = createCommonjsModule2(function(module2, exports2) {\n  Object.defineProperty(exports2, \"__esModule\", {\n    value: true\n  });\n  var IS_MAC = () => typeof window != \"undefined\" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n  var MODIFIERS = {\n    alt: \"altKey\",\n    control: \"ctrlKey\",\n    meta: \"metaKey\",\n    shift: \"shiftKey\"\n  };\n  var ALIASES = () => ({\n    add: \"+\",\n    break: \"pause\",\n    cmd: \"meta\",\n    command: \"meta\",\n    ctl: \"control\",\n    ctrl: \"control\",\n    del: \"delete\",\n    down: \"arrowdown\",\n    esc: \"escape\",\n    ins: \"insert\",\n    left: \"arrowleft\",\n    mod: IS_MAC() ? \"meta\" : \"control\",\n    opt: \"alt\",\n    option: \"alt\",\n    return: \"enter\",\n    right: \"arrowright\",\n    space: \" \",\n    spacebar: \" \",\n    up: \"arrowup\",\n    win: \"meta\",\n    windows: \"meta\"\n  });\n  var CODES = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    shift: 16,\n    control: 17,\n    alt: 18,\n    pause: 19,\n    capslock: 20,\n    escape: 27,\n    \" \": 32,\n    pageup: 33,\n    pagedown: 34,\n    end: 35,\n    home: 36,\n    arrowleft: 37,\n    arrowup: 38,\n    arrowright: 39,\n    arrowdown: 40,\n    insert: 45,\n    delete: 46,\n    meta: 91,\n    numlock: 144,\n    scrolllock: 145,\n    \";\": 186,\n    \"=\": 187,\n    \",\": 188,\n    \"-\": 189,\n    \".\": 190,\n    \"/\": 191,\n    \"`\": 192,\n    \"[\": 219,\n    \"\\\\\": 220,\n    \"]\": 221,\n    \"'\": 222\n  };\n  for (var f5 = 1; f5 < 20; f5++) {\n    CODES[\"f\" + f5] = 111 + f5;\n  }\n  function isHotkey9(hotkey, options, event) {\n    if (options && !(\"byKey\" in options)) {\n      event = options;\n      options = null;\n    }\n    if (!Array.isArray(hotkey)) {\n      hotkey = [hotkey];\n    }\n    var array = hotkey.map(function(string2) {\n      return parseHotkey(string2, options);\n    });\n    var check = function check2(e4) {\n      return array.some(function(object) {\n        return compareHotkey(object, e4);\n      });\n    };\n    var ret = event == null ? check : check(event);\n    return ret;\n  }\n  function isCodeHotkey(hotkey, event) {\n    return isHotkey9(hotkey, event);\n  }\n  function isKeyHotkey2(hotkey, event) {\n    return isHotkey9(hotkey, { byKey: true }, event);\n  }\n  function parseHotkey(hotkey, options) {\n    var byKey = options && options.byKey;\n    var ret = {};\n    hotkey = hotkey.replace(\"++\", \"+add\");\n    var values2 = hotkey.split(\"+\");\n    var length = values2.length;\n    for (var k3 in MODIFIERS) {\n      ret[MODIFIERS[k3]] = false;\n    }\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = void 0;\n    try {\n      for (var _iterator = values2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var value = _step.value;\n        var optional = value.endsWith(\"?\") && value.length > 1;\n        if (optional) {\n          value = value.slice(0, -1);\n        }\n        var name = toKeyName(value);\n        var modifier = MODIFIERS[name];\n        if (length === 1 || !modifier) {\n          if (byKey) {\n            ret.key = name;\n          } else {\n            ret.which = toKeyCode(value);\n          }\n        }\n        if (modifier) {\n          ret[modifier] = optional ? null : true;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    return ret;\n  }\n  function compareHotkey(object, event) {\n    for (var key in object) {\n      var expected = object[key];\n      var actual = void 0;\n      if (expected == null) {\n        continue;\n      }\n      if (key === \"key\" && event.key != null) {\n        actual = event.key.toLowerCase();\n      } else if (key === \"which\") {\n        actual = expected === 91 && event.which === 93 ? 91 : event.which;\n      } else {\n        actual = event[key];\n      }\n      if (actual == null && expected === false) {\n        continue;\n      }\n      if (actual !== expected) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function toKeyCode(name) {\n    name = toKeyName(name);\n    var code3 = CODES[name] || name.toUpperCase().charCodeAt(0);\n    return code3;\n  }\n  function toKeyName(name) {\n    name = name.toLowerCase();\n    name = ALIASES()[name] || name;\n    return name;\n  }\n  exports2.default = isHotkey9;\n  exports2.isHotkey = isHotkey9;\n  exports2.isCodeHotkey = isCodeHotkey;\n  exports2.isKeyHotkey = isKeyHotkey2;\n  exports2.parseHotkey = parseHotkey;\n  exports2.compareHotkey = compareHotkey;\n  exports2.toKeyCode = toKeyCode;\n  exports2.toKeyName = toKeyName;\n});\nvar isHotkey = unwrapExports(lib);\nlib.isHotkey;\nlib.isCodeHotkey;\nvar lib_3 = lib.isKeyHotkey;\nlib.parseHotkey;\nlib.compareHotkey;\nlib.toKeyCode;\nlib.toKeyName;\nvar isComposing = (editor) => ReactEditor.isComposing(editor);\nvar HOTKEYS2 = {\n  bold: \"mod+b\",\n  compose: [\"down\", \"left\", \"right\", \"up\", \"backspace\", \"enter\"],\n  deleteBackward: \"shift?+backspace\",\n  deleteForward: \"shift?+delete\",\n  extendBackward: \"shift+left\",\n  extendForward: \"shift+right\",\n  insertSoftBreak: \"shift+enter\",\n  italic: \"mod+i\",\n  moveBackward: \"left\",\n  moveForward: \"right\",\n  moveWordBackward: \"ctrl+left\",\n  moveWordForward: \"ctrl+right\",\n  splitBlock: \"enter\",\n  tab: \"tab\",\n  untab: \"shift+tab\",\n  undo: \"mod+z\"\n};\nvar APPLE_HOTKEYS2 = {\n  deleteBackward: [\"ctrl+backspace\", \"ctrl+h\"],\n  deleteForward: [\"ctrl+delete\", \"ctrl+d\"],\n  deleteLineBackward: \"cmd+shift?+backspace\",\n  deleteLineForward: [\"cmd+shift?+delete\", \"ctrl+k\"],\n  deleteWordBackward: \"opt+shift?+backspace\",\n  deleteWordForward: \"opt+shift?+delete\",\n  extendLineBackward: \"opt+shift+up\",\n  extendLineForward: \"opt+shift+down\",\n  moveLineBackward: \"opt+up\",\n  moveLineForward: \"opt+down\",\n  moveWordBackward: \"opt+left\",\n  moveWordForward: \"opt+right\",\n  redo: \"cmd+shift+z\",\n  transposeCharacter: \"ctrl+t\"\n};\nvar WINDOWS_HOTKEYS2 = {\n  deleteWordBackward: \"ctrl+shift?+backspace\",\n  deleteWordForward: \"ctrl+shift?+delete\",\n  redo: [\"ctrl+y\", \"ctrl+shift+z\"]\n};\nvar create3 = (key) => {\n  const generic = HOTKEYS2[key];\n  const apple = APPLE_HOTKEYS2[key];\n  const windows = WINDOWS_HOTKEYS2[key];\n  const isGeneric = generic && lib_3(generic);\n  const isApple = apple && lib_3(apple);\n  const isWindows = windows && lib_3(windows);\n  return (event) => {\n    if (isGeneric && isGeneric(event))\n      return true;\n    if (IS_APPLE2 && isApple && isApple(event))\n      return true;\n    if (!IS_APPLE2 && isWindows && isWindows(event))\n      return true;\n    return false;\n  };\n};\nvar createComposing = (key) => (editor, event, {\n  composing\n} = {}) => {\n  if (!create3(key)(event))\n    return false;\n  if (!!composing !== isComposing(editor))\n    return false;\n  return true;\n};\nvar Hotkeys2 = {\n  isBold: create3(\"bold\"),\n  isCompose: create3(\"compose\"),\n  isMoveBackward: create3(\"moveBackward\"),\n  isMoveForward: create3(\"moveForward\"),\n  isDeleteBackward: create3(\"deleteBackward\"),\n  isDeleteForward: create3(\"deleteForward\"),\n  isDeleteLineBackward: create3(\"deleteLineBackward\"),\n  isDeleteLineForward: create3(\"deleteLineForward\"),\n  isDeleteWordBackward: create3(\"deleteWordBackward\"),\n  isDeleteWordForward: create3(\"deleteWordForward\"),\n  isExtendBackward: create3(\"extendBackward\"),\n  isExtendForward: create3(\"extendForward\"),\n  isExtendLineBackward: create3(\"extendLineBackward\"),\n  isExtendLineForward: create3(\"extendLineForward\"),\n  isItalic: create3(\"italic\"),\n  isMoveLineBackward: create3(\"moveLineBackward\"),\n  isMoveLineForward: create3(\"moveLineForward\"),\n  isMoveWordBackward: create3(\"moveWordBackward\"),\n  isMoveWordForward: create3(\"moveWordForward\"),\n  isRedo: create3(\"redo\"),\n  isSoftBreak: create3(\"insertSoftBreak\"),\n  isSplitBlock: create3(\"splitBlock\"),\n  isTab: createComposing(\"tab\"),\n  isTransposeCharacter: create3(\"transposeCharacter\"),\n  isUndo: create3(\"undo\"),\n  isUntab: createComposing(\"untab\")\n};\nvar protocolAndDomainRE = /^(?:\\w+:)?\\/\\/(\\S+)$/;\nvar localhostDomainRE = /^localhost[:?\\d]*(?:[^:?\\d]\\S*)?$/;\nvar nonLocalhostDomainRE = /^[^\\s.]+\\.\\S{2,}$/;\nvar isUrl = (string2) => {\n  if (typeof string2 !== \"string\") {\n    return false;\n  }\n  const match2 = string2.match(protocolAndDomainRE);\n  if (!match2) {\n    return false;\n  }\n  const everythingAfterProtocol = match2[1];\n  if (!everythingAfterProtocol) {\n    return false;\n  }\n  try {\n    new URL(string2);\n  } catch (err) {\n    return false;\n  }\n  return localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol);\n};\nvar JotaiProvider = Provider;\nvar mergeProps = (props, overrideProps, {\n  handlerKeys,\n  handlerQuery = (key) => key.indexOf(\"on\") === 0\n} = {}) => {\n  const map2 = /* @__PURE__ */ new Map();\n  const acc = {};\n  const mapProps = (_props) => {\n    if (!_props)\n      return;\n    Object.entries(_props).forEach(([key, value]) => {\n      if ((!handlerKeys || handlerKeys.includes(key)) && (!handlerQuery || handlerQuery(key)) && typeof value === \"function\") {\n        var _map$get;\n        if (!map2.has(key)) {\n          map2.set(key, []);\n        }\n        (_map$get = map2.get(key)) === null || _map$get === void 0 ? void 0 : _map$get.push(value);\n        acc[key] = (...args) => {\n          var _map$get2;\n          (_map$get2 = map2.get(key)) === null || _map$get2 === void 0 ? void 0 : _map$get2.forEach((fn4) => fn4(...args));\n        };\n      } else {\n        acc[key] = value;\n      }\n    });\n  };\n  mapProps(props);\n  mapProps(overrideProps);\n  return acc;\n};\nvar isUndefined = (obj) => typeof obj === \"undefined\";\nvar isNull = (obj) => obj === null;\nvar isUndefinedOrNull = (obj) => isUndefined(obj) || isNull(obj);\nvar isDefined = (arg) => !isUndefinedOrNull(arg);\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0:\n      return func.call(thisArg);\n    case 1:\n      return func.call(thisArg, args[0]);\n    case 2:\n      return func.call(thisArg, args[0], args[1]);\n    case 3:\n      return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\nvar _apply = apply;\nfunction identity(value) {\n  return value;\n}\nvar identity_1 = identity;\nvar nativeMax = Math.max;\nfunction overRest(func, start2, transform) {\n  start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);\n  return function() {\n    var args = arguments, index5 = -1, length = nativeMax(args.length - start2, 0), array = Array(length);\n    while (++index5 < length) {\n      array[index5] = args[start2 + index5];\n    }\n    index5 = -1;\n    var otherArgs = Array(start2 + 1);\n    while (++index5 < start2) {\n      otherArgs[index5] = args[index5];\n    }\n    otherArgs[start2] = transform(array);\n    return _apply(func, this, otherArgs);\n  };\n}\nvar _overRest = overRest;\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\nvar constant_1 = constant;\nvar freeGlobal2 = typeof commonjsGlobal2 == \"object\" && commonjsGlobal2 && commonjsGlobal2.Object === Object && commonjsGlobal2;\nvar _freeGlobal2 = freeGlobal2;\nvar freeSelf2 = typeof self == \"object\" && self && self.Object === Object && self;\nvar root2 = _freeGlobal2 || freeSelf2 || Function(\"return this\")();\nvar _root2 = root2;\nvar Symbol$1 = _root2.Symbol;\nvar _Symbol2 = Symbol$1;\nvar objectProto$g = Object.prototype;\nvar hasOwnProperty$d = objectProto$g.hasOwnProperty;\nvar nativeObjectToString$12 = objectProto$g.toString;\nvar symToStringTag$12 = _Symbol2 ? _Symbol2.toStringTag : void 0;\nfunction getRawTag2(value) {\n  var isOwn = hasOwnProperty$d.call(value, symToStringTag$12), tag = value[symToStringTag$12];\n  try {\n    value[symToStringTag$12] = void 0;\n    var unmasked = true;\n  } catch (e4) {\n  }\n  var result = nativeObjectToString$12.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$12] = tag;\n    } else {\n      delete value[symToStringTag$12];\n    }\n  }\n  return result;\n}\nvar _getRawTag2 = getRawTag2;\nvar objectProto$f = Object.prototype;\nvar nativeObjectToString2 = objectProto$f.toString;\nfunction objectToString2(value) {\n  return nativeObjectToString2.call(value);\n}\nvar _objectToString2 = objectToString2;\nvar nullTag2 = \"[object Null]\";\nvar undefinedTag2 = \"[object Undefined]\";\nvar symToStringTag2 = _Symbol2 ? _Symbol2.toStringTag : void 0;\nfunction baseGetTag2(value) {\n  if (value == null) {\n    return value === void 0 ? undefinedTag2 : nullTag2;\n  }\n  return symToStringTag2 && symToStringTag2 in Object(value) ? _getRawTag2(value) : _objectToString2(value);\n}\nvar _baseGetTag2 = baseGetTag2;\nfunction isObject$1(value) {\n  var type = typeof value;\n  return value != null && (type == \"object\" || type == \"function\");\n}\nvar isObject_12 = isObject$1;\nvar asyncTag2 = \"[object AsyncFunction]\";\nvar funcTag$2 = \"[object Function]\";\nvar genTag$1 = \"[object GeneratorFunction]\";\nvar proxyTag2 = \"[object Proxy]\";\nfunction isFunction2(value) {\n  if (!isObject_12(value)) {\n    return false;\n  }\n  var tag = _baseGetTag2(value);\n  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag2 || tag == proxyTag2;\n}\nvar isFunction_12 = isFunction2;\nvar coreJsData2 = _root2[\"__core-js_shared__\"];\nvar _coreJsData2 = coreJsData2;\nvar maskSrcKey2 = function() {\n  var uid = /[^.]+$/.exec(_coreJsData2 && _coreJsData2.keys && _coreJsData2.keys.IE_PROTO || \"\");\n  return uid ? \"Symbol(src)_1.\" + uid : \"\";\n}();\nfunction isMasked2(func) {\n  return !!maskSrcKey2 && maskSrcKey2 in func;\n}\nvar _isMasked2 = isMasked2;\nvar funcProto$2 = Function.prototype;\nvar funcToString$2 = funcProto$2.toString;\nfunction toSource2(func) {\n  if (func != null) {\n    try {\n      return funcToString$2.call(func);\n    } catch (e4) {\n    }\n    try {\n      return func + \"\";\n    } catch (e4) {\n    }\n  }\n  return \"\";\n}\nvar _toSource2 = toSource2;\nvar reRegExpChar2 = /[\\\\^$.*+?()[\\]{}|]/g;\nvar reIsHostCtor2 = /^\\[object .+?Constructor\\]$/;\nvar funcProto$12 = Function.prototype;\nvar objectProto$e = Object.prototype;\nvar funcToString$12 = funcProto$12.toString;\nvar hasOwnProperty$c = objectProto$e.hasOwnProperty;\nvar reIsNative2 = RegExp(\n  \"^\" + funcToString$12.call(hasOwnProperty$c).replace(reRegExpChar2, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n);\nfunction baseIsNative2(value) {\n  if (!isObject_12(value) || _isMasked2(value)) {\n    return false;\n  }\n  var pattern = isFunction_12(value) ? reIsNative2 : reIsHostCtor2;\n  return pattern.test(_toSource2(value));\n}\nvar _baseIsNative2 = baseIsNative2;\nfunction getValue2(object, key) {\n  return object == null ? void 0 : object[key];\n}\nvar _getValue2 = getValue2;\nfunction getNative2(object, key) {\n  var value = _getValue2(object, key);\n  return _baseIsNative2(value) ? value : void 0;\n}\nvar _getNative2 = getNative2;\nvar defineProperty2 = function() {\n  try {\n    var func = _getNative2(Object, \"defineProperty\");\n    func({}, \"\", {});\n    return func;\n  } catch (e4) {\n  }\n}();\nvar _defineProperty$1 = defineProperty2;\nvar baseSetToString = !_defineProperty$1 ? identity_1 : function(func, string2) {\n  return _defineProperty$1(func, \"toString\", {\n    \"configurable\": true,\n    \"enumerable\": false,\n    \"value\": constant_1(string2),\n    \"writable\": true\n  });\n};\nvar _baseSetToString = baseSetToString;\nvar HOT_COUNT = 800;\nvar HOT_SPAN = 16;\nvar nativeNow = Date.now;\nfunction shortOut(func) {\n  var count2 = 0, lastCalled = 0;\n  return function() {\n    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count2 >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count2 = 0;\n    }\n    return func.apply(void 0, arguments);\n  };\n}\nvar _shortOut = shortOut;\nvar setToString = _shortOut(_baseSetToString);\nvar _setToString = setToString;\nfunction baseRest(func, start2) {\n  return _setToString(_overRest(func, start2, identity_1), func + \"\");\n}\nvar _baseRest = baseRest;\nfunction listCacheClear2() {\n  this.__data__ = [];\n  this.size = 0;\n}\nvar _listCacheClear2 = listCacheClear2;\nfunction eq2(value, other) {\n  return value === other || value !== value && other !== other;\n}\nvar eq_12 = eq2;\nfunction assocIndexOf2(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq_12(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\nvar _assocIndexOf2 = assocIndexOf2;\nvar arrayProto2 = Array.prototype;\nvar splice2 = arrayProto2.splice;\nfunction listCacheDelete2(key) {\n  var data = this.__data__, index5 = _assocIndexOf2(data, key);\n  if (index5 < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index5 == lastIndex) {\n    data.pop();\n  } else {\n    splice2.call(data, index5, 1);\n  }\n  --this.size;\n  return true;\n}\nvar _listCacheDelete2 = listCacheDelete2;\nfunction listCacheGet2(key) {\n  var data = this.__data__, index5 = _assocIndexOf2(data, key);\n  return index5 < 0 ? void 0 : data[index5][1];\n}\nvar _listCacheGet2 = listCacheGet2;\nfunction listCacheHas2(key) {\n  return _assocIndexOf2(this.__data__, key) > -1;\n}\nvar _listCacheHas2 = listCacheHas2;\nfunction listCacheSet2(key, value) {\n  var data = this.__data__, index5 = _assocIndexOf2(data, key);\n  if (index5 < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index5][1] = value;\n  }\n  return this;\n}\nvar _listCacheSet2 = listCacheSet2;\nfunction ListCache2(entries) {\n  var index5 = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index5 < length) {\n    var entry = entries[index5];\n    this.set(entry[0], entry[1]);\n  }\n}\nListCache2.prototype.clear = _listCacheClear2;\nListCache2.prototype[\"delete\"] = _listCacheDelete2;\nListCache2.prototype.get = _listCacheGet2;\nListCache2.prototype.has = _listCacheHas2;\nListCache2.prototype.set = _listCacheSet2;\nvar _ListCache2 = ListCache2;\nfunction stackClear2() {\n  this.__data__ = new _ListCache2();\n  this.size = 0;\n}\nvar _stackClear2 = stackClear2;\nfunction stackDelete2(key) {\n  var data = this.__data__, result = data[\"delete\"](key);\n  this.size = data.size;\n  return result;\n}\nvar _stackDelete2 = stackDelete2;\nfunction stackGet2(key) {\n  return this.__data__.get(key);\n}\nvar _stackGet2 = stackGet2;\nfunction stackHas2(key) {\n  return this.__data__.has(key);\n}\nvar _stackHas2 = stackHas2;\nvar Map$1 = _getNative2(_root2, \"Map\");\nvar _Map2 = Map$1;\nvar nativeCreate2 = _getNative2(Object, \"create\");\nvar _nativeCreate2 = nativeCreate2;\nfunction hashClear2() {\n  this.__data__ = _nativeCreate2 ? _nativeCreate2(null) : {};\n  this.size = 0;\n}\nvar _hashClear2 = hashClear2;\nfunction hashDelete2(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\nvar _hashDelete2 = hashDelete2;\nvar HASH_UNDEFINED$22 = \"__lodash_hash_undefined__\";\nvar objectProto$d = Object.prototype;\nvar hasOwnProperty$b = objectProto$d.hasOwnProperty;\nfunction hashGet2(key) {\n  var data = this.__data__;\n  if (_nativeCreate2) {\n    var result = data[key];\n    return result === HASH_UNDEFINED$22 ? void 0 : result;\n  }\n  return hasOwnProperty$b.call(data, key) ? data[key] : void 0;\n}\nvar _hashGet2 = hashGet2;\nvar objectProto$c = Object.prototype;\nvar hasOwnProperty$a = objectProto$c.hasOwnProperty;\nfunction hashHas2(key) {\n  var data = this.__data__;\n  return _nativeCreate2 ? data[key] !== void 0 : hasOwnProperty$a.call(data, key);\n}\nvar _hashHas2 = hashHas2;\nvar HASH_UNDEFINED$12 = \"__lodash_hash_undefined__\";\nfunction hashSet2(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = _nativeCreate2 && value === void 0 ? HASH_UNDEFINED$12 : value;\n  return this;\n}\nvar _hashSet2 = hashSet2;\nfunction Hash2(entries) {\n  var index5 = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index5 < length) {\n    var entry = entries[index5];\n    this.set(entry[0], entry[1]);\n  }\n}\nHash2.prototype.clear = _hashClear2;\nHash2.prototype[\"delete\"] = _hashDelete2;\nHash2.prototype.get = _hashGet2;\nHash2.prototype.has = _hashHas2;\nHash2.prototype.set = _hashSet2;\nvar _Hash2 = Hash2;\nfunction mapCacheClear2() {\n  this.size = 0;\n  this.__data__ = {\n    \"hash\": new _Hash2(),\n    \"map\": new (_Map2 || _ListCache2)(),\n    \"string\": new _Hash2()\n  };\n}\nvar _mapCacheClear2 = mapCacheClear2;\nfunction isKeyable2(value) {\n  var type = typeof value;\n  return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n}\nvar _isKeyable2 = isKeyable2;\nfunction getMapData2(map2, key) {\n  var data = map2.__data__;\n  return _isKeyable2(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n}\nvar _getMapData2 = getMapData2;\nfunction mapCacheDelete2(key) {\n  var result = _getMapData2(this, key)[\"delete\"](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\nvar _mapCacheDelete2 = mapCacheDelete2;\nfunction mapCacheGet2(key) {\n  return _getMapData2(this, key).get(key);\n}\nvar _mapCacheGet2 = mapCacheGet2;\nfunction mapCacheHas2(key) {\n  return _getMapData2(this, key).has(key);\n}\nvar _mapCacheHas2 = mapCacheHas2;\nfunction mapCacheSet2(key, value) {\n  var data = _getMapData2(this, key), size = data.size;\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\nvar _mapCacheSet2 = mapCacheSet2;\nfunction MapCache2(entries) {\n  var index5 = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index5 < length) {\n    var entry = entries[index5];\n    this.set(entry[0], entry[1]);\n  }\n}\nMapCache2.prototype.clear = _mapCacheClear2;\nMapCache2.prototype[\"delete\"] = _mapCacheDelete2;\nMapCache2.prototype.get = _mapCacheGet2;\nMapCache2.prototype.has = _mapCacheHas2;\nMapCache2.prototype.set = _mapCacheSet2;\nvar _MapCache2 = MapCache2;\nvar LARGE_ARRAY_SIZE2 = 200;\nfunction stackSet2(key, value) {\n  var data = this.__data__;\n  if (data instanceof _ListCache2) {\n    var pairs = data.__data__;\n    if (!_Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new _MapCache2(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\nvar _stackSet2 = stackSet2;\nfunction Stack2(entries) {\n  var data = this.__data__ = new _ListCache2(entries);\n  this.size = data.size;\n}\nStack2.prototype.clear = _stackClear2;\nStack2.prototype[\"delete\"] = _stackDelete2;\nStack2.prototype.get = _stackGet2;\nStack2.prototype.has = _stackHas2;\nStack2.prototype.set = _stackSet2;\nvar _Stack = Stack2;\nfunction baseAssignValue(object, key, value) {\n  if (key == \"__proto__\" && _defineProperty$1) {\n    _defineProperty$1(object, key, {\n      \"configurable\": true,\n      \"enumerable\": true,\n      \"value\": value,\n      \"writable\": true\n    });\n  } else {\n    object[key] = value;\n  }\n}\nvar _baseAssignValue = baseAssignValue;\nfunction assignMergeValue(object, key, value) {\n  if (value !== void 0 && !eq_12(object[key], value) || value === void 0 && !(key in object)) {\n    _baseAssignValue(object, key, value);\n  }\n}\nvar _assignMergeValue = assignMergeValue;\nfunction createBaseFor2(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index5 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;\n    while (length--) {\n      var key = props[fromRight ? length : ++index5];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\nvar _createBaseFor2 = createBaseFor2;\nvar baseFor2 = _createBaseFor2();\nvar _baseFor = baseFor2;\nvar _cloneBuffer = createCommonjsModule2(function(module2, exports2) {\n  var freeExports = exports2 && !exports2.nodeType && exports2;\n  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n  var Buffer2 = moduleExports ? _root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;\n  function cloneBuffer(buffer, isDeep) {\n    if (isDeep) {\n      return buffer.slice();\n    }\n    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n    buffer.copy(result);\n    return result;\n  }\n  module2.exports = cloneBuffer;\n});\nvar Uint8Array3 = _root2.Uint8Array;\nvar _Uint8Array = Uint8Array3;\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));\n  return result;\n}\nvar _cloneArrayBuffer = cloneArrayBuffer;\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\nvar _cloneTypedArray = cloneTypedArray;\nfunction copyArray(source, array) {\n  var index5 = -1, length = source.length;\n  array || (array = Array(length));\n  while (++index5 < length) {\n    array[index5] = source[index5];\n  }\n  return array;\n}\nvar _copyArray = copyArray;\nvar objectCreate = Object.create;\nvar baseCreate = function() {\n  function object() {\n  }\n  return function(proto) {\n    if (!isObject_12(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object();\n    object.prototype = void 0;\n    return result;\n  };\n}();\nvar _baseCreate = baseCreate;\nfunction overArg2(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\nvar _overArg2 = overArg2;\nvar getPrototype = _overArg2(Object.getPrototypeOf, Object);\nvar _getPrototype = getPrototype;\nvar objectProto$b2 = Object.prototype;\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor, proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto$b2;\n  return value === proto;\n}\nvar _isPrototype = isPrototype;\nfunction initCloneObject(object) {\n  return typeof object.constructor == \"function\" && !_isPrototype(object) ? _baseCreate(_getPrototype(object)) : {};\n}\nvar _initCloneObject = initCloneObject;\nfunction isObjectLike2(value) {\n  return value != null && typeof value == \"object\";\n}\nvar isObjectLike_12 = isObjectLike2;\nvar argsTag$3 = \"[object Arguments]\";\nfunction baseIsArguments2(value) {\n  return isObjectLike_12(value) && _baseGetTag2(value) == argsTag$3;\n}\nvar _baseIsArguments2 = baseIsArguments2;\nvar objectProto$a2 = Object.prototype;\nvar hasOwnProperty$9 = objectProto$a2.hasOwnProperty;\nvar propertyIsEnumerable$12 = objectProto$a2.propertyIsEnumerable;\nvar isArguments2 = _baseIsArguments2(function() {\n  return arguments;\n}()) ? _baseIsArguments2 : function(value) {\n  return isObjectLike_12(value) && hasOwnProperty$9.call(value, \"callee\") && !propertyIsEnumerable$12.call(value, \"callee\");\n};\nvar isArguments_1 = isArguments2;\nvar isArray2 = Array.isArray;\nvar isArray_1 = isArray2;\nvar MAX_SAFE_INTEGER$1 = 9007199254740991;\nfunction isLength2(value) {\n  return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;\n}\nvar isLength_12 = isLength2;\nfunction isArrayLike(value) {\n  return value != null && isLength_12(value.length) && !isFunction_12(value);\n}\nvar isArrayLike_1 = isArrayLike;\nfunction isArrayLikeObject(value) {\n  return isObjectLike_12(value) && isArrayLike_1(value);\n}\nvar isArrayLikeObject_1 = isArrayLikeObject;\nfunction stubFalse2() {\n  return false;\n}\nvar stubFalse_12 = stubFalse2;\nvar isBuffer_12 = createCommonjsModule2(function(module2, exports2) {\n  var freeExports = exports2 && !exports2.nodeType && exports2;\n  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n  var Buffer2 = moduleExports ? _root2.Buffer : void 0;\n  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;\n  var isBuffer = nativeIsBuffer || stubFalse_12;\n  module2.exports = isBuffer;\n});\nvar objectTag$4 = \"[object Object]\";\nvar funcProto2 = Function.prototype;\nvar objectProto$92 = Object.prototype;\nvar funcToString2 = funcProto2.toString;\nvar hasOwnProperty$82 = objectProto$92.hasOwnProperty;\nvar objectCtorString = funcToString2.call(Object);\nfunction isPlainObject$1(value) {\n  if (!isObjectLike_12(value) || _baseGetTag2(value) != objectTag$4) {\n    return false;\n  }\n  var proto = _getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty$82.call(proto, \"constructor\") && proto.constructor;\n  return typeof Ctor == \"function\" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString;\n}\nvar isPlainObject_1 = isPlainObject$1;\nvar argsTag$22 = \"[object Arguments]\";\nvar arrayTag$2 = \"[object Array]\";\nvar boolTag$3 = \"[object Boolean]\";\nvar dateTag$3 = \"[object Date]\";\nvar errorTag$2 = \"[object Error]\";\nvar funcTag$12 = \"[object Function]\";\nvar mapTag$5 = \"[object Map]\";\nvar numberTag$3 = \"[object Number]\";\nvar objectTag$3 = \"[object Object]\";\nvar regexpTag$3 = \"[object RegExp]\";\nvar setTag$5 = \"[object Set]\";\nvar stringTag$3 = \"[object String]\";\nvar weakMapTag$2 = \"[object WeakMap]\";\nvar arrayBufferTag$3 = \"[object ArrayBuffer]\";\nvar dataViewTag$4 = \"[object DataView]\";\nvar float32Tag$2 = \"[object Float32Array]\";\nvar float64Tag$2 = \"[object Float64Array]\";\nvar int8Tag$2 = \"[object Int8Array]\";\nvar int16Tag$2 = \"[object Int16Array]\";\nvar int32Tag$2 = \"[object Int32Array]\";\nvar uint8Tag$2 = \"[object Uint8Array]\";\nvar uint8ClampedTag$2 = \"[object Uint8ClampedArray]\";\nvar uint16Tag$2 = \"[object Uint16Array]\";\nvar uint32Tag$2 = \"[object Uint32Array]\";\nvar typedArrayTags2 = {};\ntypedArrayTags2[float32Tag$2] = typedArrayTags2[float64Tag$2] = typedArrayTags2[int8Tag$2] = typedArrayTags2[int16Tag$2] = typedArrayTags2[int32Tag$2] = typedArrayTags2[uint8Tag$2] = typedArrayTags2[uint8ClampedTag$2] = typedArrayTags2[uint16Tag$2] = typedArrayTags2[uint32Tag$2] = true;\ntypedArrayTags2[argsTag$22] = typedArrayTags2[arrayTag$2] = typedArrayTags2[arrayBufferTag$3] = typedArrayTags2[boolTag$3] = typedArrayTags2[dataViewTag$4] = typedArrayTags2[dateTag$3] = typedArrayTags2[errorTag$2] = typedArrayTags2[funcTag$12] = typedArrayTags2[mapTag$5] = typedArrayTags2[numberTag$3] = typedArrayTags2[objectTag$3] = typedArrayTags2[regexpTag$3] = typedArrayTags2[setTag$5] = typedArrayTags2[stringTag$3] = typedArrayTags2[weakMapTag$2] = false;\nfunction baseIsTypedArray2(value) {\n  return isObjectLike_12(value) && isLength_12(value.length) && !!typedArrayTags2[_baseGetTag2(value)];\n}\nvar _baseIsTypedArray2 = baseIsTypedArray2;\nfunction baseUnary2(func) {\n  return function(value) {\n    return func(value);\n  };\n}\nvar _baseUnary2 = baseUnary2;\nvar _nodeUtil2 = createCommonjsModule2(function(module2, exports2) {\n  var freeExports = exports2 && !exports2.nodeType && exports2;\n  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n  var freeProcess = moduleExports && _freeGlobal2.process;\n  var nodeUtil = function() {\n    try {\n      var types = freeModule && freeModule.require && freeModule.require(\"util\").types;\n      if (types) {\n        return types;\n      }\n      return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n    } catch (e4) {\n    }\n  }();\n  module2.exports = nodeUtil;\n});\nvar nodeIsTypedArray2 = _nodeUtil2 && _nodeUtil2.isTypedArray;\nvar isTypedArray2 = nodeIsTypedArray2 ? _baseUnary2(nodeIsTypedArray2) : _baseIsTypedArray2;\nvar isTypedArray_1 = isTypedArray2;\nfunction safeGet(object, key) {\n  if (key === \"constructor\" && typeof object[key] === \"function\") {\n    return;\n  }\n  if (key == \"__proto__\") {\n    return;\n  }\n  return object[key];\n}\nvar _safeGet = safeGet;\nvar objectProto$82 = Object.prototype;\nvar hasOwnProperty$72 = objectProto$82.hasOwnProperty;\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty$72.call(object, key) && eq_12(objValue, value)) || value === void 0 && !(key in object)) {\n    _baseAssignValue(object, key, value);\n  }\n}\nvar _assignValue = assignValue;\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n  var index5 = -1, length = props.length;\n  while (++index5 < length) {\n    var key = props[index5];\n    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;\n    if (newValue === void 0) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      _baseAssignValue(object, key, newValue);\n    } else {\n      _assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\nvar _copyObject = copyObject;\nfunction baseTimes(n8, iteratee) {\n  var index5 = -1, result = Array(n8);\n  while (++index5 < n8) {\n    result[index5] = iteratee(index5);\n  }\n  return result;\n}\nvar _baseTimes = baseTimes;\nvar MAX_SAFE_INTEGER2 = 9007199254740991;\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER2 : length;\n  return !!length && (type == \"number\" || type != \"symbol\" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);\n}\nvar _isIndex = isIndex;\nvar objectProto$72 = Object.prototype;\nvar hasOwnProperty$62 = objectProto$72.hasOwnProperty;\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray_1(value), isArg = !isArr && isArguments_1(value), isBuff = !isArr && !isArg && isBuffer_12(value), isType3 = !isArr && !isArg && !isBuff && isTypedArray_1(value), skipIndexes = isArr || isArg || isBuff || isType3, result = skipIndexes ? _baseTimes(value.length, String) : [], length = result.length;\n  for (var key in value) {\n    if ((inherited || hasOwnProperty$62.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.\n    (key == \"length\" || isBuff && (key == \"offset\" || key == \"parent\") || isType3 && (key == \"buffer\" || key == \"byteLength\" || key == \"byteOffset\") || // Skip index properties.\n    _isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\nvar _arrayLikeKeys = arrayLikeKeys;\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\nvar _nativeKeysIn = nativeKeysIn;\nvar objectProto$62 = Object.prototype;\nvar hasOwnProperty$52 = objectProto$62.hasOwnProperty;\nfunction baseKeysIn(object) {\n  if (!isObject_12(object)) {\n    return _nativeKeysIn(object);\n  }\n  var isProto = _isPrototype(object), result = [];\n  for (var key in object) {\n    if (!(key == \"constructor\" && (isProto || !hasOwnProperty$52.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\nvar _baseKeysIn = baseKeysIn;\nfunction keysIn(object) {\n  return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);\n}\nvar keysIn_1 = keysIn;\nfunction toPlainObject(value) {\n  return _copyObject(value, keysIn_1(value));\n}\nvar toPlainObject_1 = toPlainObject;\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = _safeGet(object, key), srcValue = _safeGet(source, key), stacked = stack.get(srcValue);\n  if (stacked) {\n    _assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer ? customizer(objValue, srcValue, key + \"\", object, source, stack) : void 0;\n  var isCommon = newValue === void 0;\n  if (isCommon) {\n    var isArr = isArray_1(srcValue), isBuff = !isArr && isBuffer_12(srcValue), isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray_1(objValue)) {\n        newValue = objValue;\n      } else if (isArrayLikeObject_1(objValue)) {\n        newValue = _copyArray(objValue);\n      } else if (isBuff) {\n        isCommon = false;\n        newValue = _cloneBuffer(srcValue, true);\n      } else if (isTyped) {\n        isCommon = false;\n        newValue = _cloneTypedArray(srcValue, true);\n      } else {\n        newValue = [];\n      }\n    } else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {\n      newValue = objValue;\n      if (isArguments_1(objValue)) {\n        newValue = toPlainObject_1(objValue);\n      } else if (!isObject_12(objValue) || isFunction_12(objValue)) {\n        newValue = _initCloneObject(srcValue);\n      }\n    } else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack[\"delete\"](srcValue);\n  }\n  _assignMergeValue(object, key, newValue);\n}\nvar _baseMergeDeep = baseMergeDeep;\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  _baseFor(source, function(srcValue, key) {\n    stack || (stack = new _Stack());\n    if (isObject_12(srcValue)) {\n      _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    } else {\n      var newValue = customizer ? customizer(_safeGet(object, key), srcValue, key + \"\", object, source, stack) : void 0;\n      if (newValue === void 0) {\n        newValue = srcValue;\n      }\n      _assignMergeValue(object, key, newValue);\n    }\n  }, keysIn_1);\n}\nvar _baseMerge = baseMerge;\nfunction customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n  if (isObject_12(objValue) && isObject_12(srcValue)) {\n    stack.set(srcValue, objValue);\n    _baseMerge(objValue, srcValue, void 0, customDefaultsMerge, stack);\n    stack[\"delete\"](srcValue);\n  }\n  return objValue;\n}\nvar _customDefaultsMerge = customDefaultsMerge;\nfunction isIterateeCall(value, index5, object) {\n  if (!isObject_12(object)) {\n    return false;\n  }\n  var type = typeof index5;\n  if (type == \"number\" ? isArrayLike_1(object) && _isIndex(index5, object.length) : type == \"string\" && index5 in object) {\n    return eq_12(object[index5], value);\n  }\n  return false;\n}\nvar _isIterateeCall = isIterateeCall;\nfunction createAssigner(assigner) {\n  return _baseRest(function(object, sources) {\n    var index5 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;\n    customizer = assigner.length > 3 && typeof customizer == \"function\" ? (length--, customizer) : void 0;\n    if (guard && _isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? void 0 : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index5 < length) {\n      var source = sources[index5];\n      if (source) {\n        assigner(object, source, index5, customizer);\n      }\n    }\n    return object;\n  });\n}\nvar _createAssigner = createAssigner;\nvar mergeWith = _createAssigner(function(object, source, srcIndex, customizer) {\n  _baseMerge(object, source, srcIndex, customizer);\n});\nvar mergeWith_1 = mergeWith;\nvar defaultsDeep = _baseRest(function(args) {\n  args.push(void 0, _customDefaultsMerge);\n  return _apply(mergeWith_1, void 0, args);\n});\nvar defaultsDeep_1 = defaultsDeep;\nvar overridePluginsByKey = (plugin, overrideByKey = {}, nested) => {\n  var _overrideByKey$plugin;\n  if (overrideByKey[plugin.key]) {\n    const {\n      plugins: pluginOverridesPlugins,\n      then: pluginOverridesThen,\n      ...pluginOverrides\n    } = overrideByKey[plugin.key];\n    plugin = defaultsDeep_1(pluginOverrides, plugin);\n    if (!nested) {\n      pluginOverridesPlugins === null || pluginOverridesPlugins === void 0 ? void 0 : pluginOverridesPlugins.forEach((pOverrides) => {\n        if (!plugin.plugins)\n          plugin.plugins = [];\n        const found = plugin.plugins.find((p6) => p6.key === pOverrides.key);\n        if (!found)\n          plugin.plugins.push(pOverrides);\n      });\n    }\n  }\n  if (plugin.plugins) {\n    plugin.plugins = plugin.plugins.map((p6) => overridePluginsByKey(p6, overrideByKey, true));\n  }\n  const {\n    then\n  } = plugin;\n  if (then) {\n    plugin.then = (editor, p6) => {\n      const pluginThen = {\n        key: plugin.key,\n        ...then(editor, p6)\n      };\n      return defaultsDeep_1(overridePluginsByKey(pluginThen, overrideByKey), pluginThen);\n    };\n  } else if ((_overrideByKey$plugin = overrideByKey[plugin.key]) !== null && _overrideByKey$plugin !== void 0 && _overrideByKey$plugin.then) {\n    plugin.then = overrideByKey[plugin.key].then;\n  }\n  return plugin;\n};\nvar createPluginFactory = (defaultPlugin) => (override, overrideByKey = {}) => {\n  overrideByKey[defaultPlugin.key] = override;\n  return overridePluginsByKey({\n    ...defaultPlugin\n  }, overrideByKey);\n};\nvar KEY_DESERIALIZE_AST = \"deserializeAst\";\nvar createDeserializeAstPlugin = createPluginFactory({\n  key: KEY_DESERIALIZE_AST,\n  editor: {\n    insertData: {\n      format: \"application/x-slate-fragment\",\n      getFragment: ({\n        data\n      }) => {\n        const decoded = decodeURIComponent(window.atob(data));\n        return JSON.parse(decoded);\n      }\n    }\n  }\n});\nvar eventEditorStore = createStore3(\"event-editor\")({\n  blur: null,\n  focus: null,\n  last: null\n});\nvar eventEditorActions = eventEditorStore.set;\nvar eventEditorSelectors = eventEditorStore.get;\nvar useEventEditorSelectors = eventEditorStore.use;\nvar KEY_EVENT_EDITOR = \"event-editor\";\nvar createEventEditorPlugin = createPluginFactory({\n  key: KEY_EVENT_EDITOR,\n  handlers: {\n    onFocus: (editor) => () => {\n      eventEditorActions.focus(editor.id);\n    },\n    onBlur: (editor) => () => {\n      const focus = eventEditorSelectors.focus();\n      if (focus === editor.id) {\n        eventEditorActions.focus(null);\n      }\n      eventEditorActions.blur(editor.id);\n    }\n  }\n});\nvar withTHistory = (editor) => withHistory(editor);\nvar createHistoryPlugin = createPluginFactory({\n  key: \"history\",\n  withOverrides: withTHistory\n});\nvar KEY_INLINE_VOID = \"inline-void\";\nvar withInlineVoid = (editor) => {\n  const {\n    isInline: isInline2\n  } = editor;\n  const {\n    isVoid: isVoid2\n  } = editor;\n  const inlineTypes = [];\n  const voidTypes = [];\n  editor.plugins.forEach((plugin) => {\n    if (plugin.isInline) {\n      inlineTypes.push(plugin.type);\n    }\n    if (plugin.isVoid) {\n      voidTypes.push(plugin.type);\n    }\n  });\n  editor.isInline = (element4) => {\n    return inlineTypes.includes(element4.type) ? true : isInline2(element4);\n  };\n  editor.isVoid = (element4) => voidTypes.includes(element4.type) ? true : isVoid2(element4);\n  return editor;\n};\nvar createInlineVoidPlugin = createPluginFactory({\n  key: KEY_INLINE_VOID,\n  withOverrides: withInlineVoid\n});\nvar getInjectedPlugins = (editor, plugin) => {\n  const injectedPlugins = [];\n  [...editor.plugins].reverse().forEach((p6) => {\n    var _p$inject$pluginsByKe;\n    const injectedPlugin = (_p$inject$pluginsByKe = p6.inject.pluginsByKey) === null || _p$inject$pluginsByKe === void 0 ? void 0 : _p$inject$pluginsByKe[plugin.key];\n    if (injectedPlugin)\n      injectedPlugins.push(injectedPlugin);\n  });\n  return [plugin, ...injectedPlugins];\n};\nvar pipeInsertDataQuery = (plugins, {\n  data,\n  dataTransfer\n}) => plugins.every((p6) => {\n  var _p$editor, _p$editor$insertData;\n  const query = (_p$editor = p6.editor) === null || _p$editor === void 0 ? void 0 : (_p$editor$insertData = _p$editor.insertData) === null || _p$editor$insertData === void 0 ? void 0 : _p$editor$insertData.query;\n  return !query || query({\n    data,\n    dataTransfer\n  });\n});\nvar withoutNormalizing = (editor, fn4) => {\n  let normalized = false;\n  Editor.withoutNormalizing(editor, () => {\n    normalized = !!fn4();\n  });\n  return normalized;\n};\nvar pipeInsertFragment = (editor, injectedPlugins, {\n  fragment,\n  ...options\n}) => {\n  withoutNormalizing(editor, () => {\n    injectedPlugins.some((p6) => {\n      var _p$editor, _p$editor$insertData, _p$editor$insertData$;\n      return ((_p$editor = p6.editor) === null || _p$editor === void 0 ? void 0 : (_p$editor$insertData = _p$editor.insertData) === null || _p$editor$insertData === void 0 ? void 0 : (_p$editor$insertData$ = _p$editor$insertData.preInsert) === null || _p$editor$insertData$ === void 0 ? void 0 : _p$editor$insertData$.call(_p$editor$insertData, fragment, options)) === true;\n    });\n    editor.insertFragment(fragment);\n  });\n};\nvar pipeTransformData = (plugins, {\n  data,\n  dataTransfer\n}) => {\n  plugins.forEach((p6) => {\n    var _p$editor, _p$editor$insertData;\n    const transformData = (_p$editor = p6.editor) === null || _p$editor === void 0 ? void 0 : (_p$editor$insertData = _p$editor.insertData) === null || _p$editor$insertData === void 0 ? void 0 : _p$editor$insertData.transformData;\n    if (!transformData)\n      return;\n    data = transformData(data, {\n      dataTransfer\n    });\n  });\n  return data;\n};\nvar pipeTransformFragment = (plugins, {\n  fragment,\n  ...options\n}) => {\n  plugins.forEach((p6) => {\n    var _p$editor, _p$editor$insertData;\n    const transformFragment = (_p$editor = p6.editor) === null || _p$editor === void 0 ? void 0 : (_p$editor$insertData = _p$editor.insertData) === null || _p$editor$insertData === void 0 ? void 0 : _p$editor$insertData.transformFragment;\n    if (!transformFragment)\n      return;\n    fragment = transformFragment(fragment, options);\n  });\n  return fragment;\n};\nvar withInsertData = (editor) => {\n  const {\n    insertData\n  } = editor;\n  editor.insertData = (dataTransfer) => {\n    const inserted = [...editor.plugins].reverse().some((plugin) => {\n      var _fragment;\n      const insertDataOptions = plugin.editor.insertData;\n      if (!insertDataOptions)\n        return false;\n      const injectedPlugins = getInjectedPlugins(editor, plugin);\n      const {\n        format: format3,\n        getFragment\n      } = insertDataOptions;\n      if (!format3)\n        return false;\n      let data = dataTransfer.getData(format3);\n      if (!data)\n        return;\n      if (!pipeInsertDataQuery(injectedPlugins, {\n        data,\n        dataTransfer\n      })) {\n        return false;\n      }\n      data = pipeTransformData(injectedPlugins, {\n        data,\n        dataTransfer\n      });\n      let fragment = getFragment === null || getFragment === void 0 ? void 0 : getFragment({\n        data,\n        dataTransfer\n      });\n      if (!((_fragment = fragment) !== null && _fragment !== void 0 && _fragment.length))\n        return false;\n      fragment = pipeTransformFragment(injectedPlugins, {\n        fragment,\n        data,\n        dataTransfer\n      });\n      if (!fragment.length)\n        return false;\n      pipeInsertFragment(editor, injectedPlugins, {\n        fragment,\n        data,\n        dataTransfer\n      });\n      return true;\n    });\n    if (inserted)\n      return;\n    insertData(dataTransfer);\n  };\n  return editor;\n};\nvar KEY_INSERT_DATA = \"insertData\";\nvar createInsertDataPlugin = createPluginFactory({\n  key: KEY_INSERT_DATA,\n  withOverrides: withInsertData\n});\nvar withTReact = (editor) => withReact(editor);\nvar createReactPlugin = createPluginFactory({\n  key: \"react\",\n  withOverrides: withTReact\n});\nvar KEY_SELECTION = \"selection\";\nvar createSelectionPlugin = createPluginFactory({\n  key: KEY_SELECTION,\n  withOverrides: (editor) => {\n    const {\n      apply: apply2\n    } = editor;\n    editor.apply = (operation) => {\n      if (operation.type === \"set_selection\") {\n        const {\n          properties\n        } = operation;\n        editor.prevSelection = properties;\n      }\n      apply2(operation);\n    };\n    return editor;\n  }\n});\nvar isElement2 = (value) => Element2.isElement(value);\nvar isText = (value) => Text.isText(value);\nvar ELEMENT_DEFAULT = \"p\";\nvar createTEditor = () => createEditor();\nvar createPlateStore = (state = {}) => createStore3(`plate-${state.id}`)({\n  id: \"main\",\n  value: [{\n    type: ELEMENT_DEFAULT,\n    children: [{\n      text: \"\"\n    }]\n  }],\n  editor: null,\n  isReady: false,\n  isRendered: false,\n  keyEditor: 1,\n  keyPlugins: 1,\n  keySelection: 1,\n  keyDecorate: 1,\n  decorate: null,\n  enabled: true,\n  editableProps: null,\n  onChange: null,\n  plugins: [],\n  renderElement: null,\n  renderLeaf: null,\n  ...state\n}).extendActions((_set, _get) => ({\n  /**\n   * Set a new editor with plate.\n   */\n  resetEditor: () => {\n    var _get$editor;\n    _set.editor(withPlate(createTEditor(), {\n      id: state.id,\n      plugins: (_get$editor = _get.editor()) === null || _get$editor === void 0 ? void 0 : _get$editor.plugins\n    }));\n  },\n  incrementKey: (key) => {\n    var _get$key;\n    const prev = (_get$key = _get[key]()) !== null && _get$key !== void 0 ? _get$key : 1;\n    _set[key](prev + 1);\n  }\n})).extendActions((_set) => ({\n  /**\n   * Redecorate the editor.\n   */\n  redecorate: () => {\n    _set.incrementKey(\"keyDecorate\");\n  }\n}));\nvar getPluginsByKey = (editor) => {\n  var _ref;\n  return (_ref = editor === null || editor === void 0 ? void 0 : editor.pluginsByKey) !== null && _ref !== void 0 ? _ref : {};\n};\nvar getPlugin = (editor, key) => {\n  var _getPluginsByKey$key;\n  return (_getPluginsByKey$key = getPluginsByKey(editor)[key]) !== null && _getPluginsByKey$key !== void 0 ? _getPluginsByKey$key : {\n    key\n  };\n};\nvar getPluginType = (editor, key) => {\n  var _ref, _getPlugin$type;\n  return (_ref = (_getPlugin$type = getPlugin(editor, key).type) !== null && _getPlugin$type !== void 0 ? _getPlugin$type : key) !== null && _ref !== void 0 ? _ref : \"\";\n};\nvar isInlineNode = (editor) => (node) => isText(node) || isElement2(node) && editor.isInline(node);\nvar makeBlockLazy = (type) => () => ({\n  type,\n  children: []\n});\nvar hasDifferentChildNodes = (descendants, isInline2) => {\n  return descendants.some((descendant, index5, arr) => {\n    const prevDescendant = arr[index5 - 1];\n    if (index5 !== 0) {\n      return isInline2(descendant) !== isInline2(prevDescendant);\n    }\n    return false;\n  });\n};\nvar normalizeDifferentNodeTypes = (descendants, isInline2, makeDefaultBlock) => {\n  const hasDifferentNodes = hasDifferentChildNodes(descendants, isInline2);\n  const {\n    fragment\n  } = descendants.reduce((memo3, node) => {\n    if (hasDifferentNodes && isInline2(node)) {\n      let block = memo3.precedingBlock;\n      if (!block) {\n        block = makeDefaultBlock();\n        memo3.precedingBlock = block;\n        memo3.fragment.push(block);\n      }\n      block.children.push(node);\n    } else {\n      memo3.fragment.push(node);\n      memo3.precedingBlock = null;\n    }\n    return memo3;\n  }, {\n    fragment: [],\n    precedingBlock: null\n  });\n  return fragment;\n};\nvar normalizeEmptyChildren = (descendants) => {\n  if (!descendants.length) {\n    return [{\n      text: \"\"\n    }];\n  }\n  return descendants;\n};\nvar normalize = (descendants, isInline2, makeDefaultBlock) => {\n  descendants = normalizeEmptyChildren(descendants);\n  descendants = normalizeDifferentNodeTypes(descendants, isInline2, makeDefaultBlock);\n  descendants = descendants.map((node) => {\n    if (isElement2(node)) {\n      return {\n        ...node,\n        children: normalize(node.children, isInline2, makeDefaultBlock)\n      };\n    }\n    return node;\n  });\n  return descendants;\n};\nvar normalizeDescendantsToDocumentFragment = (editor, {\n  descendants\n}) => {\n  const isInline2 = isInlineNode(editor);\n  const defaultType = getPluginType(editor, ELEMENT_DEFAULT);\n  const makeDefaultBlock = makeBlockLazy(defaultType);\n  return normalize(descendants, isInline2, makeDefaultBlock);\n};\nfunction isObject3(o7) {\n  return Object.prototype.toString.call(o7) === \"[object Object]\";\n}\nfunction isPlainObject2(o7) {\n  var ctor, prot;\n  if (isObject3(o7) === false)\n    return false;\n  ctor = o7.constructor;\n  if (ctor === void 0)\n    return true;\n  prot = ctor.prototype;\n  if (isObject3(prot) === false)\n    return false;\n  if (prot.hasOwnProperty(\"isPrototypeOf\") === false) {\n    return false;\n  }\n  return true;\n}\nfunction _defineProperty3(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar ANCHOR = /* @__PURE__ */ new WeakMap();\nvar FOCUS = /* @__PURE__ */ new WeakMap();\nvar Token = class {\n};\nvar AnchorToken = class extends Token {\n  constructor() {\n    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    super();\n    var {\n      offset: offset3,\n      path\n    } = props;\n    this.offset = offset3;\n    this.path = path;\n  }\n};\nvar FocusToken = class extends Token {\n  constructor() {\n    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    super();\n    var {\n      offset: offset3,\n      path\n    } = props;\n    this.offset = offset3;\n    this.path = path;\n  }\n};\nvar addAnchorToken = (text4, token) => {\n  var offset3 = text4.text.length;\n  ANCHOR.set(text4, [offset3, token]);\n};\nvar getAnchorOffset = (text4) => {\n  return ANCHOR.get(text4);\n};\nvar addFocusToken = (text4, token) => {\n  var offset3 = text4.text.length;\n  FOCUS.set(text4, [offset3, token]);\n};\nvar getFocusOffset = (text4) => {\n  return FOCUS.get(text4);\n};\nfunction ownKeys$13(object, enumerableOnly) {\n  var keys4 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys4.push.apply(keys4, symbols);\n  }\n  return keys4;\n}\nfunction _objectSpread$13(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    if (i5 % 2) {\n      ownKeys$13(Object(source), true).forEach(function(key) {\n        _defineProperty3(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$13(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar STRINGS = /* @__PURE__ */ new WeakSet();\nvar resolveDescendants = (children) => {\n  var nodes = [];\n  var addChild = (child2) => {\n    if (child2 == null) {\n      return;\n    }\n    var prev = nodes[nodes.length - 1];\n    if (typeof child2 === \"string\") {\n      var text4 = {\n        text: child2\n      };\n      STRINGS.add(text4);\n      child2 = text4;\n    }\n    if (Text.isText(child2)) {\n      var c5 = child2;\n      if (Text.isText(prev) && STRINGS.has(prev) && STRINGS.has(c5) && Text.equals(prev, c5, {\n        loose: true\n      })) {\n        prev.text += c5.text;\n      } else {\n        nodes.push(c5);\n      }\n    } else if (Element2.isElement(child2)) {\n      nodes.push(child2);\n    } else if (child2 instanceof Token) {\n      var n8 = nodes[nodes.length - 1];\n      if (!Text.isText(n8)) {\n        addChild(\"\");\n        n8 = nodes[nodes.length - 1];\n      }\n      if (child2 instanceof AnchorToken) {\n        addAnchorToken(n8, child2);\n      } else if (child2 instanceof FocusToken) {\n        addFocusToken(n8, child2);\n      }\n    } else {\n      throw new Error(\"Unexpected hyperscript child object: \".concat(child2));\n    }\n  };\n  for (var child of children.flat(Infinity)) {\n    addChild(child);\n  }\n  return nodes;\n};\nfunction createAnchor(tagName, attributes, children) {\n  return new AnchorToken(attributes);\n}\nfunction createCursor(tagName, attributes, children) {\n  return [new AnchorToken(attributes), new FocusToken(attributes)];\n}\nfunction createElement4(tagName, attributes, children) {\n  return _objectSpread$13(_objectSpread$13({}, attributes), {}, {\n    children: resolveDescendants(children)\n  });\n}\nfunction createFocus(tagName, attributes, children) {\n  return new FocusToken(attributes);\n}\nfunction createFragment(tagName, attributes, children) {\n  return resolveDescendants(children);\n}\nfunction createSelection(tagName, attributes, children) {\n  var anchor = children.find((c5) => c5 instanceof AnchorToken);\n  var focus = children.find((c5) => c5 instanceof FocusToken);\n  if (!anchor || anchor.offset == null || anchor.path == null) {\n    throw new Error(\"The <selection> hyperscript tag must have an <anchor> tag as a child with `path` and `offset` attributes defined.\");\n  }\n  if (!focus || focus.offset == null || focus.path == null) {\n    throw new Error(\"The <selection> hyperscript tag must have a <focus> tag as a child with `path` and `offset` attributes defined.\");\n  }\n  return _objectSpread$13({\n    anchor: {\n      offset: anchor.offset,\n      path: anchor.path\n    },\n    focus: {\n      offset: focus.offset,\n      path: focus.path\n    }\n  }, attributes);\n}\nfunction createText(tagName, attributes, children) {\n  var nodes = resolveDescendants(children);\n  if (nodes.length > 1) {\n    throw new Error(\"The <text> hyperscript tag must only contain a single node's worth of children.\");\n  }\n  var [node] = nodes;\n  if (node == null) {\n    node = {\n      text: \"\"\n    };\n  }\n  if (!Text.isText(node)) {\n    throw new Error(\"\\n    The <text> hyperscript tag can only contain text content as children.\");\n  }\n  STRINGS.delete(node);\n  Object.assign(node, attributes);\n  return node;\n}\nvar createEditor2 = (makeEditor) => (tagName, attributes, children) => {\n  var otherChildren = [];\n  var selectionChild;\n  for (var child of children) {\n    if (Range.isRange(child)) {\n      selectionChild = child;\n    } else {\n      otherChildren.push(child);\n    }\n  }\n  var descendants = resolveDescendants(otherChildren);\n  var selection = {};\n  var editor = makeEditor();\n  Object.assign(editor, attributes);\n  editor.children = descendants;\n  for (var [node, path] of Node2.texts(editor)) {\n    var anchor = getAnchorOffset(node);\n    var focus = getFocusOffset(node);\n    if (anchor != null) {\n      var [offset3] = anchor;\n      selection.anchor = {\n        path,\n        offset: offset3\n      };\n    }\n    if (focus != null) {\n      var [_offset] = focus;\n      selection.focus = {\n        path,\n        offset: _offset\n      };\n    }\n  }\n  if (selection.anchor && !selection.focus) {\n    throw new Error(\"Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<anchor />`. For collapsed selections, use `<cursor />` instead.\");\n  }\n  if (!selection.anchor && selection.focus) {\n    throw new Error(\"Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<focus />`. For collapsed selections, use `<cursor />` instead.\");\n  }\n  if (selectionChild != null) {\n    editor.selection = selectionChild;\n  } else if (Range.isRange(selection)) {\n    editor.selection = selection;\n  }\n  return editor;\n};\nfunction ownKeys3(object, enumerableOnly) {\n  var keys4 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys4.push.apply(keys4, symbols);\n  }\n  return keys4;\n}\nfunction _objectSpread3(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    if (i5 % 2) {\n      ownKeys3(Object(source), true).forEach(function(key) {\n        _defineProperty3(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys3(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar DEFAULT_CREATORS = {\n  anchor: createAnchor,\n  cursor: createCursor,\n  editor: createEditor2(createEditor),\n  element: createElement4,\n  focus: createFocus,\n  fragment: createFragment,\n  selection: createSelection,\n  text: createText\n};\nvar createHyperscript = function createHyperscript2() {\n  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n  var {\n    elements = {}\n  } = options;\n  var elementCreators = normalizeElements(elements);\n  var creators = _objectSpread3(_objectSpread3(_objectSpread3({}, DEFAULT_CREATORS), elementCreators), options.creators);\n  var jsx3 = createFactory(creators);\n  return jsx3;\n};\nvar createFactory = (creators) => {\n  var jsx3 = function jsx4(tagName, attributes) {\n    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      children[_key - 2] = arguments[_key];\n    }\n    var creator = creators[tagName];\n    if (!creator) {\n      throw new Error(\"No hyperscript creator found for tag: <\".concat(tagName, \">\"));\n    }\n    if (attributes == null) {\n      attributes = {};\n    }\n    if (!isPlainObject2(attributes)) {\n      children = [attributes].concat(children);\n      attributes = {};\n    }\n    children = children.filter((child) => Boolean(child)).flat();\n    var ret = creator(tagName, attributes, children);\n    return ret;\n  };\n  return jsx3;\n};\nvar normalizeElements = (elements) => {\n  var creators = {};\n  var _loop = function _loop2(tagName2) {\n    var props = elements[tagName2];\n    if (typeof props !== \"object\") {\n      throw new Error(\"Properties specified for a hyperscript shorthand should be an object, but for the custom element <\".concat(tagName2, \">  tag you passed: \").concat(props));\n    }\n    creators[tagName2] = (tagName3, attributes, children) => {\n      return createElement4(\"element\", _objectSpread3(_objectSpread3({}, props), attributes), children);\n    };\n  };\n  for (var tagName in elements) {\n    _loop(tagName);\n  }\n  return creators;\n};\nvar jsx = createHyperscript();\nvar deserializeHtmlNodeChildren = (editor, node) => Array.from(node.childNodes).map(deserializeHtmlNode(editor)).flat();\nvar htmlBodyToFragment = (editor, element4) => {\n  if (element4.nodeName === \"BODY\") {\n    return jsx(\"fragment\", {}, deserializeHtmlNodeChildren(editor, element4));\n  }\n};\nvar htmlBrToNewLine = (node) => {\n  if (node.nodeName === \"BR\") {\n    return \"\\n\";\n  }\n};\nfunction castArray() {\n  if (!arguments.length) {\n    return [];\n  }\n  var value = arguments[0];\n  return isArray_1(value) ? value : [value];\n}\nvar castArray_1 = castArray;\nvar pluginDeserializeHtml = (editor, plugin, {\n  element: el,\n  deserializeLeaf\n}) => {\n  var _getNode;\n  const {\n    deserializeHtml: deserializeHtml2,\n    isElement: isElementRoot,\n    isLeaf: isLeafRoot,\n    type\n  } = plugin;\n  if (!deserializeHtml2)\n    return;\n  const {\n    attributeNames,\n    query,\n    isLeaf: isLeafRule,\n    isElement: isElementRule,\n    rules\n  } = deserializeHtml2;\n  let {\n    getNode: getNode2\n  } = deserializeHtml2;\n  const isElement7 = isElementRule || isElementRoot;\n  const isLeaf = isLeafRule || isLeafRoot;\n  if (!deserializeLeaf && !isElement7) {\n    return;\n  }\n  if (deserializeLeaf && !isLeaf) {\n    return;\n  }\n  if (rules) {\n    const isValid = rules.some(({\n      validNodeName = \"*\",\n      validStyle,\n      validClassName,\n      validAttribute\n    }) => {\n      if (validNodeName) {\n        const validNodeNames = castArray_1(validNodeName);\n        if (validNodeNames.length && !validNodeNames.includes(el.nodeName) && validNodeName !== \"*\")\n          return false;\n      }\n      if (validClassName && !el.classList.contains(validClassName))\n        return false;\n      if (validStyle) {\n        for (const [key, value] of Object.entries(validStyle)) {\n          var _plugin$inject$props;\n          const values2 = castArray_1(value);\n          if (!values2.includes(el.style[key]) && value !== \"*\")\n            return;\n          if (value === \"*\" && !el.style[key])\n            return;\n          const defaultNodeValue = (_plugin$inject$props = plugin.inject.props) === null || _plugin$inject$props === void 0 ? void 0 : _plugin$inject$props.defaultNodeValue;\n          if (defaultNodeValue && defaultNodeValue === el.style[key]) {\n            return false;\n          }\n        }\n      }\n      if (validAttribute) {\n        if (typeof validAttribute === \"string\") {\n          if (!el.getAttributeNames().includes(validAttribute))\n            return false;\n        } else {\n          for (const [attributeName, attributeValue] of Object.entries(validAttribute)) {\n            const attributeValues = castArray_1(attributeValue);\n            const elAttribute = el.getAttribute(attributeName);\n            if (!elAttribute || !attributeValues.includes(elAttribute))\n              return false;\n          }\n        }\n      }\n      return true;\n    });\n    if (!isValid)\n      return;\n  }\n  if (query && !query(el)) {\n    return;\n  }\n  if (!getNode2) {\n    if (isElement7) {\n      getNode2 = () => ({\n        type\n      });\n    } else if (isLeaf) {\n      getNode2 = () => ({\n        [type]: true\n      });\n    } else {\n      return;\n    }\n  }\n  let node = (_getNode = getNode2(el, {})) !== null && _getNode !== void 0 ? _getNode : {};\n  if (!Object.keys(node).length)\n    return;\n  const injectedPlugins = getInjectedPlugins(editor, plugin);\n  injectedPlugins.forEach((injectedPlugin) => {\n    var _injectedPlugin$deser, _injectedPlugin$deser2;\n    const res = (_injectedPlugin$deser = injectedPlugin.deserializeHtml) === null || _injectedPlugin$deser === void 0 ? void 0 : (_injectedPlugin$deser2 = _injectedPlugin$deser.getNode) === null || _injectedPlugin$deser2 === void 0 ? void 0 : _injectedPlugin$deser2.call(_injectedPlugin$deser, el, node);\n    if (res) {\n      node = {\n        ...node,\n        ...res\n      };\n    }\n  });\n  if (attributeNames) {\n    const elementAttributes = {};\n    const elementAttributeNames = el.getAttributeNames();\n    for (const elementAttributeName of elementAttributeNames) {\n      if (attributeNames.includes(elementAttributeName)) {\n        elementAttributes[elementAttributeName] = el.getAttribute(elementAttributeName);\n      }\n    }\n    if (Object.keys(elementAttributes).length) {\n      node.attributes = elementAttributes;\n    }\n  }\n  return {\n    ...deserializeHtml2,\n    node\n  };\n};\nvar pipeDeserializeHtmlElement = (editor, element4) => {\n  let result;\n  [...editor.plugins].reverse().some((plugin) => {\n    result = pluginDeserializeHtml(editor, plugin, {\n      element: element4\n    });\n    return !!result;\n  });\n  return result;\n};\nvar htmlElementToElement = (editor, element4) => {\n  const deserialized = pipeDeserializeHtmlElement(editor, element4);\n  if (deserialized) {\n    var _node$children;\n    const {\n      node,\n      withoutChildren\n    } = deserialized;\n    let descendants = (_node$children = node.children) !== null && _node$children !== void 0 ? _node$children : deserializeHtmlNodeChildren(editor, element4);\n    if (!descendants.length || withoutChildren) {\n      descendants = [{\n        text: \"\"\n      }];\n    }\n    return jsx(\"element\", node, descendants);\n  }\n};\nvar merge = _createAssigner(function(object, source, srcIndex) {\n  _baseMerge(object, source, srcIndex);\n});\nvar merge_1 = merge;\nvar getNodeEntry = (editor, at, options) => Editor.node(editor, at, options);\nvar getPath = (editor, at, options) => Editor.path(editor, at, options);\nvar isVoid = (editor, value) => {\n  return Editor.isVoid(editor, value);\n};\nvar getNodeDescendants = (root5, options) => Node2.descendants(root5, options);\nvar isBlock = (editor, value) => Editor.isBlock(editor, value);\nvar match = (obj, path, predicate) => {\n  if (!predicate)\n    return true;\n  if (typeof predicate === \"object\") {\n    return Object.entries(predicate).every(([key, value]) => {\n      const values2 = castArray_1(value);\n      return values2.includes(obj[key]);\n    });\n  }\n  return predicate(obj, path);\n};\nvar getQueryOptions = (editor, options = {}) => {\n  const {\n    match: _match,\n    block\n  } = options;\n  return {\n    ...options,\n    match: _match || block ? (n8, path) => match(n8, path, _match) && (!block || isBlock(editor, n8)) : void 0\n  };\n};\nvar findDescendant = (editor, options) => {\n  try {\n    const {\n      match: _match,\n      at = editor.selection,\n      reverse = false,\n      voids = false\n    } = options;\n    if (!at)\n      return;\n    let from;\n    let to;\n    if (Span.isSpan(at)) {\n      [from, to] = at;\n    } else if (Range.isRange(at)) {\n      const first = getPath(editor, at, {\n        edge: \"start\"\n      });\n      const last2 = getPath(editor, at, {\n        edge: \"end\"\n      });\n      from = reverse ? last2 : first;\n      to = reverse ? first : last2;\n    }\n    let root5 = [editor, []];\n    if (Path.isPath(at)) {\n      root5 = getNodeEntry(editor, at);\n    }\n    const nodeEntries = getNodeDescendants(root5[0], {\n      reverse,\n      from,\n      to,\n      pass: ([n8]) => voids ? false : isVoid(editor, n8)\n    });\n    for (const [node, path] of nodeEntries) {\n      if (match(node, path, _match)) {\n        return [node, at.concat(path)];\n      }\n    }\n  } catch (error) {\n    return void 0;\n  }\n};\nvar unhangRange = (editor, range, options = {}) => {\n  const {\n    voids,\n    unhang = true\n  } = options;\n  if (Range.isRange(range) && unhang) {\n    return Editor.unhangRange(editor, range, {\n      voids\n    });\n  }\n};\nvar getNodeEntries = (editor, options) => {\n  unhangRange(editor, options === null || options === void 0 ? void 0 : options.at, options);\n  return Editor.nodes(editor, getQueryOptions(editor, options));\n};\nvar findNode = (editor, options = {}) => {\n  try {\n    const nodeEntries = getNodeEntries(editor, {\n      at: editor.selection || [],\n      ...getQueryOptions(editor, options)\n    });\n    for (const [node, path] of nodeEntries) {\n      return [node, path];\n    }\n  } catch (error) {\n    return void 0;\n  }\n};\nvar getAboveNode = (editor, options) => Editor.above(editor, getQueryOptions(editor, options));\nvar getBlockAbove = (editor, options = {}) => getAboveNode(editor, {\n  ...options,\n  block: true\n});\nvar isAncestor = (value) => Element2.isAncestor(value);\nvar getChildren = (nodeEntry) => {\n  const [node, path] = nodeEntry;\n  if (isAncestor(node)) {\n    const {\n      children\n    } = node;\n    return children.map((child, index5) => {\n      const childPath = path.concat([index5]);\n      return [child, childPath];\n    });\n  }\n  return [];\n};\nvar getEdgePoints = (editor, at) => Editor.edges(editor, at);\nvar getEdgeBlocksAbove = (editor, {\n  at: _at,\n  ...options\n} = {}) => {\n  const at = _at !== null && _at !== void 0 ? _at : editor.selection;\n  if (!at)\n    return null;\n  const [start2, end2] = getEdgePoints(editor, at !== null && at !== void 0 ? at : editor.selection);\n  const startBlock = getBlockAbove(editor, {\n    at: start2,\n    ...options\n  });\n  if (!startBlock)\n    return null;\n  const endBlock = getBlockAbove(editor, {\n    at: end2,\n    ...options\n  });\n  if (!endBlock)\n    return null;\n  return [startBlock, endBlock];\n};\nvar getLastChild$1 = (nodeEntry) => {\n  const [node, path] = nodeEntry;\n  if (isText(node))\n    return null;\n  if (!node.children.length)\n    return null;\n  const children = node.children;\n  return [children[children.length - 1], path.concat([children.length - 1])];\n};\nvar getLastChildPath = (nodeEntry) => {\n  const lastChild = getLastChild$1(nodeEntry);\n  if (!lastChild)\n    return nodeEntry[1].concat([-1]);\n  return lastChild[1];\n};\nvar isLastChild = (parentEntry, childPath) => {\n  const lastChildPath = getLastChildPath(parentEntry);\n  return Path.equals(lastChildPath, childPath);\n};\nvar getLastNode = (editor, at) => Editor.last(editor, at);\nvar getLastChild = (node, level) => {\n  if (!(level + 1) || !isAncestor(node))\n    return node;\n  const {\n    children\n  } = node;\n  const lastNode = children[children.length - 1];\n  return getLastChild(lastNode, level - 1);\n};\nvar getLastNodeByLevel = (editor, level) => {\n  const {\n    children\n  } = editor;\n  const lastNode = children[children.length - 1];\n  if (!lastNode)\n    return;\n  const [, lastPath] = getLastNode(editor, []);\n  return [getLastChild(lastNode, level - 1), lastPath.slice(0, level + 1)];\n};\nvar getMarks = (editor) => Editor.marks(editor);\nvar getMark = (editor, type) => {\n  if (!editor)\n    return;\n  const marks3 = getMarks(editor);\n  return marks3 === null || marks3 === void 0 ? void 0 : marks3[type];\n};\nvar getTEditor = (editor) => editor;\nvar createPathRef = (editor, at, options) => Editor.pathRef(editor, at, options);\nvar createPointRef = (editor, point, options) => Editor.pointRef(editor, point, options);\nvar deleteBackward = (editor, options) => Editor.deleteBackward(editor, options);\nvar hasSingleChild = (node) => {\n  if (isText(node)) {\n    return true;\n  }\n  return node.children.length === 1 && hasSingleChild(node.children[0]);\n};\nvar getParentNode = (editor, at, options) => {\n  try {\n    return Editor.parent(editor, at, options);\n  } catch (err) {\n  }\n};\nvar getPreviousNode = (editor, options) => Editor.previous(editor, options);\nvar isElementEmpty = (editor, element4) => Editor.isEmpty(editor, element4);\nvar deleteText = (editor, options) => {\n  Transforms.delete(editor, options);\n};\nvar moveNodes = (editor, options) => Transforms.moveNodes(editor, options);\nvar removeNodes = (editor, options) => Transforms.removeNodes(editor, options);\nvar select = (editor, target) => {\n  Transforms.select(editor, target);\n};\nvar mergeNodes = (editor, options = {}) => {\n  withoutNormalizing(editor, () => {\n    let {\n      match: match2,\n      at = editor.selection\n    } = options;\n    const {\n      mergeNode,\n      removeEmptyAncestor,\n      hanging = false,\n      voids = false,\n      mode = \"lowest\"\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match2 == null) {\n      if (Path.isPath(at)) {\n        const [parent2] = getParentNode(editor, at);\n        match2 = (n8) => parent2.children.includes(n8);\n      } else {\n        match2 = (n8) => isBlock(editor, n8);\n      }\n    }\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at);\n    }\n    if (Range.isRange(at)) {\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        const [, end2] = Range.edges(at);\n        const pointRef = createPointRef(editor, end2);\n        deleteText(editor, {\n          at\n        });\n        at = pointRef.unref();\n        if (options.at == null) {\n          select(editor, at);\n        }\n      }\n    }\n    const _nodes = getNodeEntries(editor, {\n      at,\n      match: match2,\n      voids,\n      mode\n    });\n    const [current] = Array.from(_nodes);\n    const prev = getPreviousNode(editor, {\n      at,\n      match: match2,\n      voids,\n      mode\n    });\n    if (!current || !prev) {\n      return;\n    }\n    const [node, path] = current;\n    const [prevNode, prevPath] = prev;\n    if (path.length === 0 || prevPath.length === 0) {\n      return;\n    }\n    const newPath = Path.next(prevPath);\n    const commonPath = Path.common(path, prevPath);\n    const isPreviousSibling = Path.isSibling(path, prevPath);\n    const _levels = Editor.levels(editor, {\n      at: path\n    });\n    const levels = Array.from(_levels, ([n8]) => n8).slice(commonPath.length).slice(0, -1);\n    const emptyAncestor = getAboveNode(editor, {\n      at: path,\n      mode: \"highest\",\n      match: (n8) => levels.includes(n8) && isElement2(n8) && hasSingleChild(n8)\n    });\n    const emptyRef = emptyAncestor && createPathRef(editor, emptyAncestor[1]);\n    let properties;\n    let position;\n    if (isText(node) && isText(prevNode)) {\n      const {\n        text: text4,\n        ...rest\n      } = node;\n      position = prevNode.text.length;\n      properties = rest;\n    } else if (isElement2(node) && isElement2(prevNode)) {\n      const {\n        children,\n        ...rest\n      } = node;\n      position = prevNode.children.length;\n      properties = rest;\n    } else {\n      throw new Error(`Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(node)} ${JSON.stringify(prevNode)}`);\n    }\n    if (!isPreviousSibling) {\n      if (!mergeNode) {\n        moveNodes(editor, {\n          at: path,\n          to: newPath,\n          voids\n        });\n      }\n    }\n    if (emptyRef) {\n      if (!removeEmptyAncestor) {\n        removeNodes(editor, {\n          at: emptyRef.current,\n          voids\n        });\n      } else {\n        const emptyPath = emptyRef.current;\n        emptyPath && removeEmptyAncestor(editor, {\n          at: emptyPath\n        });\n      }\n    }\n    if (mergeNode) {\n      mergeNode(editor, {\n        at: path,\n        to: newPath\n      });\n    } else if (isElement2(prevNode) && isElementEmpty(editor, prevNode) || isText(prevNode) && prevNode.text === \"\") {\n      removeNodes(editor, {\n        at: prevPath,\n        voids\n      });\n    } else {\n      editor.apply({\n        type: \"merge_node\",\n        path: newPath,\n        position,\n        properties\n      });\n    }\n    if (emptyRef) {\n      emptyRef.unref();\n    }\n  });\n};\nvar getEndPoint = (editor, at) => Editor.end(editor, at);\nvar getLeafNode = (editor, at, options) => Editor.leaf(editor, at, options);\nvar getPointAfter = (editor, at, options) => Editor.after(editor, at, options);\nvar getPointBefore = (editor, at, options) => Editor.before(editor, at, options);\nvar getStartPoint = (editor, at) => Editor.start(editor, at);\nvar getVoidNode = (editor, options) => Editor.void(editor, options);\nvar deleteMerge = (editor, options = {}) => {\n  withoutNormalizing(editor, () => {\n    const {\n      reverse = false,\n      unit = \"character\",\n      distance = 1,\n      voids = false\n    } = options;\n    let {\n      at = editor.selection,\n      hanging = false\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (Range.isRange(at) && Range.isCollapsed(at)) {\n      at = at.anchor;\n    }\n    if (Point.isPoint(at)) {\n      const furthestVoid = getVoidNode(editor, {\n        at,\n        mode: \"highest\"\n      });\n      if (!voids && furthestVoid) {\n        const [, voidPath] = furthestVoid;\n        at = voidPath;\n      } else {\n        const opts = {\n          unit,\n          distance\n        };\n        const target = reverse ? getPointBefore(editor, at, opts) || getStartPoint(editor, []) : getPointAfter(editor, at, opts) || getEndPoint(editor, []);\n        at = {\n          anchor: at,\n          focus: target\n        };\n        hanging = true;\n      }\n    }\n    if (Path.isPath(at)) {\n      removeNodes(editor, {\n        at,\n        voids\n      });\n      return;\n    }\n    if (Range.isCollapsed(at)) {\n      return;\n    }\n    if (!hanging) {\n      at = Editor.unhangRange(editor, at, {\n        voids\n      });\n    }\n    let [start2, end2] = Range.edges(at);\n    const startBlock = getAboveNode(editor, {\n      match: (n8) => isBlock(editor, n8),\n      at: start2,\n      voids\n    });\n    const endBlock = getAboveNode(editor, {\n      match: (n8) => isBlock(editor, n8),\n      at: end2,\n      voids\n    });\n    const isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n    const isSingleText = Path.equals(start2.path, end2.path);\n    const startVoid = voids ? null : getVoidNode(editor, {\n      at: start2,\n      mode: \"highest\"\n    });\n    const endVoid = voids ? null : getVoidNode(editor, {\n      at: end2,\n      mode: \"highest\"\n    });\n    if (startVoid) {\n      const before = getPointBefore(editor, start2);\n      if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n        start2 = before;\n      }\n    }\n    if (endVoid) {\n      const after = getPointAfter(editor, end2);\n      if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n        end2 = after;\n      }\n    }\n    const matches = [];\n    let lastPath;\n    const _nodes = getNodeEntries(editor, {\n      at,\n      voids\n    });\n    for (const entry of _nodes) {\n      const [node, path] = entry;\n      if (lastPath && Path.compare(path, lastPath) === 0) {\n        continue;\n      }\n      if (!voids && isVoid(editor, node) || !Path.isCommon(path, start2.path) && !Path.isCommon(path, end2.path)) {\n        matches.push(entry);\n        lastPath = path;\n      }\n    }\n    const pathRefs = Array.from(matches, ([, p6]) => createPathRef(editor, p6));\n    const startRef = createPointRef(editor, start2);\n    const endRef = createPointRef(editor, end2);\n    if (!isSingleText && !startVoid) {\n      const point2 = startRef.current;\n      const [node] = getLeafNode(editor, point2);\n      const {\n        path\n      } = point2;\n      const {\n        offset: offset3\n      } = start2;\n      const text4 = node.text.slice(offset3);\n      editor.apply({\n        type: \"remove_text\",\n        path,\n        offset: offset3,\n        text: text4\n      });\n    }\n    for (const pathRef of pathRefs) {\n      const path = pathRef.unref();\n      removeNodes(editor, {\n        at: path,\n        voids\n      });\n    }\n    if (!endVoid) {\n      const point2 = endRef.current;\n      const [node] = getLeafNode(editor, point2);\n      const {\n        path\n      } = point2;\n      const offset3 = isSingleText ? start2.offset : 0;\n      const text4 = node.text.slice(offset3, end2.offset);\n      editor.apply({\n        type: \"remove_text\",\n        path,\n        offset: offset3,\n        text: text4\n      });\n    }\n    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n      mergeNodes(editor, {\n        at: endRef.current,\n        hanging: true,\n        voids\n      });\n    }\n    const point = endRef.unref() || startRef.unref();\n    if (options.at == null && point) {\n      select(editor, point);\n    }\n  });\n};\nvar getEditorString = (editor, at, options) => at ? Editor.string(editor, at, options) : \"\";\nvar getNextNode = (editor, options) => Editor.next(editor, options);\nvar getPoint = (editor, at, options) => Editor.point(editor, at, options);\nvar getRange = (editor, at, to) => Editor.range(editor, at, to);\nvar isEndPoint = (editor, point, at) => !!point && Editor.isEnd(editor, point, at);\nvar isInline = (editor, value) => Editor.isInline(editor, value);\nvar isStartPoint = (editor, point, at) => !!point && Editor.isStart(editor, point, at);\nvar normalizeEditor = (editor, options) => Editor.normalize(editor, options);\nvar withoutMergingHistory = (editor, fn4) => HistoryEditor.withoutMerging(editor, fn4);\nvar getCommonNode = (root5, path, another) => Node2.common(root5, path, another);\nvar getNode = (root5, path) => {\n  try {\n    for (let i5 = 0; i5 < path.length; i5++) {\n      const p6 = path[i5];\n      if (isText(root5) || !root5.children[p6]) {\n        return null;\n      }\n      root5 = root5.children[p6];\n    }\n    return root5;\n  } catch (e4) {\n    return null;\n  }\n};\nvar getNodeChildren = (root5, path, options) => Node2.children(root5, path, options);\nvar getNodeLeaf = (root5, path) => Node2.leaf(root5, path);\nvar getNodeProps = (node) => Node2.extractProps(node);\nvar getNodeString = (node) => Node2.string(node);\nvar getNodeTexts = (root5, options) => Node2.texts(root5, options);\nvar getNodes = (root5, options) => Node2.nodes(root5, options);\nvar hasNode = (root5, path) => Node2.has(root5, path);\nvar isCollapsed = (range) => !!range && Range.isCollapsed(range);\nvar isExpanded = (range) => !!range && Range.isExpanded(range);\nvar findNodePath = (editor, node) => {\n  try {\n    return ReactEditor.findPath(editor, node);\n  } catch (e4) {\n  }\n};\nvar collapseSelection = (editor, options) => {\n  Transforms.collapse(editor, options);\n};\nvar deselect = (editor) => {\n  Transforms.deselect(editor);\n};\nvar insertFragment = (editor, fragment, options) => {\n  Transforms.insertFragment(editor, fragment, options);\n};\nvar insertNodes = (editor, nodes, options) => Transforms.insertNodes(editor, nodes, options);\nvar insertText = (editor, text4, options) => {\n  Transforms.insertText(editor, text4, options);\n};\nvar moveSelection = (editor, options) => {\n  Transforms.move(editor, options);\n};\nvar setNodes = (editor, props, options) => Transforms.setNodes(editor, props, options);\nvar setSelection = (editor, props) => {\n  Transforms.setSelection(editor, props);\n};\nvar splitNodes = (editor, options) => Transforms.splitNodes(editor, options);\nvar unsetNodes = (editor, props, options) => {\n  return Transforms.unsetNodes(editor, props, options);\n};\nvar unwrapNodes = (editor, options) => {\n  Transforms.unwrapNodes(editor, getQueryOptions(editor, options));\n};\nvar wrapNodes = (editor, element4, options) => {\n  unhangRange(editor, options === null || options === void 0 ? void 0 : options.at, options);\n  Transforms.wrapNodes(editor, element4, options);\n};\nvar focusEditor = (editor, target) => {\n  if (target) {\n    withoutNormalizing(editor, () => {\n      deselect(editor);\n      select(editor, target);\n    });\n  }\n  ReactEditor.focus(editor);\n};\nvar toDOMRange = (editor, range) => {\n  try {\n    return ReactEditor.toDOMRange(editor, range);\n  } catch (e4) {\n  }\n};\nvar getNextNodeStartPoint = (editor, at) => {\n  const nextEntry = getNextNode(editor, {\n    at\n  });\n  if (!nextEntry)\n    return;\n  return getStartPoint(editor, nextEntry[1]);\n};\nvar getNextSiblingNodes = (ancestorEntry, path) => {\n  const [ancestor, ancestorPath] = ancestorEntry;\n  const leafIndex = path[ancestorPath.length];\n  const siblings = [];\n  const ancestorChildren = ancestor.children;\n  if (leafIndex + 1 < ancestor.children.length) {\n    for (let i5 = leafIndex + 1; i5 < ancestor.children.length; i5++) {\n      siblings.push(ancestorChildren[i5]);\n    }\n  }\n  return siblings;\n};\nfunction arrayMap(array, iteratee) {\n  var index5 = -1, length = array == null ? 0 : array.length, result = Array(length);\n  while (++index5 < length) {\n    result[index5] = iteratee(array[index5], index5, array);\n  }\n  return result;\n}\nvar _arrayMap = arrayMap;\nvar HASH_UNDEFINED2 = \"__lodash_hash_undefined__\";\nfunction setCacheAdd2(value) {\n  this.__data__.set(value, HASH_UNDEFINED2);\n  return this;\n}\nvar _setCacheAdd2 = setCacheAdd2;\nfunction setCacheHas2(value) {\n  return this.__data__.has(value);\n}\nvar _setCacheHas2 = setCacheHas2;\nfunction SetCache2(values2) {\n  var index5 = -1, length = values2 == null ? 0 : values2.length;\n  this.__data__ = new _MapCache2();\n  while (++index5 < length) {\n    this.add(values2[index5]);\n  }\n}\nSetCache2.prototype.add = SetCache2.prototype.push = _setCacheAdd2;\nSetCache2.prototype.has = _setCacheHas2;\nvar _SetCache = SetCache2;\nfunction arraySome(array, predicate) {\n  var index5 = -1, length = array == null ? 0 : array.length;\n  while (++index5 < length) {\n    if (predicate(array[index5], index5, array)) {\n      return true;\n    }\n  }\n  return false;\n}\nvar _arraySome = arraySome;\nfunction cacheHas(cache2, key) {\n  return cache2.has(key);\n}\nvar _cacheHas = cacheHas;\nvar COMPARE_PARTIAL_FLAG$5 = 1;\nvar COMPARE_UNORDERED_FLAG$3 = 2;\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  var arrStacked = stack.get(array);\n  var othStacked = stack.get(other);\n  if (arrStacked && othStacked) {\n    return arrStacked == other && othStacked == array;\n  }\n  var index5 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new _SetCache() : void 0;\n  stack.set(array, other);\n  stack.set(other, array);\n  while (++index5 < arrLength) {\n    var arrValue = array[index5], othValue = other[index5];\n    if (customizer) {\n      var compared = isPartial ? customizer(othValue, arrValue, index5, other, array, stack) : customizer(arrValue, othValue, index5, array, other, stack);\n    }\n    if (compared !== void 0) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    if (seen) {\n      if (!_arraySome(other, function(othValue2, othIndex) {\n        if (!_cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {\n          return seen.push(othIndex);\n        }\n      })) {\n        result = false;\n        break;\n      }\n    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n      result = false;\n      break;\n    }\n  }\n  stack[\"delete\"](array);\n  stack[\"delete\"](other);\n  return result;\n}\nvar _equalArrays = equalArrays;\nfunction mapToArray(map2) {\n  var index5 = -1, result = Array(map2.size);\n  map2.forEach(function(value, key) {\n    result[++index5] = [key, value];\n  });\n  return result;\n}\nvar _mapToArray = mapToArray;\nfunction setToArray(set4) {\n  var index5 = -1, result = Array(set4.size);\n  set4.forEach(function(value) {\n    result[++index5] = value;\n  });\n  return result;\n}\nvar _setToArray = setToArray;\nvar COMPARE_PARTIAL_FLAG$4 = 1;\nvar COMPARE_UNORDERED_FLAG$2 = 2;\nvar boolTag$2 = \"[object Boolean]\";\nvar dateTag$2 = \"[object Date]\";\nvar errorTag$12 = \"[object Error]\";\nvar mapTag$4 = \"[object Map]\";\nvar numberTag$2 = \"[object Number]\";\nvar regexpTag$2 = \"[object RegExp]\";\nvar setTag$4 = \"[object Set]\";\nvar stringTag$2 = \"[object String]\";\nvar symbolTag$3 = \"[object Symbol]\";\nvar arrayBufferTag$2 = \"[object ArrayBuffer]\";\nvar dataViewTag$3 = \"[object DataView]\";\nvar symbolProto$2 = _Symbol2 ? _Symbol2.prototype : void 0;\nvar symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag$3:\n      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n    case arrayBufferTag$2:\n      if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {\n        return false;\n      }\n      return true;\n    case boolTag$2:\n    case dateTag$2:\n    case numberTag$2:\n      return eq_12(+object, +other);\n    case errorTag$12:\n      return object.name == other.name && object.message == other.message;\n    case regexpTag$2:\n    case stringTag$2:\n      return object == other + \"\";\n    case mapTag$4:\n      var convert = _mapToArray;\n    case setTag$4:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;\n      convert || (convert = _setToArray);\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG$2;\n      stack.set(object, other);\n      var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack[\"delete\"](object);\n      return result;\n    case symbolTag$3:\n      if (symbolValueOf$1) {\n        return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);\n      }\n  }\n  return false;\n}\nvar _equalByTag = equalByTag;\nfunction arrayPush(array, values2) {\n  var index5 = -1, length = values2.length, offset3 = array.length;\n  while (++index5 < length) {\n    array[offset3 + index5] = values2[index5];\n  }\n  return array;\n}\nvar _arrayPush = arrayPush;\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));\n}\nvar _baseGetAllKeys = baseGetAllKeys;\nfunction arrayFilter(array, predicate) {\n  var index5 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];\n  while (++index5 < length) {\n    var value = array[index5];\n    if (predicate(value, index5, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\nvar _arrayFilter = arrayFilter;\nfunction stubArray() {\n  return [];\n}\nvar stubArray_1 = stubArray;\nvar objectProto$52 = Object.prototype;\nvar propertyIsEnumerable2 = objectProto$52.propertyIsEnumerable;\nvar nativeGetSymbols$1 = Object.getOwnPropertySymbols;\nvar getSymbols = !nativeGetSymbols$1 ? stubArray_1 : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return _arrayFilter(nativeGetSymbols$1(object), function(symbol) {\n    return propertyIsEnumerable2.call(object, symbol);\n  });\n};\nvar _getSymbols = getSymbols;\nvar nativeKeys2 = _overArg2(Object.keys, Object);\nvar _nativeKeys = nativeKeys2;\nvar objectProto$42 = Object.prototype;\nvar hasOwnProperty$42 = objectProto$42.hasOwnProperty;\nfunction baseKeys(object) {\n  if (!_isPrototype(object)) {\n    return _nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty$42.call(object, key) && key != \"constructor\") {\n      result.push(key);\n    }\n  }\n  return result;\n}\nvar _baseKeys = baseKeys;\nfunction keys(object) {\n  return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);\n}\nvar keys_1 = keys;\nfunction getAllKeys(object) {\n  return _baseGetAllKeys(object, keys_1, _getSymbols);\n}\nvar _getAllKeys = getAllKeys;\nvar COMPARE_PARTIAL_FLAG$3 = 1;\nvar objectProto$32 = Object.prototype;\nvar hasOwnProperty$32 = objectProto$32.hasOwnProperty;\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = _getAllKeys(object), objLength = objProps.length, othProps = _getAllKeys(other), othLength = othProps.length;\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index5 = objLength;\n  while (index5--) {\n    var key = objProps[index5];\n    if (!(isPartial ? key in other : hasOwnProperty$32.call(other, key))) {\n      return false;\n    }\n  }\n  var objStacked = stack.get(object);\n  var othStacked = stack.get(other);\n  if (objStacked && othStacked) {\n    return objStacked == other && othStacked == object;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n  var skipCtor = isPartial;\n  while (++index5 < objLength) {\n    key = objProps[index5];\n    var objValue = object[key], othValue = other[key];\n    if (customizer) {\n      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n    }\n    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == \"constructor\");\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor, othCtor = other.constructor;\n    if (objCtor != othCtor && (\"constructor\" in object && \"constructor\" in other) && !(typeof objCtor == \"function\" && objCtor instanceof objCtor && typeof othCtor == \"function\" && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack[\"delete\"](object);\n  stack[\"delete\"](other);\n  return result;\n}\nvar _equalObjects = equalObjects;\nvar DataView2 = _getNative2(_root2, \"DataView\");\nvar _DataView2 = DataView2;\nvar Promise$12 = _getNative2(_root2, \"Promise\");\nvar _Promise2 = Promise$12;\nvar Set3 = _getNative2(_root2, \"Set\");\nvar _Set2 = Set3;\nvar WeakMap$1 = _getNative2(_root2, \"WeakMap\");\nvar _WeakMap2 = WeakMap$1;\nvar mapTag$3 = \"[object Map]\";\nvar objectTag$22 = \"[object Object]\";\nvar promiseTag2 = \"[object Promise]\";\nvar setTag$3 = \"[object Set]\";\nvar weakMapTag$12 = \"[object WeakMap]\";\nvar dataViewTag$22 = \"[object DataView]\";\nvar dataViewCtorString2 = _toSource2(_DataView2);\nvar mapCtorString2 = _toSource2(_Map2);\nvar promiseCtorString2 = _toSource2(_Promise2);\nvar setCtorString2 = _toSource2(_Set2);\nvar weakMapCtorString2 = _toSource2(_WeakMap2);\nvar getTag2 = _baseGetTag2;\nif (_DataView2 && getTag2(new _DataView2(new ArrayBuffer(1))) != dataViewTag$22 || _Map2 && getTag2(new _Map2()) != mapTag$3 || _Promise2 && getTag2(_Promise2.resolve()) != promiseTag2 || _Set2 && getTag2(new _Set2()) != setTag$3 || _WeakMap2 && getTag2(new _WeakMap2()) != weakMapTag$12) {\n  getTag2 = function(value) {\n    var result = _baseGetTag2(value), Ctor = result == objectTag$22 ? value.constructor : void 0, ctorString = Ctor ? _toSource2(Ctor) : \"\";\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString2:\n          return dataViewTag$22;\n        case mapCtorString2:\n          return mapTag$3;\n        case promiseCtorString2:\n          return promiseTag2;\n        case setCtorString2:\n          return setTag$3;\n        case weakMapCtorString2:\n          return weakMapTag$12;\n      }\n    }\n    return result;\n  };\n}\nvar _getTag = getTag2;\nvar COMPARE_PARTIAL_FLAG$2 = 1;\nvar argsTag$12 = \"[object Arguments]\";\nvar arrayTag$12 = \"[object Array]\";\nvar objectTag$12 = \"[object Object]\";\nvar objectProto$22 = Object.prototype;\nvar hasOwnProperty$22 = objectProto$22.hasOwnProperty;\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray_1(object), othIsArr = isArray_1(other), objTag = objIsArr ? arrayTag$12 : _getTag(object), othTag = othIsArr ? arrayTag$12 : _getTag(other);\n  objTag = objTag == argsTag$12 ? objectTag$12 : objTag;\n  othTag = othTag == argsTag$12 ? objectTag$12 : othTag;\n  var objIsObj = objTag == objectTag$12, othIsObj = othTag == objectTag$12, isSameTag = objTag == othTag;\n  if (isSameTag && isBuffer_12(object)) {\n    if (!isBuffer_12(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new _Stack());\n    return objIsArr || isTypedArray_1(object) ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack) : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {\n    var objIsWrapped = objIsObj && hasOwnProperty$22.call(object, \"__wrapped__\"), othIsWrapped = othIsObj && hasOwnProperty$22.call(other, \"__wrapped__\");\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;\n      stack || (stack = new _Stack());\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new _Stack());\n  return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\nvar _baseIsEqualDeep = baseIsEqualDeep;\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || !isObjectLike_12(value) && !isObjectLike_12(other)) {\n    return value !== value && other !== other;\n  }\n  return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\nvar _baseIsEqual = baseIsEqual;\nvar COMPARE_PARTIAL_FLAG$1 = 1;\nvar COMPARE_UNORDERED_FLAG$1 = 2;\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index5 = matchData.length, length = index5, noCustomizer = !customizer;\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index5--) {\n    var data = matchData[index5];\n    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n      return false;\n    }\n  }\n  while (++index5 < length) {\n    data = matchData[index5];\n    var key = data[0], objValue = object[key], srcValue = data[1];\n    if (noCustomizer && data[2]) {\n      if (objValue === void 0 && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new _Stack();\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === void 0 ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nvar _baseIsMatch = baseIsMatch;\nfunction isStrictComparable(value) {\n  return value === value && !isObject_12(value);\n}\nvar _isStrictComparable = isStrictComparable;\nfunction getMatchData(object) {\n  var result = keys_1(object), length = result.length;\n  while (length--) {\n    var key = result[length], value = object[key];\n    result[length] = [key, value, _isStrictComparable(value)];\n  }\n  return result;\n}\nvar _getMatchData = getMatchData;\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));\n  };\n}\nvar _matchesStrictComparable = matchesStrictComparable;\nfunction baseMatches(source) {\n  var matchData = _getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return _matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || _baseIsMatch(object, source, matchData);\n  };\n}\nvar _baseMatches = baseMatches;\nvar symbolTag$2 = \"[object Symbol]\";\nfunction isSymbol(value) {\n  return typeof value == \"symbol\" || isObjectLike_12(value) && _baseGetTag2(value) == symbolTag$2;\n}\nvar isSymbol_1 = isSymbol;\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nvar reIsPlainProp = /^\\w*$/;\nfunction isKey(value, object) {\n  if (isArray_1(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == \"number\" || type == \"symbol\" || type == \"boolean\" || value == null || isSymbol_1(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n}\nvar _isKey = isKey;\nvar FUNC_ERROR_TEXT2 = \"Expected a function\";\nfunction memoize2(func, resolver) {\n  if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n    throw new TypeError(FUNC_ERROR_TEXT2);\n  }\n  var memoized = function() {\n    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;\n    if (cache2.has(key)) {\n      return cache2.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache2.set(key, result) || cache2;\n    return result;\n  };\n  memoized.cache = new (memoize2.Cache || _MapCache2)();\n  return memoized;\n}\nmemoize2.Cache = _MapCache2;\nvar memoize_12 = memoize2;\nvar MAX_MEMOIZE_SIZE2 = 500;\nfunction memoizeCapped2(func) {\n  var result = memoize_12(func, function(key) {\n    if (cache2.size === MAX_MEMOIZE_SIZE2) {\n      cache2.clear();\n    }\n    return key;\n  });\n  var cache2 = result.cache;\n  return result;\n}\nvar _memoizeCapped2 = memoizeCapped2;\nvar rePropName2 = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\nvar reEscapeChar2 = /\\\\(\\\\)?/g;\nvar stringToPath2 = _memoizeCapped2(function(string2) {\n  var result = [];\n  if (string2.charCodeAt(0) === 46) {\n    result.push(\"\");\n  }\n  string2.replace(rePropName2, function(match2, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar2, \"$1\") : number || match2);\n  });\n  return result;\n});\nvar _stringToPath = stringToPath2;\nvar INFINITY$12 = 1 / 0;\nvar symbolProto$12 = _Symbol2 ? _Symbol2.prototype : void 0;\nvar symbolToString2 = symbolProto$12 ? symbolProto$12.toString : void 0;\nfunction baseToString(value) {\n  if (typeof value == \"string\") {\n    return value;\n  }\n  if (isArray_1(value)) {\n    return _arrayMap(value, baseToString) + \"\";\n  }\n  if (isSymbol_1(value)) {\n    return symbolToString2 ? symbolToString2.call(value) : \"\";\n  }\n  var result = value + \"\";\n  return result == \"0\" && 1 / value == -INFINITY$12 ? \"-0\" : result;\n}\nvar _baseToString = baseToString;\nfunction toString(value) {\n  return value == null ? \"\" : _baseToString(value);\n}\nvar toString_1 = toString;\nfunction castPath(value, object) {\n  if (isArray_1(value)) {\n    return value;\n  }\n  return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));\n}\nvar _castPath = castPath;\nvar INFINITY2 = 1 / 0;\nfunction toKey(value) {\n  if (typeof value == \"string\" || isSymbol_1(value)) {\n    return value;\n  }\n  var result = value + \"\";\n  return result == \"0\" && 1 / value == -INFINITY2 ? \"-0\" : result;\n}\nvar _toKey = toKey;\nfunction baseGet(object, path) {\n  path = _castPath(path, object);\n  var index5 = 0, length = path.length;\n  while (object != null && index5 < length) {\n    object = object[_toKey(path[index5++])];\n  }\n  return index5 && index5 == length ? object : void 0;\n}\nvar _baseGet = baseGet;\nfunction get(object, path, defaultValue) {\n  var result = object == null ? void 0 : _baseGet(object, path);\n  return result === void 0 ? defaultValue : result;\n}\nvar get_1 = get;\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\nvar _baseHasIn = baseHasIn;\nfunction hasPath(object, path, hasFunc) {\n  path = _castPath(path, object);\n  var index5 = -1, length = path.length, result = false;\n  while (++index5 < length) {\n    var key = _toKey(path[index5]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index5 != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength_12(length) && _isIndex(key, length) && (isArray_1(object) || isArguments_1(object));\n}\nvar _hasPath = hasPath;\nfunction hasIn(object, path) {\n  return object != null && _hasPath(object, path, _baseHasIn);\n}\nvar hasIn_1 = hasIn;\nvar COMPARE_PARTIAL_FLAG = 1;\nvar COMPARE_UNORDERED_FLAG = 2;\nfunction baseMatchesProperty(path, srcValue) {\n  if (_isKey(path) && _isStrictComparable(srcValue)) {\n    return _matchesStrictComparable(_toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get_1(object, path);\n    return objValue === void 0 && objValue === srcValue ? hasIn_1(object, path) : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\nvar _baseMatchesProperty = baseMatchesProperty;\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? void 0 : object[key];\n  };\n}\nvar _baseProperty = baseProperty;\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return _baseGet(object, path);\n  };\n}\nvar _basePropertyDeep = basePropertyDeep;\nfunction property(path) {\n  return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);\n}\nvar property_1 = property;\nfunction baseIteratee(value) {\n  if (typeof value == \"function\") {\n    return value;\n  }\n  if (value == null) {\n    return identity_1;\n  }\n  if (typeof value == \"object\") {\n    return isArray_1(value) ? _baseMatchesProperty(value[0], value[1]) : _baseMatches(value);\n  }\n  return property_1(value);\n}\nvar _baseIteratee = baseIteratee;\nfunction baseForOwn(object, iteratee) {\n  return object && _baseFor(object, iteratee, keys_1);\n}\nvar _baseForOwn = baseForOwn;\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike_1(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length, index5 = fromRight ? length : -1, iterable = Object(collection);\n    while (fromRight ? index5-- : ++index5 < length) {\n      if (iteratee(iterable[index5], index5, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\nvar _createBaseEach = createBaseEach;\nvar baseEach = _createBaseEach(_baseForOwn);\nvar _baseEach = baseEach;\nfunction baseMap(collection, iteratee) {\n  var index5 = -1, result = isArrayLike_1(collection) ? Array(collection.length) : [];\n  _baseEach(collection, function(value, key, collection2) {\n    result[++index5] = iteratee(value, key, collection2);\n  });\n  return result;\n}\nvar _baseMap = baseMap;\nfunction map(collection, iteratee) {\n  var func = isArray_1(collection) ? _arrayMap : _baseMap;\n  return func(collection, _baseIteratee(iteratee));\n}\nvar map_1 = map;\nvar isRangeAcrossBlocks = (editor, {\n  at,\n  ...options\n} = {}) => {\n  if (!at)\n    at = editor.selection;\n  if (!at)\n    return;\n  const [start2, end2] = Range.edges(at);\n  const startBlock = getBlockAbove(editor, {\n    at: start2,\n    ...options\n  });\n  const endBlock = getBlockAbove(editor, {\n    at: end2,\n    ...options\n  });\n  if (!startBlock && !endBlock)\n    return;\n  if (!startBlock || !endBlock)\n    return true;\n  return !Path.equals(startBlock[1], endBlock[1]);\n};\nvar getPointBeforeLocation = (editor, at, options) => {\n  if (!options || !options.match && !options.matchString) {\n    return getPointBefore(editor, at, options);\n  }\n  const unitOffset = !options.unit || options.unit === \"offset\";\n  const matchStrings = options.matchString ? castArray_1(options.matchString) : [\"\"];\n  let point;\n  matchStrings.some((matchString) => {\n    let beforeAt = at;\n    let previousBeforePoint = getPoint(editor, at, {\n      edge: \"end\"\n    });\n    const stackLength = matchString.length + 1;\n    const stack = Array(stackLength);\n    let count2 = 0;\n    while (true) {\n      var _options$match;\n      const beforePoint = getPointBefore(editor, beforeAt, options);\n      if (!beforePoint)\n        return;\n      if (isRangeAcrossBlocks(editor, {\n        at: {\n          anchor: beforePoint,\n          focus: previousBeforePoint\n        }\n      })) {\n        return;\n      }\n      const beforeString = getEditorString(editor, {\n        anchor: beforePoint,\n        focus: previousBeforePoint\n      });\n      let beforeStringToMatch = beforeString;\n      if (unitOffset && stackLength) {\n        stack.unshift({\n          point: beforePoint,\n          text: beforeString\n        });\n        stack.pop();\n        beforeStringToMatch = map_1(stack.slice(0, -1), \"text\").join(\"\");\n      }\n      if (matchString === beforeStringToMatch || (_options$match = options.match) !== null && _options$match !== void 0 && _options$match.call(options, {\n        beforeString: beforeStringToMatch,\n        beforePoint,\n        at\n      })) {\n        if (options.afterMatch) {\n          if (stackLength && unitOffset) {\n            var _stack;\n            point = (_stack = stack[stack.length - 1]) === null || _stack === void 0 ? void 0 : _stack.point;\n            return !!point;\n          }\n          point = previousBeforePoint;\n          return true;\n        }\n        point = beforePoint;\n        return true;\n      }\n      previousBeforePoint = beforePoint;\n      beforeAt = beforePoint;\n      count2 += 1;\n      if (!options.skipInvalid) {\n        if (!matchString || count2 >= matchString.length)\n          return;\n      }\n    }\n  });\n  return point;\n};\nvar getPointFromLocation = (editor, {\n  at = editor.selection,\n  focus\n} = {}) => {\n  let point;\n  if (Range.isRange(at))\n    point = !focus ? at.anchor : at.focus;\n  if (Point.isPoint(at))\n    point = at;\n  if (Path.isPath(at))\n    point = {\n      path: at,\n      offset: 0\n    };\n  return point;\n};\nvar queryNode = (entry, {\n  filter: filter3,\n  allow,\n  exclude\n} = {}) => {\n  if (!entry)\n    return false;\n  if (filter3 && !filter3(entry)) {\n    return false;\n  }\n  if (allow) {\n    const allows = castArray_1(allow);\n    if (allows.length && !allows.includes(entry[0].type)) {\n      return false;\n    }\n  }\n  if (exclude) {\n    const excludes = castArray_1(exclude);\n    if (excludes.length && excludes.includes(entry[0].type)) {\n      return false;\n    }\n  }\n  return true;\n};\nvar getPreviousNodeEndPoint = (editor, at) => {\n  const prevEntry = getPreviousNode(editor, {\n    at\n  });\n  if (!prevEntry)\n    return;\n  return getEndPoint(editor, prevEntry[1]);\n};\nvar getPreviousPath = (path) => {\n  if (path.length === 0)\n    return;\n  const last2 = path[path.length - 1];\n  if (last2 <= 0)\n    return;\n  return path.slice(0, -1).concat(last2 - 1);\n};\nvar getRangeBefore = (editor, at, options) => {\n  const anchor = getPointBeforeLocation(editor, at, options);\n  if (!anchor)\n    return;\n  const focus = getPoint(editor, at, {\n    edge: \"end\"\n  });\n  return {\n    anchor,\n    focus\n  };\n};\nvar getRangeFromBlockStart = (editor, options = {}) => {\n  var _getBlockAbove;\n  const path = (_getBlockAbove = getBlockAbove(editor, options)) === null || _getBlockAbove === void 0 ? void 0 : _getBlockAbove[1];\n  if (!path)\n    return;\n  const start2 = getStartPoint(editor, path);\n  const focus = getPointFromLocation(editor, options);\n  if (!focus)\n    return;\n  return {\n    anchor: start2,\n    focus\n  };\n};\nvar getSelectionText = (editor) => getEditorString(editor, editor.selection);\nvar isAncestorEmpty = (editor, node) => !getNodeString(node) && !node.children.some((n8) => isInline(editor, n8));\nvar isBlockAboveEmpty = (editor) => {\n  var _getBlockAbove;\n  const block = (_getBlockAbove = getBlockAbove(editor)) === null || _getBlockAbove === void 0 ? void 0 : _getBlockAbove[0];\n  if (!block)\n    return false;\n  return isAncestorEmpty(editor, block);\n};\nvar isBlockTextEmptyAfterSelection = (editor) => {\n  if (!editor.selection)\n    return false;\n  const blockAbove = getBlockAbove(editor);\n  if (!blockAbove)\n    return false;\n  const cursor = editor.selection.focus;\n  const selectionParentEntry = getParentNode(editor, editor.selection);\n  if (!selectionParentEntry)\n    return false;\n  const [, selectionParentPath] = selectionParentEntry;\n  if (!isEndPoint(editor, cursor, selectionParentPath))\n    return false;\n  const siblingNodes = getNextSiblingNodes(blockAbove, cursor.path);\n  if (siblingNodes.length) {\n    for (const siblingNode of siblingNodes) {\n      if (isText(siblingNode) && siblingNode.text) {\n        return false;\n      }\n    }\n  } else {\n    return isEndPoint(editor, cursor, blockAbove[1]);\n  }\n  return true;\n};\nvar isFirstChild = (path) => path[path.length - 1] === 0;\nvar isMarkActive = (editor, type) => {\n  return isDefined(getMark(editor, type));\n};\nvar isRangeInSameBlock = (editor, {\n  at,\n  ...options\n} = {}) => {\n  if (!at)\n    at = editor.selection;\n  if (!at)\n    return;\n  const [start2, end2] = Range.edges(at);\n  const startBlock = getBlockAbove(editor, {\n    at: start2,\n    ...options\n  });\n  const endBlock = getBlockAbove(editor, {\n    at: end2,\n    ...options\n  });\n  if (!startBlock || !endBlock)\n    return;\n  return Path.equals(startBlock[1], endBlock[1]);\n};\nvar isSelectionAtBlockEnd = (editor, options) => {\n  var _getBlockAbove, _editor$selection;\n  const path = (_getBlockAbove = getBlockAbove(editor, options)) === null || _getBlockAbove === void 0 ? void 0 : _getBlockAbove[1];\n  return !!path && isEndPoint(editor, (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.focus, path);\n};\nvar isSelectionAtBlockStart = (editor, options) => {\n  var _getBlockAbove, _editor$selection;\n  const path = (_getBlockAbove = getBlockAbove(editor, options)) === null || _getBlockAbove === void 0 ? void 0 : _getBlockAbove[1];\n  return !!path && isStartPoint(editor, (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.focus, path);\n};\nvar isSelectionExpanded = (editor) => isExpanded(editor.selection);\nvar isType = (editor, node, key) => {\n  const keys4 = castArray_1(key);\n  const types = [];\n  keys4.forEach((_key) => types.push(getPluginType(editor, _key)));\n  return types.includes(node === null || node === void 0 ? void 0 : node.type);\n};\nvar someNode = (editor, options) => {\n  return !!findNode(editor, options);\n};\nvar applyDeepToNodes = ({\n  node,\n  source,\n  apply: apply2,\n  query\n}) => {\n  const entry = [node, []];\n  if (queryNode(entry, query)) {\n    if (source instanceof Function) {\n      apply2(node, source());\n    } else {\n      apply2(node, source);\n    }\n  }\n  if (!isAncestor(node))\n    return;\n  node.children.forEach((child) => {\n    applyDeepToNodes({\n      node: child,\n      source,\n      apply: apply2,\n      query\n    });\n  });\n};\nvar mergeDeepToNodes = (options) => {\n  applyDeepToNodes({\n    ...options,\n    apply: merge_1\n  });\n};\nvar pipeDeserializeHtmlLeaf = (editor, element4) => {\n  let node = {};\n  [...editor.plugins].reverse().forEach((plugin) => {\n    const deserialized = pluginDeserializeHtml(editor, plugin, {\n      element: element4,\n      deserializeLeaf: true\n    });\n    if (!deserialized)\n      return;\n    node = {\n      ...node,\n      ...deserialized.node\n    };\n  });\n  return node;\n};\nvar htmlElementToLeaf = (editor, element4) => {\n  const node = pipeDeserializeHtmlLeaf(editor, element4);\n  return deserializeHtmlNodeChildren(editor, element4).reduce((arr, child) => {\n    if (!child)\n      return arr;\n    if (isElement2(child)) {\n      if (Object.keys(node).length) {\n        mergeDeepToNodes({\n          node: child,\n          source: node,\n          query: {\n            filter: ([n8]) => isText(n8)\n          }\n        });\n      }\n      arr.push(child);\n    } else {\n      const attributes = {\n        ...node\n      };\n      if (isText(child) && child.text) {\n        Object.keys(attributes).forEach((key) => {\n          if (attributes[key] && child[key]) {\n            attributes[key] = child[key];\n          }\n        });\n      }\n      arr.push(jsx(\"text\", attributes, child));\n    }\n    return arr;\n  }, []);\n};\nvar isHtmlText = (node) => node.nodeType === Node.TEXT_NODE;\nvar htmlTextNodeToString = (node) => {\n  if (isHtmlText(node)) {\n    return node.nodeValue === \"\\n\" ? null : node.textContent;\n  }\n};\nvar isHtmlElement = (node) => node.nodeType === Node.ELEMENT_NODE;\nvar deserializeHtmlNode = (editor) => (node) => {\n  const textNode = htmlTextNodeToString(node);\n  if (textNode)\n    return textNode;\n  if (!isHtmlElement(node))\n    return null;\n  const breakLine = htmlBrToNewLine(node);\n  if (breakLine)\n    return breakLine;\n  const fragment = htmlBodyToFragment(editor, node);\n  if (fragment)\n    return fragment;\n  const element4 = htmlElementToElement(editor, node);\n  if (element4)\n    return element4;\n  return htmlElementToLeaf(editor, node);\n};\nvar deserializeHtmlElement = (editor, element4) => {\n  return deserializeHtmlNode(editor)(element4);\n};\nvar htmlStringToDOMNode = (rawHtml, stripWhitespace = true) => {\n  const node = document.createElement(\"body\");\n  node.innerHTML = rawHtml;\n  if (stripWhitespace) {\n    node.innerHTML = node.innerHTML.replace(/(\\r\\n|\\n|\\r|\\t)/gm, \"\");\n  }\n  return node;\n};\nvar deserializeHtml = (editor, {\n  element: element4,\n  stripWhitespace = true\n}) => {\n  if (typeof element4 === \"string\") {\n    element4 = htmlStringToDOMNode(element4, stripWhitespace);\n  }\n  const fragment = deserializeHtmlElement(editor, element4);\n  return normalizeDescendantsToDocumentFragment(editor, {\n    descendants: fragment\n  });\n};\nvar parseHtmlDocument = (html) => {\n  return new DOMParser().parseFromString(html, \"text/html\");\n};\nvar KEY_DESERIALIZE_HTML = \"deserializeHtml\";\nvar createDeserializeHtmlPlugin = createPluginFactory({\n  key: KEY_DESERIALIZE_HTML,\n  then: (editor) => ({\n    editor: {\n      insertData: {\n        format: \"text/html\",\n        getFragment: ({\n          data\n        }) => {\n          const document2 = parseHtmlDocument(data);\n          return deserializeHtml(editor, {\n            element: document2.body\n          });\n        }\n      }\n    }\n  })\n});\nvar SCOPE_PLATE = Symbol(\"plate\");\nvar plateIdAtom = atom(null);\nvar usePlateId = (scope2 = SCOPE_PLATE) => {\n  const [plateId] = useAtom(plateIdAtom, scope2);\n  return plateId;\n};\nvar getEventEditorId = (id) => {\n  var _eventEditorSelectors;\n  if (id)\n    return id;\n  const focus = eventEditorSelectors.focus();\n  if (focus)\n    return focus;\n  const blur = eventEditorSelectors.blur();\n  if (blur)\n    return blur;\n  return (_eventEditorSelectors = eventEditorSelectors.last()) !== null && _eventEditorSelectors !== void 0 ? _eventEditorSelectors : \"main\";\n};\nvar loadingStore = createPlateStore({\n  id: \"loading\"\n});\nvar getPlateStore = (id) => {\n  id = getEventEditorId(id);\n  const store = platesStore.get.get(id);\n  return store || loadingStore;\n};\nvar usePlateStore = (id) => {\n  var _ref, _id;\n  const plateId = usePlateId();\n  id = (_ref = (_id = id) !== null && _id !== void 0 ? _id : plateId) !== null && _ref !== void 0 ? _ref : \"main\";\n  const store = platesStore.use.get(id);\n  if (store) {\n    return store;\n  }\n  console.warn(\"The plate hooks must be used inside the <PlateProvider id={id}> component's context.\");\n  return store || loadingStore;\n};\nvar setPlateState = (draft, state) => {\n  if (!isUndefined(state.onChange))\n    draft.onChange = state.onChange;\n  if (!isUndefined(state.plugins))\n    draft.plugins = state.plugins;\n  if (!isUndefined(state.editableProps))\n    draft.editableProps = state.editableProps;\n  if (!isUndefined(state.renderElement))\n    draft.renderElement = state.renderElement;\n  if (!isUndefined(state.renderLeaf))\n    draft.renderLeaf = state.renderLeaf;\n  if (!isUndefined(state.decorate))\n    draft.decorate = state.decorate;\n  if (!isUndefined(state.enabled))\n    draft.enabled = state.enabled;\n  if (!isUndefined(state.editor)) {\n    draft.editor = state.editor;\n    if (state.editor) {\n      draft.value = state.editor.children;\n    }\n  }\n  if (!isUndefined(state.initialValue))\n    draft.value = state.initialValue;\n  if (!isUndefined(state.value))\n    draft.value = state.value;\n  return draft;\n};\nvar createPlatesStore = (initialState3 = {}) => createStore3(\"plate\")(initialState3).extendActions((set4) => ({\n  /**\n   * Set state by id.\n   * If the store is not yet initialized, it will be initialized.\n   * If the store is already set, it will be updated.\n   */\n  // eslint-disable-next-line prettier/prettier\n  set: (id, state) => {\n    set4.state((draft) => {\n      if (!id)\n        return;\n      let store = draft[id];\n      if (!store) {\n        store = createPlateStore({\n          id,\n          ...setPlateState({}, state !== null && state !== void 0 ? state : {})\n        });\n        draft[id] = store;\n        eventEditorActions.last(id);\n      }\n    });\n  },\n  /**\n   * Remove state by id. Called by `Plate` on unmount.\n   */\n  unset: (id) => {\n    set4.state((draft) => {\n      delete draft[id];\n    });\n  }\n})).extendSelectors((state) => ({\n  // eslint-disable-next-line prettier/prettier\n  get(id) {\n    return state[id];\n  },\n  has(id) {\n    const ids = castArray_1(id);\n    return ids.every((_id) => !!state[_id]);\n  }\n}));\nvar platesStore = createPlatesStore({});\nvar platesActions = platesStore.set;\nvar platesSelectors = platesStore.get;\nvar usePlatesSelectors = platesStore.use;\nvar getPlateActions = (id) => getPlateStore(id).set;\nvar usePlateSelectors = (id) => usePlateStore(id).use;\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index5 = -1, length = array == null ? 0 : array.length;\n  while (++index5 < length) {\n    var value = array[index5];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\nvar _arrayAggregator = arrayAggregator;\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  _baseEach(collection, function(value, key, collection2) {\n    setter(accumulator, value, iteratee(value), collection2);\n  });\n  return accumulator;\n}\nvar _baseAggregator = baseAggregator;\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = isArray_1(collection) ? _arrayAggregator : _baseAggregator, accumulator = initializer ? initializer() : {};\n    return func(collection, setter, _baseIteratee(iteratee), accumulator);\n  };\n}\nvar _createAggregator = createAggregator;\nvar keyBy = _createAggregator(function(result, value, key) {\n  _baseAssignValue(result, key, value);\n});\nvar keyBy_1 = keyBy;\nfunction baseValues(object, props) {\n  return _arrayMap(props, function(key) {\n    return object[key];\n  });\n}\nvar _baseValues = baseValues;\nfunction values(object) {\n  return object == null ? [] : _baseValues(object, keys_1(object));\n}\nvar values_1 = values;\nvar mergeDeepPlugins = (editor, _plugin) => {\n  const plugin = {\n    ..._plugin\n  };\n  const {\n    then\n  } = plugin;\n  if (then) {\n    delete plugin.then;\n    const {\n      plugins: pluginPlugins\n    } = plugin;\n    const pluginThen = mergeDeepPlugins(editor, defaultsDeep_1(then(editor, plugin), plugin));\n    if (pluginPlugins && pluginThen.plugins) {\n      const merged = merge_1(keyBy_1(pluginPlugins, \"key\"), keyBy_1(pluginThen.plugins, \"key\"));\n      pluginThen.plugins = values_1(merged);\n    }\n    return pluginThen;\n  }\n  return plugin;\n};\nvar setDefaultPlugin = (plugin) => {\n  if (plugin.type === void 0)\n    plugin.type = plugin.key;\n  if (!plugin.options)\n    plugin.options = {};\n  if (!plugin.inject)\n    plugin.inject = {};\n  if (!plugin.editor)\n    plugin.editor = {};\n  return plugin;\n};\nvar flattenDeepPlugins = (editor, plugins) => {\n  if (!plugins)\n    return;\n  plugins.forEach((plugin) => {\n    let p6 = setDefaultPlugin(plugin);\n    p6 = mergeDeepPlugins(editor, p6);\n    if (!editor.pluginsByKey[p6.key]) {\n      editor.plugins.push(p6);\n      editor.pluginsByKey[p6.key] = p6;\n    } else {\n      const index5 = editor.plugins.indexOf(editor.pluginsByKey[p6.key]);\n      const mergedPlugin = defaultsDeep_1(p6, editor.pluginsByKey[p6.key]);\n      if (index5 >= 0) {\n        editor.plugins[index5] = mergedPlugin;\n      }\n      editor.pluginsByKey[p6.key] = mergedPlugin;\n    }\n    flattenDeepPlugins(editor, p6.plugins);\n  });\n};\nvar setPlatePlugins = (editor, {\n  disableCorePlugins,\n  plugins: _plugins = []\n}) => {\n  let plugins = [];\n  if (disableCorePlugins !== true) {\n    const dcp = disableCorePlugins;\n    if (typeof dcp !== \"object\" || !dcp.react) {\n      var _ref, _editor$pluginsByKey;\n      plugins.push((_ref = (_editor$pluginsByKey = editor.pluginsByKey) === null || _editor$pluginsByKey === void 0 ? void 0 : _editor$pluginsByKey.react) !== null && _ref !== void 0 ? _ref : createReactPlugin());\n    }\n    if (typeof dcp !== \"object\" || !dcp.history) {\n      var _ref2, _editor$pluginsByKey2;\n      plugins.push((_ref2 = (_editor$pluginsByKey2 = editor.pluginsByKey) === null || _editor$pluginsByKey2 === void 0 ? void 0 : _editor$pluginsByKey2.history) !== null && _ref2 !== void 0 ? _ref2 : createHistoryPlugin());\n    }\n    if (typeof dcp !== \"object\" || !dcp.eventEditor) {\n      var _ref3, _editor$pluginsByKey3;\n      plugins.push((_ref3 = (_editor$pluginsByKey3 = editor.pluginsByKey) === null || _editor$pluginsByKey3 === void 0 ? void 0 : _editor$pluginsByKey3[KEY_EVENT_EDITOR]) !== null && _ref3 !== void 0 ? _ref3 : createEventEditorPlugin());\n    }\n    if (typeof dcp !== \"object\" || !dcp.inlineVoid) {\n      var _ref4, _editor$pluginsByKey4;\n      plugins.push((_ref4 = (_editor$pluginsByKey4 = editor.pluginsByKey) === null || _editor$pluginsByKey4 === void 0 ? void 0 : _editor$pluginsByKey4[KEY_INLINE_VOID]) !== null && _ref4 !== void 0 ? _ref4 : createInlineVoidPlugin());\n    }\n    if (typeof dcp !== \"object\" || !dcp.insertData) {\n      var _ref5, _editor$pluginsByKey5;\n      plugins.push((_ref5 = (_editor$pluginsByKey5 = editor.pluginsByKey) === null || _editor$pluginsByKey5 === void 0 ? void 0 : _editor$pluginsByKey5[KEY_INSERT_DATA]) !== null && _ref5 !== void 0 ? _ref5 : createInsertDataPlugin());\n    }\n    if (typeof dcp !== \"object\" || !dcp.selection) {\n      var _ref6, _editor$pluginsByKey6;\n      plugins.push((_ref6 = (_editor$pluginsByKey6 = editor.pluginsByKey) === null || _editor$pluginsByKey6 === void 0 ? void 0 : _editor$pluginsByKey6[KEY_SELECTION]) !== null && _ref6 !== void 0 ? _ref6 : createSelectionPlugin());\n    }\n    if (typeof dcp !== \"object\" || !dcp.deserializeHtml) {\n      var _ref7, _editor$pluginsByKey7;\n      plugins.push((_ref7 = (_editor$pluginsByKey7 = editor.pluginsByKey) === null || _editor$pluginsByKey7 === void 0 ? void 0 : _editor$pluginsByKey7[KEY_DESERIALIZE_HTML]) !== null && _ref7 !== void 0 ? _ref7 : createDeserializeHtmlPlugin());\n    }\n    if (typeof dcp !== \"object\" || !dcp.deserializeAst) {\n      var _ref8, _editor$pluginsByKey8;\n      plugins.push((_ref8 = (_editor$pluginsByKey8 = editor.pluginsByKey) === null || _editor$pluginsByKey8 === void 0 ? void 0 : _editor$pluginsByKey8[KEY_DESERIALIZE_AST]) !== null && _ref8 !== void 0 ? _ref8 : createDeserializeAstPlugin());\n    }\n  }\n  plugins = [...plugins, ..._plugins];\n  editor.plugins = [];\n  editor.pluginsByKey = {};\n  flattenDeepPlugins(editor, plugins);\n  editor.plugins.forEach((plugin) => {\n    if (plugin.overrideByKey) {\n      const newPlugins = editor.plugins.map((p6) => {\n        return overridePluginsByKey(p6, plugin.overrideByKey);\n      });\n      editor.plugins = [];\n      editor.pluginsByKey = {};\n      flattenDeepPlugins(editor, newPlugins);\n    }\n  });\n  getPlateActions(editor.id).incrementKey(\"keyPlugins\");\n};\nvar withPlate = (e4, {\n  id = \"main\",\n  plugins = [],\n  disableCorePlugins\n} = {}) => {\n  let editor = e4;\n  editor.id = id;\n  editor.prevSelection = null;\n  editor.lastKeyDown = null;\n  if (!editor.key) {\n    editor.key = Math.random();\n  }\n  setPlatePlugins(editor, {\n    plugins,\n    disableCorePlugins\n  });\n  editor.plugins.forEach((plugin) => {\n    if (plugin.withOverrides) {\n      editor = plugin.withOverrides(editor, plugin);\n    }\n  });\n  return editor;\n};\nfunction arrayEach(array, iteratee) {\n  var index5 = -1, length = array == null ? 0 : array.length;\n  while (++index5 < length) {\n    if (iteratee(array[index5], index5, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\nvar _arrayEach = arrayEach;\nfunction baseAssign(object, source) {\n  return object && _copyObject(source, keys_1(source), object);\n}\nvar _baseAssign = baseAssign;\nfunction baseAssignIn(object, source) {\n  return object && _copyObject(source, keysIn_1(source), object);\n}\nvar _baseAssignIn = baseAssignIn;\nfunction copySymbols(source, object) {\n  return _copyObject(source, _getSymbols(source), object);\n}\nvar _copySymbols = copySymbols;\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\nvar getSymbolsIn = !nativeGetSymbols ? stubArray_1 : function(object) {\n  var result = [];\n  while (object) {\n    _arrayPush(result, _getSymbols(object));\n    object = _getPrototype(object);\n  }\n  return result;\n};\nvar _getSymbolsIn = getSymbolsIn;\nfunction copySymbolsIn(source, object) {\n  return _copyObject(source, _getSymbolsIn(source), object);\n}\nvar _copySymbolsIn = copySymbolsIn;\nfunction getAllKeysIn(object) {\n  return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);\n}\nvar _getAllKeysIn = getAllKeysIn;\nvar objectProto$12 = Object.prototype;\nvar hasOwnProperty$12 = objectProto$12.hasOwnProperty;\nfunction initCloneArray(array) {\n  var length = array.length, result = new array.constructor(length);\n  if (length && typeof array[0] == \"string\" && hasOwnProperty$12.call(array, \"index\")) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\nvar _initCloneArray = initCloneArray;\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\nvar _cloneDataView = cloneDataView;\nvar reFlags = /\\w*$/;\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\nvar _cloneRegExp = cloneRegExp;\nvar symbolProto2 = _Symbol2 ? _Symbol2.prototype : void 0;\nvar symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : void 0;\nfunction cloneSymbol(symbol) {\n  return symbolValueOf2 ? Object(symbolValueOf2.call(symbol)) : {};\n}\nvar _cloneSymbol = cloneSymbol;\nvar boolTag$12 = \"[object Boolean]\";\nvar dateTag$12 = \"[object Date]\";\nvar mapTag$22 = \"[object Map]\";\nvar numberTag$12 = \"[object Number]\";\nvar regexpTag$12 = \"[object RegExp]\";\nvar setTag$22 = \"[object Set]\";\nvar stringTag$12 = \"[object String]\";\nvar symbolTag$1 = \"[object Symbol]\";\nvar arrayBufferTag$12 = \"[object ArrayBuffer]\";\nvar dataViewTag$1 = \"[object DataView]\";\nvar float32Tag$1 = \"[object Float32Array]\";\nvar float64Tag$1 = \"[object Float64Array]\";\nvar int8Tag$1 = \"[object Int8Array]\";\nvar int16Tag$1 = \"[object Int16Array]\";\nvar int32Tag$1 = \"[object Int32Array]\";\nvar uint8Tag$1 = \"[object Uint8Array]\";\nvar uint8ClampedTag$1 = \"[object Uint8ClampedArray]\";\nvar uint16Tag$1 = \"[object Uint16Array]\";\nvar uint32Tag$1 = \"[object Uint32Array]\";\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag$12:\n      return _cloneArrayBuffer(object);\n    case boolTag$12:\n    case dateTag$12:\n      return new Ctor(+object);\n    case dataViewTag$1:\n      return _cloneDataView(object, isDeep);\n    case float32Tag$1:\n    case float64Tag$1:\n    case int8Tag$1:\n    case int16Tag$1:\n    case int32Tag$1:\n    case uint8Tag$1:\n    case uint8ClampedTag$1:\n    case uint16Tag$1:\n    case uint32Tag$1:\n      return _cloneTypedArray(object, isDeep);\n    case mapTag$22:\n      return new Ctor();\n    case numberTag$12:\n    case stringTag$12:\n      return new Ctor(object);\n    case regexpTag$12:\n      return _cloneRegExp(object);\n    case setTag$22:\n      return new Ctor();\n    case symbolTag$1:\n      return _cloneSymbol(object);\n  }\n}\nvar _initCloneByTag = initCloneByTag;\nvar mapTag$1 = \"[object Map]\";\nfunction baseIsMap(value) {\n  return isObjectLike_12(value) && _getTag(value) == mapTag$1;\n}\nvar _baseIsMap = baseIsMap;\nvar nodeIsMap = _nodeUtil2 && _nodeUtil2.isMap;\nvar isMap = nodeIsMap ? _baseUnary2(nodeIsMap) : _baseIsMap;\nvar isMap_1 = isMap;\nvar setTag$1 = \"[object Set]\";\nfunction baseIsSet(value) {\n  return isObjectLike_12(value) && _getTag(value) == setTag$1;\n}\nvar _baseIsSet = baseIsSet;\nvar nodeIsSet = _nodeUtil2 && _nodeUtil2.isSet;\nvar isSet = nodeIsSet ? _baseUnary2(nodeIsSet) : _baseIsSet;\nvar isSet_1 = isSet;\nvar CLONE_DEEP_FLAG$2 = 1;\nvar CLONE_FLAT_FLAG$1 = 2;\nvar CLONE_SYMBOLS_FLAG$2 = 4;\nvar argsTag = \"[object Arguments]\";\nvar arrayTag = \"[object Array]\";\nvar boolTag = \"[object Boolean]\";\nvar dateTag = \"[object Date]\";\nvar errorTag = \"[object Error]\";\nvar funcTag2 = \"[object Function]\";\nvar genTag2 = \"[object GeneratorFunction]\";\nvar mapTag2 = \"[object Map]\";\nvar numberTag = \"[object Number]\";\nvar objectTag = \"[object Object]\";\nvar regexpTag = \"[object RegExp]\";\nvar setTag2 = \"[object Set]\";\nvar stringTag = \"[object String]\";\nvar symbolTag = \"[object Symbol]\";\nvar weakMapTag2 = \"[object WeakMap]\";\nvar arrayBufferTag = \"[object ArrayBuffer]\";\nvar dataViewTag2 = \"[object DataView]\";\nvar float32Tag2 = \"[object Float32Array]\";\nvar float64Tag2 = \"[object Float64Array]\";\nvar int8Tag2 = \"[object Int8Array]\";\nvar int16Tag2 = \"[object Int16Array]\";\nvar int32Tag2 = \"[object Int32Array]\";\nvar uint8Tag2 = \"[object Uint8Array]\";\nvar uint8ClampedTag2 = \"[object Uint8ClampedArray]\";\nvar uint16Tag2 = \"[object Uint16Array]\";\nvar uint32Tag2 = \"[object Uint32Array]\";\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag2] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag2] = cloneableTags[float64Tag2] = cloneableTags[int8Tag2] = cloneableTags[int16Tag2] = cloneableTags[int32Tag2] = cloneableTags[mapTag2] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag2] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag2] = cloneableTags[uint8ClampedTag2] = cloneableTags[uint16Tag2] = cloneableTags[uint32Tag2] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag2] = cloneableTags[weakMapTag2] = false;\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== void 0) {\n    return result;\n  }\n  if (!isObject_12(value)) {\n    return value;\n  }\n  var isArr = isArray_1(value);\n  if (isArr) {\n    result = _initCloneArray(value);\n    if (!isDeep) {\n      return _copyArray(value, result);\n    }\n  } else {\n    var tag = _getTag(value), isFunc = tag == funcTag2 || tag == genTag2;\n    if (isBuffer_12(value)) {\n      return _cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || isFunc && !object) {\n      result = isFlat || isFunc ? {} : _initCloneObject(value);\n      if (!isDeep) {\n        return isFlat ? _copySymbolsIn(value, _baseAssignIn(result, value)) : _copySymbols(value, _baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = _initCloneByTag(value, tag, isDeep);\n    }\n  }\n  stack || (stack = new _Stack());\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n  if (isSet_1(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n  } else if (isMap_1(value)) {\n    value.forEach(function(subValue, key2) {\n      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));\n    });\n  }\n  var keysFunc = isFull ? isFlat ? _getAllKeysIn : _getAllKeys : isFlat ? keysIn_1 : keys_1;\n  var props = isArr ? void 0 : keysFunc(value);\n  _arrayEach(props || value, function(subValue, key2) {\n    if (props) {\n      key2 = subValue;\n      subValue = value[key2];\n    }\n    _assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));\n  });\n  return result;\n}\nvar _baseClone = baseClone;\nvar CLONE_DEEP_FLAG$1 = 1;\nvar CLONE_SYMBOLS_FLAG$1 = 4;\nfunction cloneDeep(value) {\n  return _baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);\n}\nvar cloneDeep_1 = cloneDeep;\nvar createPlugins = (plugins, {\n  components: components2,\n  overrideByKey\n} = {}) => {\n  let allOverrideByKey = {};\n  if (overrideByKey) {\n    allOverrideByKey = cloneDeep_1(overrideByKey);\n  }\n  if (components2) {\n    Object.keys(components2).forEach((key) => {\n      if (!allOverrideByKey[key])\n        allOverrideByKey[key] = {};\n      allOverrideByKey[key].component = components2[key];\n    });\n  }\n  if (Object.keys(allOverrideByKey).length) {\n    return plugins.map((plugin) => {\n      return overridePluginsByKey(plugin, allOverrideByKey);\n    });\n  }\n  return plugins;\n};\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : void 0;\n}\nvar last_1 = last;\nfunction baseSlice(array, start2, end2) {\n  var index5 = -1, length = array.length;\n  if (start2 < 0) {\n    start2 = -start2 > length ? 0 : length + start2;\n  }\n  end2 = end2 > length ? length : end2;\n  if (end2 < 0) {\n    end2 += length;\n  }\n  length = start2 > end2 ? 0 : end2 - start2 >>> 0;\n  start2 >>>= 0;\n  var result = Array(length);\n  while (++index5 < length) {\n    result[index5] = array[index5 + start2];\n  }\n  return result;\n}\nvar _baseSlice = baseSlice;\nfunction parent(object, path) {\n  return path.length < 2 ? object : _baseGet(object, _baseSlice(path, 0, -1));\n}\nvar _parent = parent;\nfunction baseUnset(object, path) {\n  path = _castPath(path, object);\n  object = _parent(object, path);\n  return object == null || delete object[_toKey(last_1(path))];\n}\nvar _baseUnset = baseUnset;\nfunction customOmitClone(value) {\n  return isPlainObject_1(value) ? void 0 : value;\n}\nvar _customOmitClone = customOmitClone;\nvar spreadableSymbol = _Symbol2 ? _Symbol2.isConcatSpreadable : void 0;\nfunction isFlattenable(value) {\n  return isArray_1(value) || isArguments_1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\nvar _isFlattenable = isFlattenable;\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index5 = -1, length = array.length;\n  predicate || (predicate = _isFlattenable);\n  result || (result = []);\n  while (++index5 < length) {\n    var value = array[index5];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        _arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\nvar _baseFlatten = baseFlatten;\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? _baseFlatten(array, 1) : [];\n}\nvar flatten_1 = flatten;\nfunction flatRest(func) {\n  return _setToString(_overRest(func, void 0, flatten_1), func + \"\");\n}\nvar _flatRest = flatRest;\nvar CLONE_DEEP_FLAG = 1;\nvar CLONE_FLAT_FLAG = 2;\nvar CLONE_SYMBOLS_FLAG = 4;\nvar omit = _flatRest(function(object, paths) {\n  var result = {};\n  if (object == null) {\n    return result;\n  }\n  var isDeep = false;\n  paths = _arrayMap(paths, function(path) {\n    path = _castPath(path, object);\n    isDeep || (isDeep = path.length > 1);\n    return path;\n  });\n  _copyObject(object, _getAllKeysIn(object), result);\n  if (isDeep) {\n    result = _baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, _customOmitClone);\n  }\n  var length = paths.length;\n  while (length--) {\n    _baseUnset(result, paths[length]);\n  }\n  return result;\n});\nvar omit_1 = omit;\nvar usePlateEditorRef = (id) => usePlateSelectors(id).editor();\nvar pipeDecorate = (editor, decorateProp) => {\n  const decorates = editor.plugins.flatMap((plugin) => {\n    var _plugin$decorate, _plugin$decorate2;\n    return (_plugin$decorate = (_plugin$decorate2 = plugin.decorate) === null || _plugin$decorate2 === void 0 ? void 0 : _plugin$decorate2.call(plugin, editor, plugin)) !== null && _plugin$decorate !== void 0 ? _plugin$decorate : [];\n  });\n  if (decorateProp) {\n    decorates.push(decorateProp);\n  }\n  if (!decorates.length)\n    return;\n  return (entry) => {\n    let ranges = [];\n    const addRanges = (newRanges) => {\n      if (newRanges !== null && newRanges !== void 0 && newRanges.length)\n        ranges = [...ranges, ...newRanges];\n    };\n    decorates.forEach((decorate) => {\n      addRanges(decorate(entry));\n    });\n    return ranges;\n  };\n};\nvar isEventHandled2 = (event, handler) => {\n  if (!handler) {\n    return false;\n  }\n  const shouldTreatEventAsHandled = handler(event);\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n  return event.isPropagationStopped();\n};\nvar pipeHandler = (editor, {\n  editableProps,\n  handlerKey\n}) => {\n  let pluginsHandlers = [];\n  pluginsHandlers = editor.plugins.flatMap((plugin) => {\n    var _plugin$handlers$hand, _plugin$handlers, _plugin$handlers$hand2;\n    return (_plugin$handlers$hand = (_plugin$handlers = plugin.handlers) === null || _plugin$handlers === void 0 ? void 0 : (_plugin$handlers$hand2 = _plugin$handlers[handlerKey]) === null || _plugin$handlers$hand2 === void 0 ? void 0 : _plugin$handlers$hand2.call(_plugin$handlers, editor, plugin)) !== null && _plugin$handlers$hand !== void 0 ? _plugin$handlers$hand : [];\n  });\n  const propsHandler = editableProps === null || editableProps === void 0 ? void 0 : editableProps[handlerKey];\n  if (!pluginsHandlers.length && !propsHandler)\n    return;\n  return (event) => {\n    const eventIsHandled = pluginsHandlers.some((handler) => isEventHandled2(event, handler));\n    if (eventIsHandled)\n      return true;\n    return isEventHandled2(event, propsHandler);\n  };\n};\nvar pluginInjectProps = (editor, {\n  key,\n  inject: {\n    props\n  }\n}, nodeProps) => {\n  var _transformNodeValue;\n  const {\n    element: element4,\n    text: text4,\n    className,\n    style\n  } = nodeProps;\n  const node = element4 !== null && element4 !== void 0 ? element4 : text4;\n  if (!node)\n    return;\n  if (!props)\n    return;\n  const {\n    nodeKey = key,\n    styleKey = nodeKey,\n    validTypes,\n    classNames,\n    transformClassName,\n    transformNodeValue,\n    transformStyle,\n    validNodeValues,\n    defaultNodeValue\n  } = props;\n  if (validTypes && isElement2(node) && node.type && !validTypes.includes(node.type)) {\n    return;\n  }\n  const nodeValue = node[nodeKey];\n  if (!nodeValue || validNodeValues && !validNodeValues.includes(nodeValue) || nodeValue === defaultNodeValue) {\n    return;\n  }\n  const res = {};\n  const transformOptions = {\n    ...nodeProps,\n    nodeValue\n  };\n  const value = (_transformNodeValue = transformNodeValue === null || transformNodeValue === void 0 ? void 0 : transformNodeValue(transformOptions)) !== null && _transformNodeValue !== void 0 ? _transformNodeValue : nodeValue;\n  if (element4) {\n    res.className = clsx_m_default(className, `slate-${nodeKey}-${nodeValue}`);\n  }\n  if (classNames !== null && classNames !== void 0 && classNames[nodeValue] || transformClassName) {\n    var _transformClassName;\n    res.className = (_transformClassName = transformClassName === null || transformClassName === void 0 ? void 0 : transformClassName(transformOptions)) !== null && _transformClassName !== void 0 ? _transformClassName : clsx_m_default(className, classNames === null || classNames === void 0 ? void 0 : classNames[value]);\n  }\n  if (styleKey) {\n    var _transformStyle;\n    res.style = (_transformStyle = transformStyle === null || transformStyle === void 0 ? void 0 : transformStyle(transformOptions)) !== null && _transformStyle !== void 0 ? _transformStyle : {\n      ...style,\n      [styleKey]: value\n    };\n  }\n  return res;\n};\nvar pipeInjectProps = (editor, nodeProps) => {\n  editor.plugins.forEach((plugin) => {\n    if (plugin.inject.props) {\n      const props = pluginInjectProps(editor, plugin, nodeProps);\n      if (props) {\n        nodeProps = {\n          ...nodeProps,\n          ...props\n        };\n      }\n    }\n  });\n  return {\n    ...nodeProps,\n    editor\n  };\n};\nvar getRenderNodeProps = ({\n  attributes,\n  nodeProps,\n  props,\n  type\n}) => {\n  let newProps = {};\n  if (props) {\n    var _ref;\n    newProps = (_ref = typeof props === \"function\" ? props(nodeProps) : props) !== null && _ref !== void 0 ? _ref : {};\n  }\n  if (!newProps.nodeProps && attributes) {\n    newProps.nodeProps = attributes;\n  }\n  nodeProps = {\n    ...nodeProps,\n    ...newProps\n  };\n  const {\n    className\n  } = nodeProps;\n  return {\n    ...nodeProps,\n    className: clsx_m_default(getSlateClass(type), className)\n  };\n};\nvar pluginRenderElement = (editor, {\n  key,\n  type,\n  component: _component,\n  props\n}) => (nodeProps) => {\n  const {\n    element: element4,\n    children: _children\n  } = nodeProps;\n  if (element4.type === type) {\n    const Element4 = _component !== null && _component !== void 0 ? _component : DefaultElement;\n    const injectAboveComponents = editor.plugins.flatMap((o7) => {\n      var _o$inject$aboveCompon, _o$inject;\n      return (_o$inject$aboveCompon = (_o$inject = o7.inject) === null || _o$inject === void 0 ? void 0 : _o$inject.aboveComponent) !== null && _o$inject$aboveCompon !== void 0 ? _o$inject$aboveCompon : [];\n    });\n    const injectBelowComponents = editor.plugins.flatMap((o7) => {\n      var _o$inject$belowCompon, _o$inject2;\n      return (_o$inject$belowCompon = (_o$inject2 = o7.inject) === null || _o$inject2 === void 0 ? void 0 : _o$inject2.belowComponent) !== null && _o$inject$belowCompon !== void 0 ? _o$inject$belowCompon : [];\n    });\n    nodeProps = getRenderNodeProps({\n      attributes: element4.attributes,\n      nodeProps,\n      props,\n      type\n    });\n    let children = _children;\n    injectBelowComponents.forEach((withHOC2) => {\n      const hoc = withHOC2({\n        ...nodeProps,\n        key\n      });\n      if (hoc) {\n        children = hoc({\n          ...nodeProps,\n          children\n        });\n      }\n    });\n    let component = /* @__PURE__ */ import_react7.default.createElement(Element4, nodeProps, children);\n    injectAboveComponents.forEach((withHOC2) => {\n      const hoc = withHOC2({\n        ...nodeProps,\n        key\n      });\n      if (hoc) {\n        component = hoc({\n          ...nodeProps,\n          children: component\n        });\n      }\n    });\n    return /* @__PURE__ */ import_react7.default.createElement(ElementProvider, {\n      element: element4,\n      scope: key\n    }, component);\n  }\n};\nvar pipeRenderElement = (editor, renderElementProp) => {\n  const renderElements = [];\n  editor.plugins.forEach((plugin) => {\n    if (plugin.isElement) {\n      renderElements.push(pluginRenderElement(editor, plugin));\n    }\n  });\n  return (nodeProps) => {\n    const props = pipeInjectProps(editor, nodeProps);\n    let element4;\n    renderElements.some((renderElement) => {\n      element4 = renderElement(props);\n      return !!element4;\n    });\n    if (element4)\n      return element4;\n    if (renderElementProp) {\n      return renderElementProp(props);\n    }\n    return /* @__PURE__ */ import_react7.default.createElement(DefaultElement, props);\n  };\n};\nvar DefaultLeaf2 = ({\n  attributes,\n  children,\n  text: text4,\n  leaf,\n  editor,\n  nodeProps,\n  ...props\n}) => /* @__PURE__ */ import_react7.default.createElement(\"span\", _extends2({}, attributes, props), children);\nvar pluginRenderLeaf = (editor, {\n  key,\n  type = key,\n  component,\n  props\n}) => (nodeProps) => {\n  const {\n    leaf,\n    children\n  } = nodeProps;\n  if (leaf[type]) {\n    const Leaf2 = component !== null && component !== void 0 ? component : DefaultLeaf2;\n    nodeProps = getRenderNodeProps({\n      attributes: leaf.attributes,\n      props,\n      nodeProps,\n      type\n    });\n    return /* @__PURE__ */ import_react7.default.createElement(Leaf2, nodeProps, children);\n  }\n  return children;\n};\nvar pipeRenderLeaf = (editor, renderLeafProp) => {\n  const renderLeafs = [];\n  editor.plugins.forEach((plugin) => {\n    if (plugin.isLeaf && plugin.key) {\n      renderLeafs.push(pluginRenderLeaf(editor, plugin));\n    }\n  });\n  return (nodeProps) => {\n    const props = pipeInjectProps(editor, nodeProps);\n    renderLeafs.forEach((renderLeaf) => {\n      const newChildren = renderLeaf(props);\n      if (newChildren !== void 0) {\n        props.children = newChildren;\n      }\n    });\n    if (renderLeafProp) {\n      return renderLeafProp(props);\n    }\n    return /* @__PURE__ */ import_react7.default.createElement(DefaultLeaf2, props);\n  };\n};\nvar useEditableProps = ({\n  id = \"main\"\n}) => {\n  const editor = usePlateEditorRef(id);\n  const keyPlugins = usePlateSelectors(id).keyPlugins();\n  const keyDecorate = usePlateSelectors(id).keyDecorate();\n  const editableProps = usePlateSelectors(id).editableProps();\n  const storeDecorate = usePlateSelectors(id).decorate();\n  const storeRenderLeaf = usePlateSelectors(id).renderLeaf();\n  const storeRenderElement = usePlateSelectors(id).renderElement();\n  const isValid = editor && !!keyPlugins;\n  const decorateMemo = (0, import_react7.useMemo)(() => {\n    if (!isValid)\n      return;\n    return pipeDecorate(editor, storeDecorate !== null && storeDecorate !== void 0 ? storeDecorate : editableProps === null || editableProps === void 0 ? void 0 : editableProps.decorate);\n  }, [editableProps === null || editableProps === void 0 ? void 0 : editableProps.decorate, editor, isValid, storeDecorate]);\n  const decorate = (0, import_react7.useMemo)(() => {\n    if (!keyDecorate || !decorateMemo)\n      return;\n    return (entry) => decorateMemo(entry);\n  }, [decorateMemo, keyDecorate]);\n  const renderElement = (0, import_react7.useMemo)(() => {\n    if (!isValid)\n      return;\n    return pipeRenderElement(editor, storeRenderElement !== null && storeRenderElement !== void 0 ? storeRenderElement : editableProps === null || editableProps === void 0 ? void 0 : editableProps.renderElement);\n  }, [editableProps === null || editableProps === void 0 ? void 0 : editableProps.renderElement, editor, isValid, storeRenderElement]);\n  const renderLeaf = (0, import_react7.useMemo)(() => {\n    if (!isValid)\n      return;\n    return pipeRenderLeaf(editor, storeRenderLeaf !== null && storeRenderLeaf !== void 0 ? storeRenderLeaf : editableProps === null || editableProps === void 0 ? void 0 : editableProps.renderLeaf);\n  }, [editableProps === null || editableProps === void 0 ? void 0 : editableProps.renderLeaf, editor, isValid, storeRenderLeaf]);\n  const props = useDeepCompareMemo(() => {\n    if (!isValid)\n      return {};\n    const _props = {\n      decorate,\n      renderElement,\n      renderLeaf\n    };\n    DOM_HANDLERS.forEach((handlerKey) => {\n      const handler = pipeHandler(editor, {\n        editableProps,\n        handlerKey\n      });\n      if (handler) {\n        _props[handlerKey] = handler;\n      }\n    });\n    return _props;\n  }, [decorate, editableProps, isValid, renderElement, renderLeaf]);\n  return useDeepCompareMemo(() => ({\n    ...omit_1(editableProps, [...DOM_HANDLERS, \"renderElement\", \"renderLeaf\"]),\n    ...props\n  }), [editableProps, props]);\n};\nvar setRef = (ref, value) => {\n  if (typeof ref === \"function\") {\n    ref(value);\n  } else if (ref !== null && ref !== void 0) {\n    ref.current = value;\n  }\n};\nvar composeRefs2 = (...refs) => (node) => refs.forEach((ref) => setRef(ref, node));\nvar useComposedRef = (...refs) => {\n  return (0, import_react7.useCallback)(composeRefs2(...refs), refs);\n};\nvar canUsePassiveEvents = () => {\n  if (typeof window === \"undefined\" || typeof window.addEventListener !== \"function\")\n    return false;\n  let passive2 = false;\n  const options = Object.defineProperty({}, \"passive\", {\n    // eslint-disable-next-line getter-return\n    get() {\n      passive2 = true;\n    }\n  });\n  const noop3 = () => null;\n  window.addEventListener(\"test\", noop3, options);\n  window.removeEventListener(\"test\", noop3, options);\n  return passive2;\n};\nvar DEFAULT_IGNORE_CLASS = \"ignore-onclickoutside\";\nvar checkClass = (el, cl) => {\n  var _el$classList;\n  return (_el$classList = el.classList) === null || _el$classList === void 0 ? void 0 : _el$classList.contains(cl);\n};\nvar hasIgnoreClass = (e4, ignoreClass) => {\n  let el = e4.target || e4;\n  while (el) {\n    if (Array.isArray(ignoreClass)) {\n      if (ignoreClass.some((c5) => checkClass(el, c5)))\n        return true;\n    } else if (checkClass(el, ignoreClass)) {\n      return true;\n    }\n    el = el.parentElement;\n  }\n  return false;\n};\nvar clickedOnScrollbar = (e4) => document.documentElement.clientWidth <= e4.clientX || document.documentElement.clientHeight <= e4.clientY;\nvar getEventOptions = (type) => type.includes(\"touch\") && canUsePassiveEvents() ? {\n  passive: true\n} : false;\nvar useOnClickOutside = (callback, {\n  refs: refsOpt,\n  disabled,\n  eventTypes = [\"mousedown\", \"touchstart\"],\n  excludeScrollbar,\n  ignoreClass = DEFAULT_IGNORE_CLASS,\n  detectIFrame = true\n} = {}) => {\n  const [refsState, setRefsState] = (0, import_react7.useState)([]);\n  const callbackRef = (0, import_react7.useRef)(callback);\n  callbackRef.current = callback;\n  const ref = (0, import_react7.useCallback)((el) => setRefsState((prevState) => [...prevState, {\n    current: el\n  }]), []);\n  (0, import_react7.useEffect)(\n    () => {\n      if (!(refsOpt !== null && refsOpt !== void 0 && refsOpt.length) && !refsState.length)\n        return;\n      const getEls = () => {\n        const els = [];\n        (refsOpt || refsState).forEach(({\n          current\n        }) => current && els.push(current));\n        return els;\n      };\n      const handler = (e4) => {\n        if (!hasIgnoreClass(e4, ignoreClass) && !(excludeScrollbar && clickedOnScrollbar(e4)) && getEls().every((el) => !el.contains(e4.target)))\n          callbackRef.current(e4);\n      };\n      const blurHandler = (e4) => // On firefox the iframe becomes document.activeElement in the next event loop\n      setTimeout(() => {\n        const {\n          activeElement\n        } = document;\n        if ((activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === \"IFRAME\" && !hasIgnoreClass(activeElement, ignoreClass) && !getEls().includes(activeElement))\n          callbackRef.current(e4);\n      }, 0);\n      const removeEventListener = () => {\n        eventTypes.forEach((type) => // @ts-ignore\n        document.removeEventListener(type, handler, getEventOptions(type)));\n        if (detectIFrame)\n          window.removeEventListener(\"blur\", blurHandler);\n      };\n      if (disabled) {\n        removeEventListener();\n        return;\n      }\n      eventTypes.forEach((type) => document.addEventListener(type, handler, getEventOptions(type)));\n      if (detectIFrame)\n        window.addEventListener(\"blur\", blurHandler);\n      return () => removeEventListener();\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      refsState,\n      ignoreClass,\n      excludeScrollbar,\n      disabled,\n      detectIFrame,\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      JSON.stringify(eventTypes)\n    ]\n  );\n  return ref;\n};\nvar useElementProps = ({\n  attributes,\n  nodeProps,\n  element: element4,\n  editor,\n  elementToAttributes,\n  ...props\n}) => {\n  var _elementToAttributes;\n  const htmlProps = {\n    ...attributes,\n    ...props,\n    ...nodeProps,\n    ...(_elementToAttributes = elementToAttributes === null || elementToAttributes === void 0 ? void 0 : elementToAttributes(element4)) !== null && _elementToAttributes !== void 0 ? _elementToAttributes : {},\n    ref: useComposedRef(props.ref, attributes.ref)\n  };\n  return htmlProps;\n};\nvar usePlateStoreEffects = ({\n  id,\n  value: valueProp,\n  enabled: enabledProp = true,\n  onChange,\n  editableProps,\n  plugins,\n  decorate,\n  renderElement,\n  renderLeaf\n}) => {\n  const plateActions = getPlateActions(id);\n  (0, import_react7.useEffect)(() => {\n    if (!isUndefined(valueProp)) {\n      valueProp && plateActions.value(valueProp);\n    }\n  }, [valueProp, plateActions]);\n  (0, import_react7.useEffect)(() => {\n    if (!isUndefined(enabledProp)) {\n      plateActions.enabled(enabledProp);\n    }\n  }, [enabledProp, plateActions]);\n  (0, import_react7.useEffect)(() => {\n    if (!isUndefined(onChange)) {\n      plateActions.onChange(onChange);\n    }\n  }, [onChange, plateActions]);\n  useDeepCompareEffect(() => {\n    if (!isUndefined(editableProps)) {\n      plateActions.editableProps(editableProps);\n    }\n  }, [editableProps, plateActions]);\n  (0, import_react7.useEffect)(() => {\n    if (!isUndefined(decorate)) {\n      plateActions.decorate(decorate);\n    }\n  }, [decorate, plateActions]);\n  (0, import_react7.useEffect)(() => {\n    if (!isUndefined(renderElement)) {\n      plateActions.renderElement(renderElement);\n    }\n  }, [renderElement, plateActions]);\n  (0, import_react7.useEffect)(() => {\n    if (!isUndefined(renderLeaf)) {\n      plateActions.renderLeaf(renderLeaf);\n    }\n  }, [renderLeaf, plateActions]);\n  (0, import_react7.useEffect)(() => {\n    if (!isUndefined(plugins)) {\n      plateActions.plugins(plugins);\n    }\n  }, [plugins, plateActions]);\n};\nvar usePlateEffects = ({\n  id = \"main\",\n  editor: editorProp,\n  initialValue,\n  normalizeInitialValue: normalizeInitialValueProp,\n  plugins: pluginsProp,\n  disableCorePlugins,\n  editableProps,\n  onChange,\n  value: valueProp,\n  enabled: enabledProp\n}) => {\n  const editor = usePlateEditorRef(id);\n  const enabled = usePlateSelectors(id).enabled();\n  const plugins = usePlateSelectors(id).plugins();\n  const value = usePlateSelectors(id).value();\n  const isReady = usePlateSelectors(id).isReady();\n  const prevEditor = (0, import_react7.useRef)(editor);\n  const prevPlugins = (0, import_react7.useRef)(plugins);\n  const plateActions = getPlateActions(id);\n  (0, import_react7.useEffect)(() => {\n    initialValue && plateActions.value(initialValue);\n  }, [plateActions]);\n  usePlateStoreEffects({\n    editableProps,\n    onChange,\n    id,\n    value: valueProp,\n    enabled: enabledProp,\n    plugins: pluginsProp\n  });\n  (0, import_react7.useEffect)(() => {\n    if (!editor || !value || isReady)\n      return;\n    normalizeInitialValue === null || normalizeInitialValue === void 0 ? void 0 : normalizeInitialValue(editor, value);\n    plateActions.isReady(true);\n  }, [editor, isReady, plateActions, value]);\n  (0, import_react7.useEffect)(() => {\n    if (editor && !enabled) {\n      plateActions.editor(null);\n    }\n  }, [enabled, editor, plateActions]);\n  (0, import_react7.useEffect)(() => {\n    if (!editor && enabled) {\n      plateActions.editor(editorProp !== null && editorProp !== void 0 ? editorProp : withPlate(createTEditor(), {\n        id,\n        plugins: pluginsProp,\n        disableCorePlugins\n      }));\n    }\n  }, [editorProp, id, plugins, editor, enabled, disableCorePlugins, plateActions, pluginsProp]);\n  (0, import_react7.useEffect)(() => {\n    if (editor && prevEditor.current === editor && prevPlugins.current !== plugins) {\n      setPlatePlugins(editor, {\n        plugins,\n        disableCorePlugins\n      });\n      prevPlugins.current = plugins;\n    }\n  }, [plugins, editor, disableCorePlugins]);\n  (0, import_react7.useEffect)(() => {\n    if (editor && normalizeInitialValueProp && isReady) {\n      normalizeEditor(editor, {\n        force: true\n      });\n    }\n  }, [editor, isReady, normalizeInitialValueProp]);\n  (0, import_react7.useEffect)(() => {\n    prevEditor.current = editor;\n  }, [editor]);\n};\nvar pipeOnChange = (editor) => {\n  const onChanges = editor.plugins.flatMap((plugin) => {\n    var _plugin$handlers$onCh, _plugin$handlers, _plugin$handlers$onCh2;\n    return (_plugin$handlers$onCh = (_plugin$handlers = plugin.handlers) === null || _plugin$handlers === void 0 ? void 0 : (_plugin$handlers$onCh2 = _plugin$handlers.onChange) === null || _plugin$handlers$onCh2 === void 0 ? void 0 : _plugin$handlers$onCh2.call(_plugin$handlers, editor, plugin)) !== null && _plugin$handlers$onCh !== void 0 ? _plugin$handlers$onCh : [];\n  });\n  return (nodes) => {\n    return onChanges.some((handler) => {\n      if (!handler) {\n        return false;\n      }\n      const shouldTreatEventAsHandled = handler(nodes);\n      if (shouldTreatEventAsHandled != null) {\n        return shouldTreatEventAsHandled;\n      }\n      return false;\n    });\n  };\n};\nvar useSlateProps = ({\n  id\n} = {}) => {\n  const editor = usePlateEditorRef(id);\n  const keyPlugins = usePlateSelectors(id).keyPlugins();\n  const value = usePlateSelectors(id).value();\n  const isReady = usePlateSelectors(id).isReady();\n  const onChangeProp = usePlateSelectors(id).onChange();\n  const onChange = (0, import_react7.useCallback)((newValue) => {\n    if (!editor || !keyPlugins)\n      return;\n    const eventIsHandled = pipeOnChange(editor)(newValue);\n    if (!eventIsHandled) {\n      onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(newValue);\n    }\n    getPlateActions(id).value(newValue);\n  }, [onChangeProp, editor, id, keyPlugins]);\n  return (0, import_react7.useMemo)(() => {\n    if (!editor || !isReady)\n      return {};\n    return {\n      key: editor.key,\n      editor,\n      onChange,\n      value\n    };\n  }, [editor, isReady, onChange, value]);\n};\nvar usePlate = (options) => {\n  const {\n    id\n  } = options;\n  usePlateEffects(options);\n  return {\n    slateProps: useSlateProps({\n      id\n    }),\n    editableProps: useEditableProps({\n      id\n    })\n  };\n};\nvar usePlatesStoreEffect = (id, props) => {\n  (0, import_react7.useEffect)(() => {\n    if (!platesSelectors.has(id)) {\n      platesActions.set(id, props);\n    }\n  }, [id]);\n};\nvar useEditorRef = () => useSlateStatic();\nvar useEditorState = () => useSlate();\nvar createComponentAs = (render2) => {\n  const Role = ({\n    asChild,\n    ...props\n  }, ref) => {\n    const Comp = asChild ? Slot : render2;\n    return Comp({\n      ref,\n      ...props\n    });\n  };\n  return /* @__PURE__ */ (0, import_react7.forwardRef)(Role);\n};\nvar isRenderProp = (children) => typeof children === \"function\";\nvar createElementAs = (Type, props) => {\n  const {\n    as: As,\n    wrapElement,\n    ...rest\n  } = props;\n  let element4;\n  if (As && typeof As !== \"string\") {\n    element4 = /* @__PURE__ */ import_react7.default.createElement(As, rest);\n  } else if (isRenderProp(props.children)) {\n    const {\n      children,\n      ...otherProps\n    } = rest;\n    element4 = props.children(otherProps);\n  } else if (As) {\n    element4 = /* @__PURE__ */ import_react7.default.createElement(As, rest);\n  } else {\n    element4 = /* @__PURE__ */ import_react7.default.createElement(Type, rest);\n  }\n  if (wrapElement) {\n    return wrapElement(element4);\n  }\n  return element4;\n};\nvar createNodeHOC = (HOC) => (Component3, props) => (childrenProps) => /* @__PURE__ */ import_react7.default.createElement(HOC, _extends2({}, childrenProps, props), /* @__PURE__ */ import_react7.default.createElement(Component3, childrenProps));\nvar createHOC = (withHOC2) => {\n  return (components2, options) => {\n    const _components = {\n      ...components2\n    };\n    const optionsByKey = {};\n    const optionsList = castArray_1(options);\n    optionsList.forEach(({\n      key,\n      keys: keys4,\n      ...opt\n    }) => {\n      const _keys = key ? [key] : keys4 !== null && keys4 !== void 0 ? keys4 : Object.keys(_components);\n      _keys.forEach((_key) => {\n        optionsByKey[_key] = {\n          ...optionsByKey[_key],\n          ...opt\n        };\n      });\n    });\n    Object.keys(optionsByKey).forEach((key) => {\n      if (!_components[key])\n        return;\n      _components[key] = withHOC2(_components[key], optionsByKey[key]);\n    });\n    return _components;\n  };\n};\nvar createNodesHOC = (HOC) => {\n  return createHOC(createNodeHOC(HOC));\n};\nvar createNodesWithHOC = (withHOC2) => {\n  return createHOC(withHOC2);\n};\nvar getPreventDefaultHandler = (cb, ...args) => (event) => {\n  event.preventDefault();\n  cb === null || cb === void 0 ? void 0 : cb(...args);\n};\nvar withHOC = (HOC, Component3, hocProps) => (props) => /* @__PURE__ */ import_react7.default.createElement(HOC, hocProps, /* @__PURE__ */ import_react7.default.createElement(Component3, props));\nvar withProps = (Component3, props) => (_props) => /* @__PURE__ */ import_react7.default.createElement(Component3, _extends2({}, _props, props));\nvar getPluginInjectProps = (editor, key) => {\n  var _getPlugin$inject$pro, _getPlugin$inject;\n  return (_getPlugin$inject$pro = (_getPlugin$inject = getPlugin(editor, key).inject) === null || _getPlugin$inject === void 0 ? void 0 : _getPlugin$inject.props) !== null && _getPlugin$inject$pro !== void 0 ? _getPlugin$inject$pro : {};\n};\nvar getPluginOptions = (editor, key) => {\n  var _getPlugin$options;\n  return (_getPlugin$options = getPlugin(editor, key).options) !== null && _getPlugin$options !== void 0 ? _getPlugin$options : {};\n};\nvar getPluginTypes = (editor, keys4) => keys4.map((key) => getPluginType(editor, key));\nvar mockPlugin = (plugin) => ({\n  key: \"\",\n  type: \"\",\n  editor: {},\n  inject: {},\n  options: {},\n  ...plugin\n});\nfunction isEqual(value, other) {\n  return _baseIsEqual(value, other);\n}\nvar isEqual_1 = isEqual;\nvar useEventEditorId = () => {\n  const focus = useEventEditorSelectors.focus();\n  const blur = useEventEditorSelectors.blur();\n  const last2 = useEventEditorSelectors.last();\n  if (focus)\n    return focus;\n  if (blur)\n    return blur;\n  return last2;\n};\nvar useEventPlateId = (id, scope2) => {\n  var _ref, _ref2;\n  const plateId = usePlateId(scope2);\n  const eventEditorId = useEventEditorId();\n  return (_ref = (_ref2 = id !== null && id !== void 0 ? id : plateId) !== null && _ref2 !== void 0 ? _ref2 : eventEditorId) !== null && _ref !== void 0 ? _ref : \"main\";\n};\nvar usePlateEditorState = (id) => {\n  usePlateSelectors(id).keyEditor();\n  return usePlateEditorRef(id);\n};\nvar normalizeInitialValue = (editor, value) => {\n  let normalizedValue = cloneDeep_1(value);\n  editor.plugins.forEach((p6) => {\n    var _p$normalizeInitialVa;\n    const _normalizedValue = (_p$normalizeInitialVa = p6.normalizeInitialValue) === null || _p$normalizeInitialVa === void 0 ? void 0 : _p$normalizeInitialVa.call(p6, normalizedValue);\n    if (_normalizedValue) {\n      normalizedValue = _normalizedValue;\n    }\n  });\n  if (!isEqual_1(value, normalizedValue)) {\n    getPlateActions(editor.id).value(normalizedValue);\n    return normalizedValue;\n  }\n};\nvar SCOPE_ELEMENT = \"element\";\nvar {\n  elementStore,\n  useElementStore\n} = createAtomStore({\n  element: null\n}, {\n  name: \"element\"\n});\nvar useElement = (pluginKey = SCOPE_ELEMENT) => {\n  const value = useElementStore().get.element(pluginKey);\n  if (!value)\n    throw new Error(`The \\`useElement(pluginKey)\\` hook must be used inside the node component's context`);\n  return value;\n};\nvar ElementProviderChild = ({\n  element: element4,\n  scope: scope2,\n  children\n}) => {\n  const setElement = useElementStore().set.element(scope2);\n  const setGlobalElement = useElementStore().set.element(SCOPE_ELEMENT);\n  (0, import_react7.useEffect)(() => {\n    setElement(element4);\n    setGlobalElement(element4);\n  }, [element4, setElement, setGlobalElement]);\n  return children;\n};\nvar ElementProvider = ({\n  element: element4,\n  scope: scope2,\n  children,\n  ...props\n}) => /* @__PURE__ */ import_react7.default.createElement(JotaiProvider, _extends2({\n  initialValues: [[elementStore.atom.element, element4]],\n  scope: SCOPE_ELEMENT\n}, props), /* @__PURE__ */ import_react7.default.createElement(JotaiProvider, _extends2({\n  initialValues: [[elementStore.atom.element, element4]],\n  scope: scope2\n}, props), /* @__PURE__ */ import_react7.default.createElement(ElementProviderChild, {\n  element: element4,\n  scope: scope2\n}, children)));\nvar Box = createComponentAs((props) => createElementAs(\"div\", props));\nvar EditorRefPluginEffect = ({\n  plugin\n}) => {\n  var _plugin$useHooks;\n  const editor = useEditorRef();\n  (_plugin$useHooks = plugin.useHooks) === null || _plugin$useHooks === void 0 ? void 0 : _plugin$useHooks.call(plugin, editor, plugin);\n  return null;\n};\nvar EditorRefEffect = ({\n  id\n}) => {\n  const editor = useEditorRef();\n  usePlateSelectors(id).keyPlugins();\n  (0, import_react7.useEffect)(() => {\n    const plateActions = getPlateActions(editor.id);\n    plateActions.isRendered(true);\n    return () => {\n      plateActions.isRendered(false);\n    };\n  }, [editor.id]);\n  return /* @__PURE__ */ import_react7.default.createElement(import_react7.default.Fragment, null, editor.plugins.map((plugin) => /* @__PURE__ */ import_react7.default.createElement(EditorRefPluginEffect, {\n    key: plugin.key,\n    plugin\n  })));\n};\nvar EditorStateEffect = /* @__PURE__ */ (0, import_react7.memo)(({\n  id\n}) => {\n  const editorState = useEditorState();\n  (0, import_react7.useEffect)(() => {\n    getPlateActions(id).incrementKey(\"keyEditor\");\n  });\n  (0, import_react7.useEffect)(() => {\n    getPlateActions(id).incrementKey(\"keySelection\");\n  }, [editorState.selection, id]);\n  return null;\n});\nvar SlateChildren = ({\n  children,\n  renderEditable,\n  editableRef,\n  editableProps,\n  editor,\n  firstChildren\n}) => {\n  const {\n    plugins\n  } = editor;\n  const editable = /* @__PURE__ */ import_react7.default.createElement(Editable, _extends2({\n    ref: editableRef\n  }, editableProps));\n  let afterEditable = null;\n  let beforeEditable = null;\n  plugins.forEach((plugin) => {\n    const {\n      renderBeforeEditable,\n      renderAfterEditable\n    } = plugin;\n    if (renderAfterEditable) {\n      afterEditable = /* @__PURE__ */ import_react7.default.createElement(import_react7.default.Fragment, null, afterEditable, renderAfterEditable());\n    }\n    if (renderBeforeEditable) {\n      beforeEditable = /* @__PURE__ */ import_react7.default.createElement(import_react7.default.Fragment, null, beforeEditable, renderBeforeEditable());\n    }\n  });\n  let aboveEditable = /* @__PURE__ */ import_react7.default.createElement(import_react7.default.Fragment, null, firstChildren, beforeEditable, renderEditable ? renderEditable(editable) : editable, /* @__PURE__ */ import_react7.default.createElement(EditorStateEffect, {\n    id: editor.id\n  }), /* @__PURE__ */ import_react7.default.createElement(EditorRefEffect, {\n    id: editor.id\n  }), afterEditable, children);\n  plugins.forEach((plugin) => {\n    const {\n      renderAboveEditable\n    } = plugin;\n    if (renderAboveEditable)\n      aboveEditable = renderAboveEditable({\n        children: aboveEditable\n      });\n  });\n  return aboveEditable;\n};\nvar PlateContent = ({\n  children,\n  editableRef,\n  firstChildren,\n  renderEditable,\n  ...options\n}) => {\n  const {\n    slateProps,\n    editableProps\n  } = usePlate(options);\n  const editor = slateProps.editor;\n  if (!editor)\n    return null;\n  return /* @__PURE__ */ import_react7.default.createElement(Slate, slateProps, /* @__PURE__ */ import_react7.default.createElement(SlateChildren, {\n    editor,\n    editableProps,\n    editableRef,\n    firstChildren,\n    renderEditable\n  }, children));\n};\nvar Plate = (props) => {\n  const {\n    id = \"main\",\n    scope: scope2 = SCOPE_PLATE,\n    ...state\n  } = props;\n  const hasId = usePlatesSelectors.has(id);\n  (0, import_react7.useEffect)(() => () => {\n    platesActions.unset(id);\n  }, [id]);\n  usePlatesStoreEffect(id, state);\n  if (!hasId)\n    return null;\n  return /* @__PURE__ */ import_react7.default.createElement(JotaiProvider, {\n    initialValues: [[plateIdAtom, id]],\n    scope: scope2\n  }, /* @__PURE__ */ import_react7.default.createElement(PlateContent, props));\n};\nvar PlateProvider = ({\n  id = \"main\",\n  children,\n  scope: scope2 = SCOPE_PLATE\n}) => {\n  const hasId = usePlatesSelectors.has(id);\n  usePlatesStoreEffect(id);\n  if (!hasId)\n    return null;\n  return /* @__PURE__ */ import_react7.default.createElement(JotaiProvider, {\n    key: id,\n    initialValues: [[plateIdAtom, id]],\n    scope: scope2\n  }, children);\n};\nvar PlateEventProvider = ({\n  id,\n  children,\n  scope: scope2\n}) => {\n  id = useEventPlateId(id, scope2);\n  return /* @__PURE__ */ import_react7.default.createElement(PlateProvider, {\n    id,\n    scope: scope2\n  }, children);\n};\nvar withPlateEventProvider = (Component3, hocProps) => withHOC(PlateEventProvider, Component3, hocProps);\nvar setElements = (editor, props, options) => setNodes(editor, props, options);\nvar toggleNodeType = (editor, options, editorNodesOptions) => {\n  const {\n    activeType,\n    inactiveType = getPluginType(editor, ELEMENT_DEFAULT)\n  } = options;\n  if (!activeType || !editor.selection)\n    return;\n  const isActive = someNode(editor, {\n    ...editorNodesOptions,\n    match: {\n      type: activeType\n    }\n  });\n  if (isActive && activeType === inactiveType)\n    return;\n  setElements(editor, {\n    type: isActive ? inactiveType : activeType\n  });\n};\nvar onKeyDownToggleElement = (editor, {\n  type,\n  options: {\n    hotkey\n  }\n}) => (e4) => {\n  const defaultType = getPluginType(editor, ELEMENT_DEFAULT);\n  if (!hotkey)\n    return;\n  const hotkeys2 = castArray_1(hotkey);\n  for (const _hotkey of hotkeys2) {\n    if (isHotkey(_hotkey, e4)) {\n      e4.preventDefault();\n      toggleNodeType(editor, {\n        activeType: type,\n        inactiveType: defaultType\n      });\n      return;\n    }\n  }\n};\nvar removeMark = (editor, {\n  key,\n  at,\n  shouldChange = true,\n  ...rest\n}) => {\n  const selection = at !== null && at !== void 0 ? at : editor.selection;\n  key = castArray_1(key);\n  if (selection) {\n    if (Range.isRange(selection) && Range.isExpanded(selection)) {\n      unsetNodes(editor, key, {\n        at: selection,\n        match: isText,\n        split: true,\n        ...rest\n      });\n    } else if (editor.selection) {\n      const marks3 = {\n        ...getMarks(editor) || {}\n      };\n      key.forEach((k3) => {\n        delete marks3[k3];\n      });\n      editor.marks = marks3;\n      shouldChange && editor.onChange();\n    }\n  }\n};\nvar toggleMark = (editor, {\n  key,\n  clear\n}) => {\n  if (!editor.selection)\n    return;\n  withoutNormalizing(editor, () => {\n    const isActive = isMarkActive(editor, key);\n    if (isActive) {\n      removeMark(editor, {\n        key\n      });\n      return;\n    }\n    if (clear) {\n      const clears = castArray_1(clear);\n      removeMark(editor, {\n        key: clears\n      });\n    }\n    editor.addMark(key, true);\n  });\n};\nvar onKeyDownToggleMark = (editor, {\n  type,\n  options: {\n    hotkey,\n    clear\n  }\n}) => (e4) => {\n  if (!hotkey)\n    return;\n  if (isHotkey(hotkey, e4)) {\n    e4.preventDefault();\n    toggleMark(editor, {\n      key: type,\n      clear\n    });\n  }\n};\nvar traverseHtmlNode = (node, callback) => {\n  const keepTraversing = callback(node);\n  if (!keepTraversing) {\n    return;\n  }\n  let child = node.firstChild;\n  while (child) {\n    const currentChild = child;\n    const previousChild = child.previousSibling;\n    child = child.nextSibling;\n    traverseHtmlNode(currentChild, callback);\n    if (// An unwrap was made. Need to compute the next child again.\n    !currentChild.previousSibling && !currentChild.nextSibling && !currentChild.parentNode && child && previousChild !== child.previousSibling && child.parentNode) {\n      if (previousChild) {\n        child = previousChild.nextSibling;\n      } else {\n        child = node.firstChild;\n      }\n    } else if (// A list was created. Need to compute the next child again.\n    !currentChild.previousSibling && !currentChild.nextSibling && !currentChild.parentNode && child && !child.previousSibling && !child.nextSibling && !child.parentNode) {\n      if (previousChild) {\n        if (previousChild.nextSibling) {\n          child = previousChild.nextSibling.nextSibling;\n        } else {\n          child = null;\n        }\n      } else if (node.firstChild) {\n        child = node.firstChild.nextSibling;\n      }\n    }\n  }\n};\nvar traverseHtmlElements = (rootNode, callback) => {\n  traverseHtmlNode(rootNode, (node) => {\n    if (!isHtmlElement(node)) {\n      return true;\n    }\n    return callback(node);\n  });\n};\nvar findHtmlElement = (rootNode, predicate) => {\n  let res = null;\n  traverseHtmlElements(rootNode, (node) => {\n    if (predicate(node)) {\n      res = node;\n      return false;\n    }\n    return true;\n  });\n  return res;\n};\nvar someHtmlElement = (rootNode, predicate) => {\n  return !!findHtmlElement(rootNode, predicate);\n};\nvar objectProto2 = Object.prototype;\nvar hasOwnProperty2 = objectProto2.hasOwnProperty;\nvar defaults = _baseRest(function(object, sources) {\n  object = Object(object);\n  var index5 = -1;\n  var length = sources.length;\n  var guard = length > 2 ? sources[2] : void 0;\n  if (guard && _isIterateeCall(sources[0], sources[1], guard)) {\n    length = 1;\n  }\n  while (++index5 < length) {\n    var source = sources[index5];\n    var props = keysIn_1(source);\n    var propsIndex = -1;\n    var propsLength = props.length;\n    while (++propsIndex < propsLength) {\n      var key = props[propsIndex];\n      var value = object[key];\n      if (value === void 0 || eq_12(value, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {\n        object[key] = source[key];\n      }\n    }\n  }\n  return object;\n});\nvar defaults_1 = defaults;\nvar defaultsDeepToNodes = (options) => {\n  applyDeepToNodes({\n    ...options,\n    apply: defaults_1\n  });\n};\nvar insertElements = (editor, nodes, options) => insertNodes(editor, nodes, options);\nvar insertEmptyElement = (editor, type, options) => {\n  insertElements(editor, {\n    type,\n    children: [{\n      text: \"\"\n    }]\n  }, getQueryOptions(editor, options));\n};\nvar moveChildren = (editor, {\n  at,\n  to,\n  match: match2,\n  fromStartIndex = 0\n}) => {\n  let moved = 0;\n  const parentPath = Path.isPath(at) ? at : at[1];\n  const parentNode = Path.isPath(at) ? getNode(editor, parentPath) : at[0];\n  if (!isBlock(editor, parentNode))\n    return moved;\n  for (let i5 = parentNode.children.length - 1; i5 >= fromStartIndex; i5--) {\n    const childPath = [...parentPath, i5];\n    const childNode = getNode(editor, childPath);\n    if (!match2 || childNode && match2([childNode, childPath])) {\n      moveNodes(editor, {\n        at: childPath,\n        to\n      });\n      moved++;\n    }\n  }\n  return moved;\n};\nvar removeNodeChildren = (editor, path, options) => {\n  withoutNormalizing(editor, () => {\n    for (const [, childPath] of getNodeChildren(editor, path, {\n      reverse: true\n    })) {\n      removeNodes(editor, {\n        ...options,\n        at: childPath\n      });\n    }\n  });\n};\nvar replaceNodeChildren = (editor, {\n  at,\n  nodes,\n  insertOptions,\n  removeOptions\n}) => {\n  withoutNormalizing(editor, () => {\n    removeNodeChildren(editor, at, removeOptions);\n    insertNodes(editor, nodes, {\n      ...insertOptions,\n      at: at.concat([0])\n    });\n  });\n};\nvar selectEditor = (editor, {\n  at,\n  edge,\n  focus\n}) => {\n  if (focus) {\n    focusEditor(editor);\n  }\n  let location = at;\n  if (edge === \"start\") {\n    location = getStartPoint(editor, []);\n  }\n  if (edge === \"end\") {\n    location = getEndPoint(editor, []);\n  }\n  if (location) {\n    select(editor, location);\n  }\n};\nvar wrapNodeChildren = (editor, element4, options) => {\n  const path = options === null || options === void 0 ? void 0 : options.at;\n  const node = getNode(editor, path);\n  if (!(node !== null && node !== void 0 && node.children))\n    return;\n  withoutNormalizing(editor, () => {\n    const firstChildPath = path.concat([0]);\n    wrapNodes(editor, element4, {\n      ...options,\n      at: firstChildPath\n    });\n    if (node.children.length < 2)\n      return;\n    moveChildren(editor, {\n      at: path,\n      to: firstChildPath.concat([1]),\n      fromStartIndex: 1\n    });\n  });\n};\n\n// node_modules/@udecode/plate-node-id/dist/index.es.js\nfunction listCacheClear3() {\n  this.__data__ = [];\n  this.size = 0;\n}\nvar _listCacheClear3 = listCacheClear3;\nfunction eq3(value, other) {\n  return value === other || value !== value && other !== other;\n}\nvar eq_13 = eq3;\nfunction assocIndexOf3(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq_13(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\nvar _assocIndexOf3 = assocIndexOf3;\nvar arrayProto3 = Array.prototype;\nvar splice3 = arrayProto3.splice;\nfunction listCacheDelete3(key) {\n  var data = this.__data__, index5 = _assocIndexOf3(data, key);\n  if (index5 < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index5 == lastIndex) {\n    data.pop();\n  } else {\n    splice3.call(data, index5, 1);\n  }\n  --this.size;\n  return true;\n}\nvar _listCacheDelete3 = listCacheDelete3;\nfunction listCacheGet3(key) {\n  var data = this.__data__, index5 = _assocIndexOf3(data, key);\n  return index5 < 0 ? void 0 : data[index5][1];\n}\nvar _listCacheGet3 = listCacheGet3;\nfunction listCacheHas3(key) {\n  return _assocIndexOf3(this.__data__, key) > -1;\n}\nvar _listCacheHas3 = listCacheHas3;\nfunction listCacheSet3(key, value) {\n  var data = this.__data__, index5 = _assocIndexOf3(data, key);\n  if (index5 < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index5][1] = value;\n  }\n  return this;\n}\nvar _listCacheSet3 = listCacheSet3;\nfunction ListCache3(entries) {\n  var index5 = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index5 < length) {\n    var entry = entries[index5];\n    this.set(entry[0], entry[1]);\n  }\n}\nListCache3.prototype.clear = _listCacheClear3;\nListCache3.prototype[\"delete\"] = _listCacheDelete3;\nListCache3.prototype.get = _listCacheGet3;\nListCache3.prototype.has = _listCacheHas3;\nListCache3.prototype.set = _listCacheSet3;\nvar _ListCache3 = ListCache3;\nfunction stackClear3() {\n  this.__data__ = new _ListCache3();\n  this.size = 0;\n}\nvar _stackClear3 = stackClear3;\nfunction stackDelete3(key) {\n  var data = this.__data__, result = data[\"delete\"](key);\n  this.size = data.size;\n  return result;\n}\nvar _stackDelete3 = stackDelete3;\nfunction stackGet3(key) {\n  return this.__data__.get(key);\n}\nvar _stackGet3 = stackGet3;\nfunction stackHas3(key) {\n  return this.__data__.has(key);\n}\nvar _stackHas3 = stackHas3;\nvar commonjsGlobal3 = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nfunction createCommonjsModule3(fn4, module2) {\n  return module2 = { exports: {} }, fn4(module2, module2.exports), module2.exports;\n}\nvar freeGlobal3 = typeof commonjsGlobal3 == \"object\" && commonjsGlobal3 && commonjsGlobal3.Object === Object && commonjsGlobal3;\nvar _freeGlobal3 = freeGlobal3;\nvar freeSelf3 = typeof self == \"object\" && self && self.Object === Object && self;\nvar root3 = _freeGlobal3 || freeSelf3 || Function(\"return this\")();\nvar _root3 = root3;\nvar Symbol3 = _root3.Symbol;\nvar _Symbol3 = Symbol3;\nvar objectProto$c2 = Object.prototype;\nvar hasOwnProperty$92 = objectProto$c2.hasOwnProperty;\nvar nativeObjectToString$13 = objectProto$c2.toString;\nvar symToStringTag$13 = _Symbol3 ? _Symbol3.toStringTag : void 0;\nfunction getRawTag3(value) {\n  var isOwn = hasOwnProperty$92.call(value, symToStringTag$13), tag = value[symToStringTag$13];\n  try {\n    value[symToStringTag$13] = void 0;\n    var unmasked = true;\n  } catch (e4) {\n  }\n  var result = nativeObjectToString$13.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$13] = tag;\n    } else {\n      delete value[symToStringTag$13];\n    }\n  }\n  return result;\n}\nvar _getRawTag3 = getRawTag3;\nvar objectProto$b3 = Object.prototype;\nvar nativeObjectToString3 = objectProto$b3.toString;\nfunction objectToString3(value) {\n  return nativeObjectToString3.call(value);\n}\nvar _objectToString3 = objectToString3;\nvar nullTag3 = \"[object Null]\";\nvar undefinedTag3 = \"[object Undefined]\";\nvar symToStringTag3 = _Symbol3 ? _Symbol3.toStringTag : void 0;\nfunction baseGetTag3(value) {\n  if (value == null) {\n    return value === void 0 ? undefinedTag3 : nullTag3;\n  }\n  return symToStringTag3 && symToStringTag3 in Object(value) ? _getRawTag3(value) : _objectToString3(value);\n}\nvar _baseGetTag3 = baseGetTag3;\nfunction isObject4(value) {\n  var type = typeof value;\n  return value != null && (type == \"object\" || type == \"function\");\n}\nvar isObject_13 = isObject4;\nvar asyncTag3 = \"[object AsyncFunction]\";\nvar funcTag$22 = \"[object Function]\";\nvar genTag$12 = \"[object GeneratorFunction]\";\nvar proxyTag3 = \"[object Proxy]\";\nfunction isFunction3(value) {\n  if (!isObject_13(value)) {\n    return false;\n  }\n  var tag = _baseGetTag3(value);\n  return tag == funcTag$22 || tag == genTag$12 || tag == asyncTag3 || tag == proxyTag3;\n}\nvar isFunction_13 = isFunction3;\nvar coreJsData3 = _root3[\"__core-js_shared__\"];\nvar _coreJsData3 = coreJsData3;\nvar maskSrcKey3 = function() {\n  var uid = /[^.]+$/.exec(_coreJsData3 && _coreJsData3.keys && _coreJsData3.keys.IE_PROTO || \"\");\n  return uid ? \"Symbol(src)_1.\" + uid : \"\";\n}();\nfunction isMasked3(func) {\n  return !!maskSrcKey3 && maskSrcKey3 in func;\n}\nvar _isMasked3 = isMasked3;\nvar funcProto$13 = Function.prototype;\nvar funcToString$13 = funcProto$13.toString;\nfunction toSource3(func) {\n  if (func != null) {\n    try {\n      return funcToString$13.call(func);\n    } catch (e4) {\n    }\n    try {\n      return func + \"\";\n    } catch (e4) {\n    }\n  }\n  return \"\";\n}\nvar _toSource3 = toSource3;\nvar reRegExpChar3 = /[\\\\^$.*+?()[\\]{}|]/g;\nvar reIsHostCtor3 = /^\\[object .+?Constructor\\]$/;\nvar funcProto3 = Function.prototype;\nvar objectProto$a3 = Object.prototype;\nvar funcToString3 = funcProto3.toString;\nvar hasOwnProperty$83 = objectProto$a3.hasOwnProperty;\nvar reIsNative3 = RegExp(\n  \"^\" + funcToString3.call(hasOwnProperty$83).replace(reRegExpChar3, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n);\nfunction baseIsNative3(value) {\n  if (!isObject_13(value) || _isMasked3(value)) {\n    return false;\n  }\n  var pattern = isFunction_13(value) ? reIsNative3 : reIsHostCtor3;\n  return pattern.test(_toSource3(value));\n}\nvar _baseIsNative3 = baseIsNative3;\nfunction getValue3(object, key) {\n  return object == null ? void 0 : object[key];\n}\nvar _getValue3 = getValue3;\nfunction getNative3(object, key) {\n  var value = _getValue3(object, key);\n  return _baseIsNative3(value) ? value : void 0;\n}\nvar _getNative3 = getNative3;\nvar Map3 = _getNative3(_root3, \"Map\");\nvar _Map3 = Map3;\nvar nativeCreate3 = _getNative3(Object, \"create\");\nvar _nativeCreate3 = nativeCreate3;\nfunction hashClear3() {\n  this.__data__ = _nativeCreate3 ? _nativeCreate3(null) : {};\n  this.size = 0;\n}\nvar _hashClear3 = hashClear3;\nfunction hashDelete3(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\nvar _hashDelete3 = hashDelete3;\nvar HASH_UNDEFINED$13 = \"__lodash_hash_undefined__\";\nvar objectProto$93 = Object.prototype;\nvar hasOwnProperty$73 = objectProto$93.hasOwnProperty;\nfunction hashGet3(key) {\n  var data = this.__data__;\n  if (_nativeCreate3) {\n    var result = data[key];\n    return result === HASH_UNDEFINED$13 ? void 0 : result;\n  }\n  return hasOwnProperty$73.call(data, key) ? data[key] : void 0;\n}\nvar _hashGet3 = hashGet3;\nvar objectProto$83 = Object.prototype;\nvar hasOwnProperty$63 = objectProto$83.hasOwnProperty;\nfunction hashHas3(key) {\n  var data = this.__data__;\n  return _nativeCreate3 ? data[key] !== void 0 : hasOwnProperty$63.call(data, key);\n}\nvar _hashHas3 = hashHas3;\nvar HASH_UNDEFINED3 = \"__lodash_hash_undefined__\";\nfunction hashSet3(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = _nativeCreate3 && value === void 0 ? HASH_UNDEFINED3 : value;\n  return this;\n}\nvar _hashSet3 = hashSet3;\nfunction Hash3(entries) {\n  var index5 = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index5 < length) {\n    var entry = entries[index5];\n    this.set(entry[0], entry[1]);\n  }\n}\nHash3.prototype.clear = _hashClear3;\nHash3.prototype[\"delete\"] = _hashDelete3;\nHash3.prototype.get = _hashGet3;\nHash3.prototype.has = _hashHas3;\nHash3.prototype.set = _hashSet3;\nvar _Hash3 = Hash3;\nfunction mapCacheClear3() {\n  this.size = 0;\n  this.__data__ = {\n    \"hash\": new _Hash3(),\n    \"map\": new (_Map3 || _ListCache3)(),\n    \"string\": new _Hash3()\n  };\n}\nvar _mapCacheClear3 = mapCacheClear3;\nfunction isKeyable3(value) {\n  var type = typeof value;\n  return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n}\nvar _isKeyable3 = isKeyable3;\nfunction getMapData3(map2, key) {\n  var data = map2.__data__;\n  return _isKeyable3(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n}\nvar _getMapData3 = getMapData3;\nfunction mapCacheDelete3(key) {\n  var result = _getMapData3(this, key)[\"delete\"](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\nvar _mapCacheDelete3 = mapCacheDelete3;\nfunction mapCacheGet3(key) {\n  return _getMapData3(this, key).get(key);\n}\nvar _mapCacheGet3 = mapCacheGet3;\nfunction mapCacheHas3(key) {\n  return _getMapData3(this, key).has(key);\n}\nvar _mapCacheHas3 = mapCacheHas3;\nfunction mapCacheSet3(key, value) {\n  var data = _getMapData3(this, key), size = data.size;\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\nvar _mapCacheSet3 = mapCacheSet3;\nfunction MapCache3(entries) {\n  var index5 = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index5 < length) {\n    var entry = entries[index5];\n    this.set(entry[0], entry[1]);\n  }\n}\nMapCache3.prototype.clear = _mapCacheClear3;\nMapCache3.prototype[\"delete\"] = _mapCacheDelete3;\nMapCache3.prototype.get = _mapCacheGet3;\nMapCache3.prototype.has = _mapCacheHas3;\nMapCache3.prototype.set = _mapCacheSet3;\nvar _MapCache3 = MapCache3;\nvar LARGE_ARRAY_SIZE3 = 200;\nfunction stackSet3(key, value) {\n  var data = this.__data__;\n  if (data instanceof _ListCache3) {\n    var pairs = data.__data__;\n    if (!_Map3 || pairs.length < LARGE_ARRAY_SIZE3 - 1) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new _MapCache3(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\nvar _stackSet3 = stackSet3;\nfunction Stack3(entries) {\n  var data = this.__data__ = new _ListCache3(entries);\n  this.size = data.size;\n}\nStack3.prototype.clear = _stackClear3;\nStack3.prototype[\"delete\"] = _stackDelete3;\nStack3.prototype.get = _stackGet3;\nStack3.prototype.has = _stackHas3;\nStack3.prototype.set = _stackSet3;\nvar _Stack2 = Stack3;\nfunction arrayEach2(array, iteratee) {\n  var index5 = -1, length = array == null ? 0 : array.length;\n  while (++index5 < length) {\n    if (iteratee(array[index5], index5, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\nvar _arrayEach2 = arrayEach2;\nvar defineProperty3 = function() {\n  try {\n    var func = _getNative3(Object, \"defineProperty\");\n    func({}, \"\", {});\n    return func;\n  } catch (e4) {\n  }\n}();\nvar _defineProperty4 = defineProperty3;\nfunction baseAssignValue2(object, key, value) {\n  if (key == \"__proto__\" && _defineProperty4) {\n    _defineProperty4(object, key, {\n      \"configurable\": true,\n      \"enumerable\": true,\n      \"value\": value,\n      \"writable\": true\n    });\n  } else {\n    object[key] = value;\n  }\n}\nvar _baseAssignValue2 = baseAssignValue2;\nvar objectProto$73 = Object.prototype;\nvar hasOwnProperty$53 = objectProto$73.hasOwnProperty;\nfunction assignValue2(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty$53.call(object, key) && eq_13(objValue, value)) || value === void 0 && !(key in object)) {\n    _baseAssignValue2(object, key, value);\n  }\n}\nvar _assignValue2 = assignValue2;\nfunction copyObject2(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n  var index5 = -1, length = props.length;\n  while (++index5 < length) {\n    var key = props[index5];\n    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;\n    if (newValue === void 0) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      _baseAssignValue2(object, key, newValue);\n    } else {\n      _assignValue2(object, key, newValue);\n    }\n  }\n  return object;\n}\nvar _copyObject2 = copyObject2;\nfunction baseTimes2(n8, iteratee) {\n  var index5 = -1, result = Array(n8);\n  while (++index5 < n8) {\n    result[index5] = iteratee(index5);\n  }\n  return result;\n}\nvar _baseTimes2 = baseTimes2;\nfunction isObjectLike3(value) {\n  return value != null && typeof value == \"object\";\n}\nvar isObjectLike_13 = isObjectLike3;\nvar argsTag$23 = \"[object Arguments]\";\nfunction baseIsArguments3(value) {\n  return isObjectLike_13(value) && _baseGetTag3(value) == argsTag$23;\n}\nvar _baseIsArguments3 = baseIsArguments3;\nvar objectProto$63 = Object.prototype;\nvar hasOwnProperty$43 = objectProto$63.hasOwnProperty;\nvar propertyIsEnumerable$13 = objectProto$63.propertyIsEnumerable;\nvar isArguments3 = _baseIsArguments3(function() {\n  return arguments;\n}()) ? _baseIsArguments3 : function(value) {\n  return isObjectLike_13(value) && hasOwnProperty$43.call(value, \"callee\") && !propertyIsEnumerable$13.call(value, \"callee\");\n};\nvar isArguments_12 = isArguments3;\nvar isArray3 = Array.isArray;\nvar isArray_12 = isArray3;\nfunction stubFalse3() {\n  return false;\n}\nvar stubFalse_13 = stubFalse3;\nvar isBuffer_13 = createCommonjsModule3(function(module2, exports2) {\n  var freeExports = exports2 && !exports2.nodeType && exports2;\n  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n  var Buffer2 = moduleExports ? _root3.Buffer : void 0;\n  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;\n  var isBuffer = nativeIsBuffer || stubFalse_13;\n  module2.exports = isBuffer;\n});\nvar MAX_SAFE_INTEGER$12 = 9007199254740991;\nvar reIsUint2 = /^(?:0|[1-9]\\d*)$/;\nfunction isIndex2(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER$12 : length;\n  return !!length && (type == \"number\" || type != \"symbol\" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);\n}\nvar _isIndex2 = isIndex2;\nvar MAX_SAFE_INTEGER3 = 9007199254740991;\nfunction isLength3(value) {\n  return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER3;\n}\nvar isLength_13 = isLength3;\nvar argsTag$13 = \"[object Arguments]\";\nvar arrayTag$13 = \"[object Array]\";\nvar boolTag$22 = \"[object Boolean]\";\nvar dateTag$22 = \"[object Date]\";\nvar errorTag$13 = \"[object Error]\";\nvar funcTag$13 = \"[object Function]\";\nvar mapTag$42 = \"[object Map]\";\nvar numberTag$22 = \"[object Number]\";\nvar objectTag$23 = \"[object Object]\";\nvar regexpTag$22 = \"[object RegExp]\";\nvar setTag$42 = \"[object Set]\";\nvar stringTag$22 = \"[object String]\";\nvar weakMapTag$22 = \"[object WeakMap]\";\nvar arrayBufferTag$22 = \"[object ArrayBuffer]\";\nvar dataViewTag$32 = \"[object DataView]\";\nvar float32Tag$22 = \"[object Float32Array]\";\nvar float64Tag$22 = \"[object Float64Array]\";\nvar int8Tag$22 = \"[object Int8Array]\";\nvar int16Tag$22 = \"[object Int16Array]\";\nvar int32Tag$22 = \"[object Int32Array]\";\nvar uint8Tag$22 = \"[object Uint8Array]\";\nvar uint8ClampedTag$22 = \"[object Uint8ClampedArray]\";\nvar uint16Tag$22 = \"[object Uint16Array]\";\nvar uint32Tag$22 = \"[object Uint32Array]\";\nvar typedArrayTags3 = {};\ntypedArrayTags3[float32Tag$22] = typedArrayTags3[float64Tag$22] = typedArrayTags3[int8Tag$22] = typedArrayTags3[int16Tag$22] = typedArrayTags3[int32Tag$22] = typedArrayTags3[uint8Tag$22] = typedArrayTags3[uint8ClampedTag$22] = typedArrayTags3[uint16Tag$22] = typedArrayTags3[uint32Tag$22] = true;\ntypedArrayTags3[argsTag$13] = typedArrayTags3[arrayTag$13] = typedArrayTags3[arrayBufferTag$22] = typedArrayTags3[boolTag$22] = typedArrayTags3[dataViewTag$32] = typedArrayTags3[dateTag$22] = typedArrayTags3[errorTag$13] = typedArrayTags3[funcTag$13] = typedArrayTags3[mapTag$42] = typedArrayTags3[numberTag$22] = typedArrayTags3[objectTag$23] = typedArrayTags3[regexpTag$22] = typedArrayTags3[setTag$42] = typedArrayTags3[stringTag$22] = typedArrayTags3[weakMapTag$22] = false;\nfunction baseIsTypedArray3(value) {\n  return isObjectLike_13(value) && isLength_13(value.length) && !!typedArrayTags3[_baseGetTag3(value)];\n}\nvar _baseIsTypedArray3 = baseIsTypedArray3;\nfunction baseUnary3(func) {\n  return function(value) {\n    return func(value);\n  };\n}\nvar _baseUnary3 = baseUnary3;\nvar _nodeUtil3 = createCommonjsModule3(function(module2, exports2) {\n  var freeExports = exports2 && !exports2.nodeType && exports2;\n  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n  var freeProcess = moduleExports && _freeGlobal3.process;\n  var nodeUtil = function() {\n    try {\n      var types = freeModule && freeModule.require && freeModule.require(\"util\").types;\n      if (types) {\n        return types;\n      }\n      return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n    } catch (e4) {\n    }\n  }();\n  module2.exports = nodeUtil;\n});\nvar nodeIsTypedArray3 = _nodeUtil3 && _nodeUtil3.isTypedArray;\nvar isTypedArray3 = nodeIsTypedArray3 ? _baseUnary3(nodeIsTypedArray3) : _baseIsTypedArray3;\nvar isTypedArray_12 = isTypedArray3;\nvar objectProto$53 = Object.prototype;\nvar hasOwnProperty$33 = objectProto$53.hasOwnProperty;\nfunction arrayLikeKeys2(value, inherited) {\n  var isArr = isArray_12(value), isArg = !isArr && isArguments_12(value), isBuff = !isArr && !isArg && isBuffer_13(value), isType3 = !isArr && !isArg && !isBuff && isTypedArray_12(value), skipIndexes = isArr || isArg || isBuff || isType3, result = skipIndexes ? _baseTimes2(value.length, String) : [], length = result.length;\n  for (var key in value) {\n    if ((inherited || hasOwnProperty$33.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.\n    (key == \"length\" || isBuff && (key == \"offset\" || key == \"parent\") || isType3 && (key == \"buffer\" || key == \"byteLength\" || key == \"byteOffset\") || // Skip index properties.\n    _isIndex2(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\nvar _arrayLikeKeys2 = arrayLikeKeys2;\nvar objectProto$43 = Object.prototype;\nfunction isPrototype2(value) {\n  var Ctor = value && value.constructor, proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto$43;\n  return value === proto;\n}\nvar _isPrototype2 = isPrototype2;\nfunction overArg3(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\nvar _overArg3 = overArg3;\nvar nativeKeys3 = _overArg3(Object.keys, Object);\nvar _nativeKeys2 = nativeKeys3;\nvar objectProto$33 = Object.prototype;\nvar hasOwnProperty$23 = objectProto$33.hasOwnProperty;\nfunction baseKeys2(object) {\n  if (!_isPrototype2(object)) {\n    return _nativeKeys2(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty$23.call(object, key) && key != \"constructor\") {\n      result.push(key);\n    }\n  }\n  return result;\n}\nvar _baseKeys2 = baseKeys2;\nfunction isArrayLike2(value) {\n  return value != null && isLength_13(value.length) && !isFunction_13(value);\n}\nvar isArrayLike_12 = isArrayLike2;\nfunction keys2(object) {\n  return isArrayLike_12(object) ? _arrayLikeKeys2(object) : _baseKeys2(object);\n}\nvar keys_12 = keys2;\nfunction baseAssign2(object, source) {\n  return object && _copyObject2(source, keys_12(source), object);\n}\nvar _baseAssign2 = baseAssign2;\nfunction nativeKeysIn2(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\nvar _nativeKeysIn2 = nativeKeysIn2;\nvar objectProto$23 = Object.prototype;\nvar hasOwnProperty$13 = objectProto$23.hasOwnProperty;\nfunction baseKeysIn2(object) {\n  if (!isObject_13(object)) {\n    return _nativeKeysIn2(object);\n  }\n  var isProto = _isPrototype2(object), result = [];\n  for (var key in object) {\n    if (!(key == \"constructor\" && (isProto || !hasOwnProperty$13.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\nvar _baseKeysIn2 = baseKeysIn2;\nfunction keysIn2(object) {\n  return isArrayLike_12(object) ? _arrayLikeKeys2(object, true) : _baseKeysIn2(object);\n}\nvar keysIn_12 = keysIn2;\nfunction baseAssignIn2(object, source) {\n  return object && _copyObject2(source, keysIn_12(source), object);\n}\nvar _baseAssignIn2 = baseAssignIn2;\nvar _cloneBuffer2 = createCommonjsModule3(function(module2, exports2) {\n  var freeExports = exports2 && !exports2.nodeType && exports2;\n  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n  var Buffer2 = moduleExports ? _root3.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;\n  function cloneBuffer(buffer, isDeep) {\n    if (isDeep) {\n      return buffer.slice();\n    }\n    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n    buffer.copy(result);\n    return result;\n  }\n  module2.exports = cloneBuffer;\n});\nfunction copyArray2(source, array) {\n  var index5 = -1, length = source.length;\n  array || (array = Array(length));\n  while (++index5 < length) {\n    array[index5] = source[index5];\n  }\n  return array;\n}\nvar _copyArray2 = copyArray2;\nfunction arrayFilter2(array, predicate) {\n  var index5 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];\n  while (++index5 < length) {\n    var value = array[index5];\n    if (predicate(value, index5, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\nvar _arrayFilter2 = arrayFilter2;\nfunction stubArray2() {\n  return [];\n}\nvar stubArray_12 = stubArray2;\nvar objectProto$13 = Object.prototype;\nvar propertyIsEnumerable3 = objectProto$13.propertyIsEnumerable;\nvar nativeGetSymbols$12 = Object.getOwnPropertySymbols;\nvar getSymbols2 = !nativeGetSymbols$12 ? stubArray_12 : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return _arrayFilter2(nativeGetSymbols$12(object), function(symbol) {\n    return propertyIsEnumerable3.call(object, symbol);\n  });\n};\nvar _getSymbols2 = getSymbols2;\nfunction copySymbols2(source, object) {\n  return _copyObject2(source, _getSymbols2(source), object);\n}\nvar _copySymbols2 = copySymbols2;\nfunction arrayPush2(array, values2) {\n  var index5 = -1, length = values2.length, offset3 = array.length;\n  while (++index5 < length) {\n    array[offset3 + index5] = values2[index5];\n  }\n  return array;\n}\nvar _arrayPush2 = arrayPush2;\nvar getPrototype2 = _overArg3(Object.getPrototypeOf, Object);\nvar _getPrototype2 = getPrototype2;\nvar nativeGetSymbols2 = Object.getOwnPropertySymbols;\nvar getSymbolsIn2 = !nativeGetSymbols2 ? stubArray_12 : function(object) {\n  var result = [];\n  while (object) {\n    _arrayPush2(result, _getSymbols2(object));\n    object = _getPrototype2(object);\n  }\n  return result;\n};\nvar _getSymbolsIn2 = getSymbolsIn2;\nfunction copySymbolsIn2(source, object) {\n  return _copyObject2(source, _getSymbolsIn2(source), object);\n}\nvar _copySymbolsIn2 = copySymbolsIn2;\nfunction baseGetAllKeys2(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray_12(object) ? result : _arrayPush2(result, symbolsFunc(object));\n}\nvar _baseGetAllKeys2 = baseGetAllKeys2;\nfunction getAllKeys2(object) {\n  return _baseGetAllKeys2(object, keys_12, _getSymbols2);\n}\nvar _getAllKeys2 = getAllKeys2;\nfunction getAllKeysIn2(object) {\n  return _baseGetAllKeys2(object, keysIn_12, _getSymbolsIn2);\n}\nvar _getAllKeysIn2 = getAllKeysIn2;\nvar DataView3 = _getNative3(_root3, \"DataView\");\nvar _DataView3 = DataView3;\nvar Promise$13 = _getNative3(_root3, \"Promise\");\nvar _Promise3 = Promise$13;\nvar Set4 = _getNative3(_root3, \"Set\");\nvar _Set3 = Set4;\nvar WeakMap3 = _getNative3(_root3, \"WeakMap\");\nvar _WeakMap3 = WeakMap3;\nvar mapTag$32 = \"[object Map]\";\nvar objectTag$13 = \"[object Object]\";\nvar promiseTag3 = \"[object Promise]\";\nvar setTag$32 = \"[object Set]\";\nvar weakMapTag$13 = \"[object WeakMap]\";\nvar dataViewTag$23 = \"[object DataView]\";\nvar dataViewCtorString3 = _toSource3(_DataView3);\nvar mapCtorString3 = _toSource3(_Map3);\nvar promiseCtorString3 = _toSource3(_Promise3);\nvar setCtorString3 = _toSource3(_Set3);\nvar weakMapCtorString3 = _toSource3(_WeakMap3);\nvar getTag3 = _baseGetTag3;\nif (_DataView3 && getTag3(new _DataView3(new ArrayBuffer(1))) != dataViewTag$23 || _Map3 && getTag3(new _Map3()) != mapTag$32 || _Promise3 && getTag3(_Promise3.resolve()) != promiseTag3 || _Set3 && getTag3(new _Set3()) != setTag$32 || _WeakMap3 && getTag3(new _WeakMap3()) != weakMapTag$13) {\n  getTag3 = function(value) {\n    var result = _baseGetTag3(value), Ctor = result == objectTag$13 ? value.constructor : void 0, ctorString = Ctor ? _toSource3(Ctor) : \"\";\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString3:\n          return dataViewTag$23;\n        case mapCtorString3:\n          return mapTag$32;\n        case promiseCtorString3:\n          return promiseTag3;\n        case setCtorString3:\n          return setTag$32;\n        case weakMapCtorString3:\n          return weakMapTag$13;\n      }\n    }\n    return result;\n  };\n}\nvar _getTag2 = getTag3;\nvar objectProto3 = Object.prototype;\nvar hasOwnProperty3 = objectProto3.hasOwnProperty;\nfunction initCloneArray2(array) {\n  var length = array.length, result = new array.constructor(length);\n  if (length && typeof array[0] == \"string\" && hasOwnProperty3.call(array, \"index\")) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\nvar _initCloneArray2 = initCloneArray2;\nvar Uint8Array4 = _root3.Uint8Array;\nvar _Uint8Array2 = Uint8Array4;\nfunction cloneArrayBuffer2(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new _Uint8Array2(result).set(new _Uint8Array2(arrayBuffer));\n  return result;\n}\nvar _cloneArrayBuffer2 = cloneArrayBuffer2;\nfunction cloneDataView2(dataView, isDeep) {\n  var buffer = isDeep ? _cloneArrayBuffer2(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\nvar _cloneDataView2 = cloneDataView2;\nvar reFlags2 = /\\w*$/;\nfunction cloneRegExp2(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags2.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\nvar _cloneRegExp2 = cloneRegExp2;\nvar symbolProto3 = _Symbol3 ? _Symbol3.prototype : void 0;\nvar symbolValueOf3 = symbolProto3 ? symbolProto3.valueOf : void 0;\nfunction cloneSymbol2(symbol) {\n  return symbolValueOf3 ? Object(symbolValueOf3.call(symbol)) : {};\n}\nvar _cloneSymbol2 = cloneSymbol2;\nfunction cloneTypedArray2(typedArray, isDeep) {\n  var buffer = isDeep ? _cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\nvar _cloneTypedArray2 = cloneTypedArray2;\nvar boolTag$13 = \"[object Boolean]\";\nvar dateTag$13 = \"[object Date]\";\nvar mapTag$23 = \"[object Map]\";\nvar numberTag$13 = \"[object Number]\";\nvar regexpTag$13 = \"[object RegExp]\";\nvar setTag$23 = \"[object Set]\";\nvar stringTag$13 = \"[object String]\";\nvar symbolTag$12 = \"[object Symbol]\";\nvar arrayBufferTag$13 = \"[object ArrayBuffer]\";\nvar dataViewTag$12 = \"[object DataView]\";\nvar float32Tag$12 = \"[object Float32Array]\";\nvar float64Tag$12 = \"[object Float64Array]\";\nvar int8Tag$12 = \"[object Int8Array]\";\nvar int16Tag$12 = \"[object Int16Array]\";\nvar int32Tag$12 = \"[object Int32Array]\";\nvar uint8Tag$12 = \"[object Uint8Array]\";\nvar uint8ClampedTag$12 = \"[object Uint8ClampedArray]\";\nvar uint16Tag$12 = \"[object Uint16Array]\";\nvar uint32Tag$12 = \"[object Uint32Array]\";\nfunction initCloneByTag2(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag$13:\n      return _cloneArrayBuffer2(object);\n    case boolTag$13:\n    case dateTag$13:\n      return new Ctor(+object);\n    case dataViewTag$12:\n      return _cloneDataView2(object, isDeep);\n    case float32Tag$12:\n    case float64Tag$12:\n    case int8Tag$12:\n    case int16Tag$12:\n    case int32Tag$12:\n    case uint8Tag$12:\n    case uint8ClampedTag$12:\n    case uint16Tag$12:\n    case uint32Tag$12:\n      return _cloneTypedArray2(object, isDeep);\n    case mapTag$23:\n      return new Ctor();\n    case numberTag$13:\n    case stringTag$13:\n      return new Ctor(object);\n    case regexpTag$13:\n      return _cloneRegExp2(object);\n    case setTag$23:\n      return new Ctor();\n    case symbolTag$12:\n      return _cloneSymbol2(object);\n  }\n}\nvar _initCloneByTag2 = initCloneByTag2;\nvar objectCreate2 = Object.create;\nvar baseCreate2 = function() {\n  function object() {\n  }\n  return function(proto) {\n    if (!isObject_13(proto)) {\n      return {};\n    }\n    if (objectCreate2) {\n      return objectCreate2(proto);\n    }\n    object.prototype = proto;\n    var result = new object();\n    object.prototype = void 0;\n    return result;\n  };\n}();\nvar _baseCreate2 = baseCreate2;\nfunction initCloneObject2(object) {\n  return typeof object.constructor == \"function\" && !_isPrototype2(object) ? _baseCreate2(_getPrototype2(object)) : {};\n}\nvar _initCloneObject2 = initCloneObject2;\nvar mapTag$12 = \"[object Map]\";\nfunction baseIsMap2(value) {\n  return isObjectLike_13(value) && _getTag2(value) == mapTag$12;\n}\nvar _baseIsMap2 = baseIsMap2;\nvar nodeIsMap2 = _nodeUtil3 && _nodeUtil3.isMap;\nvar isMap2 = nodeIsMap2 ? _baseUnary3(nodeIsMap2) : _baseIsMap2;\nvar isMap_12 = isMap2;\nvar setTag$12 = \"[object Set]\";\nfunction baseIsSet2(value) {\n  return isObjectLike_13(value) && _getTag2(value) == setTag$12;\n}\nvar _baseIsSet2 = baseIsSet2;\nvar nodeIsSet2 = _nodeUtil3 && _nodeUtil3.isSet;\nvar isSet2 = nodeIsSet2 ? _baseUnary3(nodeIsSet2) : _baseIsSet2;\nvar isSet_12 = isSet2;\nvar CLONE_DEEP_FLAG$12 = 1;\nvar CLONE_FLAT_FLAG2 = 2;\nvar CLONE_SYMBOLS_FLAG$12 = 4;\nvar argsTag2 = \"[object Arguments]\";\nvar arrayTag2 = \"[object Array]\";\nvar boolTag2 = \"[object Boolean]\";\nvar dateTag2 = \"[object Date]\";\nvar errorTag2 = \"[object Error]\";\nvar funcTag3 = \"[object Function]\";\nvar genTag3 = \"[object GeneratorFunction]\";\nvar mapTag3 = \"[object Map]\";\nvar numberTag2 = \"[object Number]\";\nvar objectTag2 = \"[object Object]\";\nvar regexpTag2 = \"[object RegExp]\";\nvar setTag3 = \"[object Set]\";\nvar stringTag2 = \"[object String]\";\nvar symbolTag2 = \"[object Symbol]\";\nvar weakMapTag3 = \"[object WeakMap]\";\nvar arrayBufferTag2 = \"[object ArrayBuffer]\";\nvar dataViewTag3 = \"[object DataView]\";\nvar float32Tag3 = \"[object Float32Array]\";\nvar float64Tag3 = \"[object Float64Array]\";\nvar int8Tag3 = \"[object Int8Array]\";\nvar int16Tag3 = \"[object Int16Array]\";\nvar int32Tag3 = \"[object Int32Array]\";\nvar uint8Tag3 = \"[object Uint8Array]\";\nvar uint8ClampedTag3 = \"[object Uint8ClampedArray]\";\nvar uint16Tag3 = \"[object Uint16Array]\";\nvar uint32Tag3 = \"[object Uint32Array]\";\nvar cloneableTags2 = {};\ncloneableTags2[argsTag2] = cloneableTags2[arrayTag2] = cloneableTags2[arrayBufferTag2] = cloneableTags2[dataViewTag3] = cloneableTags2[boolTag2] = cloneableTags2[dateTag2] = cloneableTags2[float32Tag3] = cloneableTags2[float64Tag3] = cloneableTags2[int8Tag3] = cloneableTags2[int16Tag3] = cloneableTags2[int32Tag3] = cloneableTags2[mapTag3] = cloneableTags2[numberTag2] = cloneableTags2[objectTag2] = cloneableTags2[regexpTag2] = cloneableTags2[setTag3] = cloneableTags2[stringTag2] = cloneableTags2[symbolTag2] = cloneableTags2[uint8Tag3] = cloneableTags2[uint8ClampedTag3] = cloneableTags2[uint16Tag3] = cloneableTags2[uint32Tag3] = true;\ncloneableTags2[errorTag2] = cloneableTags2[funcTag3] = cloneableTags2[weakMapTag3] = false;\nfunction baseClone2(value, bitmask, customizer, key, object, stack) {\n  var result, isDeep = bitmask & CLONE_DEEP_FLAG$12, isFlat = bitmask & CLONE_FLAT_FLAG2, isFull = bitmask & CLONE_SYMBOLS_FLAG$12;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== void 0) {\n    return result;\n  }\n  if (!isObject_13(value)) {\n    return value;\n  }\n  var isArr = isArray_12(value);\n  if (isArr) {\n    result = _initCloneArray2(value);\n    if (!isDeep) {\n      return _copyArray2(value, result);\n    }\n  } else {\n    var tag = _getTag2(value), isFunc = tag == funcTag3 || tag == genTag3;\n    if (isBuffer_13(value)) {\n      return _cloneBuffer2(value, isDeep);\n    }\n    if (tag == objectTag2 || tag == argsTag2 || isFunc && !object) {\n      result = isFlat || isFunc ? {} : _initCloneObject2(value);\n      if (!isDeep) {\n        return isFlat ? _copySymbolsIn2(value, _baseAssignIn2(result, value)) : _copySymbols2(value, _baseAssign2(result, value));\n      }\n    } else {\n      if (!cloneableTags2[tag]) {\n        return object ? value : {};\n      }\n      result = _initCloneByTag2(value, tag, isDeep);\n    }\n  }\n  stack || (stack = new _Stack2());\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n  if (isSet_12(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone2(subValue, bitmask, customizer, subValue, value, stack));\n    });\n  } else if (isMap_12(value)) {\n    value.forEach(function(subValue, key2) {\n      result.set(key2, baseClone2(subValue, bitmask, customizer, key2, value, stack));\n    });\n  }\n  var keysFunc = isFull ? isFlat ? _getAllKeysIn2 : _getAllKeys2 : isFlat ? keysIn_12 : keys_12;\n  var props = isArr ? void 0 : keysFunc(value);\n  _arrayEach2(props || value, function(subValue, key2) {\n    if (props) {\n      key2 = subValue;\n      subValue = value[key2];\n    }\n    _assignValue2(result, key2, baseClone2(subValue, bitmask, customizer, key2, value, stack));\n  });\n  return result;\n}\nvar _baseClone2 = baseClone2;\nvar CLONE_DEEP_FLAG2 = 1;\nvar CLONE_SYMBOLS_FLAG2 = 4;\nfunction cloneDeep2(value) {\n  return _baseClone2(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2);\n}\nvar cloneDeep_12 = cloneDeep2;\nvar withNodeId = (editor, {\n  options: {\n    idKey = \"\",\n    idCreator,\n    filterText,\n    filter: filter3,\n    reuseId,\n    allow,\n    exclude\n  }\n}) => {\n  const {\n    apply: apply2\n  } = editor;\n  const idPropsCreator = () => ({\n    [idKey]: idCreator()\n  });\n  const filterNode = (nodeEntry) => {\n    var _nodeEntry$;\n    return filter3(nodeEntry) && (!filterText || ((_nodeEntry$ = nodeEntry[0]) === null || _nodeEntry$ === void 0 ? void 0 : _nodeEntry$.type) !== void 0);\n  };\n  const query = {\n    filter: filterNode,\n    allow,\n    exclude\n  };\n  editor.apply = (operation) => {\n    if (operation.type === \"insert_node\") {\n      const node = cloneDeep_12(operation.node);\n      if (!reuseId || someNode(editor, {\n        match: {\n          [idKey]: node[idKey]\n        },\n        at: []\n      })) {\n        delete node[idKey];\n      }\n      defaultsDeepToNodes({\n        node,\n        source: idPropsCreator,\n        query\n      });\n      return apply2({\n        ...operation,\n        node\n      });\n    }\n    if (operation.type === \"split_node\") {\n      const node = operation.properties;\n      if (queryNode([node, []], query)) {\n        let id = operation.properties[idKey];\n        if (!reuseId || id === void 0 || someNode(editor, {\n          match: {\n            [idKey]: id\n          },\n          at: []\n        })) {\n          id = idCreator();\n        }\n        return apply2({\n          ...operation,\n          properties: {\n            ...operation.properties,\n            [idKey]: id\n          }\n        });\n      }\n    }\n    return apply2(operation);\n  };\n  return editor;\n};\nvar KEY_NODE_ID = \"nodeId\";\nvar createNodeIdPlugin = createPluginFactory({\n  key: KEY_NODE_ID,\n  withOverrides: withNodeId,\n  options: {\n    idKey: \"id\",\n    idCreator: () => Date.now(),\n    filterText: true,\n    filter: () => true\n  }\n});\n\n// node_modules/beautiful-react-hooks/esm/useDebouncedCallback.js\nvar import_react10 = require(\"react\");\nvar import_lodash = __toESM(require_lodash());\n\n// node_modules/beautiful-react-hooks/esm/useWillUnmount.js\nvar import_react9 = require(\"react\");\n\n// node_modules/beautiful-react-hooks/esm/shared/isFunction.js\nvar isFunction4 = (functionToCheck) => !!(typeof functionToCheck === \"function\" && !!functionToCheck.constructor && !!functionToCheck.call && !!functionToCheck.apply);\nvar isFunction_default = isFunction4;\n\n// node_modules/beautiful-react-hooks/esm/factory/createHandlerSetter.js\nvar import_react8 = require(\"react\");\nvar createHandlerSetter = (callback) => {\n  const handlerRef = (0, import_react8.useRef)(callback);\n  const setHandler = (0, import_react8.useRef)((nextCallback) => {\n    if (typeof nextCallback !== \"function\") {\n      throw new Error(\"the argument supplied to the 'setHandler' function should be of type function\");\n    }\n    handlerRef.current = nextCallback;\n  });\n  return [handlerRef, setHandler.current];\n};\nvar createHandlerSetter_default = createHandlerSetter;\n\n// node_modules/beautiful-react-hooks/esm/useWillUnmount.js\nvar useWillUnmount = (callback) => {\n  const mountRef = (0, import_react9.useRef)(false);\n  const [handler, setHandler] = createHandlerSetter_default(callback);\n  (0, import_react9.useEffect)(() => {\n    mountRef.current = true;\n    return () => {\n      if (isFunction_default(handler === null || handler === void 0 ? void 0 : handler.current) && mountRef.current) {\n        handler.current();\n      }\n    };\n  }, []);\n  return setHandler;\n};\nvar useWillUnmount_default = useWillUnmount;\n\n// node_modules/beautiful-react-hooks/esm/useDebouncedCallback.js\nvar defaultOptions = {\n  leading: false,\n  trailing: true\n};\nvar useDebouncedCallback = (fn4, dependencies, wait = 600, options = defaultOptions) => {\n  const debounced = (0, import_react10.useRef)((0, import_lodash.default)(fn4, wait, options));\n  (0, import_react10.useEffect)(() => {\n    debounced.current = (0, import_lodash.default)(fn4, wait, options);\n  }, [fn4, wait, options]);\n  useWillUnmount_default(() => {\n    var _a;\n    (_a = debounced.current) === null || _a === void 0 ? void 0 : _a.cancel();\n  });\n  return (0, import_react10.useCallback)(debounced.current, dependencies);\n};\nvar useDebouncedCallback_default = useDebouncedCallback;\n\n// node_modules/react-dnd/dist/core/DndContext.js\nvar import_react11 = require(\"react\");\nvar DndContext = (0, import_react11.createContext)({\n  dragDropManager: void 0\n});\n\n// node_modules/react-dnd/dist/core/DndProvider.js\nvar import_jsx_runtime = require(\"react/jsx-runtime\");\n\n// node_modules/@babel/runtime/helpers/esm/typeof.js\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj2) {\n    return typeof obj2;\n  } : function(obj2) {\n    return obj2 && \"function\" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n  }, _typeof(obj);\n}\n\n// node_modules/@babel/runtime/helpers/esm/toPrimitive.js\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null)\n    return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== void 0) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\")\n      return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\n// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\n// node_modules/@babel/runtime/helpers/esm/defineProperty.js\nfunction _defineProperty5(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// node_modules/redux/es/redux.js\nvar $$observable = function() {\n  return typeof Symbol === \"function\" && Symbol.observable || \"@@observable\";\n}();\nvar randomString = function randomString2() {\n  return Math.random().toString(36).substring(7).split(\"\").join(\".\");\n};\nvar ActionTypes = {\n  INIT: \"@@redux/INIT\" + randomString(),\n  REPLACE: \"@@redux/REPLACE\" + randomString(),\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\n    return \"@@redux/PROBE_UNKNOWN_ACTION\" + randomString();\n  }\n};\nfunction isPlainObject3(obj) {\n  if (typeof obj !== \"object\" || obj === null)\n    return false;\n  var proto = obj;\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n  return Object.getPrototypeOf(obj) === proto;\n}\nfunction miniKindOf(val) {\n  if (val === void 0)\n    return \"undefined\";\n  if (val === null)\n    return \"null\";\n  var type = typeof val;\n  switch (type) {\n    case \"boolean\":\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"function\": {\n      return type;\n    }\n  }\n  if (Array.isArray(val))\n    return \"array\";\n  if (isDate(val))\n    return \"date\";\n  if (isError(val))\n    return \"error\";\n  var constructorName = ctorName(val);\n  switch (constructorName) {\n    case \"Symbol\":\n    case \"Promise\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n    case \"Map\":\n    case \"Set\":\n      return constructorName;\n  }\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, \"\");\n}\nfunction ctorName(val) {\n  return typeof val.constructor === \"function\" ? val.constructor.name : null;\n}\nfunction isError(val) {\n  return val instanceof Error || typeof val.message === \"string\" && val.constructor && typeof val.constructor.stackTraceLimit === \"number\";\n}\nfunction isDate(val) {\n  if (val instanceof Date)\n    return true;\n  return typeof val.toDateString === \"function\" && typeof val.getDate === \"function\" && typeof val.setDate === \"function\";\n}\nfunction kindOf(val) {\n  var typeOfVal = typeof val;\n  if (true) {\n    typeOfVal = miniKindOf(val);\n  }\n  return typeOfVal;\n}\nfunction createStore4(reducer, preloadedState, enhancer) {\n  var _ref2;\n  if (typeof preloadedState === \"function\" && typeof enhancer === \"function\" || typeof enhancer === \"function\" && typeof arguments[3] === \"function\") {\n    throw new Error(false ? formatProdErrorMessage(0) : \"It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.\");\n  }\n  if (typeof preloadedState === \"function\" && typeof enhancer === \"undefined\") {\n    enhancer = preloadedState;\n    preloadedState = void 0;\n  }\n  if (typeof enhancer !== \"undefined\") {\n    if (typeof enhancer !== \"function\") {\n      throw new Error(false ? formatProdErrorMessage(1) : \"Expected the enhancer to be a function. Instead, received: '\" + kindOf(enhancer) + \"'\");\n    }\n    return enhancer(createStore4)(reducer, preloadedState);\n  }\n  if (typeof reducer !== \"function\") {\n    throw new Error(false ? formatProdErrorMessage(2) : \"Expected the root reducer to be a function. Instead, received: '\" + kindOf(reducer) + \"'\");\n  }\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n  function getState2() {\n    if (isDispatching) {\n      throw new Error(false ? formatProdErrorMessage(3) : \"You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.\");\n    }\n    return currentState;\n  }\n  function subscribe(listener) {\n    if (typeof listener !== \"function\") {\n      throw new Error(false ? formatProdErrorMessage(4) : \"Expected the listener to be a function. Instead, received: '\" + kindOf(listener) + \"'\");\n    }\n    if (isDispatching) {\n      throw new Error(false ? formatProdErrorMessage(5) : \"You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.\");\n    }\n    var isSubscribed = true;\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n      if (isDispatching) {\n        throw new Error(false ? formatProdErrorMessage(6) : \"You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.\");\n      }\n      isSubscribed = false;\n      ensureCanMutateNextListeners();\n      var index5 = nextListeners.indexOf(listener);\n      nextListeners.splice(index5, 1);\n      currentListeners = null;\n    };\n  }\n  function dispatch2(action) {\n    if (!isPlainObject3(action)) {\n      throw new Error(false ? formatProdErrorMessage(7) : \"Actions must be plain objects. Instead, the actual type was: '\" + kindOf(action) + \"'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.\");\n    }\n    if (typeof action.type === \"undefined\") {\n      throw new Error(false ? formatProdErrorMessage(8) : 'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');\n    }\n    if (isDispatching) {\n      throw new Error(false ? formatProdErrorMessage(9) : \"Reducers may not dispatch actions.\");\n    }\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n    var listeners = currentListeners = nextListeners;\n    for (var i5 = 0; i5 < listeners.length; i5++) {\n      var listener = listeners[i5];\n      listener();\n    }\n    return action;\n  }\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== \"function\") {\n      throw new Error(false ? formatProdErrorMessage(10) : \"Expected the nextReducer to be a function. Instead, received: '\" + kindOf(nextReducer));\n    }\n    currentReducer = nextReducer;\n    dispatch2({\n      type: ActionTypes.REPLACE\n    });\n  }\n  function observable() {\n    var _ref;\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe2(observer) {\n        if (typeof observer !== \"object\" || observer === null) {\n          throw new Error(false ? formatProdErrorMessage(11) : \"Expected the observer to be an object. Instead, received: '\" + kindOf(observer) + \"'\");\n        }\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState2());\n          }\n        }\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return {\n          unsubscribe\n        };\n      }\n    }, _ref[$$observable] = function() {\n      return this;\n    }, _ref;\n  }\n  dispatch2({\n    type: ActionTypes.INIT\n  });\n  return _ref2 = {\n    dispatch: dispatch2,\n    subscribe,\n    getState: getState2,\n    replaceReducer\n  }, _ref2[$$observable] = observable, _ref2;\n}\nfunction warning(message) {\n  if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n    console.error(message);\n  }\n  try {\n    throw new Error(message);\n  } catch (e4) {\n  }\n}\nfunction isCrushed() {\n}\nif (typeof isCrushed.name === \"string\" && isCrushed.name !== \"isCrushed\") {\n  warning('You are currently using minified code outside of NODE_ENV === \"production\". This means that you are running a slower development build of Redux. You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) to ensure you have the correct code for your production build.');\n}\n\n// node_modules/@react-dnd/invariant/dist/index.js\nfunction invariant(condition, format3, ...args) {\n  if (isProduction()) {\n    if (format3 === void 0) {\n      throw new Error(\"invariant requires an error message argument\");\n    }\n  }\n  if (!condition) {\n    let error;\n    if (format3 === void 0) {\n      error = new Error(\"Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.\");\n    } else {\n      let argIndex = 0;\n      error = new Error(format3.replace(/%s/g, function() {\n        return args[argIndex++];\n      }));\n      error.name = \"Invariant Violation\";\n    }\n    error.framesToPop = 1;\n    throw error;\n  }\n}\nfunction isProduction() {\n  return typeof process !== \"undefined\" && false;\n}\n\n// node_modules/dnd-core/dist/utils/js_utils.js\nfunction get2(obj, path, defaultValue) {\n  return path.split(\".\").reduce(\n    (a7, c5) => a7 && a7[c5] ? a7[c5] : defaultValue || null,\n    obj\n  );\n}\nfunction without(items, item) {\n  return items.filter(\n    (i5) => i5 !== item\n  );\n}\nfunction isObject5(input) {\n  return typeof input === \"object\";\n}\nfunction xor(itemsA, itemsB) {\n  const map2 = /* @__PURE__ */ new Map();\n  const insertItem = (item) => {\n    map2.set(item, map2.has(item) ? map2.get(item) + 1 : 1);\n  };\n  itemsA.forEach(insertItem);\n  itemsB.forEach(insertItem);\n  const result = [];\n  map2.forEach((count2, key) => {\n    if (count2 === 1) {\n      result.push(key);\n    }\n  });\n  return result;\n}\nfunction intersection(itemsA, itemsB) {\n  return itemsA.filter(\n    (t6) => itemsB.indexOf(t6) > -1\n  );\n}\n\n// node_modules/dnd-core/dist/actions/dragDrop/types.js\nvar INIT_COORDS = \"dnd-core/INIT_COORDS\";\nvar BEGIN_DRAG = \"dnd-core/BEGIN_DRAG\";\nvar PUBLISH_DRAG_SOURCE = \"dnd-core/PUBLISH_DRAG_SOURCE\";\nvar HOVER = \"dnd-core/HOVER\";\nvar DROP = \"dnd-core/DROP\";\nvar END_DRAG = \"dnd-core/END_DRAG\";\n\n// node_modules/dnd-core/dist/actions/dragDrop/local/setClientOffset.js\nfunction setClientOffset(clientOffset, sourceClientOffset) {\n  return {\n    type: INIT_COORDS,\n    payload: {\n      sourceClientOffset: sourceClientOffset || null,\n      clientOffset: clientOffset || null\n    }\n  };\n}\n\n// node_modules/dnd-core/dist/actions/dragDrop/beginDrag.js\nvar ResetCoordinatesAction = {\n  type: INIT_COORDS,\n  payload: {\n    clientOffset: null,\n    sourceClientOffset: null\n  }\n};\nfunction createBeginDrag(manager) {\n  return function beginDrag(sourceIds = [], options = {\n    publishSource: true\n  }) {\n    const { publishSource = true, clientOffset, getSourceClientOffset: getSourceClientOffset2 } = options;\n    const monitor = manager.getMonitor();\n    const registry = manager.getRegistry();\n    manager.dispatch(setClientOffset(clientOffset));\n    verifyInvariants(sourceIds, monitor, registry);\n    const sourceId = getDraggableSource(sourceIds, monitor);\n    if (sourceId == null) {\n      manager.dispatch(ResetCoordinatesAction);\n      return;\n    }\n    let sourceClientOffset = null;\n    if (clientOffset) {\n      if (!getSourceClientOffset2) {\n        throw new Error(\"getSourceClientOffset must be defined\");\n      }\n      verifyGetSourceClientOffsetIsFunction(getSourceClientOffset2);\n      sourceClientOffset = getSourceClientOffset2(sourceId);\n    }\n    manager.dispatch(setClientOffset(clientOffset, sourceClientOffset));\n    const source = registry.getSource(sourceId);\n    const item = source.beginDrag(monitor, sourceId);\n    if (item == null) {\n      return void 0;\n    }\n    verifyItemIsObject(item);\n    registry.pinSource(sourceId);\n    const itemType = registry.getSourceType(sourceId);\n    return {\n      type: BEGIN_DRAG,\n      payload: {\n        itemType,\n        item,\n        sourceId,\n        clientOffset: clientOffset || null,\n        sourceClientOffset: sourceClientOffset || null,\n        isSourcePublic: !!publishSource\n      }\n    };\n  };\n}\nfunction verifyInvariants(sourceIds, monitor, registry) {\n  invariant(!monitor.isDragging(), \"Cannot call beginDrag while dragging.\");\n  sourceIds.forEach(function(sourceId) {\n    invariant(registry.getSource(sourceId), \"Expected sourceIds to be registered.\");\n  });\n}\nfunction verifyGetSourceClientOffsetIsFunction(getSourceClientOffset2) {\n  invariant(typeof getSourceClientOffset2 === \"function\", \"When clientOffset is provided, getSourceClientOffset must be a function.\");\n}\nfunction verifyItemIsObject(item) {\n  invariant(isObject5(item), \"Item must be an object.\");\n}\nfunction getDraggableSource(sourceIds, monitor) {\n  let sourceId = null;\n  for (let i5 = sourceIds.length - 1; i5 >= 0; i5--) {\n    if (monitor.canDragSource(sourceIds[i5])) {\n      sourceId = sourceIds[i5];\n      break;\n    }\n  }\n  return sourceId;\n}\n\n// node_modules/dnd-core/dist/actions/dragDrop/drop.js\nfunction _defineProperty6(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _objectSpread4(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    var ownKeys5 = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === \"function\") {\n      ownKeys5 = ownKeys5.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n    ownKeys5.forEach(function(key) {\n      _defineProperty6(target, key, source[key]);\n    });\n  }\n  return target;\n}\nfunction createDrop(manager) {\n  return function drop(options = {}) {\n    const monitor = manager.getMonitor();\n    const registry = manager.getRegistry();\n    verifyInvariants2(monitor);\n    const targetIds = getDroppableTargets(monitor);\n    targetIds.forEach((targetId, index5) => {\n      const dropResult = determineDropResult(targetId, index5, registry, monitor);\n      const action = {\n        type: DROP,\n        payload: {\n          dropResult: _objectSpread4({}, options, dropResult)\n        }\n      };\n      manager.dispatch(action);\n    });\n  };\n}\nfunction verifyInvariants2(monitor) {\n  invariant(monitor.isDragging(), \"Cannot call drop while not dragging.\");\n  invariant(!monitor.didDrop(), \"Cannot call drop twice during one drag operation.\");\n}\nfunction determineDropResult(targetId, index5, registry, monitor) {\n  const target = registry.getTarget(targetId);\n  let dropResult = target ? target.drop(monitor, targetId) : void 0;\n  verifyDropResultType(dropResult);\n  if (typeof dropResult === \"undefined\") {\n    dropResult = index5 === 0 ? {} : monitor.getDropResult();\n  }\n  return dropResult;\n}\nfunction verifyDropResultType(dropResult) {\n  invariant(typeof dropResult === \"undefined\" || isObject5(dropResult), \"Drop result must either be an object or undefined.\");\n}\nfunction getDroppableTargets(monitor) {\n  const targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);\n  targetIds.reverse();\n  return targetIds;\n}\n\n// node_modules/dnd-core/dist/actions/dragDrop/endDrag.js\nfunction createEndDrag(manager) {\n  return function endDrag() {\n    const monitor = manager.getMonitor();\n    const registry = manager.getRegistry();\n    verifyIsDragging(monitor);\n    const sourceId = monitor.getSourceId();\n    if (sourceId != null) {\n      const source = registry.getSource(sourceId, true);\n      source.endDrag(monitor, sourceId);\n      registry.unpinSource();\n    }\n    return {\n      type: END_DRAG\n    };\n  };\n}\nfunction verifyIsDragging(monitor) {\n  invariant(monitor.isDragging(), \"Cannot call endDrag while not dragging.\");\n}\n\n// node_modules/dnd-core/dist/utils/matchesType.js\nfunction matchesType(targetType, draggedItemType) {\n  if (draggedItemType === null) {\n    return targetType === null;\n  }\n  return Array.isArray(targetType) ? targetType.some(\n    (t6) => t6 === draggedItemType\n  ) : targetType === draggedItemType;\n}\n\n// node_modules/dnd-core/dist/actions/dragDrop/hover.js\nfunction createHover(manager) {\n  return function hover(targetIdsArg, { clientOffset } = {}) {\n    verifyTargetIdsIsArray(targetIdsArg);\n    const targetIds = targetIdsArg.slice(0);\n    const monitor = manager.getMonitor();\n    const registry = manager.getRegistry();\n    const draggedItemType = monitor.getItemType();\n    removeNonMatchingTargetIds(targetIds, registry, draggedItemType);\n    checkInvariants(targetIds, monitor, registry);\n    hoverAllTargets(targetIds, monitor, registry);\n    return {\n      type: HOVER,\n      payload: {\n        targetIds,\n        clientOffset: clientOffset || null\n      }\n    };\n  };\n}\nfunction verifyTargetIdsIsArray(targetIdsArg) {\n  invariant(Array.isArray(targetIdsArg), \"Expected targetIds to be an array.\");\n}\nfunction checkInvariants(targetIds, monitor, registry) {\n  invariant(monitor.isDragging(), \"Cannot call hover while not dragging.\");\n  invariant(!monitor.didDrop(), \"Cannot call hover after drop.\");\n  for (let i5 = 0; i5 < targetIds.length; i5++) {\n    const targetId = targetIds[i5];\n    invariant(targetIds.lastIndexOf(targetId) === i5, \"Expected targetIds to be unique in the passed array.\");\n    const target = registry.getTarget(targetId);\n    invariant(target, \"Expected targetIds to be registered.\");\n  }\n}\nfunction removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {\n  for (let i5 = targetIds.length - 1; i5 >= 0; i5--) {\n    const targetId = targetIds[i5];\n    const targetType = registry.getTargetType(targetId);\n    if (!matchesType(targetType, draggedItemType)) {\n      targetIds.splice(i5, 1);\n    }\n  }\n}\nfunction hoverAllTargets(targetIds, monitor, registry) {\n  targetIds.forEach(function(targetId) {\n    const target = registry.getTarget(targetId);\n    target.hover(monitor, targetId);\n  });\n}\n\n// node_modules/dnd-core/dist/actions/dragDrop/publishDragSource.js\nfunction createPublishDragSource(manager) {\n  return function publishDragSource() {\n    const monitor = manager.getMonitor();\n    if (monitor.isDragging()) {\n      return {\n        type: PUBLISH_DRAG_SOURCE\n      };\n    }\n    return;\n  };\n}\n\n// node_modules/dnd-core/dist/actions/dragDrop/index.js\nfunction createDragDropActions(manager) {\n  return {\n    beginDrag: createBeginDrag(manager),\n    publishDragSource: createPublishDragSource(manager),\n    hover: createHover(manager),\n    drop: createDrop(manager),\n    endDrag: createEndDrag(manager)\n  };\n}\n\n// node_modules/dnd-core/dist/classes/DragDropManagerImpl.js\nvar DragDropManagerImpl = class {\n  receiveBackend(backend) {\n    this.backend = backend;\n  }\n  getMonitor() {\n    return this.monitor;\n  }\n  getBackend() {\n    return this.backend;\n  }\n  getRegistry() {\n    return this.monitor.registry;\n  }\n  getActions() {\n    const manager = this;\n    const { dispatch: dispatch2 } = this.store;\n    function bindActionCreator(actionCreator) {\n      return (...args) => {\n        const action = actionCreator.apply(manager, args);\n        if (typeof action !== \"undefined\") {\n          dispatch2(action);\n        }\n      };\n    }\n    const actions = createDragDropActions(this);\n    return Object.keys(actions).reduce((boundActions, key) => {\n      const action = actions[key];\n      boundActions[key] = bindActionCreator(action);\n      return boundActions;\n    }, {});\n  }\n  dispatch(action) {\n    this.store.dispatch(action);\n  }\n  constructor(store, monitor) {\n    this.isSetUp = false;\n    this.handleRefCountChange = () => {\n      const shouldSetUp = this.store.getState().refCount > 0;\n      if (this.backend) {\n        if (shouldSetUp && !this.isSetUp) {\n          this.backend.setup();\n          this.isSetUp = true;\n        } else if (!shouldSetUp && this.isSetUp) {\n          this.backend.teardown();\n          this.isSetUp = false;\n        }\n      }\n    };\n    this.store = store;\n    this.monitor = monitor;\n    store.subscribe(this.handleRefCountChange);\n  }\n};\n\n// node_modules/dnd-core/dist/utils/coords.js\nfunction add(a7, b4) {\n  return {\n    x: a7.x + b4.x,\n    y: a7.y + b4.y\n  };\n}\nfunction subtract(a7, b4) {\n  return {\n    x: a7.x - b4.x,\n    y: a7.y - b4.y\n  };\n}\nfunction getSourceClientOffset(state) {\n  const { clientOffset, initialClientOffset, initialSourceClientOffset } = state;\n  if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {\n    return null;\n  }\n  return subtract(add(clientOffset, initialSourceClientOffset), initialClientOffset);\n}\nfunction getDifferenceFromInitialOffset(state) {\n  const { clientOffset, initialClientOffset } = state;\n  if (!clientOffset || !initialClientOffset) {\n    return null;\n  }\n  return subtract(clientOffset, initialClientOffset);\n}\n\n// node_modules/dnd-core/dist/utils/dirtiness.js\nvar NONE = [];\nvar ALL = [];\nNONE.__IS_NONE__ = true;\nALL.__IS_ALL__ = true;\nfunction areDirty(dirtyIds, handlerIds) {\n  if (dirtyIds === NONE) {\n    return false;\n  }\n  if (dirtyIds === ALL || typeof handlerIds === \"undefined\") {\n    return true;\n  }\n  const commonIds = intersection(handlerIds, dirtyIds);\n  return commonIds.length > 0;\n}\n\n// node_modules/dnd-core/dist/classes/DragDropMonitorImpl.js\nvar DragDropMonitorImpl = class {\n  subscribeToStateChange(listener, options = {}) {\n    const { handlerIds } = options;\n    invariant(typeof listener === \"function\", \"listener must be a function.\");\n    invariant(typeof handlerIds === \"undefined\" || Array.isArray(handlerIds), \"handlerIds, when specified, must be an array of strings.\");\n    let prevStateId = this.store.getState().stateId;\n    const handleChange = () => {\n      const state = this.store.getState();\n      const currentStateId = state.stateId;\n      try {\n        const canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);\n        if (!canSkipListener) {\n          listener();\n        }\n      } finally {\n        prevStateId = currentStateId;\n      }\n    };\n    return this.store.subscribe(handleChange);\n  }\n  subscribeToOffsetChange(listener) {\n    invariant(typeof listener === \"function\", \"listener must be a function.\");\n    let previousState = this.store.getState().dragOffset;\n    const handleChange = () => {\n      const nextState = this.store.getState().dragOffset;\n      if (nextState === previousState) {\n        return;\n      }\n      previousState = nextState;\n      listener();\n    };\n    return this.store.subscribe(handleChange);\n  }\n  canDragSource(sourceId) {\n    if (!sourceId) {\n      return false;\n    }\n    const source = this.registry.getSource(sourceId);\n    invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);\n    if (this.isDragging()) {\n      return false;\n    }\n    return source.canDrag(this, sourceId);\n  }\n  canDropOnTarget(targetId) {\n    if (!targetId) {\n      return false;\n    }\n    const target = this.registry.getTarget(targetId);\n    invariant(target, `Expected to find a valid target. targetId=${targetId}`);\n    if (!this.isDragging() || this.didDrop()) {\n      return false;\n    }\n    const targetType = this.registry.getTargetType(targetId);\n    const draggedItemType = this.getItemType();\n    return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);\n  }\n  isDragging() {\n    return Boolean(this.getItemType());\n  }\n  isDraggingSource(sourceId) {\n    if (!sourceId) {\n      return false;\n    }\n    const source = this.registry.getSource(sourceId, true);\n    invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);\n    if (!this.isDragging() || !this.isSourcePublic()) {\n      return false;\n    }\n    const sourceType = this.registry.getSourceType(sourceId);\n    const draggedItemType = this.getItemType();\n    if (sourceType !== draggedItemType) {\n      return false;\n    }\n    return source.isDragging(this, sourceId);\n  }\n  isOverTarget(targetId, options = {\n    shallow: false\n  }) {\n    if (!targetId) {\n      return false;\n    }\n    const { shallow: shallow2 } = options;\n    if (!this.isDragging()) {\n      return false;\n    }\n    const targetType = this.registry.getTargetType(targetId);\n    const draggedItemType = this.getItemType();\n    if (draggedItemType && !matchesType(targetType, draggedItemType)) {\n      return false;\n    }\n    const targetIds = this.getTargetIds();\n    if (!targetIds.length) {\n      return false;\n    }\n    const index5 = targetIds.indexOf(targetId);\n    if (shallow2) {\n      return index5 === targetIds.length - 1;\n    } else {\n      return index5 > -1;\n    }\n  }\n  getItemType() {\n    return this.store.getState().dragOperation.itemType;\n  }\n  getItem() {\n    return this.store.getState().dragOperation.item;\n  }\n  getSourceId() {\n    return this.store.getState().dragOperation.sourceId;\n  }\n  getTargetIds() {\n    return this.store.getState().dragOperation.targetIds;\n  }\n  getDropResult() {\n    return this.store.getState().dragOperation.dropResult;\n  }\n  didDrop() {\n    return this.store.getState().dragOperation.didDrop;\n  }\n  isSourcePublic() {\n    return Boolean(this.store.getState().dragOperation.isSourcePublic);\n  }\n  getInitialClientOffset() {\n    return this.store.getState().dragOffset.initialClientOffset;\n  }\n  getInitialSourceClientOffset() {\n    return this.store.getState().dragOffset.initialSourceClientOffset;\n  }\n  getClientOffset() {\n    return this.store.getState().dragOffset.clientOffset;\n  }\n  getSourceClientOffset() {\n    return getSourceClientOffset(this.store.getState().dragOffset);\n  }\n  getDifferenceFromInitialOffset() {\n    return getDifferenceFromInitialOffset(this.store.getState().dragOffset);\n  }\n  constructor(store, registry) {\n    this.store = store;\n    this.registry = registry;\n  }\n};\n\n// node_modules/@react-dnd/asap/dist/makeRequestCall.js\nvar scope = typeof global !== \"undefined\" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\nfunction makeRequestCallFromTimer(callback) {\n  return function requestCall() {\n    const timeoutHandle = setTimeout(handleTimer, 0);\n    const intervalHandle = setInterval(handleTimer, 50);\n    function handleTimer() {\n      clearTimeout(timeoutHandle);\n      clearInterval(intervalHandle);\n      callback();\n    }\n  };\n}\nfunction makeRequestCallFromMutationObserver(callback) {\n  let toggle = 1;\n  const observer = new BrowserMutationObserver(callback);\n  const node = document.createTextNode(\"\");\n  observer.observe(node, {\n    characterData: true\n  });\n  return function requestCall() {\n    toggle = -toggle;\n    node.data = toggle;\n  };\n}\nvar makeRequestCall = typeof BrowserMutationObserver === \"function\" ? (\n  // reliably everywhere they are implemented.\n  // They are implemented in all modern browsers.\n  //\n  // - Android 4-4.3\n  // - Chrome 26-34\n  // - Firefox 14-29\n  // - Internet Explorer 11\n  // - iPad Safari 6-7.1\n  // - iPhone Safari 7-7.1\n  // - Safari 6-7\n  makeRequestCallFromMutationObserver\n) : (\n  // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n  // 11-12, and in web workers in many engines.\n  // Although message channels yield to any queued rendering and IO tasks, they\n  // would be better than imposing the 4ms delay of timers.\n  // However, they do not work reliably in Internet Explorer or Safari.\n  // Internet Explorer 10 is the only browser that has setImmediate but does\n  // not have MutationObservers.\n  // Although setImmediate yields to the browser's renderer, it would be\n  // preferrable to falling back to setTimeout since it does not have\n  // the minimum 4ms penalty.\n  // Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n  // Desktop to a lesser extent) that renders both setImmediate and\n  // MessageChannel useless for the purposes of ASAP.\n  // https://github.com/kriskowal/q/issues/396\n  // Timers are implemented universally.\n  // We fall back to timers in workers in most engines, and in foreground\n  // contexts in the following browsers.\n  // However, note that even this simple case requires nuances to operate in a\n  // broad spectrum of browsers.\n  //\n  // - Firefox 3-13\n  // - Internet Explorer 6-9\n  // - iPad Safari 4.3\n  // - Lynx 2.8.7\n  makeRequestCallFromTimer\n);\n\n// node_modules/@react-dnd/asap/dist/AsapQueue.js\nvar AsapQueue = class {\n  // Use the fastest means possible to execute a task in its own turn, with\n  // priority over other events including IO, animation, reflow, and redraw\n  // events in browsers.\n  //\n  // An exception thrown by a task will permanently interrupt the processing of\n  // subsequent tasks. The higher level `asap` function ensures that if an\n  // exception is thrown by a task, that the task queue will continue flushing as\n  // soon as possible, but if you use `rawAsap` directly, you are responsible to\n  // either ensure that no exceptions are thrown from your task, or to manually\n  // call `rawAsap.requestFlush` if an exception is thrown.\n  enqueueTask(task) {\n    const { queue: q2, requestFlush } = this;\n    if (!q2.length) {\n      requestFlush();\n      this.flushing = true;\n    }\n    q2[q2.length] = task;\n  }\n  constructor() {\n    this.queue = [];\n    this.pendingErrors = [];\n    this.flushing = false;\n    this.index = 0;\n    this.capacity = 1024;\n    this.flush = () => {\n      const { queue: q2 } = this;\n      while (this.index < q2.length) {\n        const currentIndex = this.index;\n        this.index++;\n        q2[currentIndex].call();\n        if (this.index > this.capacity) {\n          for (let scan = 0, newLength = q2.length - this.index; scan < newLength; scan++) {\n            q2[scan] = q2[scan + this.index];\n          }\n          q2.length -= this.index;\n          this.index = 0;\n        }\n      }\n      q2.length = 0;\n      this.index = 0;\n      this.flushing = false;\n    };\n    this.registerPendingError = (err) => {\n      this.pendingErrors.push(err);\n      this.requestErrorThrow();\n    };\n    this.requestFlush = makeRequestCall(this.flush);\n    this.requestErrorThrow = makeRequestCallFromTimer(() => {\n      if (this.pendingErrors.length) {\n        throw this.pendingErrors.shift();\n      }\n    });\n  }\n};\n\n// node_modules/@react-dnd/asap/dist/RawTask.js\nvar RawTask = class {\n  call() {\n    try {\n      this.task && this.task();\n    } catch (error) {\n      this.onError(error);\n    } finally {\n      this.task = null;\n      this.release(this);\n    }\n  }\n  constructor(onError, release2) {\n    this.onError = onError;\n    this.release = release2;\n    this.task = null;\n  }\n};\n\n// node_modules/@react-dnd/asap/dist/TaskFactory.js\nvar TaskFactory = class {\n  create(task) {\n    const tasks = this.freeTasks;\n    const t1 = tasks.length ? tasks.pop() : new RawTask(\n      this.onError,\n      (t6) => tasks[tasks.length] = t6\n    );\n    t1.task = task;\n    return t1;\n  }\n  constructor(onError) {\n    this.onError = onError;\n    this.freeTasks = [];\n  }\n};\n\n// node_modules/@react-dnd/asap/dist/asap.js\nvar asapQueue = new AsapQueue();\nvar taskFactory = new TaskFactory(asapQueue.registerPendingError);\nfunction asap(task) {\n  asapQueue.enqueueTask(taskFactory.create(task));\n}\n\n// node_modules/dnd-core/dist/actions/registry.js\nvar ADD_SOURCE = \"dnd-core/ADD_SOURCE\";\nvar ADD_TARGET = \"dnd-core/ADD_TARGET\";\nvar REMOVE_SOURCE = \"dnd-core/REMOVE_SOURCE\";\nvar REMOVE_TARGET = \"dnd-core/REMOVE_TARGET\";\nfunction addSource(sourceId) {\n  return {\n    type: ADD_SOURCE,\n    payload: {\n      sourceId\n    }\n  };\n}\nfunction addTarget(targetId) {\n  return {\n    type: ADD_TARGET,\n    payload: {\n      targetId\n    }\n  };\n}\nfunction removeSource(sourceId) {\n  return {\n    type: REMOVE_SOURCE,\n    payload: {\n      sourceId\n    }\n  };\n}\nfunction removeTarget(targetId) {\n  return {\n    type: REMOVE_TARGET,\n    payload: {\n      targetId\n    }\n  };\n}\n\n// node_modules/dnd-core/dist/contracts.js\nfunction validateSourceContract(source) {\n  invariant(typeof source.canDrag === \"function\", \"Expected canDrag to be a function.\");\n  invariant(typeof source.beginDrag === \"function\", \"Expected beginDrag to be a function.\");\n  invariant(typeof source.endDrag === \"function\", \"Expected endDrag to be a function.\");\n}\nfunction validateTargetContract(target) {\n  invariant(typeof target.canDrop === \"function\", \"Expected canDrop to be a function.\");\n  invariant(typeof target.hover === \"function\", \"Expected hover to be a function.\");\n  invariant(typeof target.drop === \"function\", \"Expected beginDrag to be a function.\");\n}\nfunction validateType(type, allowArray) {\n  if (allowArray && Array.isArray(type)) {\n    type.forEach(\n      (t6) => validateType(t6, false)\n    );\n    return;\n  }\n  invariant(typeof type === \"string\" || typeof type === \"symbol\", allowArray ? \"Type can only be a string, a symbol, or an array of either.\" : \"Type can only be a string or a symbol.\");\n}\n\n// node_modules/dnd-core/dist/interfaces.js\nvar HandlerRole;\n(function(HandlerRole2) {\n  HandlerRole2[\"SOURCE\"] = \"SOURCE\";\n  HandlerRole2[\"TARGET\"] = \"TARGET\";\n})(HandlerRole || (HandlerRole = {}));\n\n// node_modules/dnd-core/dist/utils/getNextUniqueId.js\nvar nextUniqueId = 0;\nfunction getNextUniqueId() {\n  return nextUniqueId++;\n}\n\n// node_modules/dnd-core/dist/classes/HandlerRegistryImpl.js\nfunction getNextHandlerId(role) {\n  const id = getNextUniqueId().toString();\n  switch (role) {\n    case HandlerRole.SOURCE:\n      return `S${id}`;\n    case HandlerRole.TARGET:\n      return `T${id}`;\n    default:\n      throw new Error(`Unknown Handler Role: ${role}`);\n  }\n}\nfunction parseRoleFromHandlerId(handlerId) {\n  switch (handlerId[0]) {\n    case \"S\":\n      return HandlerRole.SOURCE;\n    case \"T\":\n      return HandlerRole.TARGET;\n    default:\n      throw new Error(`Cannot parse handler ID: ${handlerId}`);\n  }\n}\nfunction mapContainsValue(map2, searchValue) {\n  const entries = map2.entries();\n  let isDone = false;\n  do {\n    const { done, value: [, value] } = entries.next();\n    if (value === searchValue) {\n      return true;\n    }\n    isDone = !!done;\n  } while (!isDone);\n  return false;\n}\nvar HandlerRegistryImpl = class {\n  addSource(type, source) {\n    validateType(type);\n    validateSourceContract(source);\n    const sourceId = this.addHandler(HandlerRole.SOURCE, type, source);\n    this.store.dispatch(addSource(sourceId));\n    return sourceId;\n  }\n  addTarget(type, target) {\n    validateType(type, true);\n    validateTargetContract(target);\n    const targetId = this.addHandler(HandlerRole.TARGET, type, target);\n    this.store.dispatch(addTarget(targetId));\n    return targetId;\n  }\n  containsHandler(handler) {\n    return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);\n  }\n  getSource(sourceId, includePinned = false) {\n    invariant(this.isSourceId(sourceId), \"Expected a valid source ID.\");\n    const isPinned = includePinned && sourceId === this.pinnedSourceId;\n    const source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);\n    return source;\n  }\n  getTarget(targetId) {\n    invariant(this.isTargetId(targetId), \"Expected a valid target ID.\");\n    return this.dropTargets.get(targetId);\n  }\n  getSourceType(sourceId) {\n    invariant(this.isSourceId(sourceId), \"Expected a valid source ID.\");\n    return this.types.get(sourceId);\n  }\n  getTargetType(targetId) {\n    invariant(this.isTargetId(targetId), \"Expected a valid target ID.\");\n    return this.types.get(targetId);\n  }\n  isSourceId(handlerId) {\n    const role = parseRoleFromHandlerId(handlerId);\n    return role === HandlerRole.SOURCE;\n  }\n  isTargetId(handlerId) {\n    const role = parseRoleFromHandlerId(handlerId);\n    return role === HandlerRole.TARGET;\n  }\n  removeSource(sourceId) {\n    invariant(this.getSource(sourceId), \"Expected an existing source.\");\n    this.store.dispatch(removeSource(sourceId));\n    asap(() => {\n      this.dragSources.delete(sourceId);\n      this.types.delete(sourceId);\n    });\n  }\n  removeTarget(targetId) {\n    invariant(this.getTarget(targetId), \"Expected an existing target.\");\n    this.store.dispatch(removeTarget(targetId));\n    this.dropTargets.delete(targetId);\n    this.types.delete(targetId);\n  }\n  pinSource(sourceId) {\n    const source = this.getSource(sourceId);\n    invariant(source, \"Expected an existing source.\");\n    this.pinnedSourceId = sourceId;\n    this.pinnedSource = source;\n  }\n  unpinSource() {\n    invariant(this.pinnedSource, \"No source is pinned at the time.\");\n    this.pinnedSourceId = null;\n    this.pinnedSource = null;\n  }\n  addHandler(role, type, handler) {\n    const id = getNextHandlerId(role);\n    this.types.set(id, type);\n    if (role === HandlerRole.SOURCE) {\n      this.dragSources.set(id, handler);\n    } else if (role === HandlerRole.TARGET) {\n      this.dropTargets.set(id, handler);\n    }\n    return id;\n  }\n  constructor(store) {\n    this.types = /* @__PURE__ */ new Map();\n    this.dragSources = /* @__PURE__ */ new Map();\n    this.dropTargets = /* @__PURE__ */ new Map();\n    this.pinnedSourceId = null;\n    this.pinnedSource = null;\n    this.store = store;\n  }\n};\n\n// node_modules/dnd-core/dist/utils/equality.js\nvar strictEquality = (a7, b4) => a7 === b4;\nfunction areCoordsEqual(offsetA, offsetB) {\n  if (!offsetA && !offsetB) {\n    return true;\n  } else if (!offsetA || !offsetB) {\n    return false;\n  } else {\n    return offsetA.x === offsetB.x && offsetA.y === offsetB.y;\n  }\n}\nfunction areArraysEqual(a7, b4, isEqual2 = strictEquality) {\n  if (a7.length !== b4.length) {\n    return false;\n  }\n  for (let i5 = 0; i5 < a7.length; ++i5) {\n    if (!isEqual2(a7[i5], b4[i5])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// node_modules/dnd-core/dist/reducers/dirtyHandlerIds.js\nfunction reduce(_state = NONE, action) {\n  switch (action.type) {\n    case HOVER:\n      break;\n    case ADD_SOURCE:\n    case ADD_TARGET:\n    case REMOVE_TARGET:\n    case REMOVE_SOURCE:\n      return NONE;\n    case BEGIN_DRAG:\n    case PUBLISH_DRAG_SOURCE:\n    case END_DRAG:\n    case DROP:\n    default:\n      return ALL;\n  }\n  const { targetIds = [], prevTargetIds = [] } = action.payload;\n  const result = xor(targetIds, prevTargetIds);\n  const didChange = result.length > 0 || !areArraysEqual(targetIds, prevTargetIds);\n  if (!didChange) {\n    return NONE;\n  }\n  const prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];\n  const innermostTargetId = targetIds[targetIds.length - 1];\n  if (prevInnermostTargetId !== innermostTargetId) {\n    if (prevInnermostTargetId) {\n      result.push(prevInnermostTargetId);\n    }\n    if (innermostTargetId) {\n      result.push(innermostTargetId);\n    }\n  }\n  return result;\n}\n\n// node_modules/dnd-core/dist/reducers/dragOffset.js\nfunction _defineProperty7(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _objectSpread5(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    var ownKeys5 = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === \"function\") {\n      ownKeys5 = ownKeys5.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n    ownKeys5.forEach(function(key) {\n      _defineProperty7(target, key, source[key]);\n    });\n  }\n  return target;\n}\nvar initialState = {\n  initialSourceClientOffset: null,\n  initialClientOffset: null,\n  clientOffset: null\n};\nfunction reduce2(state = initialState, action) {\n  const { payload } = action;\n  switch (action.type) {\n    case INIT_COORDS:\n    case BEGIN_DRAG:\n      return {\n        initialSourceClientOffset: payload.sourceClientOffset,\n        initialClientOffset: payload.clientOffset,\n        clientOffset: payload.clientOffset\n      };\n    case HOVER:\n      if (areCoordsEqual(state.clientOffset, payload.clientOffset)) {\n        return state;\n      }\n      return _objectSpread5({}, state, {\n        clientOffset: payload.clientOffset\n      });\n    case END_DRAG:\n    case DROP:\n      return initialState;\n    default:\n      return state;\n  }\n}\n\n// node_modules/dnd-core/dist/reducers/dragOperation.js\nfunction _defineProperty8(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _objectSpread6(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    var ownKeys5 = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === \"function\") {\n      ownKeys5 = ownKeys5.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n    ownKeys5.forEach(function(key) {\n      _defineProperty8(target, key, source[key]);\n    });\n  }\n  return target;\n}\nvar initialState2 = {\n  itemType: null,\n  item: null,\n  sourceId: null,\n  targetIds: [],\n  dropResult: null,\n  didDrop: false,\n  isSourcePublic: null\n};\nfunction reduce3(state = initialState2, action) {\n  const { payload } = action;\n  switch (action.type) {\n    case BEGIN_DRAG:\n      return _objectSpread6({}, state, {\n        itemType: payload.itemType,\n        item: payload.item,\n        sourceId: payload.sourceId,\n        isSourcePublic: payload.isSourcePublic,\n        dropResult: null,\n        didDrop: false\n      });\n    case PUBLISH_DRAG_SOURCE:\n      return _objectSpread6({}, state, {\n        isSourcePublic: true\n      });\n    case HOVER:\n      return _objectSpread6({}, state, {\n        targetIds: payload.targetIds\n      });\n    case REMOVE_TARGET:\n      if (state.targetIds.indexOf(payload.targetId) === -1) {\n        return state;\n      }\n      return _objectSpread6({}, state, {\n        targetIds: without(state.targetIds, payload.targetId)\n      });\n    case DROP:\n      return _objectSpread6({}, state, {\n        dropResult: payload.dropResult,\n        didDrop: true,\n        targetIds: []\n      });\n    case END_DRAG:\n      return _objectSpread6({}, state, {\n        itemType: null,\n        item: null,\n        sourceId: null,\n        dropResult: null,\n        didDrop: false,\n        isSourcePublic: null,\n        targetIds: []\n      });\n    default:\n      return state;\n  }\n}\n\n// node_modules/dnd-core/dist/reducers/refCount.js\nfunction reduce4(state = 0, action) {\n  switch (action.type) {\n    case ADD_SOURCE:\n    case ADD_TARGET:\n      return state + 1;\n    case REMOVE_SOURCE:\n    case REMOVE_TARGET:\n      return state - 1;\n    default:\n      return state;\n  }\n}\n\n// node_modules/dnd-core/dist/reducers/stateId.js\nfunction reduce5(state = 0) {\n  return state + 1;\n}\n\n// node_modules/dnd-core/dist/reducers/index.js\nfunction _defineProperty9(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _objectSpread7(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    var ownKeys5 = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === \"function\") {\n      ownKeys5 = ownKeys5.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n    ownKeys5.forEach(function(key) {\n      _defineProperty9(target, key, source[key]);\n    });\n  }\n  return target;\n}\nfunction reduce6(state = {}, action) {\n  return {\n    dirtyHandlerIds: reduce(state.dirtyHandlerIds, {\n      type: action.type,\n      payload: _objectSpread7({}, action.payload, {\n        prevTargetIds: get2(state, \"dragOperation.targetIds\", [])\n      })\n    }),\n    dragOffset: reduce2(state.dragOffset, action),\n    refCount: reduce4(state.refCount, action),\n    dragOperation: reduce3(state.dragOperation, action),\n    stateId: reduce5(state.stateId)\n  };\n}\n\n// node_modules/dnd-core/dist/createDragDropManager.js\nfunction createDragDropManager(backendFactory, globalContext = void 0, backendOptions = {}, debugMode = false) {\n  const store = makeStoreInstance(debugMode);\n  const monitor = new DragDropMonitorImpl(store, new HandlerRegistryImpl(store));\n  const manager = new DragDropManagerImpl(store, monitor);\n  const backend = backendFactory(manager, globalContext, backendOptions);\n  manager.receiveBackend(backend);\n  return manager;\n}\nfunction makeStoreInstance(debugMode) {\n  const reduxDevTools = typeof window !== \"undefined\" && window.__REDUX_DEVTOOLS_EXTENSION__;\n  return createStore4(reduce6, debugMode && reduxDevTools && reduxDevTools({\n    name: \"dnd-core\",\n    instanceId: \"dnd-core\"\n  }));\n}\n\n// node_modules/react-dnd/dist/core/DndProvider.js\nvar import_react12 = require(\"react\");\nfunction _objectWithoutProperties3(source, excluded) {\n  if (source == null)\n    return {};\n  var target = _objectWithoutPropertiesLoose3(source, excluded);\n  var key, i5;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i5 = 0; i5 < sourceSymbolKeys.length; i5++) {\n      key = sourceSymbolKeys[i5];\n      if (excluded.indexOf(key) >= 0)\n        continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key))\n        continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose3(source, excluded) {\n  if (source == null)\n    return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i5;\n  for (i5 = 0; i5 < sourceKeys.length; i5++) {\n    key = sourceKeys[i5];\n    if (excluded.indexOf(key) >= 0)\n      continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nvar refCount = 0;\nvar INSTANCE_SYM = Symbol.for(\"__REACT_DND_CONTEXT_INSTANCE__\");\nvar DndProvider = /* @__PURE__ */ (0, import_react12.memo)(function DndProvider2(_param) {\n  var { children } = _param, props = _objectWithoutProperties3(_param, [\n    \"children\"\n  ]);\n  const [manager, isGlobalInstance] = getDndContextValue(props);\n  (0, import_react12.useEffect)(() => {\n    if (isGlobalInstance) {\n      const context = getGlobalContext();\n      ++refCount;\n      return () => {\n        if (--refCount === 0) {\n          context[INSTANCE_SYM] = null;\n        }\n      };\n    }\n    return;\n  }, []);\n  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DndContext.Provider, {\n    value: manager,\n    children\n  });\n});\nfunction getDndContextValue(props) {\n  if (\"manager\" in props) {\n    const manager2 = {\n      dragDropManager: props.manager\n    };\n    return [\n      manager2,\n      false\n    ];\n  }\n  const manager = createSingletonDndContext(props.backend, props.context, props.options, props.debugMode);\n  const isGlobalInstance = !props.context;\n  return [\n    manager,\n    isGlobalInstance\n  ];\n}\nfunction createSingletonDndContext(backend, context = getGlobalContext(), options, debugMode) {\n  const ctx = context;\n  if (!ctx[INSTANCE_SYM]) {\n    ctx[INSTANCE_SYM] = {\n      dragDropManager: createDragDropManager(backend, context, options, debugMode)\n    };\n  }\n  return ctx[INSTANCE_SYM];\n}\nfunction getGlobalContext() {\n  return typeof global !== \"undefined\" ? global : window;\n}\n\n// node_modules/react-dnd/dist/hooks/useCollector.js\nvar import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);\nvar import_react14 = require(\"react\");\n\n// node_modules/react-dnd/dist/hooks/useIsomorphicLayoutEffect.js\nvar import_react13 = require(\"react\");\nvar useIsomorphicLayoutEffect2 = typeof window !== \"undefined\" ? import_react13.useLayoutEffect : import_react13.useEffect;\n\n// node_modules/react-dnd/dist/hooks/useCollector.js\nfunction useCollector(monitor, collect, onUpdate) {\n  const [collected, setCollected] = (0, import_react14.useState)(\n    () => collect(monitor)\n  );\n  const updateCollected = (0, import_react14.useCallback)(() => {\n    const nextValue = collect(monitor);\n    if (!(0, import_fast_deep_equal.default)(collected, nextValue)) {\n      setCollected(nextValue);\n      if (onUpdate) {\n        onUpdate();\n      }\n    }\n  }, [\n    collected,\n    monitor,\n    onUpdate\n  ]);\n  useIsomorphicLayoutEffect2(updateCollected);\n  return [\n    collected,\n    updateCollected\n  ];\n}\n\n// node_modules/react-dnd/dist/hooks/useMonitorOutput.js\nfunction useMonitorOutput(monitor, collect, onCollect) {\n  const [collected, updateCollected] = useCollector(monitor, collect, onCollect);\n  useIsomorphicLayoutEffect2(function subscribeToMonitorStateChange() {\n    const handlerId = monitor.getHandlerId();\n    if (handlerId == null) {\n      return;\n    }\n    return monitor.subscribeToStateChange(updateCollected, {\n      handlerIds: [\n        handlerId\n      ]\n    });\n  }, [\n    monitor,\n    updateCollected\n  ]);\n  return collected;\n}\n\n// node_modules/react-dnd/dist/hooks/useCollectedProps.js\nfunction useCollectedProps(collector, monitor, connector) {\n  return useMonitorOutput(\n    monitor,\n    collector || (() => ({})),\n    () => connector.reconnect()\n  );\n}\n\n// node_modules/react-dnd/dist/hooks/useOptionalFactory.js\nvar import_react15 = require(\"react\");\nfunction useOptionalFactory(arg, deps) {\n  const memoDeps = [\n    ...deps || []\n  ];\n  if (deps == null && typeof arg !== \"function\") {\n    memoDeps.push(arg);\n  }\n  return (0, import_react15.useMemo)(() => {\n    return typeof arg === \"function\" ? arg() : arg;\n  }, memoDeps);\n}\n\n// node_modules/react-dnd/dist/hooks/useDrag/connectors.js\nvar import_react16 = require(\"react\");\nfunction useConnectDragSource(connector) {\n  return (0, import_react16.useMemo)(\n    () => connector.hooks.dragSource(),\n    [\n      connector\n    ]\n  );\n}\nfunction useConnectDragPreview(connector) {\n  return (0, import_react16.useMemo)(\n    () => connector.hooks.dragPreview(),\n    [\n      connector\n    ]\n  );\n}\n\n// node_modules/react-dnd/dist/hooks/useDrag/useDragSourceConnector.js\nvar import_react19 = require(\"react\");\n\n// node_modules/react-dnd/dist/internals/DragSourceMonitorImpl.js\nvar isCallingCanDrag = false;\nvar isCallingIsDragging = false;\nvar DragSourceMonitorImpl = class {\n  receiveHandlerId(sourceId) {\n    this.sourceId = sourceId;\n  }\n  getHandlerId() {\n    return this.sourceId;\n  }\n  canDrag() {\n    invariant(!isCallingCanDrag, \"You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor\");\n    try {\n      isCallingCanDrag = true;\n      return this.internalMonitor.canDragSource(this.sourceId);\n    } finally {\n      isCallingCanDrag = false;\n    }\n  }\n  isDragging() {\n    if (!this.sourceId) {\n      return false;\n    }\n    invariant(!isCallingIsDragging, \"You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor\");\n    try {\n      isCallingIsDragging = true;\n      return this.internalMonitor.isDraggingSource(this.sourceId);\n    } finally {\n      isCallingIsDragging = false;\n    }\n  }\n  subscribeToStateChange(listener, options) {\n    return this.internalMonitor.subscribeToStateChange(listener, options);\n  }\n  isDraggingSource(sourceId) {\n    return this.internalMonitor.isDraggingSource(sourceId);\n  }\n  isOverTarget(targetId, options) {\n    return this.internalMonitor.isOverTarget(targetId, options);\n  }\n  getTargetIds() {\n    return this.internalMonitor.getTargetIds();\n  }\n  isSourcePublic() {\n    return this.internalMonitor.isSourcePublic();\n  }\n  getSourceId() {\n    return this.internalMonitor.getSourceId();\n  }\n  subscribeToOffsetChange(listener) {\n    return this.internalMonitor.subscribeToOffsetChange(listener);\n  }\n  canDragSource(sourceId) {\n    return this.internalMonitor.canDragSource(sourceId);\n  }\n  canDropOnTarget(targetId) {\n    return this.internalMonitor.canDropOnTarget(targetId);\n  }\n  getItemType() {\n    return this.internalMonitor.getItemType();\n  }\n  getItem() {\n    return this.internalMonitor.getItem();\n  }\n  getDropResult() {\n    return this.internalMonitor.getDropResult();\n  }\n  didDrop() {\n    return this.internalMonitor.didDrop();\n  }\n  getInitialClientOffset() {\n    return this.internalMonitor.getInitialClientOffset();\n  }\n  getInitialSourceClientOffset() {\n    return this.internalMonitor.getInitialSourceClientOffset();\n  }\n  getSourceClientOffset() {\n    return this.internalMonitor.getSourceClientOffset();\n  }\n  getClientOffset() {\n    return this.internalMonitor.getClientOffset();\n  }\n  getDifferenceFromInitialOffset() {\n    return this.internalMonitor.getDifferenceFromInitialOffset();\n  }\n  constructor(manager) {\n    this.sourceId = null;\n    this.internalMonitor = manager.getMonitor();\n  }\n};\n\n// node_modules/react-dnd/dist/internals/DropTargetMonitorImpl.js\nvar isCallingCanDrop = false;\nvar DropTargetMonitorImpl = class {\n  receiveHandlerId(targetId) {\n    this.targetId = targetId;\n  }\n  getHandlerId() {\n    return this.targetId;\n  }\n  subscribeToStateChange(listener, options) {\n    return this.internalMonitor.subscribeToStateChange(listener, options);\n  }\n  canDrop() {\n    if (!this.targetId) {\n      return false;\n    }\n    invariant(!isCallingCanDrop, \"You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor\");\n    try {\n      isCallingCanDrop = true;\n      return this.internalMonitor.canDropOnTarget(this.targetId);\n    } finally {\n      isCallingCanDrop = false;\n    }\n  }\n  isOver(options) {\n    if (!this.targetId) {\n      return false;\n    }\n    return this.internalMonitor.isOverTarget(this.targetId, options);\n  }\n  getItemType() {\n    return this.internalMonitor.getItemType();\n  }\n  getItem() {\n    return this.internalMonitor.getItem();\n  }\n  getDropResult() {\n    return this.internalMonitor.getDropResult();\n  }\n  didDrop() {\n    return this.internalMonitor.didDrop();\n  }\n  getInitialClientOffset() {\n    return this.internalMonitor.getInitialClientOffset();\n  }\n  getInitialSourceClientOffset() {\n    return this.internalMonitor.getInitialSourceClientOffset();\n  }\n  getSourceClientOffset() {\n    return this.internalMonitor.getSourceClientOffset();\n  }\n  getClientOffset() {\n    return this.internalMonitor.getClientOffset();\n  }\n  getDifferenceFromInitialOffset() {\n    return this.internalMonitor.getDifferenceFromInitialOffset();\n  }\n  constructor(manager) {\n    this.targetId = null;\n    this.internalMonitor = manager.getMonitor();\n  }\n};\n\n// node_modules/react-dnd/dist/internals/registration.js\nfunction registerTarget(type, target, manager) {\n  const registry = manager.getRegistry();\n  const targetId = registry.addTarget(type, target);\n  return [\n    targetId,\n    () => registry.removeTarget(targetId)\n  ];\n}\nfunction registerSource(type, source, manager) {\n  const registry = manager.getRegistry();\n  const sourceId = registry.addSource(type, source);\n  return [\n    sourceId,\n    () => registry.removeSource(sourceId)\n  ];\n}\n\n// node_modules/@react-dnd/shallowequal/dist/index.js\nfunction shallowEqual(objA, objB, compare, compareContext) {\n  let compareResult = compare ? compare.call(compareContext, objA, objB) : void 0;\n  if (compareResult !== void 0) {\n    return !!compareResult;\n  }\n  if (objA === objB) {\n    return true;\n  }\n  if (typeof objA !== \"object\" || !objA || typeof objB !== \"object\" || !objB) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n  const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);\n  for (let idx = 0; idx < keysA.length; idx++) {\n    const key = keysA[idx];\n    if (!bHasOwnProperty(key)) {\n      return false;\n    }\n    const valueA = objA[key];\n    const valueB = objB[key];\n    compareResult = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;\n    if (compareResult === false || compareResult === void 0 && valueA !== valueB) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// node_modules/react-dnd/dist/internals/isRef.js\nfunction isRef(obj) {\n  return (\n    // eslint-disable-next-line no-prototype-builtins\n    obj !== null && typeof obj === \"object\" && Object.prototype.hasOwnProperty.call(obj, \"current\")\n  );\n}\n\n// node_modules/react-dnd/dist/internals/wrapConnectorHooks.js\nvar import_react17 = require(\"react\");\nfunction throwIfCompositeComponentElement(element4) {\n  if (typeof element4.type === \"string\") {\n    return;\n  }\n  const displayName = element4.type.displayName || element4.type.name || \"the component\";\n  throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${displayName} into a <div>, or turn it into a drag source or a drop target itself.`);\n}\nfunction wrapHookToRecognizeElement(hook) {\n  return (elementOrNode = null, options = null) => {\n    if (!(0, import_react17.isValidElement)(elementOrNode)) {\n      const node = elementOrNode;\n      hook(node, options);\n      return node;\n    }\n    const element4 = elementOrNode;\n    throwIfCompositeComponentElement(element4);\n    const ref = options ? (node) => hook(node, options) : hook;\n    return cloneWithRef(element4, ref);\n  };\n}\nfunction wrapConnectorHooks(hooks) {\n  const wrappedHooks = {};\n  Object.keys(hooks).forEach((key) => {\n    const hook = hooks[key];\n    if (key.endsWith(\"Ref\")) {\n      wrappedHooks[key] = hooks[key];\n    } else {\n      const wrappedHook = wrapHookToRecognizeElement(hook);\n      wrappedHooks[key] = () => wrappedHook;\n    }\n  });\n  return wrappedHooks;\n}\nfunction setRef2(ref, node) {\n  if (typeof ref === \"function\") {\n    ref(node);\n  } else {\n    ref.current = node;\n  }\n}\nfunction cloneWithRef(element4, newRef) {\n  const previousRef = element4.ref;\n  invariant(typeof previousRef !== \"string\", \"Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs\");\n  if (!previousRef) {\n    return (0, import_react17.cloneElement)(element4, {\n      ref: newRef\n    });\n  } else {\n    return (0, import_react17.cloneElement)(element4, {\n      ref: (node) => {\n        setRef2(previousRef, node);\n        setRef2(newRef, node);\n      }\n    });\n  }\n}\n\n// node_modules/react-dnd/dist/internals/SourceConnector.js\nvar SourceConnector = class {\n  receiveHandlerId(newHandlerId) {\n    if (this.handlerId === newHandlerId) {\n      return;\n    }\n    this.handlerId = newHandlerId;\n    this.reconnect();\n  }\n  get connectTarget() {\n    return this.dragSource;\n  }\n  get dragSourceOptions() {\n    return this.dragSourceOptionsInternal;\n  }\n  set dragSourceOptions(options) {\n    this.dragSourceOptionsInternal = options;\n  }\n  get dragPreviewOptions() {\n    return this.dragPreviewOptionsInternal;\n  }\n  set dragPreviewOptions(options) {\n    this.dragPreviewOptionsInternal = options;\n  }\n  reconnect() {\n    const didChange = this.reconnectDragSource();\n    this.reconnectDragPreview(didChange);\n  }\n  reconnectDragSource() {\n    const dragSource = this.dragSource;\n    const didChange = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();\n    if (didChange) {\n      this.disconnectDragSource();\n    }\n    if (!this.handlerId) {\n      return didChange;\n    }\n    if (!dragSource) {\n      this.lastConnectedDragSource = dragSource;\n      return didChange;\n    }\n    if (didChange) {\n      this.lastConnectedHandlerId = this.handlerId;\n      this.lastConnectedDragSource = dragSource;\n      this.lastConnectedDragSourceOptions = this.dragSourceOptions;\n      this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, dragSource, this.dragSourceOptions);\n    }\n    return didChange;\n  }\n  reconnectDragPreview(forceDidChange = false) {\n    const dragPreview = this.dragPreview;\n    const didChange = forceDidChange || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();\n    if (didChange) {\n      this.disconnectDragPreview();\n    }\n    if (!this.handlerId) {\n      return;\n    }\n    if (!dragPreview) {\n      this.lastConnectedDragPreview = dragPreview;\n      return;\n    }\n    if (didChange) {\n      this.lastConnectedHandlerId = this.handlerId;\n      this.lastConnectedDragPreview = dragPreview;\n      this.lastConnectedDragPreviewOptions = this.dragPreviewOptions;\n      this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, dragPreview, this.dragPreviewOptions);\n    }\n  }\n  didHandlerIdChange() {\n    return this.lastConnectedHandlerId !== this.handlerId;\n  }\n  didConnectedDragSourceChange() {\n    return this.lastConnectedDragSource !== this.dragSource;\n  }\n  didConnectedDragPreviewChange() {\n    return this.lastConnectedDragPreview !== this.dragPreview;\n  }\n  didDragSourceOptionsChange() {\n    return !shallowEqual(this.lastConnectedDragSourceOptions, this.dragSourceOptions);\n  }\n  didDragPreviewOptionsChange() {\n    return !shallowEqual(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);\n  }\n  disconnectDragSource() {\n    if (this.dragSourceUnsubscribe) {\n      this.dragSourceUnsubscribe();\n      this.dragSourceUnsubscribe = void 0;\n    }\n  }\n  disconnectDragPreview() {\n    if (this.dragPreviewUnsubscribe) {\n      this.dragPreviewUnsubscribe();\n      this.dragPreviewUnsubscribe = void 0;\n      this.dragPreviewNode = null;\n      this.dragPreviewRef = null;\n    }\n  }\n  get dragSource() {\n    return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;\n  }\n  get dragPreview() {\n    return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;\n  }\n  clearDragSource() {\n    this.dragSourceNode = null;\n    this.dragSourceRef = null;\n  }\n  clearDragPreview() {\n    this.dragPreviewNode = null;\n    this.dragPreviewRef = null;\n  }\n  constructor(backend) {\n    this.hooks = wrapConnectorHooks({\n      dragSource: (node, options) => {\n        this.clearDragSource();\n        this.dragSourceOptions = options || null;\n        if (isRef(node)) {\n          this.dragSourceRef = node;\n        } else {\n          this.dragSourceNode = node;\n        }\n        this.reconnectDragSource();\n      },\n      dragPreview: (node, options) => {\n        this.clearDragPreview();\n        this.dragPreviewOptions = options || null;\n        if (isRef(node)) {\n          this.dragPreviewRef = node;\n        } else {\n          this.dragPreviewNode = node;\n        }\n        this.reconnectDragPreview();\n      }\n    });\n    this.handlerId = null;\n    this.dragSourceRef = null;\n    this.dragSourceOptionsInternal = null;\n    this.dragPreviewRef = null;\n    this.dragPreviewOptionsInternal = null;\n    this.lastConnectedHandlerId = null;\n    this.lastConnectedDragSource = null;\n    this.lastConnectedDragSourceOptions = null;\n    this.lastConnectedDragPreview = null;\n    this.lastConnectedDragPreviewOptions = null;\n    this.backend = backend;\n  }\n};\n\n// node_modules/react-dnd/dist/internals/TargetConnector.js\nvar TargetConnector = class {\n  get connectTarget() {\n    return this.dropTarget;\n  }\n  reconnect() {\n    const didChange = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();\n    if (didChange) {\n      this.disconnectDropTarget();\n    }\n    const dropTarget = this.dropTarget;\n    if (!this.handlerId) {\n      return;\n    }\n    if (!dropTarget) {\n      this.lastConnectedDropTarget = dropTarget;\n      return;\n    }\n    if (didChange) {\n      this.lastConnectedHandlerId = this.handlerId;\n      this.lastConnectedDropTarget = dropTarget;\n      this.lastConnectedDropTargetOptions = this.dropTargetOptions;\n      this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, dropTarget, this.dropTargetOptions);\n    }\n  }\n  receiveHandlerId(newHandlerId) {\n    if (newHandlerId === this.handlerId) {\n      return;\n    }\n    this.handlerId = newHandlerId;\n    this.reconnect();\n  }\n  get dropTargetOptions() {\n    return this.dropTargetOptionsInternal;\n  }\n  set dropTargetOptions(options) {\n    this.dropTargetOptionsInternal = options;\n  }\n  didHandlerIdChange() {\n    return this.lastConnectedHandlerId !== this.handlerId;\n  }\n  didDropTargetChange() {\n    return this.lastConnectedDropTarget !== this.dropTarget;\n  }\n  didOptionsChange() {\n    return !shallowEqual(this.lastConnectedDropTargetOptions, this.dropTargetOptions);\n  }\n  disconnectDropTarget() {\n    if (this.unsubscribeDropTarget) {\n      this.unsubscribeDropTarget();\n      this.unsubscribeDropTarget = void 0;\n    }\n  }\n  get dropTarget() {\n    return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;\n  }\n  clearDropTarget() {\n    this.dropTargetRef = null;\n    this.dropTargetNode = null;\n  }\n  constructor(backend) {\n    this.hooks = wrapConnectorHooks({\n      dropTarget: (node, options) => {\n        this.clearDropTarget();\n        this.dropTargetOptions = options;\n        if (isRef(node)) {\n          this.dropTargetRef = node;\n        } else {\n          this.dropTargetNode = node;\n        }\n        this.reconnect();\n      }\n    });\n    this.handlerId = null;\n    this.dropTargetRef = null;\n    this.dropTargetOptionsInternal = null;\n    this.lastConnectedHandlerId = null;\n    this.lastConnectedDropTarget = null;\n    this.lastConnectedDropTargetOptions = null;\n    this.backend = backend;\n  }\n};\n\n// node_modules/react-dnd/dist/hooks/useDragDropManager.js\nvar import_react18 = require(\"react\");\nfunction useDragDropManager() {\n  const { dragDropManager } = (0, import_react18.useContext)(DndContext);\n  invariant(dragDropManager != null, \"Expected drag drop context\");\n  return dragDropManager;\n}\n\n// node_modules/react-dnd/dist/hooks/useDrag/useDragSourceConnector.js\nfunction useDragSourceConnector(dragSourceOptions, dragPreviewOptions) {\n  const manager = useDragDropManager();\n  const connector = (0, import_react19.useMemo)(\n    () => new SourceConnector(manager.getBackend()),\n    [\n      manager\n    ]\n  );\n  useIsomorphicLayoutEffect2(() => {\n    connector.dragSourceOptions = dragSourceOptions || null;\n    connector.reconnect();\n    return () => connector.disconnectDragSource();\n  }, [\n    connector,\n    dragSourceOptions\n  ]);\n  useIsomorphicLayoutEffect2(() => {\n    connector.dragPreviewOptions = dragPreviewOptions || null;\n    connector.reconnect();\n    return () => connector.disconnectDragPreview();\n  }, [\n    connector,\n    dragPreviewOptions\n  ]);\n  return connector;\n}\n\n// node_modules/react-dnd/dist/hooks/useDrag/useDragSourceMonitor.js\nvar import_react20 = require(\"react\");\nfunction useDragSourceMonitor() {\n  const manager = useDragDropManager();\n  return (0, import_react20.useMemo)(\n    () => new DragSourceMonitorImpl(manager),\n    [\n      manager\n    ]\n  );\n}\n\n// node_modules/react-dnd/dist/hooks/useDrag/useDragSource.js\nvar import_react21 = require(\"react\");\n\n// node_modules/react-dnd/dist/hooks/useDrag/DragSourceImpl.js\nvar DragSourceImpl = class {\n  beginDrag() {\n    const spec = this.spec;\n    const monitor = this.monitor;\n    let result = null;\n    if (typeof spec.item === \"object\") {\n      result = spec.item;\n    } else if (typeof spec.item === \"function\") {\n      result = spec.item(monitor);\n    } else {\n      result = {};\n    }\n    return result !== null && result !== void 0 ? result : null;\n  }\n  canDrag() {\n    const spec = this.spec;\n    const monitor = this.monitor;\n    if (typeof spec.canDrag === \"boolean\") {\n      return spec.canDrag;\n    } else if (typeof spec.canDrag === \"function\") {\n      return spec.canDrag(monitor);\n    } else {\n      return true;\n    }\n  }\n  isDragging(globalMonitor, target) {\n    const spec = this.spec;\n    const monitor = this.monitor;\n    const { isDragging } = spec;\n    return isDragging ? isDragging(monitor) : target === globalMonitor.getSourceId();\n  }\n  endDrag() {\n    const spec = this.spec;\n    const monitor = this.monitor;\n    const connector = this.connector;\n    const { end: end2 } = spec;\n    if (end2) {\n      end2(monitor.getItem(), monitor);\n    }\n    connector.reconnect();\n  }\n  constructor(spec, monitor, connector) {\n    this.spec = spec;\n    this.monitor = monitor;\n    this.connector = connector;\n  }\n};\n\n// node_modules/react-dnd/dist/hooks/useDrag/useDragSource.js\nfunction useDragSource(spec, monitor, connector) {\n  const handler = (0, import_react21.useMemo)(\n    () => new DragSourceImpl(spec, monitor, connector),\n    [\n      monitor,\n      connector\n    ]\n  );\n  (0, import_react21.useEffect)(() => {\n    handler.spec = spec;\n  }, [\n    spec\n  ]);\n  return handler;\n}\n\n// node_modules/react-dnd/dist/hooks/useDrag/useDragType.js\nvar import_react22 = require(\"react\");\nfunction useDragType(spec) {\n  return (0, import_react22.useMemo)(() => {\n    const result = spec.type;\n    invariant(result != null, \"spec.type must be defined\");\n    return result;\n  }, [\n    spec\n  ]);\n}\n\n// node_modules/react-dnd/dist/hooks/useDrag/useRegisteredDragSource.js\nfunction useRegisteredDragSource(spec, monitor, connector) {\n  const manager = useDragDropManager();\n  const handler = useDragSource(spec, monitor, connector);\n  const itemType = useDragType(spec);\n  useIsomorphicLayoutEffect2(function registerDragSource() {\n    if (itemType != null) {\n      const [handlerId, unregister] = registerSource(itemType, handler, manager);\n      monitor.receiveHandlerId(handlerId);\n      connector.receiveHandlerId(handlerId);\n      return unregister;\n    }\n    return;\n  }, [\n    manager,\n    monitor,\n    connector,\n    handler,\n    itemType\n  ]);\n}\n\n// node_modules/react-dnd/dist/hooks/useDrag/useDrag.js\nfunction useDrag(specArg, deps) {\n  const spec = useOptionalFactory(specArg, deps);\n  invariant(!spec.begin, `useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)`);\n  const monitor = useDragSourceMonitor();\n  const connector = useDragSourceConnector(spec.options, spec.previewOptions);\n  useRegisteredDragSource(spec, monitor, connector);\n  return [\n    useCollectedProps(spec.collect, monitor, connector),\n    useConnectDragSource(connector),\n    useConnectDragPreview(connector)\n  ];\n}\n\n// node_modules/react-dnd/dist/hooks/useDrop/connectors.js\nvar import_react23 = require(\"react\");\nfunction useConnectDropTarget(connector) {\n  return (0, import_react23.useMemo)(\n    () => connector.hooks.dropTarget(),\n    [\n      connector\n    ]\n  );\n}\n\n// node_modules/react-dnd/dist/hooks/useDrop/useDropTargetConnector.js\nvar import_react24 = require(\"react\");\nfunction useDropTargetConnector(options) {\n  const manager = useDragDropManager();\n  const connector = (0, import_react24.useMemo)(\n    () => new TargetConnector(manager.getBackend()),\n    [\n      manager\n    ]\n  );\n  useIsomorphicLayoutEffect2(() => {\n    connector.dropTargetOptions = options || null;\n    connector.reconnect();\n    return () => connector.disconnectDropTarget();\n  }, [\n    options\n  ]);\n  return connector;\n}\n\n// node_modules/react-dnd/dist/hooks/useDrop/useDropTargetMonitor.js\nvar import_react25 = require(\"react\");\nfunction useDropTargetMonitor() {\n  const manager = useDragDropManager();\n  return (0, import_react25.useMemo)(\n    () => new DropTargetMonitorImpl(manager),\n    [\n      manager\n    ]\n  );\n}\n\n// node_modules/react-dnd/dist/hooks/useDrop/useAccept.js\nvar import_react26 = require(\"react\");\nfunction useAccept(spec) {\n  const { accept } = spec;\n  return (0, import_react26.useMemo)(() => {\n    invariant(spec.accept != null, \"accept must be defined\");\n    return Array.isArray(accept) ? accept : [\n      accept\n    ];\n  }, [\n    accept\n  ]);\n}\n\n// node_modules/react-dnd/dist/hooks/useDrop/useDropTarget.js\nvar import_react27 = require(\"react\");\n\n// node_modules/react-dnd/dist/hooks/useDrop/DropTargetImpl.js\nvar DropTargetImpl = class {\n  canDrop() {\n    const spec = this.spec;\n    const monitor = this.monitor;\n    return spec.canDrop ? spec.canDrop(monitor.getItem(), monitor) : true;\n  }\n  hover() {\n    const spec = this.spec;\n    const monitor = this.monitor;\n    if (spec.hover) {\n      spec.hover(monitor.getItem(), monitor);\n    }\n  }\n  drop() {\n    const spec = this.spec;\n    const monitor = this.monitor;\n    if (spec.drop) {\n      return spec.drop(monitor.getItem(), monitor);\n    }\n    return;\n  }\n  constructor(spec, monitor) {\n    this.spec = spec;\n    this.monitor = monitor;\n  }\n};\n\n// node_modules/react-dnd/dist/hooks/useDrop/useDropTarget.js\nfunction useDropTarget(spec, monitor) {\n  const dropTarget = (0, import_react27.useMemo)(\n    () => new DropTargetImpl(spec, monitor),\n    [\n      monitor\n    ]\n  );\n  (0, import_react27.useEffect)(() => {\n    dropTarget.spec = spec;\n  }, [\n    spec\n  ]);\n  return dropTarget;\n}\n\n// node_modules/react-dnd/dist/hooks/useDrop/useRegisteredDropTarget.js\nfunction useRegisteredDropTarget(spec, monitor, connector) {\n  const manager = useDragDropManager();\n  const dropTarget = useDropTarget(spec, monitor);\n  const accept = useAccept(spec);\n  useIsomorphicLayoutEffect2(function registerDropTarget() {\n    const [handlerId, unregister] = registerTarget(accept, dropTarget, manager);\n    monitor.receiveHandlerId(handlerId);\n    connector.receiveHandlerId(handlerId);\n    return unregister;\n  }, [\n    manager,\n    monitor,\n    dropTarget,\n    connector,\n    accept.map(\n      (a7) => a7.toString()\n    ).join(\"|\")\n  ]);\n}\n\n// node_modules/react-dnd/dist/hooks/useDrop/useDrop.js\nfunction useDrop(specArg, deps) {\n  const spec = useOptionalFactory(specArg, deps);\n  const monitor = useDropTargetMonitor();\n  const connector = useDropTargetConnector(spec.options);\n  useRegisteredDropTarget(spec, monitor, connector);\n  return [\n    useCollectedProps(spec.collect, monitor, connector),\n    useConnectDropTarget(connector)\n  ];\n}\n\n// node_modules/react-dnd-html5-backend/dist/utils/js_utils.js\nfunction memoize3(fn4) {\n  let result = null;\n  const memoized = () => {\n    if (result == null) {\n      result = fn4();\n    }\n    return result;\n  };\n  return memoized;\n}\nfunction without2(items, item) {\n  return items.filter(\n    (i5) => i5 !== item\n  );\n}\nfunction union(itemsA, itemsB) {\n  const set4 = /* @__PURE__ */ new Set();\n  const insertItem = (item) => set4.add(item);\n  itemsA.forEach(insertItem);\n  itemsB.forEach(insertItem);\n  const result = [];\n  set4.forEach(\n    (key) => result.push(key)\n  );\n  return result;\n}\n\n// node_modules/react-dnd-html5-backend/dist/EnterLeaveCounter.js\nvar EnterLeaveCounter = class {\n  enter(enteringNode) {\n    const previousLength = this.entered.length;\n    const isNodeEntered = (node) => this.isNodeInDocument(node) && (!node.contains || node.contains(enteringNode));\n    this.entered = union(this.entered.filter(isNodeEntered), [\n      enteringNode\n    ]);\n    return previousLength === 0 && this.entered.length > 0;\n  }\n  leave(leavingNode) {\n    const previousLength = this.entered.length;\n    this.entered = without2(this.entered.filter(this.isNodeInDocument), leavingNode);\n    return previousLength > 0 && this.entered.length === 0;\n  }\n  reset() {\n    this.entered = [];\n  }\n  constructor(isNodeInDocument) {\n    this.entered = [];\n    this.isNodeInDocument = isNodeInDocument;\n  }\n};\n\n// node_modules/react-dnd-html5-backend/dist/NativeDragSources/NativeDragSource.js\nvar NativeDragSource = class {\n  initializeExposedProperties() {\n    Object.keys(this.config.exposeProperties).forEach((property2) => {\n      Object.defineProperty(this.item, property2, {\n        configurable: true,\n        enumerable: true,\n        get() {\n          console.warn(`Browser doesn't allow reading \"${property2}\" until the drop event.`);\n          return null;\n        }\n      });\n    });\n  }\n  loadDataTransfer(dataTransfer) {\n    if (dataTransfer) {\n      const newProperties = {};\n      Object.keys(this.config.exposeProperties).forEach((property2) => {\n        const propertyFn = this.config.exposeProperties[property2];\n        if (propertyFn != null) {\n          newProperties[property2] = {\n            value: propertyFn(dataTransfer, this.config.matchesTypes),\n            configurable: true,\n            enumerable: true\n          };\n        }\n      });\n      Object.defineProperties(this.item, newProperties);\n    }\n  }\n  canDrag() {\n    return true;\n  }\n  beginDrag() {\n    return this.item;\n  }\n  isDragging(monitor, handle) {\n    return handle === monitor.getSourceId();\n  }\n  endDrag() {\n  }\n  constructor(config2) {\n    this.config = config2;\n    this.item = {};\n    this.initializeExposedProperties();\n  }\n};\n\n// node_modules/react-dnd-html5-backend/dist/NativeTypes.js\nvar NativeTypes_exports = {};\n__export(NativeTypes_exports, {\n  FILE: () => FILE,\n  HTML: () => HTML,\n  TEXT: () => TEXT,\n  URL: () => URL2\n});\nvar FILE = \"__NATIVE_FILE__\";\nvar URL2 = \"__NATIVE_URL__\";\nvar TEXT = \"__NATIVE_TEXT__\";\nvar HTML = \"__NATIVE_HTML__\";\n\n// node_modules/react-dnd-html5-backend/dist/NativeDragSources/getDataFromDataTransfer.js\nfunction getDataFromDataTransfer(dataTransfer, typesToTry, defaultValue) {\n  const result = typesToTry.reduce(\n    (resultSoFar, typeToTry) => resultSoFar || dataTransfer.getData(typeToTry),\n    \"\"\n  );\n  return result != null ? result : defaultValue;\n}\n\n// node_modules/react-dnd-html5-backend/dist/NativeDragSources/nativeTypesConfig.js\nvar nativeTypesConfig = {\n  [FILE]: {\n    exposeProperties: {\n      files: (dataTransfer) => Array.prototype.slice.call(dataTransfer.files),\n      items: (dataTransfer) => dataTransfer.items,\n      dataTransfer: (dataTransfer) => dataTransfer\n    },\n    matchesTypes: [\n      \"Files\"\n    ]\n  },\n  [HTML]: {\n    exposeProperties: {\n      html: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, \"\"),\n      dataTransfer: (dataTransfer) => dataTransfer\n    },\n    matchesTypes: [\n      \"Html\",\n      \"text/html\"\n    ]\n  },\n  [URL2]: {\n    exposeProperties: {\n      urls: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, \"\").split(\"\\n\"),\n      dataTransfer: (dataTransfer) => dataTransfer\n    },\n    matchesTypes: [\n      \"Url\",\n      \"text/uri-list\"\n    ]\n  },\n  [TEXT]: {\n    exposeProperties: {\n      text: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, \"\"),\n      dataTransfer: (dataTransfer) => dataTransfer\n    },\n    matchesTypes: [\n      \"Text\",\n      \"text/plain\"\n    ]\n  }\n};\n\n// node_modules/react-dnd-html5-backend/dist/NativeDragSources/index.js\nfunction createNativeDragSource(type, dataTransfer) {\n  const config2 = nativeTypesConfig[type];\n  if (!config2) {\n    throw new Error(`native type ${type} has no configuration`);\n  }\n  const result = new NativeDragSource(config2);\n  result.loadDataTransfer(dataTransfer);\n  return result;\n}\nfunction matchNativeItemType(dataTransfer) {\n  if (!dataTransfer) {\n    return null;\n  }\n  const dataTransferTypes = Array.prototype.slice.call(dataTransfer.types || []);\n  return Object.keys(nativeTypesConfig).filter((nativeItemType) => {\n    const typeConfig = nativeTypesConfig[nativeItemType];\n    if (!(typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.matchesTypes)) {\n      return false;\n    }\n    return typeConfig.matchesTypes.some(\n      (t6) => dataTransferTypes.indexOf(t6) > -1\n    );\n  })[0] || null;\n}\n\n// node_modules/react-dnd-html5-backend/dist/BrowserDetector.js\nvar isFirefox = memoize3(\n  () => /firefox/i.test(navigator.userAgent)\n);\nvar isSafari = memoize3(\n  () => Boolean(window.safari)\n);\n\n// node_modules/react-dnd-html5-backend/dist/MonotonicInterpolant.js\nvar MonotonicInterpolant = class {\n  interpolate(x4) {\n    const { xs, ys, c1s, c2s, c3s } = this;\n    let i5 = xs.length - 1;\n    if (x4 === xs[i5]) {\n      return ys[i5];\n    }\n    let low = 0;\n    let high = c3s.length - 1;\n    let mid;\n    while (low <= high) {\n      mid = Math.floor(0.5 * (low + high));\n      const xHere = xs[mid];\n      if (xHere < x4) {\n        low = mid + 1;\n      } else if (xHere > x4) {\n        high = mid - 1;\n      } else {\n        return ys[mid];\n      }\n    }\n    i5 = Math.max(0, high);\n    const diff = x4 - xs[i5];\n    const diffSq = diff * diff;\n    return ys[i5] + c1s[i5] * diff + c2s[i5] * diffSq + c3s[i5] * diff * diffSq;\n  }\n  constructor(xs, ys) {\n    const { length } = xs;\n    const indexes = [];\n    for (let i5 = 0; i5 < length; i5++) {\n      indexes.push(i5);\n    }\n    indexes.sort(\n      (a7, b4) => xs[a7] < xs[b4] ? -1 : 1\n    );\n    const dys = [];\n    const dxs = [];\n    const ms = [];\n    let dx;\n    let dy;\n    for (let i1 = 0; i1 < length - 1; i1++) {\n      dx = xs[i1 + 1] - xs[i1];\n      dy = ys[i1 + 1] - ys[i1];\n      dxs.push(dx);\n      dys.push(dy);\n      ms.push(dy / dx);\n    }\n    const c1s = [\n      ms[0]\n    ];\n    for (let i22 = 0; i22 < dxs.length - 1; i22++) {\n      const m22 = ms[i22];\n      const mNext = ms[i22 + 1];\n      if (m22 * mNext <= 0) {\n        c1s.push(0);\n      } else {\n        dx = dxs[i22];\n        const dxNext = dxs[i22 + 1];\n        const common = dx + dxNext;\n        c1s.push(3 * common / ((common + dxNext) / m22 + (common + dx) / mNext));\n      }\n    }\n    c1s.push(ms[ms.length - 1]);\n    const c2s = [];\n    const c3s = [];\n    let m4;\n    for (let i32 = 0; i32 < c1s.length - 1; i32++) {\n      m4 = ms[i32];\n      const c1 = c1s[i32];\n      const invDx = 1 / dxs[i32];\n      const common = c1 + c1s[i32 + 1] - m4 - m4;\n      c2s.push((m4 - c1 - common) * invDx);\n      c3s.push(common * invDx * invDx);\n    }\n    this.xs = xs;\n    this.ys = ys;\n    this.c1s = c1s;\n    this.c2s = c2s;\n    this.c3s = c3s;\n  }\n};\n\n// node_modules/react-dnd-html5-backend/dist/OffsetUtils.js\nvar ELEMENT_NODE = 1;\nfunction getNodeClientOffset(node) {\n  const el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;\n  if (!el) {\n    return null;\n  }\n  const { top: top2, left: left2 } = el.getBoundingClientRect();\n  return {\n    x: left2,\n    y: top2\n  };\n}\nfunction getEventClientOffset(e4) {\n  return {\n    x: e4.clientX,\n    y: e4.clientY\n  };\n}\nfunction isImageNode(node) {\n  var ref;\n  return node.nodeName === \"IMG\" && (isFirefox() || !((ref = document.documentElement) === null || ref === void 0 ? void 0 : ref.contains(node)));\n}\nfunction getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {\n  let dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;\n  let dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;\n  if (isSafari() && isImage) {\n    dragPreviewHeight /= window.devicePixelRatio;\n    dragPreviewWidth /= window.devicePixelRatio;\n  }\n  return {\n    dragPreviewWidth,\n    dragPreviewHeight\n  };\n}\nfunction getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {\n  const isImage = isImageNode(dragPreview);\n  const dragPreviewNode = isImage ? sourceNode : dragPreview;\n  const dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);\n  const offsetFromDragPreview = {\n    x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,\n    y: clientOffset.y - dragPreviewNodeOffsetFromClient.y\n  };\n  const { offsetWidth: sourceWidth, offsetHeight: sourceHeight } = sourceNode;\n  const { anchorX, anchorY } = anchorPoint;\n  const { dragPreviewWidth, dragPreviewHeight } = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight);\n  const calculateYOffset = () => {\n    const interpolantY = new MonotonicInterpolant([\n      0,\n      0.5,\n      1\n    ], [\n      // Dock to the top\n      offsetFromDragPreview.y,\n      offsetFromDragPreview.y / sourceHeight * dragPreviewHeight,\n      // Dock to the bottom\n      offsetFromDragPreview.y + dragPreviewHeight - sourceHeight\n    ]);\n    let y5 = interpolantY.interpolate(anchorY);\n    if (isSafari() && isImage) {\n      y5 += (window.devicePixelRatio - 1) * dragPreviewHeight;\n    }\n    return y5;\n  };\n  const calculateXOffset = () => {\n    const interpolantX = new MonotonicInterpolant([\n      0,\n      0.5,\n      1\n    ], [\n      // Dock to the left\n      offsetFromDragPreview.x,\n      offsetFromDragPreview.x / sourceWidth * dragPreviewWidth,\n      // Dock to the right\n      offsetFromDragPreview.x + dragPreviewWidth - sourceWidth\n    ]);\n    return interpolantX.interpolate(anchorX);\n  };\n  const { offsetX, offsetY } = offsetPoint;\n  const isManualOffsetX = offsetX === 0 || offsetX;\n  const isManualOffsetY = offsetY === 0 || offsetY;\n  return {\n    x: isManualOffsetX ? offsetX : calculateXOffset(),\n    y: isManualOffsetY ? offsetY : calculateYOffset()\n  };\n}\n\n// node_modules/react-dnd-html5-backend/dist/OptionsReader.js\nvar OptionsReader = class {\n  get window() {\n    if (this.globalContext) {\n      return this.globalContext;\n    } else if (typeof window !== \"undefined\") {\n      return window;\n    }\n    return void 0;\n  }\n  get document() {\n    var ref;\n    if ((ref = this.globalContext) === null || ref === void 0 ? void 0 : ref.document) {\n      return this.globalContext.document;\n    } else if (this.window) {\n      return this.window.document;\n    } else {\n      return void 0;\n    }\n  }\n  get rootElement() {\n    var ref;\n    return ((ref = this.optionsArgs) === null || ref === void 0 ? void 0 : ref.rootElement) || this.window;\n  }\n  constructor(globalContext, options) {\n    this.ownerDocument = null;\n    this.globalContext = globalContext;\n    this.optionsArgs = options;\n  }\n};\n\n// node_modules/react-dnd-html5-backend/dist/HTML5BackendImpl.js\nfunction _defineProperty10(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _objectSpread8(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = arguments[i5] != null ? arguments[i5] : {};\n    var ownKeys5 = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === \"function\") {\n      ownKeys5 = ownKeys5.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n    ownKeys5.forEach(function(key) {\n      _defineProperty10(target, key, source[key]);\n    });\n  }\n  return target;\n}\nvar HTML5BackendImpl = class {\n  /**\n  * Generate profiling statistics for the HTML5Backend.\n  */\n  profile() {\n    var ref, ref1;\n    return {\n      sourcePreviewNodes: this.sourcePreviewNodes.size,\n      sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n      sourceNodeOptions: this.sourceNodeOptions.size,\n      sourceNodes: this.sourceNodes.size,\n      dragStartSourceIds: ((ref = this.dragStartSourceIds) === null || ref === void 0 ? void 0 : ref.length) || 0,\n      dropTargetIds: this.dropTargetIds.length,\n      dragEnterTargetIds: this.dragEnterTargetIds.length,\n      dragOverTargetIds: ((ref1 = this.dragOverTargetIds) === null || ref1 === void 0 ? void 0 : ref1.length) || 0\n    };\n  }\n  // public for test\n  get window() {\n    return this.options.window;\n  }\n  get document() {\n    return this.options.document;\n  }\n  /**\n  * Get the root element to use for event subscriptions\n  */\n  get rootElement() {\n    return this.options.rootElement;\n  }\n  setup() {\n    const root5 = this.rootElement;\n    if (root5 === void 0) {\n      return;\n    }\n    if (root5.__isReactDndBackendSetUp) {\n      throw new Error(\"Cannot have two HTML5 backends at the same time.\");\n    }\n    root5.__isReactDndBackendSetUp = true;\n    this.addEventListeners(root5);\n  }\n  teardown() {\n    const root5 = this.rootElement;\n    if (root5 === void 0) {\n      return;\n    }\n    root5.__isReactDndBackendSetUp = false;\n    this.removeEventListeners(this.rootElement);\n    this.clearCurrentDragSourceNode();\n    if (this.asyncEndDragFrameId) {\n      var ref;\n      (ref = this.window) === null || ref === void 0 ? void 0 : ref.cancelAnimationFrame(this.asyncEndDragFrameId);\n    }\n  }\n  connectDragPreview(sourceId, node, options) {\n    this.sourcePreviewNodeOptions.set(sourceId, options);\n    this.sourcePreviewNodes.set(sourceId, node);\n    return () => {\n      this.sourcePreviewNodes.delete(sourceId);\n      this.sourcePreviewNodeOptions.delete(sourceId);\n    };\n  }\n  connectDragSource(sourceId, node, options) {\n    this.sourceNodes.set(sourceId, node);\n    this.sourceNodeOptions.set(sourceId, options);\n    const handleDragStart = (e4) => this.handleDragStart(e4, sourceId);\n    const handleSelectStart = (e4) => this.handleSelectStart(e4);\n    node.setAttribute(\"draggable\", \"true\");\n    node.addEventListener(\"dragstart\", handleDragStart);\n    node.addEventListener(\"selectstart\", handleSelectStart);\n    return () => {\n      this.sourceNodes.delete(sourceId);\n      this.sourceNodeOptions.delete(sourceId);\n      node.removeEventListener(\"dragstart\", handleDragStart);\n      node.removeEventListener(\"selectstart\", handleSelectStart);\n      node.setAttribute(\"draggable\", \"false\");\n    };\n  }\n  connectDropTarget(targetId, node) {\n    const handleDragEnter = (e4) => this.handleDragEnter(e4, targetId);\n    const handleDragOver = (e4) => this.handleDragOver(e4, targetId);\n    const handleDrop = (e4) => this.handleDrop(e4, targetId);\n    node.addEventListener(\"dragenter\", handleDragEnter);\n    node.addEventListener(\"dragover\", handleDragOver);\n    node.addEventListener(\"drop\", handleDrop);\n    return () => {\n      node.removeEventListener(\"dragenter\", handleDragEnter);\n      node.removeEventListener(\"dragover\", handleDragOver);\n      node.removeEventListener(\"drop\", handleDrop);\n    };\n  }\n  addEventListeners(target) {\n    if (!target.addEventListener) {\n      return;\n    }\n    target.addEventListener(\"dragstart\", this.handleTopDragStart);\n    target.addEventListener(\"dragstart\", this.handleTopDragStartCapture, true);\n    target.addEventListener(\"dragend\", this.handleTopDragEndCapture, true);\n    target.addEventListener(\"dragenter\", this.handleTopDragEnter);\n    target.addEventListener(\"dragenter\", this.handleTopDragEnterCapture, true);\n    target.addEventListener(\"dragleave\", this.handleTopDragLeaveCapture, true);\n    target.addEventListener(\"dragover\", this.handleTopDragOver);\n    target.addEventListener(\"dragover\", this.handleTopDragOverCapture, true);\n    target.addEventListener(\"drop\", this.handleTopDrop);\n    target.addEventListener(\"drop\", this.handleTopDropCapture, true);\n  }\n  removeEventListeners(target) {\n    if (!target.removeEventListener) {\n      return;\n    }\n    target.removeEventListener(\"dragstart\", this.handleTopDragStart);\n    target.removeEventListener(\"dragstart\", this.handleTopDragStartCapture, true);\n    target.removeEventListener(\"dragend\", this.handleTopDragEndCapture, true);\n    target.removeEventListener(\"dragenter\", this.handleTopDragEnter);\n    target.removeEventListener(\"dragenter\", this.handleTopDragEnterCapture, true);\n    target.removeEventListener(\"dragleave\", this.handleTopDragLeaveCapture, true);\n    target.removeEventListener(\"dragover\", this.handleTopDragOver);\n    target.removeEventListener(\"dragover\", this.handleTopDragOverCapture, true);\n    target.removeEventListener(\"drop\", this.handleTopDrop);\n    target.removeEventListener(\"drop\", this.handleTopDropCapture, true);\n  }\n  getCurrentSourceNodeOptions() {\n    const sourceId = this.monitor.getSourceId();\n    const sourceNodeOptions = this.sourceNodeOptions.get(sourceId);\n    return _objectSpread8({\n      dropEffect: this.altKeyPressed ? \"copy\" : \"move\"\n    }, sourceNodeOptions || {});\n  }\n  getCurrentDropEffect() {\n    if (this.isDraggingNativeItem()) {\n      return \"copy\";\n    }\n    return this.getCurrentSourceNodeOptions().dropEffect;\n  }\n  getCurrentSourcePreviewNodeOptions() {\n    const sourceId = this.monitor.getSourceId();\n    const sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId);\n    return _objectSpread8({\n      anchorX: 0.5,\n      anchorY: 0.5,\n      captureDraggingState: false\n    }, sourcePreviewNodeOptions || {});\n  }\n  isDraggingNativeItem() {\n    const itemType = this.monitor.getItemType();\n    return Object.keys(NativeTypes_exports).some(\n      (key) => NativeTypes_exports[key] === itemType\n    );\n  }\n  beginDragNativeItem(type, dataTransfer) {\n    this.clearCurrentDragSourceNode();\n    this.currentNativeSource = createNativeDragSource(type, dataTransfer);\n    this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);\n    this.actions.beginDrag([\n      this.currentNativeHandle\n    ]);\n  }\n  setCurrentDragSourceNode(node) {\n    this.clearCurrentDragSourceNode();\n    this.currentDragSourceNode = node;\n    const MOUSE_MOVE_TIMEOUT = 1e3;\n    this.mouseMoveTimeoutTimer = setTimeout(() => {\n      var ref;\n      return (ref = this.rootElement) === null || ref === void 0 ? void 0 : ref.addEventListener(\"mousemove\", this.endDragIfSourceWasRemovedFromDOM, true);\n    }, MOUSE_MOVE_TIMEOUT);\n  }\n  clearCurrentDragSourceNode() {\n    if (this.currentDragSourceNode) {\n      this.currentDragSourceNode = null;\n      if (this.rootElement) {\n        var ref;\n        (ref = this.window) === null || ref === void 0 ? void 0 : ref.clearTimeout(this.mouseMoveTimeoutTimer || void 0);\n        this.rootElement.removeEventListener(\"mousemove\", this.endDragIfSourceWasRemovedFromDOM, true);\n      }\n      this.mouseMoveTimeoutTimer = null;\n      return true;\n    }\n    return false;\n  }\n  handleDragStart(e4, sourceId) {\n    if (e4.defaultPrevented) {\n      return;\n    }\n    if (!this.dragStartSourceIds) {\n      this.dragStartSourceIds = [];\n    }\n    this.dragStartSourceIds.unshift(sourceId);\n  }\n  handleDragEnter(_e, targetId) {\n    this.dragEnterTargetIds.unshift(targetId);\n  }\n  handleDragOver(_e, targetId) {\n    if (this.dragOverTargetIds === null) {\n      this.dragOverTargetIds = [];\n    }\n    this.dragOverTargetIds.unshift(targetId);\n  }\n  handleDrop(_e, targetId) {\n    this.dropTargetIds.unshift(targetId);\n  }\n  constructor(manager, globalContext, options) {\n    this.sourcePreviewNodes = /* @__PURE__ */ new Map();\n    this.sourcePreviewNodeOptions = /* @__PURE__ */ new Map();\n    this.sourceNodes = /* @__PURE__ */ new Map();\n    this.sourceNodeOptions = /* @__PURE__ */ new Map();\n    this.dragStartSourceIds = null;\n    this.dropTargetIds = [];\n    this.dragEnterTargetIds = [];\n    this.currentNativeSource = null;\n    this.currentNativeHandle = null;\n    this.currentDragSourceNode = null;\n    this.altKeyPressed = false;\n    this.mouseMoveTimeoutTimer = null;\n    this.asyncEndDragFrameId = null;\n    this.dragOverTargetIds = null;\n    this.lastClientOffset = null;\n    this.hoverRafId = null;\n    this.getSourceClientOffset = (sourceId) => {\n      const source = this.sourceNodes.get(sourceId);\n      return source && getNodeClientOffset(source) || null;\n    };\n    this.endDragNativeItem = () => {\n      if (!this.isDraggingNativeItem()) {\n        return;\n      }\n      this.actions.endDrag();\n      if (this.currentNativeHandle) {\n        this.registry.removeSource(this.currentNativeHandle);\n      }\n      this.currentNativeHandle = null;\n      this.currentNativeSource = null;\n    };\n    this.isNodeInDocument = (node) => {\n      return Boolean(node && this.document && this.document.body && this.document.body.contains(node));\n    };\n    this.endDragIfSourceWasRemovedFromDOM = () => {\n      const node = this.currentDragSourceNode;\n      if (node == null || this.isNodeInDocument(node)) {\n        return;\n      }\n      if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {\n        this.actions.endDrag();\n      }\n      this.cancelHover();\n    };\n    this.scheduleHover = (dragOverTargetIds) => {\n      if (this.hoverRafId === null && typeof requestAnimationFrame !== \"undefined\") {\n        this.hoverRafId = requestAnimationFrame(() => {\n          if (this.monitor.isDragging()) {\n            this.actions.hover(dragOverTargetIds || [], {\n              clientOffset: this.lastClientOffset\n            });\n          }\n          this.hoverRafId = null;\n        });\n      }\n    };\n    this.cancelHover = () => {\n      if (this.hoverRafId !== null && typeof cancelAnimationFrame !== \"undefined\") {\n        cancelAnimationFrame(this.hoverRafId);\n        this.hoverRafId = null;\n      }\n    };\n    this.handleTopDragStartCapture = () => {\n      this.clearCurrentDragSourceNode();\n      this.dragStartSourceIds = [];\n    };\n    this.handleTopDragStart = (e4) => {\n      if (e4.defaultPrevented) {\n        return;\n      }\n      const { dragStartSourceIds } = this;\n      this.dragStartSourceIds = null;\n      const clientOffset = getEventClientOffset(e4);\n      if (this.monitor.isDragging()) {\n        this.actions.endDrag();\n        this.cancelHover();\n      }\n      this.actions.beginDrag(dragStartSourceIds || [], {\n        publishSource: false,\n        getSourceClientOffset: this.getSourceClientOffset,\n        clientOffset\n      });\n      const { dataTransfer } = e4;\n      const nativeType = matchNativeItemType(dataTransfer);\n      if (this.monitor.isDragging()) {\n        if (dataTransfer && typeof dataTransfer.setDragImage === \"function\") {\n          const sourceId = this.monitor.getSourceId();\n          const sourceNode = this.sourceNodes.get(sourceId);\n          const dragPreview = this.sourcePreviewNodes.get(sourceId) || sourceNode;\n          if (dragPreview) {\n            const { anchorX, anchorY, offsetX, offsetY } = this.getCurrentSourcePreviewNodeOptions();\n            const anchorPoint = {\n              anchorX,\n              anchorY\n            };\n            const offsetPoint = {\n              offsetX,\n              offsetY\n            };\n            const dragPreviewOffset = getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);\n            dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);\n          }\n        }\n        try {\n          dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.setData(\"application/json\", {});\n        } catch (err) {\n        }\n        this.setCurrentDragSourceNode(e4.target);\n        const { captureDraggingState } = this.getCurrentSourcePreviewNodeOptions();\n        if (!captureDraggingState) {\n          setTimeout(\n            () => this.actions.publishDragSource(),\n            0\n          );\n        } else {\n          this.actions.publishDragSource();\n        }\n      } else if (nativeType) {\n        this.beginDragNativeItem(nativeType);\n      } else if (dataTransfer && !dataTransfer.types && (e4.target && !e4.target.hasAttribute || !e4.target.hasAttribute(\"draggable\"))) {\n        return;\n      } else {\n        e4.preventDefault();\n      }\n    };\n    this.handleTopDragEndCapture = () => {\n      if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {\n        this.actions.endDrag();\n      }\n      this.cancelHover();\n    };\n    this.handleTopDragEnterCapture = (e4) => {\n      this.dragEnterTargetIds = [];\n      if (this.isDraggingNativeItem()) {\n        var ref;\n        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e4.dataTransfer);\n      }\n      const isFirstEnter = this.enterLeaveCounter.enter(e4.target);\n      if (!isFirstEnter || this.monitor.isDragging()) {\n        return;\n      }\n      const { dataTransfer } = e4;\n      const nativeType = matchNativeItemType(dataTransfer);\n      if (nativeType) {\n        this.beginDragNativeItem(nativeType, dataTransfer);\n      }\n    };\n    this.handleTopDragEnter = (e4) => {\n      const { dragEnterTargetIds } = this;\n      this.dragEnterTargetIds = [];\n      if (!this.monitor.isDragging()) {\n        return;\n      }\n      this.altKeyPressed = e4.altKey;\n      if (dragEnterTargetIds.length > 0) {\n        this.actions.hover(dragEnterTargetIds, {\n          clientOffset: getEventClientOffset(e4)\n        });\n      }\n      const canDrop = dragEnterTargetIds.some(\n        (targetId) => this.monitor.canDropOnTarget(targetId)\n      );\n      if (canDrop) {\n        e4.preventDefault();\n        if (e4.dataTransfer) {\n          e4.dataTransfer.dropEffect = this.getCurrentDropEffect();\n        }\n      }\n    };\n    this.handleTopDragOverCapture = (e4) => {\n      this.dragOverTargetIds = [];\n      if (this.isDraggingNativeItem()) {\n        var ref;\n        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e4.dataTransfer);\n      }\n    };\n    this.handleTopDragOver = (e4) => {\n      const { dragOverTargetIds } = this;\n      this.dragOverTargetIds = [];\n      if (!this.monitor.isDragging()) {\n        e4.preventDefault();\n        if (e4.dataTransfer) {\n          e4.dataTransfer.dropEffect = \"none\";\n        }\n        return;\n      }\n      this.altKeyPressed = e4.altKey;\n      this.lastClientOffset = getEventClientOffset(e4);\n      this.scheduleHover(dragOverTargetIds);\n      const canDrop = (dragOverTargetIds || []).some(\n        (targetId) => this.monitor.canDropOnTarget(targetId)\n      );\n      if (canDrop) {\n        e4.preventDefault();\n        if (e4.dataTransfer) {\n          e4.dataTransfer.dropEffect = this.getCurrentDropEffect();\n        }\n      } else if (this.isDraggingNativeItem()) {\n        e4.preventDefault();\n      } else {\n        e4.preventDefault();\n        if (e4.dataTransfer) {\n          e4.dataTransfer.dropEffect = \"none\";\n        }\n      }\n    };\n    this.handleTopDragLeaveCapture = (e4) => {\n      if (this.isDraggingNativeItem()) {\n        e4.preventDefault();\n      }\n      const isLastLeave = this.enterLeaveCounter.leave(e4.target);\n      if (!isLastLeave) {\n        return;\n      }\n      if (this.isDraggingNativeItem()) {\n        setTimeout(\n          () => this.endDragNativeItem(),\n          0\n        );\n      }\n      this.cancelHover();\n    };\n    this.handleTopDropCapture = (e4) => {\n      this.dropTargetIds = [];\n      if (this.isDraggingNativeItem()) {\n        var ref;\n        e4.preventDefault();\n        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e4.dataTransfer);\n      } else if (matchNativeItemType(e4.dataTransfer)) {\n        e4.preventDefault();\n      }\n      this.enterLeaveCounter.reset();\n    };\n    this.handleTopDrop = (e4) => {\n      const { dropTargetIds } = this;\n      this.dropTargetIds = [];\n      this.actions.hover(dropTargetIds, {\n        clientOffset: getEventClientOffset(e4)\n      });\n      this.actions.drop({\n        dropEffect: this.getCurrentDropEffect()\n      });\n      if (this.isDraggingNativeItem()) {\n        this.endDragNativeItem();\n      } else if (this.monitor.isDragging()) {\n        this.actions.endDrag();\n      }\n      this.cancelHover();\n    };\n    this.handleSelectStart = (e4) => {\n      const target = e4.target;\n      if (typeof target.dragDrop !== \"function\") {\n        return;\n      }\n      if (target.tagName === \"INPUT\" || target.tagName === \"SELECT\" || target.tagName === \"TEXTAREA\" || target.isContentEditable) {\n        return;\n      }\n      e4.preventDefault();\n      target.dragDrop();\n    };\n    this.options = new OptionsReader(globalContext, options);\n    this.actions = manager.getActions();\n    this.monitor = manager.getMonitor();\n    this.registry = manager.getRegistry();\n    this.enterLeaveCounter = new EnterLeaveCounter(this.isNodeInDocument);\n  }\n};\n\n// node_modules/react-dnd-html5-backend/dist/getEmptyImage.js\nvar emptyImage;\nfunction getEmptyImage() {\n  if (!emptyImage) {\n    emptyImage = new Image();\n    emptyImage.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n  }\n  return emptyImage;\n}\n\n// node_modules/react-dnd-html5-backend/dist/index.js\nvar HTML5Backend = function createBackend(manager, context, options) {\n  return new HTML5BackendImpl(manager, context, options);\n};\n\n// src/transform/ast-utils/getNodeAdditionalProperties.ts\nvar import_pick = __toESM(require_pick());\n\n// src/transform/ast-utils/mapAttributes.ts\nfunction removeTypeFromAttributes(attributes) {\n  if (attributes === void 0) {\n    return;\n  }\n  return Object.keys(attributes).reduce((accumulator, key) => {\n    const value = attributes[key];\n    if (value.type === \"string\") {\n      accumulator[key] = value.value;\n    }\n    return accumulator;\n  }, {});\n}\n\n// src/transform/ast-utils/getNodeAdditionalProperties.ts\nfunction getWikiASTAdditionalProperties(node) {\n  const result = {\n    ...(0, import_pick.default)(node, [\"orderedAttributes\", \"isBlock\"])\n  };\n  if (node.attributes !== void 0) {\n    result.attributes = removeTypeFromAttributes(node.attributes);\n    result[\"tw-attributes\"] = node.attributes;\n  }\n  return result;\n}\nfunction getSlatePlateASTAdditionalProperties(node) {\n  const result = {\n    ...(0, import_pick.default)(node, [\"orderedAttributes\", \"isBlock\"])\n  };\n  if (node[\"tw-attributes\"]) {\n    result.attributes = node[\"tw-attributes\"];\n  }\n  return result;\n}\n\n// src/transform/wikiast-util-from-slate-plate-ast/traverse.ts\nfunction convertNodes(builders4, nodes) {\n  if (nodes === void 0 || nodes.length === 0) {\n    return [];\n  }\n  return nodes.reduce((accumulator, node) => {\n    return [...accumulator, ...convertWikiAstNode(builders4, node)];\n  }, []);\n}\nfunction convertWikiAstNode(builders4, node) {\n  if (isText(node)) {\n    return [builders4.text(builders4, node)];\n  }\n  if (isElement2(node)) {\n    const builder = builders4[node.type];\n    if (typeof builder === \"function\") {\n      const builtSlateNodeOrNodes = builder(builders4, node);\n      return Array.isArray(builtSlateNodeOrNodes) ? builtSlateNodeOrNodes.map((child) => ({ ...getSlatePlateASTAdditionalProperties(node), ...child })) : [{ ...getSlatePlateASTAdditionalProperties(node), ...builtSlateNodeOrNodes }];\n    }\n  }\n  if (\"children\" in node) {\n    return convertNodes(builders4, node.children);\n  }\n  return [];\n}\n\n// node_modules/@udecode/plate-reset-node/dist/index.es.js\nfunction unwrapExports2(x4) {\n  return x4 && x4.__esModule && Object.prototype.hasOwnProperty.call(x4, \"default\") ? x4[\"default\"] : x4;\n}\nfunction createCommonjsModule4(fn4, module2) {\n  return module2 = { exports: {} }, fn4(module2, module2.exports), module2.exports;\n}\nvar lib2 = createCommonjsModule4(function(module2, exports2) {\n  Object.defineProperty(exports2, \"__esModule\", {\n    value: true\n  });\n  var IS_MAC = () => typeof window != \"undefined\" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n  var MODIFIERS = {\n    alt: \"altKey\",\n    control: \"ctrlKey\",\n    meta: \"metaKey\",\n    shift: \"shiftKey\"\n  };\n  var ALIASES = () => ({\n    add: \"+\",\n    break: \"pause\",\n    cmd: \"meta\",\n    command: \"meta\",\n    ctl: \"control\",\n    ctrl: \"control\",\n    del: \"delete\",\n    down: \"arrowdown\",\n    esc: \"escape\",\n    ins: \"insert\",\n    left: \"arrowleft\",\n    mod: IS_MAC() ? \"meta\" : \"control\",\n    opt: \"alt\",\n    option: \"alt\",\n    return: \"enter\",\n    right: \"arrowright\",\n    space: \" \",\n    spacebar: \" \",\n    up: \"arrowup\",\n    win: \"meta\",\n    windows: \"meta\"\n  });\n  var CODES = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    shift: 16,\n    control: 17,\n    alt: 18,\n    pause: 19,\n    capslock: 20,\n    escape: 27,\n    \" \": 32,\n    pageup: 33,\n    pagedown: 34,\n    end: 35,\n    home: 36,\n    arrowleft: 37,\n    arrowup: 38,\n    arrowright: 39,\n    arrowdown: 40,\n    insert: 45,\n    delete: 46,\n    meta: 91,\n    numlock: 144,\n    scrolllock: 145,\n    \";\": 186,\n    \"=\": 187,\n    \",\": 188,\n    \"-\": 189,\n    \".\": 190,\n    \"/\": 191,\n    \"`\": 192,\n    \"[\": 219,\n    \"\\\\\": 220,\n    \"]\": 221,\n    \"'\": 222\n  };\n  for (var f5 = 1; f5 < 20; f5++) {\n    CODES[\"f\" + f5] = 111 + f5;\n  }\n  function isHotkey9(hotkey, options, event) {\n    if (options && !(\"byKey\" in options)) {\n      event = options;\n      options = null;\n    }\n    if (!Array.isArray(hotkey)) {\n      hotkey = [hotkey];\n    }\n    var array = hotkey.map(function(string2) {\n      return parseHotkey(string2, options);\n    });\n    var check = function check2(e4) {\n      return array.some(function(object) {\n        return compareHotkey(object, e4);\n      });\n    };\n    var ret = event == null ? check : check(event);\n    return ret;\n  }\n  function isCodeHotkey(hotkey, event) {\n    return isHotkey9(hotkey, event);\n  }\n  function isKeyHotkey2(hotkey, event) {\n    return isHotkey9(hotkey, { byKey: true }, event);\n  }\n  function parseHotkey(hotkey, options) {\n    var byKey = options && options.byKey;\n    var ret = {};\n    hotkey = hotkey.replace(\"++\", \"+add\");\n    var values2 = hotkey.split(\"+\");\n    var length = values2.length;\n    for (var k3 in MODIFIERS) {\n      ret[MODIFIERS[k3]] = false;\n    }\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = void 0;\n    try {\n      for (var _iterator = values2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var value = _step.value;\n        var optional = value.endsWith(\"?\") && value.length > 1;\n        if (optional) {\n          value = value.slice(0, -1);\n        }\n        var name = toKeyName(value);\n        var modifier = MODIFIERS[name];\n        if (length === 1 || !modifier) {\n          if (byKey) {\n            ret.key = name;\n          } else {\n            ret.which = toKeyCode(value);\n          }\n        }\n        if (modifier) {\n          ret[modifier] = optional ? null : true;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    return ret;\n  }\n  function compareHotkey(object, event) {\n    for (var key in object) {\n      var expected = object[key];\n      var actual = void 0;\n      if (expected == null) {\n        continue;\n      }\n      if (key === \"key\" && event.key != null) {\n        actual = event.key.toLowerCase();\n      } else if (key === \"which\") {\n        actual = expected === 91 && event.which === 93 ? 91 : event.which;\n      } else {\n        actual = event[key];\n      }\n      if (actual == null && expected === false) {\n        continue;\n      }\n      if (actual !== expected) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function toKeyCode(name) {\n    name = toKeyName(name);\n    var code3 = CODES[name] || name.toUpperCase().charCodeAt(0);\n    return code3;\n  }\n  function toKeyName(name) {\n    name = name.toLowerCase();\n    name = ALIASES()[name] || name;\n    return name;\n  }\n  exports2.default = isHotkey9;\n  exports2.isHotkey = isHotkey9;\n  exports2.isCodeHotkey = isCodeHotkey;\n  exports2.isKeyHotkey = isKeyHotkey2;\n  exports2.parseHotkey = parseHotkey;\n  exports2.compareHotkey = compareHotkey;\n  exports2.toKeyCode = toKeyCode;\n  exports2.toKeyName = toKeyName;\n});\nvar isHotkey2 = unwrapExports2(lib2);\nlib2.isHotkey;\nlib2.isCodeHotkey;\nlib2.isKeyHotkey;\nlib2.parseHotkey;\nlib2.compareHotkey;\nlib2.toKeyCode;\nlib2.toKeyName;\nvar SIMULATE_BACKSPACE = {\n  key: \"\",\n  which: 8\n};\nvar onKeyDownResetNode = (editor, {\n  options: {\n    rules\n  }\n}) => (event) => {\n  let reset;\n  if (editor.selection && isCollapsed(editor.selection)) {\n    rules.forEach(({\n      types,\n      defaultType,\n      hotkey,\n      predicate,\n      onReset\n    }) => {\n      if (hotkey && isHotkey2(hotkey, event)) {\n        if (predicate(editor) && someNode(editor, {\n          match: {\n            type: types\n          }\n        })) {\n          var _event$preventDefault;\n          (_event$preventDefault = event.preventDefault) === null || _event$preventDefault === void 0 ? void 0 : _event$preventDefault.call(event);\n          setElements(editor, {\n            type: defaultType\n          });\n          if (onReset) {\n            onReset(editor);\n          }\n          reset = true;\n        }\n      }\n    });\n  }\n  return reset;\n};\nvar KEY_RESET_NODE = \"resetNode\";\nvar createResetNodePlugin = createPluginFactory({\n  key: KEY_RESET_NODE,\n  handlers: {\n    onKeyDown: onKeyDownResetNode\n  },\n  options: {\n    rules: []\n  }\n});\n\n// node_modules/@udecode/plate-list/dist/index.es.js\nvar isArray4 = Array.isArray;\nvar isArray_13 = isArray4;\nfunction castArray2() {\n  if (!arguments.length) {\n    return [];\n  }\n  var value = arguments[0];\n  return isArray_13(value) ? value : [value];\n}\nvar castArray_12 = castArray2;\nfunction unwrapExports3(x4) {\n  return x4 && x4.__esModule && Object.prototype.hasOwnProperty.call(x4, \"default\") ? x4[\"default\"] : x4;\n}\nfunction createCommonjsModule5(fn4, module2) {\n  return module2 = { exports: {} }, fn4(module2, module2.exports), module2.exports;\n}\nvar lib3 = createCommonjsModule5(function(module2, exports2) {\n  Object.defineProperty(exports2, \"__esModule\", {\n    value: true\n  });\n  var IS_MAC = () => typeof window != \"undefined\" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n  var MODIFIERS = {\n    alt: \"altKey\",\n    control: \"ctrlKey\",\n    meta: \"metaKey\",\n    shift: \"shiftKey\"\n  };\n  var ALIASES = () => ({\n    add: \"+\",\n    break: \"pause\",\n    cmd: \"meta\",\n    command: \"meta\",\n    ctl: \"control\",\n    ctrl: \"control\",\n    del: \"delete\",\n    down: \"arrowdown\",\n    esc: \"escape\",\n    ins: \"insert\",\n    left: \"arrowleft\",\n    mod: IS_MAC() ? \"meta\" : \"control\",\n    opt: \"alt\",\n    option: \"alt\",\n    return: \"enter\",\n    right: \"arrowright\",\n    space: \" \",\n    spacebar: \" \",\n    up: \"arrowup\",\n    win: \"meta\",\n    windows: \"meta\"\n  });\n  var CODES = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    shift: 16,\n    control: 17,\n    alt: 18,\n    pause: 19,\n    capslock: 20,\n    escape: 27,\n    \" \": 32,\n    pageup: 33,\n    pagedown: 34,\n    end: 35,\n    home: 36,\n    arrowleft: 37,\n    arrowup: 38,\n    arrowright: 39,\n    arrowdown: 40,\n    insert: 45,\n    delete: 46,\n    meta: 91,\n    numlock: 144,\n    scrolllock: 145,\n    \";\": 186,\n    \"=\": 187,\n    \",\": 188,\n    \"-\": 189,\n    \".\": 190,\n    \"/\": 191,\n    \"`\": 192,\n    \"[\": 219,\n    \"\\\\\": 220,\n    \"]\": 221,\n    \"'\": 222\n  };\n  for (var f5 = 1; f5 < 20; f5++) {\n    CODES[\"f\" + f5] = 111 + f5;\n  }\n  function isHotkey9(hotkey, options, event) {\n    if (options && !(\"byKey\" in options)) {\n      event = options;\n      options = null;\n    }\n    if (!Array.isArray(hotkey)) {\n      hotkey = [hotkey];\n    }\n    var array = hotkey.map(function(string2) {\n      return parseHotkey(string2, options);\n    });\n    var check = function check2(e4) {\n      return array.some(function(object) {\n        return compareHotkey(object, e4);\n      });\n    };\n    var ret = event == null ? check : check(event);\n    return ret;\n  }\n  function isCodeHotkey(hotkey, event) {\n    return isHotkey9(hotkey, event);\n  }\n  function isKeyHotkey2(hotkey, event) {\n    return isHotkey9(hotkey, { byKey: true }, event);\n  }\n  function parseHotkey(hotkey, options) {\n    var byKey = options && options.byKey;\n    var ret = {};\n    hotkey = hotkey.replace(\"++\", \"+add\");\n    var values2 = hotkey.split(\"+\");\n    var length = values2.length;\n    for (var k3 in MODIFIERS) {\n      ret[MODIFIERS[k3]] = false;\n    }\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = void 0;\n    try {\n      for (var _iterator = values2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var value = _step.value;\n        var optional = value.endsWith(\"?\") && value.length > 1;\n        if (optional) {\n          value = value.slice(0, -1);\n        }\n        var name = toKeyName(value);\n        var modifier = MODIFIERS[name];\n        if (length === 1 || !modifier) {\n          if (byKey) {\n            ret.key = name;\n          } else {\n            ret.which = toKeyCode(value);\n          }\n        }\n        if (modifier) {\n          ret[modifier] = optional ? null : true;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    return ret;\n  }\n  function compareHotkey(object, event) {\n    for (var key in object) {\n      var expected = object[key];\n      var actual = void 0;\n      if (expected == null) {\n        continue;\n      }\n      if (key === \"key\" && event.key != null) {\n        actual = event.key.toLowerCase();\n      } else if (key === \"which\") {\n        actual = expected === 91 && event.which === 93 ? 91 : event.which;\n      } else {\n        actual = event[key];\n      }\n      if (actual == null && expected === false) {\n        continue;\n      }\n      if (actual !== expected) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function toKeyCode(name) {\n    name = toKeyName(name);\n    var code3 = CODES[name] || name.toUpperCase().charCodeAt(0);\n    return code3;\n  }\n  function toKeyName(name) {\n    name = name.toLowerCase();\n    name = ALIASES()[name] || name;\n    return name;\n  }\n  exports2.default = isHotkey9;\n  exports2.isHotkey = isHotkey9;\n  exports2.isCodeHotkey = isCodeHotkey;\n  exports2.isKeyHotkey = isKeyHotkey2;\n  exports2.parseHotkey = parseHotkey;\n  exports2.compareHotkey = compareHotkey;\n  exports2.toKeyCode = toKeyCode;\n  exports2.toKeyName = toKeyName;\n});\nvar isHotkey3 = unwrapExports3(lib3);\nlib3.isHotkey;\nlib3.isCodeHotkey;\nlib3.isKeyHotkey;\nlib3.parseHotkey;\nlib3.compareHotkey;\nlib3.toKeyCode;\nlib3.toKeyName;\nvar isListNested = (editor, listPath) => {\n  var _getParentNode;\n  const listParentNode = (_getParentNode = getParentNode(editor, listPath)) === null || _getParentNode === void 0 ? void 0 : _getParentNode[0];\n  return (listParentNode === null || listParentNode === void 0 ? void 0 : listParentNode.type) === getPluginType(editor, ELEMENT_LI);\n};\nvar getUnorderedListType = (editor) => {\n  return getPluginType(editor, ELEMENT_UL);\n};\nvar getOrderedListType = (editor) => {\n  return getPluginType(editor, ELEMENT_OL);\n};\nvar getListTypes = (editor) => {\n  return [getOrderedListType(editor), getUnorderedListType(editor)];\n};\nvar getListItemType = (editor) => {\n  return getPluginType(editor, ELEMENT_LI);\n};\nvar getListItemContentType = (editor) => {\n  return getPluginType(editor, ELEMENT_LIC);\n};\nvar getHighestEmptyList = (editor, {\n  diffListPath,\n  liPath\n}) => {\n  const list = getAboveNode(editor, {\n    at: liPath,\n    match: {\n      type: getListTypes(editor)\n    }\n  });\n  if (!list)\n    return;\n  const [listNode, listPath] = list;\n  if (!diffListPath || !Path.equals(listPath, diffListPath)) {\n    if (listNode.children.length < 2) {\n      const liParent = getAboveNode(editor, {\n        at: listPath,\n        match: {\n          type: getPluginType(editor, ELEMENT_LI)\n        }\n      });\n      if (liParent) {\n        return getHighestEmptyList(editor, {\n          liPath: liParent[1],\n          diffListPath\n        }) || listPath;\n      }\n    }\n    return liPath;\n  }\n};\nvar getListItemEntry = (editor, {\n  at = editor.selection\n} = {}) => {\n  const liType = getPluginType(editor, ELEMENT_LI);\n  let _at;\n  if (Range.isRange(at) && !isCollapsed(at)) {\n    _at = at.focus.path;\n  } else if (Range.isRange(at)) {\n    _at = at.anchor.path;\n  } else {\n    _at = at;\n  }\n  if (_at) {\n    const node = getNode(editor, _at);\n    if (node) {\n      const listItem = getAboveNode(editor, {\n        at: _at,\n        match: {\n          type: liType\n        }\n      });\n      if (listItem) {\n        const list = getParentNode(editor, listItem[1]);\n        return {\n          list,\n          listItem\n        };\n      }\n    }\n  }\n};\nvar getListRoot = (editor, at = editor.selection) => {\n  if (!at)\n    return;\n  const parentList = getAboveNode(editor, {\n    at,\n    match: {\n      type: [getPluginType(editor, ELEMENT_UL), getPluginType(editor, ELEMENT_OL)]\n    }\n  });\n  if (parentList) {\n    var _getListRoot;\n    const [, parentListPath] = parentList;\n    return (_getListRoot = getListRoot(editor, parentListPath)) !== null && _getListRoot !== void 0 ? _getListRoot : parentList;\n  }\n};\nvar hasListChild = (editor, node) => node.children.some((n8) => match(n8, [], {\n  type: getListTypes(editor)\n}));\nvar isAcrossListItems = (editor) => {\n  const {\n    selection\n  } = editor;\n  if (!selection || isCollapsed(selection)) {\n    return false;\n  }\n  const isAcrossBlocks = isRangeAcrossBlocks(editor);\n  if (!isAcrossBlocks)\n    return false;\n  return someNode(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_LI)\n    }\n  });\n};\nvar isListRoot = (editor, node) => isElement2(node) && getListTypes(editor).includes(node.type);\nvar moveListItemDown = (editor, {\n  list,\n  listItem\n}) => {\n  const [listNode] = list;\n  const [, listItemPath] = listItem;\n  let previousListItemPath;\n  try {\n    previousListItemPath = Path.previous(listItemPath);\n  } catch (e4) {\n    return;\n  }\n  const previousSiblingItem = getNodeEntry(editor, previousListItemPath);\n  if (previousSiblingItem) {\n    const [previousNode, previousPath] = previousSiblingItem;\n    const sublist = previousNode.children.find((n8) => match(n8, [], {\n      type: getListTypes(editor)\n    }));\n    const newPath = previousPath.concat(sublist ? [1, sublist.children.length] : [1]);\n    withoutNormalizing(editor, () => {\n      if (!sublist) {\n        wrapNodes(editor, {\n          type: listNode.type,\n          children: []\n        }, {\n          at: listItemPath\n        });\n      }\n      moveNodes(editor, {\n        at: listItemPath,\n        to: newPath\n      });\n    });\n  }\n};\nvar moveListItemsToList = (editor, {\n  fromList,\n  fromListItem,\n  fromStartIndex,\n  to: _to,\n  toList,\n  toListIndex = null,\n  deleteFromList = true\n}) => {\n  let fromListPath;\n  let moved;\n  withoutNormalizing(editor, () => {\n    if (fromListItem) {\n      const fromListItemSublist = findDescendant(editor, {\n        at: fromListItem[1],\n        match: {\n          type: getListTypes(editor)\n        }\n      });\n      if (!fromListItemSublist)\n        return;\n      fromListPath = fromListItemSublist === null || fromListItemSublist === void 0 ? void 0 : fromListItemSublist[1];\n    } else if (fromList) {\n      fromListPath = fromList[1];\n    } else {\n      return;\n    }\n    let to = null;\n    if (_to)\n      to = _to;\n    if (toList) {\n      if (toListIndex !== null)\n        to = toList[1].concat([toListIndex]);\n      else {\n        const lastChildPath = getLastChildPath(toList);\n        to = Path.next(lastChildPath);\n      }\n    }\n    if (!to)\n      return;\n    moved = moveChildren(editor, {\n      at: fromListPath,\n      to,\n      fromStartIndex\n    });\n    if (deleteFromList) {\n      deleteText(editor, {\n        at: fromListPath\n      });\n    }\n  });\n  return moved;\n};\nvar unwrapList = (editor, {\n  at\n} = {}) => {\n  const ancestorListTypeCheck = () => {\n    if (getAboveNode(editor, {\n      match: {\n        type: getListTypes(editor),\n        at\n      }\n    })) {\n      return true;\n    }\n    if (!at && editor.selection) {\n      const commonNode = getCommonNode(editor, editor.selection.anchor.path, editor.selection.focus.path);\n      if (isElement2(commonNode[0]) && getListTypes(editor).includes(commonNode[0].type)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  withoutNormalizing(editor, () => {\n    do {\n      setElements(editor, {\n        type: getPluginType(editor, ELEMENT_DEFAULT)\n      });\n      unwrapNodes(editor, {\n        at,\n        match: {\n          type: getPluginType(editor, ELEMENT_LI)\n        },\n        split: true\n      });\n      unwrapNodes(editor, {\n        at,\n        match: {\n          type: [getPluginType(editor, ELEMENT_UL), getPluginType(editor, ELEMENT_OL)]\n        },\n        split: true\n      });\n    } while (ancestorListTypeCheck());\n  });\n};\nvar moveListItemUp = (editor, {\n  list,\n  listItem\n}) => {\n  const move = () => {\n    const [listNode, listPath] = list;\n    const [liNode, liPath] = listItem;\n    const liParent = getAboveNode(editor, {\n      at: listPath,\n      match: {\n        type: getPluginType(editor, ELEMENT_LI)\n      }\n    });\n    if (!liParent) {\n      let toListPath2;\n      try {\n        toListPath2 = Path.next(listPath);\n      } catch (err) {\n        return;\n      }\n      const condA = hasListChild(editor, liNode);\n      const condB = !isLastChild(list, liPath);\n      if (condA || condB) {\n        insertElements(editor, {\n          type: listNode.type,\n          children: []\n        }, {\n          at: toListPath2\n        });\n      }\n      if (condA) {\n        const toListNode = getNode(editor, toListPath2);\n        if (!toListNode)\n          return;\n        moveListItemsToList(editor, {\n          fromListItem: listItem,\n          toList: [toListNode, toListPath2]\n        });\n      }\n      if (condB) {\n        const toListNode = getNode(editor, toListPath2);\n        if (!toListNode)\n          return;\n        moveListItemsToList(editor, {\n          fromList: list,\n          fromStartIndex: liPath[liPath.length - 1] + 1,\n          toList: [toListNode, toListPath2],\n          deleteFromList: false\n        });\n      }\n      unwrapList(editor, {\n        at: liPath.concat(0)\n      });\n      return true;\n    }\n    const [, liParentPath] = liParent;\n    const toListPath = liPath.concat([1]);\n    if (!isLastChild(list, liPath)) {\n      if (!hasListChild(editor, liNode)) {\n        insertElements(editor, {\n          type: listNode.type,\n          children: []\n        }, {\n          at: toListPath\n        });\n      }\n      const toListNode = getNode(editor, toListPath);\n      if (!toListNode)\n        return;\n      moveListItemsToList(editor, {\n        fromListItem: liParent,\n        toList: [toListNode, toListPath],\n        fromStartIndex: liPath[liPath.length - 1] + 1,\n        deleteFromList: false\n      });\n    }\n    const movedUpLiPath = Path.next(liParentPath);\n    moveNodes(editor, {\n      at: liPath,\n      to: movedUpLiPath\n    });\n    return true;\n  };\n  let moved = false;\n  withoutNormalizing(editor, () => {\n    moved = move();\n  });\n  return moved;\n};\nvar removeFirstListItem = (editor, {\n  list,\n  listItem\n}) => {\n  const [, listPath] = list;\n  if (!isListNested(editor, listPath)) {\n    moveListItemUp(editor, {\n      list,\n      listItem\n    });\n    return true;\n  }\n  return false;\n};\nvar moveListItems = (editor, {\n  increase = true,\n  at = (() => {\n    var _editor$selection;\n    return (_editor$selection = editor.selection) !== null && _editor$selection !== void 0 ? _editor$selection : void 0;\n  })(),\n  enableResetOnShiftTab\n} = {}) => {\n  const _nodes = getNodeEntries(editor, {\n    at,\n    match: {\n      type: getPluginType(editor, ELEMENT_LIC)\n    }\n  });\n  const lics = Array.from(_nodes);\n  if (!lics.length)\n    return;\n  const highestLicPaths = [];\n  const highestLicPathRefs = [];\n  lics.forEach((lic2) => {\n    const licPath = lic2[1];\n    const liPath = Path.parent(licPath);\n    const isAncestor2 = highestLicPaths.some((path) => {\n      const highestLiPath = Path.parent(path);\n      return Path.isAncestor(highestLiPath, liPath);\n    });\n    if (!isAncestor2) {\n      highestLicPaths.push(licPath);\n      highestLicPathRefs.push(createPathRef(editor, licPath));\n    }\n  });\n  const licPathRefsToMove = increase ? highestLicPathRefs : highestLicPathRefs.reverse();\n  withoutNormalizing(editor, () => {\n    licPathRefsToMove.forEach((licPathRef) => {\n      const licPath = licPathRef.unref();\n      if (!licPath)\n        return;\n      const listItem = getParentNode(editor, licPath);\n      if (!listItem)\n        return;\n      const parentList = getParentNode(editor, listItem[1]);\n      if (!parentList)\n        return;\n      if (increase) {\n        moveListItemDown(editor, {\n          list: parentList,\n          listItem\n        });\n      } else if (isListNested(editor, parentList[1])) {\n        moveListItemUp(editor, {\n          list: parentList,\n          listItem\n        });\n      } else if (enableResetOnShiftTab) {\n        removeFirstListItem(editor, {\n          list: parentList,\n          listItem\n        });\n      }\n    });\n  });\n};\nvar insertListItem = (editor) => {\n  const liType = getPluginType(editor, ELEMENT_LI);\n  const licType = getPluginType(editor, ELEMENT_LIC);\n  if (!editor.selection) {\n    return false;\n  }\n  const licEntry = getAboveNode(editor, {\n    match: {\n      type: licType\n    }\n  });\n  if (!licEntry)\n    return false;\n  const [, paragraphPath] = licEntry;\n  const listItemEntry = getParentNode(editor, paragraphPath);\n  if (!listItemEntry)\n    return false;\n  const [listItemNode, listItemPath] = listItemEntry;\n  if (listItemNode.type !== liType)\n    return false;\n  let success = false;\n  withoutNormalizing(editor, () => {\n    if (!Range.isCollapsed(editor.selection)) {\n      deleteText(editor);\n    }\n    const isStart = isStartPoint(editor, editor.selection.focus, paragraphPath);\n    const isEnd = isBlockTextEmptyAfterSelection(editor);\n    const nextParagraphPath = Path.next(paragraphPath);\n    const nextListItemPath = Path.next(listItemPath);\n    if (isStart) {\n      insertElements(editor, {\n        type: liType,\n        children: [{\n          type: licType,\n          children: [{\n            text: \"\"\n          }]\n        }]\n      }, {\n        at: listItemPath\n      });\n      success = true;\n      return;\n    }\n    if (!isEnd) {\n      withoutNormalizing(editor, () => {\n        splitNodes(editor);\n        wrapNodes(editor, {\n          type: liType,\n          children: []\n        }, {\n          at: nextParagraphPath\n        });\n        moveNodes(editor, {\n          at: nextParagraphPath,\n          to: nextListItemPath\n        });\n        select(editor, nextListItemPath);\n        collapseSelection(editor, {\n          edge: \"start\"\n        });\n      });\n    } else {\n      const marks3 = getMarks(editor) || {};\n      insertElements(editor, {\n        type: liType,\n        children: [{\n          type: licType,\n          children: [{\n            text: \"\",\n            ...marks3\n          }]\n        }]\n      }, {\n        at: nextListItemPath\n      });\n      select(editor, nextListItemPath);\n    }\n    if (listItemNode.children.length > 1) {\n      moveNodes(editor, {\n        at: nextParagraphPath,\n        to: nextListItemPath.concat(1)\n      });\n    }\n    success = true;\n  });\n  return success;\n};\nvar moveListItemSublistItemsToListItemSublist = (editor, {\n  fromListItem,\n  toListItem,\n  start: start2\n}) => {\n  const [, fromListItemPath] = fromListItem;\n  const [, toListItemPath] = toListItem;\n  let moved = 0;\n  withoutNormalizing(editor, () => {\n    const fromListItemSublist = findDescendant(editor, {\n      at: fromListItemPath,\n      match: {\n        type: getListTypes(editor)\n      }\n    });\n    if (!fromListItemSublist)\n      return;\n    const [, fromListItemSublistPath] = fromListItemSublist;\n    const toListItemSublist = findDescendant(editor, {\n      at: toListItemPath,\n      match: {\n        type: getListTypes(editor)\n      }\n    });\n    let to;\n    if (!toListItemSublist) {\n      const fromList = getParentNode(editor, fromListItemPath);\n      if (!fromList)\n        return;\n      const [fromListNode] = fromList;\n      const fromListType = fromListNode.type;\n      const toListItemSublistPath = toListItemPath.concat([1]);\n      insertElements(editor, {\n        type: fromListType,\n        children: []\n      }, {\n        at: toListItemSublistPath\n      });\n      to = toListItemSublistPath.concat([0]);\n    } else if (start2) {\n      const [, toListItemSublistPath] = toListItemSublist;\n      to = toListItemSublistPath.concat([0]);\n    } else {\n      to = Path.next(getLastChildPath(toListItemSublist));\n    }\n    moved = moveChildren(editor, {\n      at: fromListItemSublistPath,\n      to\n    });\n    deleteText(editor, {\n      at: fromListItemSublistPath\n    });\n  });\n  return moved;\n};\nvar removeListItem = (editor, {\n  list,\n  listItem,\n  reverse = true\n}) => {\n  const [liNode, liPath] = listItem;\n  if (isExpanded(editor.selection) || !hasListChild(editor, liNode)) {\n    return false;\n  }\n  const previousLiPath = getPreviousPath(liPath);\n  let success = false;\n  withoutNormalizing(editor, () => {\n    if (previousLiPath) {\n      const previousLi = getNodeEntry(editor, previousLiPath);\n      let tempLiPath = Path.next(liPath);\n      insertElements(editor, {\n        type: getPluginType(editor, ELEMENT_LI),\n        children: [{\n          type: getPluginType(editor, ELEMENT_LIC),\n          children: [{\n            text: \"\"\n          }]\n        }]\n      }, {\n        at: tempLiPath\n      });\n      const tempLi = getNodeEntry(editor, tempLiPath);\n      const tempLiPathRef = createPathRef(editor, tempLi[1]);\n      moveListItemSublistItemsToListItemSublist(editor, {\n        fromListItem: listItem,\n        toListItem: tempLi\n      });\n      deleteMerge(editor, {\n        reverse\n      });\n      tempLiPath = tempLiPathRef.unref();\n      moveListItemSublistItemsToListItemSublist(editor, {\n        fromListItem: [tempLi[0], tempLiPath],\n        toListItem: previousLi\n      });\n      removeNodes(editor, {\n        at: tempLiPath\n      });\n      success = true;\n      return;\n    }\n    moveListItemsToList(editor, {\n      fromListItem: listItem,\n      toList: list,\n      toListIndex: 1\n    });\n  });\n  return success;\n};\nvar toggleList = (editor, {\n  type\n}) => withoutNormalizing(editor, () => {\n  if (!editor.selection) {\n    return;\n  }\n  if (isCollapsed(editor.selection) || !isRangeAcrossBlocks(editor)) {\n    const res = getListItemEntry(editor);\n    if (res) {\n      const {\n        list\n      } = res;\n      if (list[0].type !== type) {\n        setElements(editor, {\n          type\n        }, {\n          at: editor.selection,\n          match: (n8) => isElement2(n8) && getListTypes(editor).includes(n8.type),\n          mode: \"lowest\"\n        });\n      } else {\n        unwrapList(editor);\n      }\n    } else {\n      const list = {\n        type,\n        children: []\n      };\n      wrapNodes(editor, list);\n      const _nodes = getNodeEntries(editor, {\n        match: {\n          type: getPluginType(editor, ELEMENT_DEFAULT)\n        }\n      });\n      const nodes = Array.from(_nodes);\n      setElements(editor, {\n        type: getPluginType(editor, ELEMENT_LIC)\n      });\n      const listItem = {\n        type: getPluginType(editor, ELEMENT_LI),\n        children: []\n      };\n      for (const [, path] of nodes) {\n        wrapNodes(editor, listItem, {\n          at: path\n        });\n      }\n    }\n  } else {\n    const [startPoint, endPoint] = Range.edges(editor.selection);\n    const commonEntry = getCommonNode(editor, startPoint.path, endPoint.path);\n    if (getListTypes(editor).includes(commonEntry[0].type) || commonEntry[0].type === getPluginType(editor, ELEMENT_LI)) {\n      if (commonEntry[0].type !== type) {\n        const startList = findNode(editor, {\n          at: Range.start(editor.selection),\n          match: {\n            type: getListTypes(editor)\n          },\n          mode: \"lowest\"\n        });\n        const endList = findNode(editor, {\n          at: Range.end(editor.selection),\n          match: {\n            type: getListTypes(editor)\n          },\n          mode: \"lowest\"\n        });\n        const rangeLength = Math.min(startList[1].length, endList[1].length);\n        setElements(editor, {\n          type\n        }, {\n          at: editor.selection,\n          match: (n8, path) => isElement2(n8) && getListTypes(editor).includes(n8.type) && path.length >= rangeLength,\n          mode: \"all\"\n        });\n      } else {\n        unwrapList(editor);\n      }\n    } else {\n      const rootPathLength = commonEntry[1].length;\n      const _nodes = getNodeEntries(editor, {\n        mode: \"all\"\n      });\n      const nodes = Array.from(_nodes).filter(([, path]) => path.length === rootPathLength + 1);\n      nodes.forEach((n8) => {\n        if (getListTypes(editor).includes(n8[0].type)) {\n          setElements(editor, {\n            type\n          }, {\n            at: n8[1],\n            match: (_n) => isElement2(_n) && getListTypes(editor).includes(_n.type),\n            mode: \"all\"\n          });\n        } else {\n          setElements(editor, {\n            type: getPluginType(editor, ELEMENT_LIC)\n          }, {\n            at: n8[1]\n          });\n          const listItem = {\n            type: getPluginType(editor, ELEMENT_LI),\n            children: []\n          };\n          wrapNodes(editor, listItem, {\n            at: n8[1]\n          });\n          const list = {\n            type,\n            children: []\n          };\n          wrapNodes(editor, list, {\n            at: n8[1]\n          });\n        }\n      });\n    }\n  }\n});\nvar onKeyDownList = (editor, {\n  type,\n  options: {\n    hotkey,\n    enableResetOnShiftTab\n  }\n}) => (e4) => {\n  const isTab = Hotkeys2.isTab(editor, e4);\n  const isUntab = Hotkeys2.isUntab(editor, e4);\n  let workRange = editor.selection;\n  if (editor.selection && (isTab || isUntab)) {\n    const {\n      selection\n    } = editor;\n    if (!isCollapsed(editor.selection)) {\n      const {\n        anchor,\n        focus\n      } = Range.isBackward(selection) ? {\n        anchor: {\n          ...selection.focus\n        },\n        focus: {\n          ...selection.anchor\n        }\n      } : {\n        anchor: {\n          ...selection.anchor\n        },\n        focus: {\n          ...selection.focus\n        }\n      };\n      anchor.offset = 0;\n      const unHungRange = unhangRange(editor, {\n        anchor,\n        focus\n      });\n      if (unHungRange) {\n        workRange = unHungRange;\n        select(editor, unHungRange);\n      }\n    }\n    const listSelected = someNode(editor, {\n      match: {\n        type: getPluginType(editor, ELEMENT_LIC)\n      }\n    });\n    if (workRange && listSelected) {\n      e4.preventDefault();\n      moveListItems(editor, {\n        at: workRange,\n        increase: isTab,\n        enableResetOnShiftTab\n      });\n      return true;\n    }\n  }\n  if (!hotkey)\n    return;\n  const hotkeys2 = castArray_12(hotkey);\n  for (const _hotkey of hotkeys2) {\n    if (isHotkey3(_hotkey)(e4)) {\n      toggleList(editor, {\n        type\n      });\n    }\n  }\n};\nvar deleteBackwardList = (editor, unit) => {\n  const res = getListItemEntry(editor, {});\n  let moved = false;\n  if (res) {\n    const {\n      list,\n      listItem\n    } = res;\n    if (isSelectionAtBlockStart(editor, {\n      match: (node) => node.type === getPluginType(editor, ELEMENT_LI)\n    })) {\n      withoutNormalizing(editor, () => {\n        moved = removeFirstListItem(editor, {\n          list,\n          listItem\n        });\n        if (moved)\n          return true;\n        moved = removeListItem(editor, {\n          list,\n          listItem\n        });\n        if (moved)\n          return true;\n        if (isFirstChild(listItem[1]) && !isListNested(editor, list[1])) {\n          onKeyDownResetNode(editor, mockPlugin({\n            options: {\n              rules: [{\n                types: [getPluginType(editor, ELEMENT_LI)],\n                defaultType: getPluginType(editor, ELEMENT_DEFAULT),\n                hotkey: \"backspace\",\n                predicate: () => isSelectionAtBlockStart(editor),\n                onReset: (e4) => unwrapList(e4)\n              }]\n            }\n          }))(SIMULATE_BACKSPACE);\n          moved = true;\n          return;\n        }\n        deleteMerge(editor, {\n          unit,\n          reverse: true\n        });\n        moved = true;\n      });\n    }\n  }\n  return moved;\n};\nvar selectionIsNotInAListHandler = (editor) => {\n  const pointAfterSelection = getPointAfter(editor, editor.selection.focus.path);\n  if (pointAfterSelection) {\n    const nextSiblingListRes = getListItemEntry(editor, {\n      at: pointAfterSelection\n    });\n    if (nextSiblingListRes) {\n      const {\n        listItem\n      } = nextSiblingListRes;\n      const parentBlockEntity = getBlockAbove(editor, {\n        at: editor.selection.anchor\n      });\n      if (!getEditorString(editor, parentBlockEntity[1])) {\n        removeNodes(editor);\n        return true;\n      }\n      if (hasListChild(editor, listItem[0])) {\n        const sublistRes = getListItemEntry(editor, {\n          at: [...listItem[1], 1, 0, 0]\n        });\n        moveListItemUp(editor, sublistRes);\n      }\n    }\n  }\n  return false;\n};\nvar selectionIsInAListHandler = (editor, res) => {\n  const {\n    listItem\n  } = res;\n  if (!hasListChild(editor, listItem[0])) {\n    const liType = getPluginType(editor, ELEMENT_LI);\n    const _nodes = getNodeEntries(editor, {\n      at: listItem[1],\n      mode: \"lowest\",\n      match: (node, path) => {\n        var _getNode;\n        if (path.length === 0) {\n          return false;\n        }\n        const isNodeLi = node.type === liType;\n        const isSiblingOfNodeLi = ((_getNode = getNode(editor, Path.next(path))) === null || _getNode === void 0 ? void 0 : _getNode.type) === liType;\n        return isNodeLi && isSiblingOfNodeLi;\n      }\n    });\n    const liWithSiblings = Array.from(_nodes, (entry) => entry[1])[0];\n    if (!liWithSiblings) {\n      const pointAfterListItem = getPointAfter(editor, listItem[1]);\n      if (pointAfterListItem) {\n        const nextSiblingListRes = getListItemEntry(editor, {\n          at: pointAfterListItem\n        });\n        if (nextSiblingListRes) {\n          const listRoot = getListRoot(editor, listItem[1]);\n          moveListItemsToList(editor, {\n            fromList: nextSiblingListRes.list,\n            toList: listRoot,\n            deleteFromList: true\n          });\n          return true;\n        }\n      }\n      return false;\n    }\n    const siblingListItem = getNodeEntry(editor, Path.next(liWithSiblings));\n    const siblingList = getParentNode(editor, siblingListItem[1]);\n    if (siblingList && removeListItem(editor, {\n      list: siblingList,\n      listItem: siblingListItem,\n      reverse: false\n    })) {\n      return true;\n    }\n    return false;\n  }\n  const nestedList = getNodeEntry(editor, Path.next([...listItem[1], 0]));\n  const nestedListItem = getChildren(nestedList)[0];\n  if (removeFirstListItem(editor, {\n    list: nestedList,\n    listItem: nestedListItem\n  })) {\n    return true;\n  }\n  if (removeListItem(editor, {\n    list: nestedList,\n    listItem: nestedListItem\n  })) {\n    return true;\n  }\n  return false;\n};\nvar deleteForwardList = (editor) => {\n  let skipDefaultDelete = false;\n  if (!(editor !== null && editor !== void 0 && editor.selection)) {\n    return skipDefaultDelete;\n  }\n  if (!isSelectionAtBlockEnd(editor)) {\n    return skipDefaultDelete;\n  }\n  withoutNormalizing(editor, () => {\n    const res = getListItemEntry(editor, {});\n    if (!res) {\n      skipDefaultDelete = selectionIsNotInAListHandler(editor);\n      return;\n    }\n    skipDefaultDelete = selectionIsInAListHandler(editor, res);\n  });\n  return skipDefaultDelete;\n};\nvar deleteFragmentList = (editor) => {\n  let deleted = false;\n  withoutNormalizing(editor, () => {\n    if (!isAcrossListItems(editor))\n      return;\n    const end2 = getEndPoint(editor, editor.selection);\n    const liEnd = getAboveNode(editor, {\n      at: end2,\n      match: {\n        type: getPluginType(editor, ELEMENT_LI)\n      }\n    });\n    const liEndCanBeDeleted = liEnd && !hasListChild(editor, liEnd[0]);\n    const liEndPathRef = liEndCanBeDeleted ? createPathRef(editor, liEnd[1]) : void 0;\n    deleteMerge(editor);\n    const start2 = getStartPoint(editor, editor.selection);\n    const liStart = getAboveNode(editor, {\n      at: start2,\n      match: {\n        type: getPluginType(editor, ELEMENT_LI)\n      }\n    });\n    if (liEndPathRef) {\n      const liEndPath = liEndPathRef.unref();\n      const listStart = liStart && getParentNode(editor, liStart[1]);\n      const deletePath = getHighestEmptyList(editor, {\n        liPath: liEndPath,\n        diffListPath: listStart === null || listStart === void 0 ? void 0 : listStart[1]\n      });\n      if (deletePath) {\n        removeNodes(editor, {\n          at: deletePath\n        });\n      }\n      deleted = true;\n    }\n  });\n  return deleted;\n};\nvar insertBreakList = (editor) => {\n  if (!editor.selection)\n    return;\n  const res = getListItemEntry(editor, {});\n  let moved;\n  if (res) {\n    const {\n      list,\n      listItem\n    } = res;\n    if (isBlockAboveEmpty(editor)) {\n      moved = moveListItemUp(editor, {\n        list,\n        listItem\n      });\n      if (moved)\n        return true;\n    }\n  }\n  const didReset = onKeyDownResetNode(editor, mockPlugin({\n    options: {\n      rules: [{\n        types: [getPluginType(editor, ELEMENT_LI)],\n        defaultType: getPluginType(editor, ELEMENT_DEFAULT),\n        predicate: () => !moved && isBlockAboveEmpty(editor),\n        onReset: (_editor) => unwrapList(_editor)\n      }]\n    }\n  }))(SIMULATE_BACKSPACE);\n  if (didReset)\n    return true;\n  if (!moved) {\n    const inserted = insertListItem(editor);\n    if (inserted)\n      return true;\n  }\n};\nvar insertFragmentList = (editor) => {\n  const {\n    insertFragment: _insertFragment\n  } = editor;\n  const listItemPlugin = getPlugin(editor, ELEMENT_LI);\n  const listItemType = getListItemType(editor);\n  const listItemContentType = getListItemContentType(editor);\n  const getFirstAncestorOfType = (root5, entry, {\n    type\n  }) => {\n    let ancestor = Path.parent(entry[1]);\n    while (getNode(root5, ancestor).type !== type) {\n      ancestor = Path.parent(ancestor);\n    }\n    return [getNode(root5, ancestor), ancestor];\n  };\n  const findListItemsWithContent = (first) => {\n    let prev = null;\n    let node = first;\n    while (isListRoot(editor, node) || node.type === listItemType && node.children[0].type !== listItemContentType) {\n      prev = node;\n      [node] = node.children;\n    }\n    return prev ? prev.children : [node];\n  };\n  const trimList = (listRoot) => {\n    if (!isListRoot(editor, listRoot)) {\n      return [listRoot];\n    }\n    const _texts = getNodeTexts(listRoot);\n    const textEntries = Array.from(_texts);\n    const commonAncestorEntry = textEntries.reduce(\n      (commonAncestor, textEntry) => Path.isAncestor(commonAncestor[1], textEntry[1]) ? commonAncestor : getCommonNode(listRoot, textEntry[1], commonAncestor[1]),\n      // any list item would do, we grab the first one\n      getFirstAncestorOfType(listRoot, textEntries[0], listItemPlugin)\n    );\n    const [first, ...rest] = isListRoot(editor, commonAncestorEntry[0]) ? commonAncestorEntry[0].children : [commonAncestorEntry[0]];\n    return [...findListItemsWithContent(first), ...rest];\n  };\n  const wrapNodeIntoListItem = (node) => {\n    return node.type === listItemType ? node : {\n      type: listItemType,\n      children: [node]\n    };\n  };\n  const isSingleLic = (fragment) => {\n    const isFragmentOnlyListRoot = fragment.length === 1 && isListRoot(editor, fragment[0]);\n    return isFragmentOnlyListRoot && [...getNodes({\n      children: fragment\n    })].filter((entry) => isElement2(entry[0])).filter(([node]) => node.type === listItemContentType).length === 1;\n  };\n  const getTextAndListItemNodes = (fragment, liEntry, licEntry) => {\n    const [, liPath] = liEntry;\n    const [licNode, licPath] = licEntry;\n    const isEmptyNode = !getNodeString(licNode);\n    const [first, ...rest] = fragment.flatMap(trimList).map(wrapNodeIntoListItem);\n    let textNode;\n    let listItemNodes;\n    if (isListRoot(editor, fragment[0])) {\n      if (isSingleLic(fragment)) {\n        textNode = first;\n        listItemNodes = rest;\n      } else if (isEmptyNode) {\n        const li3 = getNode(editor, liPath);\n        const [, ...currentSublists] = li3.children;\n        const [newLic, ...newSublists] = first.children;\n        insertElements(editor, newLic, {\n          at: Path.next(licPath),\n          select: true\n        });\n        removeNodes(editor, {\n          at: licPath\n        });\n        if (newSublists !== null && newSublists !== void 0 && newSublists.length) {\n          if (currentSublists !== null && currentSublists !== void 0 && currentSublists.length) {\n            const path = [...liPath, 1, 0];\n            insertElements(editor, newSublists[0].children, {\n              at: path,\n              select: true\n            });\n          } else {\n            insertElements(editor, newSublists, {\n              at: Path.next(licPath),\n              select: true\n            });\n          }\n        }\n        textNode = {\n          text: \"\"\n        };\n        listItemNodes = rest;\n      } else {\n        textNode = {\n          text: \"\"\n        };\n        listItemNodes = [first, ...rest];\n      }\n    } else {\n      textNode = first;\n      listItemNodes = rest;\n    }\n    return {\n      textNode,\n      listItemNodes\n    };\n  };\n  return (fragment) => {\n    let liEntry = findNode(editor, {\n      match: {\n        type: listItemType\n      },\n      mode: \"lowest\"\n    });\n    if (!liEntry) {\n      return _insertFragment(isListRoot(editor, fragment[0]) ? [{\n        text: \"\"\n      }, ...fragment] : fragment);\n    }\n    insertFragment(editor, [{\n      text: \"\"\n    }]);\n    liEntry = findNode(editor, {\n      match: {\n        type: listItemType\n      },\n      mode: \"lowest\"\n    });\n    const licEntry = findNode(editor, {\n      match: {\n        type: listItemContentType\n      },\n      mode: \"lowest\"\n    });\n    if (!licEntry) {\n      return _insertFragment(isListRoot(editor, fragment[0]) ? [{\n        text: \"\"\n      }, ...fragment] : fragment);\n    }\n    const {\n      textNode,\n      listItemNodes\n    } = getTextAndListItemNodes(fragment, liEntry, licEntry);\n    insertFragment(editor, [textNode]);\n    const [, liPath] = liEntry;\n    return insertElements(editor, listItemNodes, {\n      at: Path.next(liPath),\n      select: true\n    });\n  };\n};\nvar getDeepInlineChildren = (editor, {\n  children\n}) => {\n  const inlineChildren = [];\n  for (const child of children) {\n    if (isBlock(editor, child[0])) {\n      inlineChildren.push(...getDeepInlineChildren(editor, {\n        children: getChildren(child)\n      }));\n    } else {\n      inlineChildren.push(child);\n    }\n  }\n  return inlineChildren;\n};\nvar normalizeListItem = (editor, {\n  listItem,\n  validLiChildrenTypes = []\n}) => {\n  let changed = false;\n  const allValidLiChildrenTypes = [getPluginType(editor, ELEMENT_UL), getPluginType(editor, ELEMENT_OL), getPluginType(editor, ELEMENT_LIC), ...validLiChildrenTypes];\n  const [, liPath] = listItem;\n  const liChildren = getChildren(listItem);\n  const invalidLiChildrenPathRefs = liChildren.filter(([child]) => !allValidLiChildrenTypes.includes(child.type)).map(([, childPath]) => createPathRef(editor, childPath));\n  const firstLiChild = liChildren[0];\n  const [firstLiChildNode, firstLiChildPath] = firstLiChild !== null && firstLiChild !== void 0 ? firstLiChild : [];\n  if (!firstLiChild || !isBlock(editor, firstLiChildNode)) {\n    insertEmptyElement(editor, getPluginType(editor, ELEMENT_LIC), {\n      at: liPath.concat([0])\n    });\n    return true;\n  }\n  if (isBlock(editor, firstLiChildNode) && !match(firstLiChildNode, [], {\n    type: getPluginType(editor, ELEMENT_LIC)\n  })) {\n    if (match(firstLiChildNode, [], {\n      type: getListTypes(editor)\n    })) {\n      const parent2 = getParentNode(editor, listItem[1]);\n      const sublist = firstLiChild;\n      const children = getChildren(firstLiChild).reverse();\n      children.forEach((c5) => {\n        moveListItemUp(editor, {\n          list: sublist,\n          listItem: c5\n        });\n      });\n      removeNodes(editor, {\n        at: [...parent2[1], 0]\n      });\n      return true;\n    }\n    if (validLiChildrenTypes.includes(firstLiChildNode.type)) {\n      return true;\n    }\n    setElements(editor, {\n      type: getPluginType(editor, ELEMENT_LIC)\n    }, {\n      at: firstLiChildPath\n    });\n    changed = true;\n  }\n  const licChildren = getChildren(firstLiChild);\n  if (licChildren.length) {\n    var _licChildren;\n    const blockPathRefs = [];\n    const inlineChildren = [];\n    for (const licChild of licChildren) {\n      if (!isBlock(editor, licChild[0])) {\n        break;\n      }\n      blockPathRefs.push(createPathRef(editor, licChild[1]));\n      inlineChildren.push(...getDeepInlineChildren(editor, {\n        children: getChildren(licChild)\n      }));\n    }\n    const to = Path.next((_licChildren = licChildren[licChildren.length - 1]) === null || _licChildren === void 0 ? void 0 : _licChildren[1]);\n    inlineChildren.reverse().forEach(([, path]) => {\n      moveNodes(editor, {\n        at: path,\n        to\n      });\n    });\n    blockPathRefs.forEach((pathRef) => {\n      const path = pathRef.unref();\n      path && removeNodes(editor, {\n        at: path\n      });\n    });\n    if (blockPathRefs.length) {\n      changed = true;\n    }\n  }\n  if (changed)\n    return true;\n  invalidLiChildrenPathRefs.reverse().forEach((ref) => {\n    const path = ref.unref();\n    path && moveNodes(editor, {\n      at: path,\n      to: firstLiChildPath.concat([0])\n    });\n  });\n  return !!invalidLiChildrenPathRefs.length;\n};\nvar normalizeNestedList = (editor, {\n  nestedListItem\n}) => {\n  const [, path] = nestedListItem;\n  const parentNode = getParentNode(editor, path);\n  const hasParentList = parentNode && match(parentNode[0], [], {\n    type: getListTypes(editor)\n  });\n  if (!hasParentList) {\n    return false;\n  }\n  let previousListItemPath;\n  try {\n    previousListItemPath = Path.previous(path);\n  } catch (e4) {\n    return false;\n  }\n  const previousSiblingItem = getNodeEntry(editor, previousListItemPath);\n  if (previousSiblingItem) {\n    const [, previousPath] = previousSiblingItem;\n    const newPath = previousPath.concat([1]);\n    moveNodes(editor, {\n      at: path,\n      to: newPath\n    });\n    return true;\n  }\n};\nvar normalizeList = (editor, {\n  validLiChildrenTypes\n}) => {\n  const {\n    normalizeNode\n  } = editor;\n  const liType = getPluginType(editor, ELEMENT_LI);\n  const licType = getPluginType(editor, ELEMENT_LIC);\n  const defaultType = getPluginType(editor, ELEMENT_DEFAULT);\n  return ([node, path]) => {\n    if (!isElement2(node)) {\n      return normalizeNode([node, path]);\n    }\n    if (isListRoot(editor, node)) {\n      const nonLiChild = getChildren([node, path]).find(([child]) => child.type !== liType);\n      if (nonLiChild) {\n        return wrapNodes(editor, {\n          type: liType,\n          children: []\n        }, {\n          at: nonLiChild[1]\n        });\n      }\n    }\n    if (match(node, [], {\n      type: getListTypes(editor)\n    })) {\n      if (!node.children.length || !node.children.find((item) => item.type === liType)) {\n        return removeNodes(editor, {\n          at: path\n        });\n      }\n      const nextPath = Path.next(path);\n      const nextNode = getNode(editor, nextPath);\n      if ((nextNode === null || nextNode === void 0 ? void 0 : nextNode.type) === node.type) {\n        moveListItemsToList(editor, {\n          fromList: [nextNode, nextPath],\n          toList: [node, path],\n          deleteFromList: true\n        });\n      }\n      const prevPath = getPreviousPath(path);\n      const prevNode = getNode(editor, prevPath);\n      if ((prevNode === null || prevNode === void 0 ? void 0 : prevNode.type) === node.type) {\n        editor.normalizeNode([prevNode, prevPath]);\n        return;\n      }\n      if (normalizeNestedList(editor, {\n        nestedListItem: [node, path]\n      })) {\n        return;\n      }\n    }\n    if (node.type === getPluginType(editor, ELEMENT_LI)) {\n      if (normalizeListItem(editor, {\n        listItem: [node, path],\n        validLiChildrenTypes\n      })) {\n        return;\n      }\n    }\n    if (node.type === licType && licType !== defaultType) {\n      var _getParentNode;\n      if (((_getParentNode = getParentNode(editor, path)) === null || _getParentNode === void 0 ? void 0 : _getParentNode[0].type) !== liType) {\n        setElements(editor, {\n          type: defaultType\n        }, {\n          at: path\n        });\n        return;\n      }\n    }\n    normalizeNode([node, path]);\n  };\n};\nvar withList = (editor, {\n  options: {\n    validLiChildrenTypes\n  }\n}) => {\n  const {\n    insertBreak,\n    deleteBackward: deleteBackward2,\n    deleteForward,\n    deleteFragment\n  } = editor;\n  editor.insertBreak = () => {\n    if (insertBreakList(editor))\n      return;\n    insertBreak();\n  };\n  editor.deleteBackward = (unit) => {\n    if (deleteBackwardList(editor, unit))\n      return;\n    deleteBackward2(unit);\n  };\n  editor.deleteForward = (unit) => {\n    if (deleteForwardList(editor))\n      return;\n    deleteForward(unit);\n  };\n  editor.deleteFragment = () => {\n    if (deleteFragmentList(editor))\n      return;\n    deleteFragment();\n  };\n  editor.insertFragment = insertFragmentList(editor);\n  editor.normalizeNode = normalizeList(editor, {\n    validLiChildrenTypes\n  });\n  return editor;\n};\nvar ELEMENT_UL = \"ul\";\nvar ELEMENT_OL = \"ol\";\nvar ELEMENT_LI = \"li\";\nvar ELEMENT_LIC = \"lic\";\nvar createListPlugin = createPluginFactory({\n  key: \"list\",\n  plugins: [{\n    key: ELEMENT_UL,\n    isElement: true,\n    handlers: {\n      onKeyDown: onKeyDownList\n    },\n    withOverrides: withList,\n    deserializeHtml: {\n      rules: [{\n        validNodeName: \"UL\"\n      }]\n    }\n  }, {\n    key: ELEMENT_OL,\n    isElement: true,\n    handlers: {\n      onKeyDown: onKeyDownList\n    },\n    deserializeHtml: {\n      rules: [{\n        validNodeName: \"OL\"\n      }]\n    }\n  }, {\n    key: ELEMENT_LI,\n    isElement: true,\n    deserializeHtml: {\n      rules: [{\n        validNodeName: \"LI\"\n      }]\n    },\n    then: (editor, {\n      type\n    }) => ({\n      inject: {\n        pluginsByKey: {\n          [KEY_DESERIALIZE_HTML]: {\n            editor: {\n              insertData: {\n                preInsert: () => {\n                  return someNode(editor, {\n                    match: {\n                      type\n                    }\n                  });\n                }\n              }\n            }\n          }\n        }\n      }\n    })\n  }, {\n    key: ELEMENT_LIC,\n    isElement: true\n  }]\n});\nvar ELEMENT_TODO_LI = \"action_item\";\nvar createTodoListPlugin = createPluginFactory({\n  key: ELEMENT_TODO_LI,\n  isElement: true,\n  handlers: {\n    onKeyDown: onKeyDownToggleElement\n  },\n  options: {\n    hotkey: [\"mod+opt+4\", \"mod+shift+4\"]\n  }\n});\n\n// src/transform/wikiast-util-from-slate-plate-ast/wikiAstBuilder/index.ts\nvar import_html_tags = __toESM(require_html_tags2());\n\n// src/transform/wikiast-util-from-slate-plate-ast/wikiAstBuilder/codeblock.ts\nfunction codeblock(builders4, node) {\n  const { code: code3, language = \"\" } = node;\n  const attributes = {};\n  if (language !== void 0) {\n    attributes.language = {\n      type: \"string\",\n      value: language\n    };\n  }\n  attributes.code = {\n    type: \"string\",\n    value: code3\n  };\n  return {\n    type: \"codeblock\",\n    attributes\n  };\n}\n\n// src/transform/wikiast-util-from-slate-plate-ast/wikiAstBuilder/element/blockquote.ts\nfunction blockquote(builders4, node) {\n  const children = convertNodes(builders4, node.children).flatMap((child) => {\n    if (child.type === \"text\") {\n      return (child.text ?? \"\").split(\"\\n\").map((line) => ({\n        type: \"element\",\n        tag: \"div\",\n        children: [{ type: \"text\", text: line }]\n      }));\n    }\n    return [child];\n  });\n  return {\n    type: \"element\",\n    tag: \"blockquote\",\n    children\n  };\n}\n\n// src/transform/wikiast-util-from-slate-plate-ast/wikiAstBuilder/element/a.ts\nvar import_pick2 = __toESM(require_pick());\nfunction a3(builders4, node) {\n  if (node[\"tw-type\"] === \"link\") {\n    const typedNode = node;\n    const result2 = {\n      ...(0, import_pick2.default)(typedNode, [\"orderedAttributes\", \"isBlock\"]),\n      type: \"link\",\n      attributes: {\n        ...typedNode.attributes,\n        to: {\n          type: \"string\",\n          value: typedNode.url\n        }\n      },\n      children: [\n        {\n          type: \"text\",\n          text: typedNode.children[0].text\n        }\n      ]\n    };\n    return result2;\n  }\n  const result = {\n    type: \"element\",\n    tag: \"a\",\n    // slate will add empty text child to it, we don't need that in wikiast\n    children: node.children.length > 0 && (node.children[0].text !== \"\" || !(\"text\" in node.children[0])) ? convertNodes(builders4, node.children) : []\n  };\n  return result;\n}\n\n// src/transform/wikiast-util-from-slate-plate-ast/wikiAstBuilder/text.ts\nfunction textWithoutMark(builders4, node) {\n  return {\n    type: \"text\",\n    text: node.text\n  };\n}\nfunction unwrapSlateTextWithP(nodes) {\n  return nodes.flatMap((node) => {\n    if (node.type === \"p\" && Array.isArray(node.children) && node.children.every((node2) => \"text\" in node2)) {\n      return node.children;\n    }\n    return node;\n  });\n}\nvar markTypeMap = {\n  bold: \"strong\",\n  italic: \"em\",\n  underline: \"u\",\n  strikethrough: \"strike\",\n  code: \"code\",\n  superscript: \"sup\",\n  subscript: \"sub\"\n};\nfunction text(builders4, node) {\n  for (const markType of [\"bold\", \"italic\", \"underline\", \"strikethrough\", \"subscript\", \"superscript\", \"code\"]) {\n    if (node[markType] === true) {\n      return {\n        type: \"element\",\n        tag: markTypeMap[markType],\n        children: [text(builders4, { ...node, [markType]: void 0 })]\n      };\n    }\n  }\n  return textWithoutMark(builders4, node);\n}\n\n// src/transform/wikiast-util-from-slate-plate-ast/wikiAstBuilder/element/table.ts\nfunction table(builders4, node) {\n  const children = convertNodes(builders4, node.children);\n  return {\n    type: \"element\",\n    tag: \"table\",\n    children: [\n      {\n        type: \"element\",\n        tag: \"tbody\",\n        children\n      }\n    ]\n  };\n}\nfunction td(builders4, node) {\n  const children = convertNodes(builders4, unwrapSlateTextWithP(node.children));\n  return {\n    type: \"element\",\n    tag: \"td\",\n    children\n  };\n}\n\n// src/transform/wikiast-util-from-slate-plate-ast/wikiAstBuilder/element/index.ts\nvar elementBuilders = {\n  blockquote,\n  a: a3,\n  table,\n  td\n};\nfunction element(builders4, node) {\n  const { type: tag, children } = node;\n  const customElementHandler = elementBuilders[tag];\n  if (typeof customElementHandler === \"function\") {\n    return customElementHandler(builders4, node);\n  }\n  return {\n    type: \"element\",\n    tag,\n    children: convertNodes(builders4, children)\n  };\n}\n\n// src/transform/wikiast-util-from-slate-plate-ast/wikiAstBuilder/lic.ts\nfunction lic(builders4, node) {\n  const { children } = node;\n  const nodesSpreadIntoList = convertNodes(builders4, children);\n  if (nodesSpreadIntoList.length > 0) {\n    return nodesSpreadIntoList.filter((child) => child.type !== \"text\" || child.text !== \"\");\n  }\n  return nodesSpreadIntoList;\n}\n\n// src/transform/wikiast-util-from-slate-plate-ast/wikiAstBuilder/widget.ts\nfunction widget(builders4, node) {\n  return node.node;\n}\n\n// src/transform/wikiast-util-from-slate-plate-ast/wikiAstBuilder/set.ts\nfunction set(builders4, node) {\n  const children = convertNodes(builders4, node.children);\n  return { ...node.node, children };\n}\n\n// src/editor/plugins/codeblock/constants.ts\nvar ELEMENT_CODE_BLOCK = \"codeblock\";\nvar ELEMENT_CODE_LINE = \"code_line\";\nvar CODE_BLOCK_LANGUAGES_POPULAR = [\n  \"TiddlyWiki\",\n  \"Shell\",\n  \"CSS\",\n  \"Git\",\n  \"GraphQL\",\n  \"HTML\",\n  \"JavaScript\",\n  \"JSON\",\n  \"JSX\",\n  \"Markdown\",\n  \"SQL\",\n  \"SVG\",\n  \"TSX\",\n  \"TypeScript\",\n  \"WebAssembly\"\n];\nvar CODE_BLOCK_LANGUAGES = {\n  ANTLR4: \"antlr4\",\n  C: \"c\",\n  \"C#\": \"csharp\",\n  CSS: \"css\",\n  CoffeeScript: \"coffeescript\",\n  CMake: \"cmake\",\n  Dart: \"dart\",\n  Django: \"django\",\n  Docker: \"docker\",\n  EJS: \"ejs\",\n  Erlang: \"erlang\",\n  Git: \"git\",\n  Go: \"go\",\n  GraphQL: \"graphql\",\n  Groovy: \"groovy\",\n  HTML: \"html\",\n  Java: \"java\",\n  JavaScript: \"javascript\",\n  JSON: \"json\",\n  JSX: \"jsx\",\n  Kotlin: \"kotlin\",\n  LaTeX: \"latex\",\n  Less: \"less\",\n  Lua: \"lua\",\n  Makefile: \"makefile\",\n  Markdown: [\"markdown\", \"md\"],\n  MATLAB: \"matlab\",\n  Markup: \"markup\",\n  \"Objective-C\": \"objectivec\",\n  Perl: \"perl\",\n  PHP: \"php\",\n  PowerShell: \"powershell\",\n  \".properties\": \"properties\",\n  \"Protocol Buffers\": \"protobuf\",\n  Python: \"python\",\n  R: \"r\",\n  Ruby: \"ruby\",\n  \"Sass (Sass)\": \"sass\",\n  \"Sass (Scss)\": \"scss\",\n  Scala: \"scala\",\n  Scheme: \"scheme\",\n  SQL: \"sql\",\n  Shell: [\"bash\", \"sh\", \"zsh\", \"shell\"],\n  Swift: \"swift\",\n  SVG: \"svg\",\n  TSX: \"tsx\",\n  TiddlyWiki: [\"tiddlywiki5\", \"tiddlywiki\", \"tid\"],\n  TypeScript: \"typescript\",\n  WebAssembly: \"wasm\",\n  YAML: \"yaml\",\n  XML: \"xml\"\n};\nfunction normalizeLanguage(language) {\n  for (const values2 of Object.values(CODE_BLOCK_LANGUAGES)) {\n    if (Array.isArray(values2)) {\n      if (values2.includes(language)) {\n        return values2[0];\n      }\n    } else if (values2 === language) {\n      return values2;\n    }\n  }\n  return language;\n}\n\n// src/transform/wikiast-util-from-slate-plate-ast/wikiAstBuilder/index.ts\nvar builders = {\n  // auto parse basic element nodes\n  // eslint-disable-next-line unicorn/prefer-object-from-entries\n  ...import_html_tags.default.reduce(\n    (previousValue, currentValue) => {\n      previousValue[currentValue] = element;\n      return previousValue;\n    },\n    // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter, @typescript-eslint/consistent-type-assertions\n    {}\n  ),\n  [ELEMENT_CODE_BLOCK]: codeblock,\n  [ELEMENT_LIC]: lic,\n  text,\n  widget,\n  macro: widget,\n  set\n};\n\n// src/transform/wikiast-util-from-slate-plate-ast/index.ts\nfunction wikiAstFromSlateAst(input) {\n  return convertNodes(builders, Array.isArray(input) ? input : [input]);\n}\n\n// src/transform/wikiast-util-from-wikitext/index.ts\nfunction wikiAstFromWikiText(input) {\n  if (typeof $tw === \"undefined\") {\n    return [];\n  }\n  const rootNode = $tw.wiki.parseText(\"text/vnd.tiddlywiki\", input).tree;\n  return rootNode;\n}\n\n// src/transform/wikiast-util-to-slate-plate-ast/traverse.ts\nfunction convertNodes2(context, nodes) {\n  if (nodes === void 0 || nodes.length === 0) {\n    return [{ text: \"\" }];\n  }\n  return nodes.reduce((accumulator, node) => {\n    return [...accumulator, ...slateNode(context, node)];\n  }, []);\n}\nfunction slateNode(context, node) {\n  const id = context.idCreator?.();\n  const withId = (nodeToAddId) => id === void 0 ? nodeToAddId : { ...nodeToAddId, id };\n  if (node.type in context.builders) {\n    const builder = context.builders[node.type];\n    if (typeof builder === \"function\") {\n      const builtSlateNodeOrNodes = builder(context, node);\n      return Array.isArray(builtSlateNodeOrNodes) ? builtSlateNodeOrNodes.map((child) => withId({ ...getWikiASTAdditionalProperties(node), ...child })) : [withId({ ...getWikiASTAdditionalProperties(node), ...builtSlateNodeOrNodes })];\n    }\n  } else {\n    if (typeof node.type === \"string\" && \"tag\" in node && typeof node.tag === \"string\") {\n      const widgetNode = withId({ ...getWikiASTAdditionalProperties, ...context.builders.widget(context, node) });\n      return [widgetNode];\n    }\n  }\n  return [];\n}\n\n// src/transform/wikiast-util-to-slate-plate-ast/slateBuilder/element/ul.ts\nfunction ul(context, node) {\n  const { tag, children } = node;\n  return {\n    type: tag,\n    children: convertNodes2(context, children)\n  };\n}\n\n// src/transform/ast-utils/mergeAdjacent.ts\nfunction mergeAdjacent(nodes, typeToMerge) {\n  const result = [];\n  let current;\n  for (const node of nodes) {\n    if (current !== void 0 && current.type === node.type && (typeToMerge ? node.type === typeToMerge : true)) {\n      if (!Array.isArray(current.children)) {\n        current.children = [];\n      }\n      current.children.push(...node.children ?? []);\n    } else {\n      result.push(node);\n      current = node;\n    }\n  }\n  return result;\n}\n\n// src/transform/wikiast-util-to-slate-plate-ast/slateBuilder/element/li.ts\nfunction li(context, node) {\n  const { children } = node;\n  const childrenWithLic = children.flatMap((child) => {\n    if (child.type === \"text\" || child.tag !== \"ol\" && child.tag !== \"ul\") {\n      return { type: ELEMENT_LIC, children: convertNodes2(context, [child]) };\n    }\n    return convertNodes2(context, [child]);\n  });\n  const childrenWithLicMerged = mergeAdjacent(childrenWithLic, ELEMENT_LIC);\n  const childrenWithLicPadded = childrenWithLicMerged.map((child) => {\n    if (child.type === ELEMENT_LIC) {\n      if (child.children.length > 0) {\n        if (!child.children[0].text) {\n          child.children.push({ text: \"\" });\n        }\n        if (!child.children[child.children.length - 1].text) {\n          child.children.unshift({ text: \"\" });\n        }\n      } else {\n        child.children.push({ text: \"\" });\n      }\n    }\n    return child;\n  });\n  return {\n    type: ELEMENT_LI,\n    // slate don't allow empty element, we need to provide at least one empty lic node\n    children: childrenWithLicPadded.length > 0 ? childrenWithLicPadded : [{ type: ELEMENT_LIC, children: [{ text: \"\" }] }]\n  };\n}\n\n// src/transform/wikiast-util-to-slate-plate-ast/slateBuilder/text.ts\nvar import_omit = __toESM(require_omit());\nvar textLevelKeysToOmit = [\"type\", \"start\", \"end\"];\nfunction text2(context, text4) {\n  return {\n    text: \"\",\n    // provides default text\n    ...(0, import_omit.default)(text4, textLevelKeysToOmit),\n    ...context.marks\n  };\n}\nfunction mergeSiblingTexts(node) {\n  return {\n    ...node,\n    children: node.children.reduce((accumulator, child) => {\n      const lastChild = accumulator[accumulator.length - 1];\n      if (isText(child)) {\n        if (isText(lastChild)) {\n          return [...accumulator.slice(0, -1), { text: lastChild.text + \"\\n\" + child.text }];\n        }\n        return [...accumulator, child];\n      }\n      return [...accumulator, mergeSiblingTexts(child)];\n    }, [])\n  };\n}\nfunction wrapTextWithP(nodes) {\n  return nodes.map((node) => {\n    if (typeof node.text === \"string\" && node.type === void 0) {\n      return {\n        type: \"p\",\n        children: [node]\n      };\n    }\n    return node;\n  });\n}\n\n// src/transform/wikiast-util-to-slate-plate-ast/slateBuilder/element/blockquote.ts\nfunction blockquote2(context, node) {\n  const children = convertNodes2(context, node.children).flatMap((child) => {\n    if (child.type === \"div\") {\n      return child.children;\n    }\n    return [child];\n  });\n  const result = {\n    type: node.tag,\n    children\n  };\n  return mergeSiblingTexts(result);\n}\n\n// src/transform/wikiast-util-to-slate-plate-ast/slateBuilder/element/marks.ts\nvar markTypeMap2 = {\n  strong: \"bold\",\n  em: \"italic\",\n  u: \"underline\",\n  strike: \"strikethrough\",\n  code: \"code\",\n  sup: \"superscript\",\n  sub: \"subscript\"\n};\nvar markTypes = Object.keys(markTypeMap2);\nfunction toggleMarkFactory(markType) {\n  function toggleMark2(context, node) {\n    const alreadyHaveMark = context.marks[markType] ?? false;\n    context.marks[markType] = true;\n    const result = convertNodes2(context, node.children);\n    if (!alreadyHaveMark) {\n      delete context.marks[markType];\n    }\n    return result;\n  }\n  return toggleMark2;\n}\nvar marks = {};\nfor (const markType of markTypes) {\n  marks[markType] = toggleMarkFactory(markTypeMap2[markType]);\n}\n\n// src/transform/wikiast-util-to-slate-plate-ast/slateBuilder/element/table.ts\nfunction tbody(context, node) {\n  const { children } = node;\n  return convertNodes2(context, children);\n}\nfunction td2(context, node) {\n  const { tag, children } = node;\n  return {\n    type: tag,\n    children: wrapTextWithP(convertNodes2(context, children))\n  };\n}\n\n// src/transform/wikiast-util-to-slate-plate-ast/slateBuilder/element/index.ts\nvar elementBuilders2 = { ul, ol: ul, li, blockquote: blockquote2, ...marks, tbody, td: td2 };\nfunction element2(context, node) {\n  const { tag, children } = node;\n  if (typeof elementBuilders2[tag] === \"function\") {\n    return elementBuilders2[tag](context, node);\n  }\n  return {\n    type: tag,\n    children: convertNodes2(context, children)\n  };\n}\n\n// src/transform/wikiast-util-to-slate-plate-ast/slateBuilder/link.ts\nfunction link(context, node) {\n  const {\n    to: { value: to }\n  } = node.attributes ?? {};\n  const [{ text: text4 }] = node.children ?? [];\n  return {\n    type: \"a\",\n    \"tw-type\": \"link\",\n    url: to,\n    children: [{ text: text4 }]\n  };\n}\n\n// src/editor/plugins/widget/index.ts\nvar ELEMENT_WIDGET = \"widget\";\nvar createWidgetPlugin = createPluginFactory({\n  key: ELEMENT_WIDGET,\n  isElement: true,\n  isVoid: true\n});\n\n// src/transform/wikiast-util-to-slate-plate-ast/slateBuilder/widget.ts\nfunction widget2(context, node) {\n  return {\n    node,\n    type: ELEMENT_WIDGET,\n    isElement: true,\n    isVoid: true,\n    children: [{ text: \"\" }]\n  };\n}\n\n// src/editor/plugins/macro/index.ts\nvar ELEMENT_MACRO = \"macro\";\nvar createMacroPlugin = createPluginFactory({\n  key: ELEMENT_MACRO,\n  isElement: true,\n  isVoid: true\n});\n\n// src/transform/wikiast-util-to-slate-plate-ast/slateBuilder/macro.ts\nfunction macro(context, node) {\n  if (\"tag\" in node) {\n    return context.builders.widget(context, node);\n  }\n  return {\n    node,\n    type: ELEMENT_MACRO,\n    isElement: true,\n    isVoid: true,\n    children: [{ text: \"\" }]\n  };\n}\n\n// src/transform/wikiast-util-to-slate-plate-ast/slateBuilder/codeblock.ts\nfunction codeblock2(context, node) {\n  const language = node.attributes.language?.value ?? \"\";\n  const code3 = node.attributes.code?.value ?? \"\";\n  return {\n    type: ELEMENT_CODE_BLOCK,\n    isElement: true,\n    isVoid: true,\n    language,\n    code: code3,\n    children: [{ text: \"\" }]\n  };\n}\n\n// src/editor/plugins/set/index.ts\nvar ELEMENT_SET = \"set\";\nvar createSetVariablePlugin = createPluginFactory({\n  key: ELEMENT_SET,\n  isElement: true,\n  isVoid: true\n});\n\n// src/transform/wikiast-util-to-slate-plate-ast/slateBuilder/set.ts\nfunction set2(context, node) {\n  const { children, ...nodeWithoutChildren } = node;\n  if (\"tag\" in node) {\n    return {\n      ...context.builders.widget(context, nodeWithoutChildren),\n      children: convertNodes2(context, children)\n    };\n  }\n  return {\n    node: nodeWithoutChildren,\n    type: ELEMENT_SET,\n    isElement: true,\n    isVoid: true,\n    children: convertNodes2(context, children)\n  };\n}\n\n// src/transform/wikiast-util-to-slate-plate-ast/slateBuilder/index.ts\nvar builders2 = {\n  element: element2,\n  text: text2,\n  link,\n  codeblock: codeblock2,\n  /**\n   * We render most tw widgets using tw-react\n   */\n  widget: widget2,\n  image: widget2,\n  tiddler: widget2,\n  macrocall: macro,\n  set: set2\n};\n\n// src/transform/wikiast-util-to-slate-plate-ast/index.ts\nvar initialContext = {\n  builders: builders2,\n  marks: {}\n};\nfunction wikiAstToSlateAst(node, options) {\n  return convertNodes2({ ...initialContext, ...options }, Array.isArray(node) ? node : [node]);\n}\n\n// src/transform/wikiast-util-to-wikitext/index.ts\nvar import_cloneDeep = __toESM(require_cloneDeep());\n\n// node_modules/unist-util-parents/index.js\nvar cache = /* @__PURE__ */ new WeakMap();\nfunction parents(tree) {\n  return wrapNode(tree, null);\n}\nfunction wrapNode(node, parent2) {\n  var proxy;\n  var key;\n  if (cache.has(node)) {\n    return cache.get(node);\n  }\n  proxy = {};\n  for (key in node) {\n    if (key !== \"children\") {\n      proxy[key] = node[key];\n    }\n  }\n  Object.defineProperty(proxy, \"node\", {\n    writable: true,\n    configurable: true,\n    value: node\n  });\n  Object.defineProperty(proxy, \"parent\", {\n    configurable: true,\n    get: getParent,\n    set: setParent\n  });\n  if (node.children) {\n    Object.defineProperty(proxy, \"children\", {\n      enumerable: true,\n      configurable: true,\n      get: getChildren3\n    });\n  }\n  cache.set(node, proxy);\n  return proxy;\n  function getParent() {\n    return parent2;\n  }\n  function setParent(newParent) {\n    parent2 = newParent;\n  }\n  function getChildren3() {\n    return node.children.map((c5) => wrapNode(c5, proxy));\n  }\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/element/a.ts\nfunction a4(context, node) {\n  const { attributes, children } = node;\n  if (attributes?.class?.value?.includes(\"tc-tiddlylink-external\")) {\n    return context.builders.link(\n      context,\n      {\n        type: \"link\",\n        attributes: {\n          to: attributes.href\n        },\n        children\n      },\n      { prefix: \"ext\" }\n    );\n  }\n  const jsxResult = context.builders.jsx(context, node);\n  return jsxResult;\n}\n\n// src/transform/wikiast-util-to-wikitext/traverse.ts\nfunction convertNodes3(context, nodes) {\n  const isRoot = context.root;\n  context.root = false;\n  const previousStackIndex = context.index;\n  context.index = 0;\n  if (nodes === void 0 || nodes.length === 0) {\n    return [];\n  }\n  const result = nodes.reduce((accumulator, node) => {\n    const result2 = [...accumulator, ...convertOneNode(context, node)];\n    context.index += 1;\n    return isRoot ? [...result2, \"\\n\"] : result2;\n  }, []);\n  context.index = previousStackIndex;\n  return result;\n}\nfunction convertOneNode(context, node) {\n  const { builders: builders4 } = context;\n  let result = [];\n  if (node.type in builders4) {\n    const builder = builders4[node.type];\n    if (typeof builder === \"function\") {\n      const builtSlateNodeOrNodes = builder(context, node);\n      result = Array.isArray(builtSlateNodeOrNodes) ? builtSlateNodeOrNodes : [builtSlateNodeOrNodes];\n    }\n  } else {\n    if (typeof node.type === \"string\" && \"tag\" in node && typeof node.tag === \"string\") {\n      result = builders4.widget(context, node);\n    }\n  }\n  return node.isBlock === true ? [...result, \"\\n\"] : result;\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/element/p.ts\nfunction p3(context, { type, tag, children }) {\n  return [...convertNodes3(context, children), \"\\n\"];\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/element/div.ts\nfunction div(context, { type, tag, children }) {\n  return convertNodes3(context, children);\n}\n\n// src/transform/token-stream-utils/dropExtraTailingN.ts\nvar import_dropRightWhile = __toESM(require_dropRightWhile());\nfunction dropExtraTailingN(tokens) {\n  const listWithoutNToken = (0, import_dropRightWhile.default)(tokens, (token) => token === \"\\n\" || token === \"\\n\\n\");\n  if (listWithoutNToken[listWithoutNToken.length - 1]?.endsWith?.(\"\\n\")) {\n    listWithoutNToken[listWithoutNToken.length - 1] = listWithoutNToken[listWithoutNToken.length - 1].slice(\n      0,\n      listWithoutNToken[listWithoutNToken.length - 1].length - 1\n    );\n  }\n  return listWithoutNToken;\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/element/ul.ts\nfunction ul2(context, { tag, children, parent: parent2 }) {\n  context.indentLevels += 1;\n  const alreadyInList = context.listMode !== void 0;\n  context.listMode = tag;\n  const result = convertNodes3(context, children);\n  context.indentLevels -= 1;\n  const tagOfNextSibling = parent2?.children?.[context.index]?.tag;\n  if (tagOfNextSibling !== \"ul\" && tagOfNextSibling !== \"ol\" && tagOfNextSibling !== \"li\") {\n    context.listMode = void 0;\n  }\n  let needExtraN = false;\n  if (context.indentLevels === -1) {\n    needExtraN = !((tagOfNextSibling === \"ul\" || tagOfNextSibling === \"ol\") && tagOfNextSibling !== tag || tagOfNextSibling === \"blockquote\");\n  }\n  const listResultWithN = needExtraN ? (\n    // add empty line between list and following non-list content\n    [...dropExtraTailingN(result), \"\\n\"]\n  ) : (\n    // change line if we are nested list (means this ol is inside a li, and should change line), see test case `ol > li > mark > text` for example\n    [alreadyInList ? \"\\n\" : \"\", ...result]\n  );\n  return listResultWithN;\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/element/li.ts\nvar import_repeat = __toESM(require_repeat());\nvar import_unist_util_find = __toESM(require_unist_util_find());\nfunction li2(context, node) {\n  const listItemDot = context.listMode === \"ul\" ? \"*\" : \"#\";\n  const childTextContent = convertNodes3(context, node.children);\n  const isLeafLi = (0, import_unist_util_find.default)({ ...node, tag: void 0 }, { tag: \"li\" }) === void 0;\n  return [`${(0, import_repeat.default)(listItemDot, context.indentLevels + 1)} ${childTextContent.join(\"\")}`, isLeafLi ? \"\\n\" : \"\"];\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/element/h1.ts\nvar import_repeat2 = __toESM(require_repeat());\nfunction h1(context, node) {\n  const { attributes, children, tag } = node;\n  if (!attributes?.class?.value) {\n    const level = Number(tag.replace(\"h\", \"\"));\n    return [(0, import_repeat2.default)(\"!\", level), \" \", ...convertNodes3(context, children), \"\\n\"];\n  }\n  const jsxResult = context.builders.jsx(context, node);\n  return jsxResult;\n}\nvar headings = { h1, h2: h1, h3: h1, h4: h1, h5: h1, h6: h1 };\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/element/blockquote.ts\nfunction blockquote3(context, { type, tag, children }) {\n  if (children === void 0 || children.length === 0) {\n    return [];\n  }\n  if (children[0].tag === \"div\") {\n    const texts = convertNodes3(context, children);\n    return texts.map((line) => `> ${line}\n`);\n  }\n  return [`<<<`, ...convertNodes3(context, children), `<<<`, \"\\n\"];\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/element/marks.ts\nvar markTypeMap3 = {\n  strong: `''`,\n  em: \"//\",\n  u: \"__\",\n  strike: \"~~\",\n  code: \"`\",\n  sup: \"^^\",\n  sub: \",,\"\n};\nvar markTypes2 = Object.keys(markTypeMap3);\nfunction toggleMarkFactory2(markType) {\n  function toggleMark2(context, node) {\n    const alreadyHaveMark = context.marks[markType] ?? false;\n    context.marks[markType] = true;\n    const result = convertNodes3(context, node.children);\n    if (!alreadyHaveMark) {\n      delete context.marks[markType];\n    }\n    return [`${markTypeMap3[markType]}${result.join(\"\")}${markTypeMap3[markType]}`];\n  }\n  return toggleMark2;\n}\nvar marks2 = {};\nfor (const markType of markTypes2) {\n  marks2[markType] = toggleMarkFactory2(markType);\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/element/table.ts\nfunction table2(context, { type, tag, children }) {\n  return convertNodes3(context, children);\n}\nfunction tbody2(context, { type, tag, children }) {\n  return convertNodes3(context, children);\n}\nfunction tr(context, { type, tag, children }) {\n  return [\"|\", ...convertNodes3(context, children).join(\"|\"), \"|\\n\"];\n}\nfunction td3(context, { type, tag, children }) {\n  return convertNodes3(context, children);\n}\nvar tableTags = { table: table2, tbody: tbody2, tr, td: td3 };\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/element/index.ts\nvar elementBuilders3 = { a: a4, p: p3, div, ul: ul2, ol: ul2, li: li2, blockquote: blockquote3, ...marks2, ...headings, ...tableTags };\nfunction element3(context, node) {\n  const { tag } = node;\n  const { builders: builders4 } = context;\n  if (typeof builders4[tag] === \"function\") {\n    return builders4[tag](context, node);\n  }\n  return builders4.jsx(context, node);\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/text.ts\nfunction text3(context, node) {\n  return [node.text];\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/link.ts\nfunction link2(context, node, options) {\n  const { prefix = \"\" } = options ?? {};\n  const {\n    to: { value: to }\n  } = node.attributes ?? {};\n  const [{ text: text4 }] = node.children ?? [];\n  return [`[${prefix}[`, text4, to !== text4 ? `|${to}` : \"\", `]]`];\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/jsx.ts\nfunction jsx2(context, node, options) {\n  const { prefix = \"\" } = options ?? {};\n  const { tag, isSelfClosing, orderedAttributes, attributes, children } = node;\n  const attributeList = orderedAttributes !== void 0 ? orderedAttributes : attributes !== void 0 ? Object.keys(attributes).map((key) => attributes[key]) : [];\n  const kvPairs = attributeList.map((attributeNode) => {\n    const builder = context.builders[attributeNode.type];\n    const value = builder(context, attributeNode).join(\"\");\n    const valueWithQuote = attributeNode.type === \"macro\" ? value : `\"${value}\"`;\n    return `${attributeNode.name}=${valueWithQuote}`;\n  }).join(\" \");\n  const jsxResult = isSelfClosing ? [`<${prefix}${tag} ${kvPairs}/>`] : [`<${prefix}${tag} ${kvPairs}>`, ...convertNodes3(context, children), `</${prefix}${tag}>`];\n  return jsxResult;\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/image.ts\nfunction image(context, node) {\n  const width = node.attributes?.width !== void 0 ? ` width=${String(node.attributes.width.value)}` : \"\";\n  const whiteSpace = width ? \" \" : \"\";\n  const tooltip = node.attributes?.tooltip !== void 0 ? `${String(node.attributes.tooltip.value)}|` : \"\";\n  const source = node.attributes?.source !== void 0 ? node.attributes.source.value : \"\";\n  return [`[img${width}${whiteSpace}[${tooltip}${String(source)}]]`];\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/transclude.ts\nfunction tiddler(context, node) {\n  const source = node.attributes?.tiddler !== void 0 ? node.attributes.tiddler.value : \"\";\n  const templateName = node.children?.[0]?.attributes?.tiddler?.value;\n  const templatePart = templateName !== void 0 && templateName !== source ? `|${templateName}` : \"\";\n  return [`{{${source}${templatePart}}}`];\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/widget.ts\nfunction widget3(context, node) {\n  const jsxResult = context.builders.jsx(context, node);\n  return jsxResult;\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/macro.ts\nfunction macro2(context, node) {\n  if (typeof node.value === \"string\")\n    return [node.value];\n  const macroType = node.value?.type;\n  return macroType in context.builders ? context.builders[macroType](context, node.value) : [];\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/macrocall.ts\nfunction macrocall(context, node) {\n  const { name, params, tag } = node;\n  if (tag === \"$macrocall\") {\n    return context.builders.widget(context, node);\n  }\n  if (name === void 0)\n    return [];\n  const parameterString = params?.flatMap((parameter) => {\n    const parameterKeyString = parameter.name ? `${parameter.name}:` : \"\";\n    const parameterValues = context.builders[parameter.type]?.(context, parameter) ?? [];\n    return parameterValues.map((text4) => text4.includes(\" \") ? `\"${text4}\"` : text4).map((value) => `${parameterKeyString}${value}`);\n  }).join(\" \");\n  return [`<<`, name, parameterString === void 0 ? \"\" : ` ${parameterString}`, `>>`];\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/set.ts\nfunction set3(context, node) {\n  const { attributes, children, tag } = node;\n  const childrenTexts = convertNodes3(context, children);\n  if (tag === \"$set\") {\n    return [...context.builders.widget(context, node), ...childrenTexts];\n  }\n  if (attributes === void 0)\n    return [];\n  const name = attributes?.name?.value ?? \"\";\n  const value = attributes?.value?.value ?? \"\";\n  if (!name)\n    return [];\n  return [`\\\\define`, \" \", `${name}()`, \" \", value, \"\\n\\n\", ...childrenTexts];\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/string.ts\nfunction string(context, node) {\n  return [String(node.value)];\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/codeblock.ts\nfunction codeblock3(context, node) {\n  const language = node.attributes.language?.value ?? \"\";\n  const code3 = node.attributes.code?.value ?? \"\";\n  return [`\\`\\`\\``, language, \"\\n\", code3, \"\\n\", `\\`\\`\\``];\n}\n\n// src/transform/wikiast-util-to-wikitext/astSerializer/index.ts\nvar builders3 = {\n  element: element3,\n  ...elementBuilders3,\n  text: text3,\n  image,\n  tiddler,\n  link: link2,\n  jsx: jsx2,\n  widget: widget3,\n  macro: macro2,\n  macrocall,\n  set: set3,\n  string,\n  codeblock: codeblock3,\n  \"macro-parameter\": string,\n  number: string,\n  bigint: string,\n  boolean: string\n};\n\n// src/transform/wikiast-util-to-wikitext/index.ts\nvar import_repeat3 = __toESM(require_repeat());\nvar defaultContext = {\n  builders: builders3,\n  indentLevels: -1,\n  index: 0,\n  listMode: void 0,\n  marks: {},\n  nodes: [],\n  root: true\n};\nfunction wikiAstToWikiText(input, options) {\n  const { extraTailingNCount = 0 } = options ?? {};\n  const nodes = Array.isArray(input) ? input.map((node) => parents(node)) : [parents(input)];\n  const lines = convertNodes3((0, import_cloneDeep.default)((0, import_cloneDeep.default)({ ...defaultContext, nodes })), nodes);\n  return dropExtraTailingN(lines).join(\"\") + (0, import_repeat3.default)(\"\\n\", extraTailingNCount);\n}\n\n// src/transform/serialize.ts\nfunction serialize(value) {\n  const wikiAst = wikiAstFromSlateAst(value);\n  const shouldAddTailingN = wikiAst.length > 1 && wikiAst[wikiAst.length - 1].isBlock === true;\n  return wikiAstToWikiText(wikiAst, { extraTailingNCount: shouldAddTailingN ? 1 : 0 });\n}\nfunction deserialize(input, options) {\n  return wikiAstToSlateAst(wikiAstFromWikiText(input), options);\n}\n\n// node_modules/@udecode/plate-autoformat/dist/index.es.js\nfunction unwrapExports4(x4) {\n  return x4 && x4.__esModule && Object.prototype.hasOwnProperty.call(x4, \"default\") ? x4[\"default\"] : x4;\n}\nfunction createCommonjsModule6(fn4, module2) {\n  return module2 = { exports: {} }, fn4(module2, module2.exports), module2.exports;\n}\nvar lib4 = createCommonjsModule6(function(module2, exports2) {\n  Object.defineProperty(exports2, \"__esModule\", {\n    value: true\n  });\n  var IS_MAC = () => typeof window != \"undefined\" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n  var MODIFIERS = {\n    alt: \"altKey\",\n    control: \"ctrlKey\",\n    meta: \"metaKey\",\n    shift: \"shiftKey\"\n  };\n  var ALIASES = () => ({\n    add: \"+\",\n    break: \"pause\",\n    cmd: \"meta\",\n    command: \"meta\",\n    ctl: \"control\",\n    ctrl: \"control\",\n    del: \"delete\",\n    down: \"arrowdown\",\n    esc: \"escape\",\n    ins: \"insert\",\n    left: \"arrowleft\",\n    mod: IS_MAC() ? \"meta\" : \"control\",\n    opt: \"alt\",\n    option: \"alt\",\n    return: \"enter\",\n    right: \"arrowright\",\n    space: \" \",\n    spacebar: \" \",\n    up: \"arrowup\",\n    win: \"meta\",\n    windows: \"meta\"\n  });\n  var CODES = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    shift: 16,\n    control: 17,\n    alt: 18,\n    pause: 19,\n    capslock: 20,\n    escape: 27,\n    \" \": 32,\n    pageup: 33,\n    pagedown: 34,\n    end: 35,\n    home: 36,\n    arrowleft: 37,\n    arrowup: 38,\n    arrowright: 39,\n    arrowdown: 40,\n    insert: 45,\n    delete: 46,\n    meta: 91,\n    numlock: 144,\n    scrolllock: 145,\n    \";\": 186,\n    \"=\": 187,\n    \",\": 188,\n    \"-\": 189,\n    \".\": 190,\n    \"/\": 191,\n    \"`\": 192,\n    \"[\": 219,\n    \"\\\\\": 220,\n    \"]\": 221,\n    \"'\": 222\n  };\n  for (var f5 = 1; f5 < 20; f5++) {\n    CODES[\"f\" + f5] = 111 + f5;\n  }\n  function isHotkey9(hotkey, options, event) {\n    if (options && !(\"byKey\" in options)) {\n      event = options;\n      options = null;\n    }\n    if (!Array.isArray(hotkey)) {\n      hotkey = [hotkey];\n    }\n    var array = hotkey.map(function(string2) {\n      return parseHotkey(string2, options);\n    });\n    var check = function check2(e4) {\n      return array.some(function(object) {\n        return compareHotkey(object, e4);\n      });\n    };\n    var ret = event == null ? check : check(event);\n    return ret;\n  }\n  function isCodeHotkey(hotkey, event) {\n    return isHotkey9(hotkey, event);\n  }\n  function isKeyHotkey2(hotkey, event) {\n    return isHotkey9(hotkey, { byKey: true }, event);\n  }\n  function parseHotkey(hotkey, options) {\n    var byKey = options && options.byKey;\n    var ret = {};\n    hotkey = hotkey.replace(\"++\", \"+add\");\n    var values2 = hotkey.split(\"+\");\n    var length = values2.length;\n    for (var k3 in MODIFIERS) {\n      ret[MODIFIERS[k3]] = false;\n    }\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = void 0;\n    try {\n      for (var _iterator = values2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var value = _step.value;\n        var optional = value.endsWith(\"?\") && value.length > 1;\n        if (optional) {\n          value = value.slice(0, -1);\n        }\n        var name = toKeyName(value);\n        var modifier = MODIFIERS[name];\n        if (length === 1 || !modifier) {\n          if (byKey) {\n            ret.key = name;\n          } else {\n            ret.which = toKeyCode(value);\n          }\n        }\n        if (modifier) {\n          ret[modifier] = optional ? null : true;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    return ret;\n  }\n  function compareHotkey(object, event) {\n    for (var key in object) {\n      var expected = object[key];\n      var actual = void 0;\n      if (expected == null) {\n        continue;\n      }\n      if (key === \"key\" && event.key != null) {\n        actual = event.key.toLowerCase();\n      } else if (key === \"which\") {\n        actual = expected === 91 && event.which === 93 ? 91 : event.which;\n      } else {\n        actual = event[key];\n      }\n      if (actual == null && expected === false) {\n        continue;\n      }\n      if (actual !== expected) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function toKeyCode(name) {\n    name = toKeyName(name);\n    var code3 = CODES[name] || name.toUpperCase().charCodeAt(0);\n    return code3;\n  }\n  function toKeyName(name) {\n    name = name.toLowerCase();\n    name = ALIASES()[name] || name;\n    return name;\n  }\n  exports2.default = isHotkey9;\n  exports2.isHotkey = isHotkey9;\n  exports2.isCodeHotkey = isCodeHotkey;\n  exports2.isKeyHotkey = isKeyHotkey2;\n  exports2.parseHotkey = parseHotkey;\n  exports2.compareHotkey = compareHotkey;\n  exports2.toKeyCode = toKeyCode;\n  exports2.toKeyName = toKeyName;\n});\nvar isHotkey4 = unwrapExports4(lib4);\nlib4.isHotkey;\nlib4.isCodeHotkey;\nlib4.isKeyHotkey;\nlib4.parseHotkey;\nlib4.compareHotkey;\nlib4.toKeyCode;\nlib4.toKeyName;\nvar onKeyDownAutoformat = (editor, {\n  options: {\n    rules,\n    enableUndoOnDelete\n  }\n}) => (e4) => {\n  if (!isHotkey4(\"backspace\", {\n    byKey: true\n  }, e4))\n    return false;\n  if (!rules)\n    return false;\n  if (!enableUndoOnDelete)\n    return false;\n  const {\n    selection\n  } = editor;\n  if (!selection || !Range.isCollapsed(selection))\n    return;\n  const [start2, end2] = Range.edges(selection);\n  const before = getPointBefore(editor, end2, {\n    unit: \"character\",\n    distance: 1\n  });\n  if (!start2)\n    return false;\n  if (!before)\n    return false;\n  const charRange = {\n    anchor: before,\n    focus: start2\n  };\n  if (!charRange)\n    return false;\n  const char = getEditorString(editor, charRange);\n  if (!char)\n    return false;\n  const matchers = [...rules].filter((rule2) => {\n    const textRule = rule2;\n    if (textRule) {\n      return textRule.mode === \"text\" && textRule.format === char;\n    }\n    return false;\n  });\n  if (!matchers || matchers.length === 0)\n    return false;\n  e4.preventDefault();\n  deleteBackward(editor, {\n    unit: \"character\"\n  });\n  const rule = matchers[0];\n  if (rule && typeof rule.match === \"string\") {\n    insertText(editor, rule.match);\n  } else {\n    const matchArray = rule.match;\n    if (matchArray && matchArray.length > 0) {\n      insertText(editor, matchArray[0]);\n    }\n  }\n  return true;\n};\nvar isArray5 = Array.isArray;\nvar isArray_14 = isArray5;\nfunction castArray3() {\n  if (!arguments.length) {\n    return [];\n  }\n  var value = arguments[0];\n  return isArray_14(value) ? value : [value];\n}\nvar castArray_13 = castArray3;\nvar getMatchRange = ({\n  match: match2,\n  trigger: trigger2\n}) => {\n  let start2;\n  let end2;\n  if (typeof match2 === \"object\") {\n    start2 = match2.start;\n    end2 = match2.end;\n  } else {\n    start2 = match2;\n    end2 = start2.split(\"\").reverse().join(\"\");\n  }\n  const triggers = trigger2 ? castArray_13(trigger2) : [end2.slice(-1)];\n  end2 = trigger2 ? end2 : end2.slice(0, -1);\n  return {\n    start: start2,\n    end: end2,\n    triggers\n  };\n};\nvar autoformatBlock = (editor, {\n  text: text4,\n  trigger: trigger2,\n  match: _match,\n  type = ELEMENT_DEFAULT,\n  allowSameTypeAbove = false,\n  preFormat,\n  format: format3,\n  triggerAtBlockStart = true\n}) => {\n  const matches = castArray_13(_match);\n  for (const match2 of matches) {\n    const {\n      end: end2,\n      triggers\n    } = getMatchRange({\n      match: {\n        start: \"\",\n        end: match2\n      },\n      trigger: trigger2\n    });\n    if (!triggers.includes(text4))\n      continue;\n    let matchRange;\n    if (triggerAtBlockStart) {\n      matchRange = getRangeFromBlockStart(editor);\n      const hasVoidNode = someNode(editor, {\n        at: matchRange,\n        match: (n8) => isVoid(editor, n8)\n      });\n      if (hasVoidNode)\n        continue;\n      const textFromBlockStart = getEditorString(editor, matchRange);\n      if (end2 !== textFromBlockStart)\n        continue;\n    } else {\n      matchRange = getRangeBefore(editor, editor.selection, {\n        matchString: end2\n      });\n      if (!matchRange)\n        continue;\n    }\n    if (!allowSameTypeAbove) {\n      const isBelowSameBlockType = someNode(editor, {\n        match: {\n          type\n        }\n      });\n      if (isBelowSameBlockType)\n        continue;\n    }\n    if (match2.length > 1) {\n      deleteText(editor, {\n        at: matchRange\n      });\n    }\n    if (preFormat) {\n      preFormat(editor);\n    }\n    if (!format3) {\n      setElements(editor, {\n        type\n      }, {\n        match: (n8) => isBlock(editor, n8)\n      });\n    } else {\n      format3(editor);\n    }\n    return true;\n  }\n  return false;\n};\nvar isPreviousCharacterEmpty = (editor, at) => {\n  const range = getRangeBefore(editor, at);\n  if (range) {\n    const text4 = getEditorString(editor, range);\n    if (text4) {\n      const noWhiteSpaceRegex = new RegExp(`\\\\S+`);\n      return !text4.match(noWhiteSpaceRegex);\n    }\n  }\n  return true;\n};\nvar getMatchPoints = (editor, {\n  start: start2,\n  end: end2\n}) => {\n  const selection = editor.selection;\n  let beforeEndMatchPoint = selection.anchor;\n  if (end2) {\n    beforeEndMatchPoint = getPointBeforeLocation(editor, selection, {\n      matchString: end2\n    });\n    if (!beforeEndMatchPoint)\n      return;\n  }\n  let afterStartMatchPoint;\n  let beforeStartMatchPoint;\n  if (start2) {\n    afterStartMatchPoint = getPointBeforeLocation(editor, beforeEndMatchPoint, {\n      matchString: start2,\n      skipInvalid: true,\n      afterMatch: true\n    });\n    if (!afterStartMatchPoint)\n      return;\n    beforeStartMatchPoint = getPointBeforeLocation(editor, beforeEndMatchPoint, {\n      matchString: start2,\n      skipInvalid: true\n    });\n    if (!isPreviousCharacterEmpty(editor, beforeStartMatchPoint))\n      return;\n  }\n  return {\n    afterStartMatchPoint,\n    beforeStartMatchPoint,\n    beforeEndMatchPoint\n  };\n};\nvar autoformatMark = (editor, {\n  type,\n  text: text4,\n  trigger: trigger2,\n  match: _match,\n  ignoreTrim\n}) => {\n  if (!type)\n    return false;\n  const selection = editor.selection;\n  const matches = castArray_13(_match);\n  for (const match2 of matches) {\n    const {\n      start: start2,\n      end: end2,\n      triggers\n    } = getMatchRange({\n      match: match2,\n      trigger: trigger2\n    });\n    if (!triggers.includes(text4))\n      continue;\n    const matched = getMatchPoints(editor, {\n      start: start2,\n      end: end2\n    });\n    if (!matched)\n      continue;\n    const {\n      afterStartMatchPoint,\n      beforeEndMatchPoint,\n      beforeStartMatchPoint\n    } = matched;\n    const matchRange = {\n      anchor: afterStartMatchPoint,\n      focus: beforeEndMatchPoint\n    };\n    if (!ignoreTrim) {\n      const matchText = getEditorString(editor, matchRange);\n      if (matchText.trim() !== matchText)\n        continue;\n    }\n    if (end2) {\n      deleteText(editor, {\n        at: {\n          anchor: beforeEndMatchPoint,\n          focus: selection.anchor\n        }\n      });\n    }\n    const marks3 = castArray_13(type);\n    select(editor, matchRange);\n    marks3.forEach((mark) => {\n      editor.addMark(mark, true);\n    });\n    collapseSelection(editor, {\n      edge: \"end\"\n    });\n    removeMark(editor, {\n      key: marks3,\n      shouldChange: false\n    });\n    deleteText(editor, {\n      at: {\n        anchor: beforeStartMatchPoint,\n        focus: afterStartMatchPoint\n      }\n    });\n    return true;\n  }\n  return false;\n};\nvar autoformatText = (editor, {\n  text: text4,\n  match: _match,\n  trigger: trigger2,\n  format: format3\n}) => {\n  const selection = editor.selection;\n  const matches = castArray_13(_match);\n  for (const match2 of matches) {\n    const {\n      start: start2,\n      end: end2,\n      triggers\n    } = getMatchRange({\n      match: Array.isArray(format3) ? match2 : {\n        start: \"\",\n        end: match2\n      },\n      trigger: trigger2\n    });\n    if (!triggers.includes(text4))\n      continue;\n    const matched = getMatchPoints(editor, {\n      start: start2,\n      end: end2\n    });\n    if (!matched)\n      continue;\n    const {\n      afterStartMatchPoint,\n      beforeEndMatchPoint,\n      beforeStartMatchPoint\n    } = matched;\n    if (end2) {\n      deleteText(editor, {\n        at: {\n          anchor: beforeEndMatchPoint,\n          focus: selection.anchor\n        }\n      });\n    }\n    if (typeof format3 === \"function\") {\n      format3(editor, matched);\n    } else {\n      const formatEnd = Array.isArray(format3) ? format3[1] : format3;\n      editor.insertText(formatEnd);\n      if (beforeStartMatchPoint) {\n        const formatStart = Array.isArray(format3) ? format3[0] : format3;\n        deleteText(editor, {\n          at: {\n            anchor: beforeStartMatchPoint,\n            focus: afterStartMatchPoint\n          }\n        });\n        insertText(editor, formatStart, {\n          at: beforeStartMatchPoint\n        });\n      }\n    }\n    return true;\n  }\n  return false;\n};\nvar withAutoformat = (editor, {\n  options: {\n    rules\n  }\n}) => {\n  const {\n    insertText: insertText2\n  } = editor;\n  editor.insertText = (text4) => {\n    if (!isCollapsed(editor.selection))\n      return insertText2(text4);\n    for (const rule of rules) {\n      var _autoformatter$mode;\n      const {\n        mode = \"text\",\n        insertTrigger,\n        query\n      } = rule;\n      if (query && !query(editor, {\n        ...rule,\n        text: text4\n      }))\n        continue;\n      const autoformatter = {\n        block: autoformatBlock,\n        mark: autoformatMark,\n        text: autoformatText\n      };\n      if ((_autoformatter$mode = autoformatter[mode]) !== null && _autoformatter$mode !== void 0 && _autoformatter$mode.call(autoformatter, editor, {\n        ...rule,\n        text: text4\n      })) {\n        return insertTrigger && insertText2(text4);\n      }\n    }\n    insertText2(text4);\n  };\n  return editor;\n};\nvar KEY_AUTOFORMAT = \"autoformat\";\nvar createAutoformatPlugin = createPluginFactory({\n  key: KEY_AUTOFORMAT,\n  withOverrides: withAutoformat,\n  handlers: {\n    onKeyDown: onKeyDownAutoformat\n  },\n  options: {\n    rules: []\n  }\n});\nvar autoformatComparison = [{\n  mode: \"text\",\n  match: \"!>\",\n  format: \"\\u226F\"\n}, {\n  mode: \"text\",\n  match: \"!<\",\n  format: \"\\u226E\"\n}, {\n  mode: \"text\",\n  match: \">=\",\n  format: \"\\u2265\"\n}, {\n  mode: \"text\",\n  match: \"<=\",\n  format: \"\\u2264\"\n}, {\n  mode: \"text\",\n  match: \"!>=\",\n  format: \"\\u2271\"\n}, {\n  mode: \"text\",\n  match: \"!<=\",\n  format: \"\\u2270\"\n}];\nvar autoformatEquality = [{\n  mode: \"text\",\n  match: \"!=\",\n  format: \"\\u2260\"\n}, {\n  mode: \"text\",\n  match: \"==\",\n  format: \"\\u2261\"\n}, {\n  mode: \"text\",\n  match: [\"!==\", \"\\u2260=\"],\n  format: \"\\u2262\"\n}, {\n  mode: \"text\",\n  match: \"~=\",\n  format: \"\\u2248\"\n}, {\n  mode: \"text\",\n  match: \"!~=\",\n  format: \"\\u2249\"\n}];\nvar autoformatFraction = [{\n  mode: \"text\",\n  match: \"1/2\",\n  format: \"\\xBD\"\n}, {\n  mode: \"text\",\n  match: \"1/3\",\n  format: \"\\u2153\"\n}, {\n  mode: \"text\",\n  match: \"1/4\",\n  format: \"\\xBC\"\n}, {\n  mode: \"text\",\n  match: \"1/5\",\n  format: \"\\u2155\"\n}, {\n  mode: \"text\",\n  match: \"1/6\",\n  format: \"\\u2159\"\n}, {\n  mode: \"text\",\n  match: \"1/7\",\n  format: \"\\u2150\"\n}, {\n  mode: \"text\",\n  match: \"1/8\",\n  format: \"\\u215B\"\n}, {\n  mode: \"text\",\n  match: \"1/9\",\n  format: \"\\u2151\"\n}, {\n  mode: \"text\",\n  match: \"1/10\",\n  format: \"\\u2152\"\n}, {\n  mode: \"text\",\n  match: \"2/3\",\n  format: \"\\u2154\"\n}, {\n  mode: \"text\",\n  match: \"2/5\",\n  format: \"\\u2156\"\n}, {\n  mode: \"text\",\n  match: \"3/4\",\n  format: \"\\xBE\"\n}, {\n  mode: \"text\",\n  match: \"3/5\",\n  format: \"\\u2157\"\n}, {\n  mode: \"text\",\n  match: \"3/8\",\n  format: \"\\u215C\"\n}, {\n  mode: \"text\",\n  match: \"4/5\",\n  format: \"\\u2158\"\n}, {\n  mode: \"text\",\n  match: \"5/6\",\n  format: \"\\u215A\"\n}, {\n  mode: \"text\",\n  match: \"5/8\",\n  format: \"\\u215D\"\n}, {\n  mode: \"text\",\n  match: \"7/8\",\n  format: \"\\u215E\"\n}];\nvar autoformatDivision = [{\n  mode: \"text\",\n  match: \"//\",\n  format: \"\\xF7\"\n}];\nvar autoformatOperation = [{\n  mode: \"text\",\n  match: \"+-\",\n  format: \"\\xB1\"\n}, {\n  mode: \"text\",\n  match: \"%%\",\n  format: \"\\u2030\"\n}, {\n  mode: \"text\",\n  match: [\"%%%\", \"\\u2030%\"],\n  format: \"\\u2031\"\n}, ...autoformatDivision];\nvar autoformatSubscriptNumbers = [{\n  mode: \"text\",\n  match: \"~0\",\n  format: \"\\u2080\"\n}, {\n  mode: \"text\",\n  match: \"~1\",\n  format: \"\\u2081\"\n}, {\n  mode: \"text\",\n  match: \"~2\",\n  format: \"\\u2082\"\n}, {\n  mode: \"text\",\n  match: \"~3\",\n  format: \"\\u2083\"\n}, {\n  mode: \"text\",\n  match: \"~4\",\n  format: \"\\u2084\"\n}, {\n  mode: \"text\",\n  match: \"~5\",\n  format: \"\\u2085\"\n}, {\n  mode: \"text\",\n  match: \"~6\",\n  format: \"\\u2086\"\n}, {\n  mode: \"text\",\n  match: \"~7\",\n  format: \"\\u2087\"\n}, {\n  mode: \"text\",\n  match: \"~8\",\n  format: \"\\u2088\"\n}, {\n  mode: \"text\",\n  match: \"~9\",\n  format: \"\\u2089\"\n}];\nvar autoformatSubscriptSymbols = [{\n  mode: \"text\",\n  match: \"~+\",\n  format: \"\\u208A\"\n}, {\n  mode: \"text\",\n  match: \"~-\",\n  format: \"\\u208B\"\n}];\nvar autoformatSuperscriptNumbers = [{\n  mode: \"text\",\n  match: \"^0\",\n  format: \"\\u2070\"\n}, {\n  mode: \"text\",\n  match: \"^1\",\n  format: \"\\xB9\"\n}, {\n  mode: \"text\",\n  match: \"^2\",\n  format: \"\\xB2\"\n}, {\n  mode: \"text\",\n  match: \"^3\",\n  format: \"\\xB3\"\n}, {\n  mode: \"text\",\n  match: \"^4\",\n  format: \"\\u2074\"\n}, {\n  mode: \"text\",\n  match: \"^5\",\n  format: \"\\u2075\"\n}, {\n  mode: \"text\",\n  match: \"^6\",\n  format: \"\\u2076\"\n}, {\n  mode: \"text\",\n  match: \"^7\",\n  format: \"\\u2077\"\n}, {\n  mode: \"text\",\n  match: \"^8\",\n  format: \"\\u2078\"\n}, {\n  mode: \"text\",\n  match: \"^9\",\n  format: \"\\u2079\"\n}];\nvar autoformatSuperscriptSymbols = [{\n  mode: \"text\",\n  match: \"^o\",\n  format: \"\\xB0\"\n}, {\n  mode: \"text\",\n  match: \"^+\",\n  format: \"\\u207A\"\n}, {\n  mode: \"text\",\n  match: \"^-\",\n  format: \"\\u207B\"\n}];\nvar autoformatMath = [...autoformatComparison, ...autoformatEquality, ...autoformatOperation, ...autoformatFraction, ...autoformatSuperscriptSymbols, ...autoformatSubscriptSymbols, ...autoformatSuperscriptNumbers, ...autoformatSubscriptNumbers];\n\n// node_modules/@udecode/plate-block-quote/dist/index.es.js\nvar ELEMENT_BLOCKQUOTE = \"blockquote\";\nvar createBlockquotePlugin = createPluginFactory({\n  key: ELEMENT_BLOCKQUOTE,\n  isElement: true,\n  deserializeHtml: {\n    rules: [{\n      validNodeName: \"BLOCKQUOTE\"\n    }]\n  },\n  handlers: {\n    onKeyDown: onKeyDownToggleElement\n  },\n  options: {\n    hotkey: \"mod+shift+.\"\n  }\n});\n\n// node_modules/@udecode/plate-basic-marks/dist/index.es.js\nvar MARK_BOLD = \"bold\";\nvar createBoldPlugin = createPluginFactory({\n  key: MARK_BOLD,\n  isLeaf: true,\n  deserializeHtml: {\n    rules: [{\n      validNodeName: [\"STRONG\", \"B\"]\n    }, {\n      validStyle: {\n        fontWeight: [\"600\", \"700\", \"bold\"]\n      }\n    }],\n    query: (el) => !someHtmlElement(el, (node) => node.style.fontWeight === \"normal\")\n  },\n  handlers: {\n    onKeyDown: onKeyDownToggleMark\n  },\n  options: {\n    hotkey: \"mod+b\"\n  }\n});\nvar MARK_CODE = \"code\";\nvar createCodePlugin = createPluginFactory({\n  key: MARK_CODE,\n  isLeaf: true,\n  deserializeHtml: {\n    rules: [{\n      validNodeName: [\"CODE\"]\n    }, {\n      validStyle: {\n        wordWrap: \"break-word\"\n      }\n    }, {\n      validStyle: {\n        fontFamily: \"Consolas\"\n      }\n    }],\n    query(el) {\n      const blockAbove = findHtmlParentElement(el, \"P\");\n      if ((blockAbove === null || blockAbove === void 0 ? void 0 : blockAbove.style.fontFamily) === \"Consolas\")\n        return false;\n      return !findHtmlParentElement(el, \"PRE\");\n    }\n  },\n  handlers: {\n    onKeyDown: onKeyDownToggleMark\n  },\n  options: {\n    hotkey: \"mod+e\"\n  }\n});\nvar MARK_ITALIC = \"italic\";\nvar createItalicPlugin = createPluginFactory({\n  key: MARK_ITALIC,\n  isLeaf: true,\n  handlers: {\n    onKeyDown: onKeyDownToggleMark\n  },\n  options: {\n    hotkey: \"mod+i\"\n  },\n  deserializeHtml: {\n    rules: [{\n      validNodeName: [\"EM\", \"I\"]\n    }, {\n      validStyle: {\n        fontStyle: \"italic\"\n      }\n    }],\n    query: (el) => !someHtmlElement(el, (node) => node.style.fontStyle === \"normal\")\n  }\n});\nvar MARK_STRIKETHROUGH = \"strikethrough\";\nvar createStrikethroughPlugin = createPluginFactory({\n  key: MARK_STRIKETHROUGH,\n  isLeaf: true,\n  handlers: {\n    onKeyDown: onKeyDownToggleMark\n  },\n  options: {\n    hotkey: \"mod+shift+x\"\n  },\n  deserializeHtml: {\n    rules: [{\n      validNodeName: [\"S\", \"DEL\", \"STRIKE\"]\n    }, {\n      validStyle: {\n        textDecoration: \"line-through\"\n      }\n    }],\n    query: (el) => !someHtmlElement(el, (node) => node.style.textDecoration === \"none\")\n  }\n});\nvar MARK_SUBSCRIPT$1 = \"subscript\";\nvar MARK_SUPERSCRIPT$1 = \"superscript\";\nvar createSubscriptPlugin = createPluginFactory({\n  key: MARK_SUBSCRIPT$1,\n  isLeaf: true,\n  handlers: {\n    onKeyDown: onKeyDownToggleMark\n  },\n  options: {\n    hotkey: \"mod+,\",\n    clear: MARK_SUPERSCRIPT$1\n  },\n  deserializeHtml: {\n    rules: [{\n      validNodeName: [\"SUB\"]\n    }, {\n      validStyle: {\n        verticalAlign: \"sub\"\n      }\n    }]\n  }\n});\nvar MARK_SUPERSCRIPT = \"superscript\";\nvar MARK_SUBSCRIPT = \"subscript\";\nvar createSuperscriptPlugin = createPluginFactory({\n  key: MARK_SUPERSCRIPT,\n  isLeaf: true,\n  handlers: {\n    onKeyDown: onKeyDownToggleMark\n  },\n  options: {\n    hotkey: \"mod+.\",\n    clear: MARK_SUBSCRIPT\n  },\n  deserializeHtml: {\n    rules: [{\n      validNodeName: [\"SUP\"]\n    }, {\n      validStyle: {\n        verticalAlign: \"super\"\n      }\n    }]\n  }\n});\nvar MARK_UNDERLINE = \"underline\";\nvar createUnderlinePlugin = createPluginFactory({\n  key: MARK_UNDERLINE,\n  isLeaf: true,\n  handlers: {\n    onKeyDown: onKeyDownToggleMark\n  },\n  options: {\n    hotkey: \"mod+u\"\n  },\n  deserializeHtml: {\n    rules: [{\n      validNodeName: [\"U\"]\n    }, {\n      validStyle: {\n        textDecoration: [\"underline\"]\n      }\n    }],\n    query: (el) => !someHtmlElement(el, (node) => node.style.textDecoration === \"none\")\n  }\n});\nvar createBasicMarksPlugin = createPluginFactory({\n  key: \"basicMarks\",\n  plugins: [createBoldPlugin(), createCodePlugin(), createItalicPlugin(), createStrikethroughPlugin(), createSubscriptPlugin(), createSuperscriptPlugin(), createUnderlinePlugin()]\n});\n\n// node_modules/@udecode/plate-trailing-block/dist/index.es.js\nvar withTrailingBlock = (editor, {\n  type,\n  options: {\n    level,\n    ...query\n  }\n}) => {\n  const {\n    normalizeNode\n  } = editor;\n  editor.normalizeNode = ([currentNode, currentPath]) => {\n    if (!currentPath.length) {\n      const lastChild = getLastNodeByLevel(editor, level);\n      const lastChildNode = lastChild === null || lastChild === void 0 ? void 0 : lastChild[0];\n      if (!lastChildNode || lastChildNode.type !== type && queryNode(lastChild, query)) {\n        const at = lastChild ? Path.next(lastChild[1]) : [0];\n        insertElements(editor, {\n          type,\n          children: [{\n            text: \"\"\n          }]\n        }, {\n          at\n        });\n        return;\n      }\n    }\n    return normalizeNode([currentNode, currentPath]);\n  };\n  return editor;\n};\nvar KEY_TRAILING_BLOCK = \"trailingBlock\";\nvar createTrailingBlockPlugin = createPluginFactory({\n  key: KEY_TRAILING_BLOCK,\n  withOverrides: withTrailingBlock,\n  options: {\n    level: 0\n  },\n  then: (editor) => ({\n    type: getPluginType(editor, ELEMENT_DEFAULT)\n  })\n});\n\n// node_modules/@udecode/plate-break/dist/index.es.js\nfunction unwrapExports5(x4) {\n  return x4 && x4.__esModule && Object.prototype.hasOwnProperty.call(x4, \"default\") ? x4[\"default\"] : x4;\n}\nfunction createCommonjsModule7(fn4, module2) {\n  return module2 = { exports: {} }, fn4(module2, module2.exports), module2.exports;\n}\nvar lib5 = createCommonjsModule7(function(module2, exports2) {\n  Object.defineProperty(exports2, \"__esModule\", {\n    value: true\n  });\n  var IS_MAC = () => typeof window != \"undefined\" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n  var MODIFIERS = {\n    alt: \"altKey\",\n    control: \"ctrlKey\",\n    meta: \"metaKey\",\n    shift: \"shiftKey\"\n  };\n  var ALIASES = () => ({\n    add: \"+\",\n    break: \"pause\",\n    cmd: \"meta\",\n    command: \"meta\",\n    ctl: \"control\",\n    ctrl: \"control\",\n    del: \"delete\",\n    down: \"arrowdown\",\n    esc: \"escape\",\n    ins: \"insert\",\n    left: \"arrowleft\",\n    mod: IS_MAC() ? \"meta\" : \"control\",\n    opt: \"alt\",\n    option: \"alt\",\n    return: \"enter\",\n    right: \"arrowright\",\n    space: \" \",\n    spacebar: \" \",\n    up: \"arrowup\",\n    win: \"meta\",\n    windows: \"meta\"\n  });\n  var CODES = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    shift: 16,\n    control: 17,\n    alt: 18,\n    pause: 19,\n    capslock: 20,\n    escape: 27,\n    \" \": 32,\n    pageup: 33,\n    pagedown: 34,\n    end: 35,\n    home: 36,\n    arrowleft: 37,\n    arrowup: 38,\n    arrowright: 39,\n    arrowdown: 40,\n    insert: 45,\n    delete: 46,\n    meta: 91,\n    numlock: 144,\n    scrolllock: 145,\n    \";\": 186,\n    \"=\": 187,\n    \",\": 188,\n    \"-\": 189,\n    \".\": 190,\n    \"/\": 191,\n    \"`\": 192,\n    \"[\": 219,\n    \"\\\\\": 220,\n    \"]\": 221,\n    \"'\": 222\n  };\n  for (var f5 = 1; f5 < 20; f5++) {\n    CODES[\"f\" + f5] = 111 + f5;\n  }\n  function isHotkey9(hotkey, options, event) {\n    if (options && !(\"byKey\" in options)) {\n      event = options;\n      options = null;\n    }\n    if (!Array.isArray(hotkey)) {\n      hotkey = [hotkey];\n    }\n    var array = hotkey.map(function(string2) {\n      return parseHotkey(string2, options);\n    });\n    var check = function check2(e4) {\n      return array.some(function(object) {\n        return compareHotkey(object, e4);\n      });\n    };\n    var ret = event == null ? check : check(event);\n    return ret;\n  }\n  function isCodeHotkey(hotkey, event) {\n    return isHotkey9(hotkey, event);\n  }\n  function isKeyHotkey2(hotkey, event) {\n    return isHotkey9(hotkey, { byKey: true }, event);\n  }\n  function parseHotkey(hotkey, options) {\n    var byKey = options && options.byKey;\n    var ret = {};\n    hotkey = hotkey.replace(\"++\", \"+add\");\n    var values2 = hotkey.split(\"+\");\n    var length = values2.length;\n    for (var k3 in MODIFIERS) {\n      ret[MODIFIERS[k3]] = false;\n    }\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = void 0;\n    try {\n      for (var _iterator = values2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var value = _step.value;\n        var optional = value.endsWith(\"?\") && value.length > 1;\n        if (optional) {\n          value = value.slice(0, -1);\n        }\n        var name = toKeyName(value);\n        var modifier = MODIFIERS[name];\n        if (length === 1 || !modifier) {\n          if (byKey) {\n            ret.key = name;\n          } else {\n            ret.which = toKeyCode(value);\n          }\n        }\n        if (modifier) {\n          ret[modifier] = optional ? null : true;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    return ret;\n  }\n  function compareHotkey(object, event) {\n    for (var key in object) {\n      var expected = object[key];\n      var actual = void 0;\n      if (expected == null) {\n        continue;\n      }\n      if (key === \"key\" && event.key != null) {\n        actual = event.key.toLowerCase();\n      } else if (key === \"which\") {\n        actual = expected === 91 && event.which === 93 ? 91 : event.which;\n      } else {\n        actual = event[key];\n      }\n      if (actual == null && expected === false) {\n        continue;\n      }\n      if (actual !== expected) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function toKeyCode(name) {\n    name = toKeyName(name);\n    var code3 = CODES[name] || name.toUpperCase().charCodeAt(0);\n    return code3;\n  }\n  function toKeyName(name) {\n    name = name.toLowerCase();\n    name = ALIASES()[name] || name;\n    return name;\n  }\n  exports2.default = isHotkey9;\n  exports2.isHotkey = isHotkey9;\n  exports2.isCodeHotkey = isCodeHotkey;\n  exports2.isKeyHotkey = isKeyHotkey2;\n  exports2.parseHotkey = parseHotkey;\n  exports2.compareHotkey = compareHotkey;\n  exports2.toKeyCode = toKeyCode;\n  exports2.toKeyName = toKeyName;\n});\nvar isHotkey5 = unwrapExports5(lib5);\nlib5.isHotkey;\nlib5.isCodeHotkey;\nlib5.isKeyHotkey;\nlib5.parseHotkey;\nlib5.compareHotkey;\nlib5.toKeyCode;\nlib5.toKeyName;\nvar exitBreakAtEdges = (editor, {\n  start: start2,\n  end: end2\n}) => {\n  let queryEdge = false;\n  let isEdge = false;\n  let isStart = false;\n  if (start2 || end2) {\n    queryEdge = true;\n    if (start2 && isSelectionAtBlockStart(editor)) {\n      isEdge = true;\n      isStart = true;\n    }\n    if (end2 && isSelectionAtBlockEnd(editor)) {\n      isEdge = true;\n    }\n    if (isEdge && isExpanded(editor.selection)) {\n      editor.deleteFragment();\n    }\n  }\n  return {\n    queryEdge,\n    isEdge,\n    isStart\n  };\n};\nvar exitBreak = (editor, {\n  level = 0,\n  defaultType = getPluginType(editor, ELEMENT_DEFAULT),\n  query = {},\n  before\n}) => {\n  if (!editor.selection)\n    return;\n  const {\n    queryEdge,\n    isEdge,\n    isStart\n  } = exitBreakAtEdges(editor, query);\n  if (isStart)\n    before = true;\n  if (queryEdge && !isEdge)\n    return;\n  const selectionPath = getPath(editor, editor.selection);\n  let insertPath;\n  if (before) {\n    insertPath = selectionPath.slice(0, level + 1);\n  } else {\n    insertPath = Path.next(selectionPath.slice(0, level + 1));\n  }\n  insertElements(editor, {\n    type: defaultType,\n    children: [{\n      text: \"\"\n    }]\n  }, {\n    at: insertPath,\n    select: !isStart\n  });\n  return true;\n};\nvar onKeyDownExitBreak = (editor, {\n  options: {\n    rules = []\n  }\n}) => (event) => {\n  const entry = getBlockAbove(editor);\n  if (!entry)\n    return;\n  rules.forEach(({\n    hotkey,\n    ...rule\n  }) => {\n    if (isHotkey5(hotkey, event) && queryNode(entry, rule.query)) {\n      if (exitBreak(editor, rule)) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n  });\n};\nvar KEY_EXIT_BREAK = \"exitBreak\";\nvar createExitBreakPlugin = createPluginFactory({\n  key: KEY_EXIT_BREAK,\n  handlers: {\n    onKeyDown: onKeyDownExitBreak\n  },\n  options: {\n    rules: [{\n      hotkey: \"mod+enter\"\n    }, {\n      hotkey: \"mod+shift+enter\",\n      before: true\n    }]\n  }\n});\nvar onKeyDownSingleLine = () => (event) => {\n  if (Hotkeys2.isSplitBlock(event)) {\n    event.preventDefault();\n  }\n};\nvar withSingleLine = (editor) => {\n  const {\n    normalizeNode\n  } = editor;\n  editor.insertBreak = () => null;\n  editor.normalizeNode = (entry) => {\n    if (editor.children.length > 1) {\n      removeNodes(editor, {\n        at: [],\n        mode: \"highest\",\n        match: (node, path) => path[0] > 0\n      });\n    }\n    normalizeNode(entry);\n  };\n  return editor;\n};\nvar KEY_SINGLE_LINE = \"singleLine\";\nvar createSingleLinePlugin = createPluginFactory({\n  key: KEY_SINGLE_LINE,\n  handlers: {\n    onKeyDown: onKeyDownSingleLine\n  },\n  withOverrides: withSingleLine\n});\nvar onKeyDownSoftBreak = (editor, {\n  options: {\n    rules = []\n  }\n}) => (event) => {\n  const entry = getBlockAbove(editor);\n  if (!entry)\n    return;\n  rules.forEach(({\n    hotkey,\n    query\n  }) => {\n    if (isHotkey5(hotkey, event) && queryNode(entry, query)) {\n      event.preventDefault();\n      event.stopPropagation();\n      editor.insertText(\"\\n\");\n    }\n  });\n};\nvar KEY_SOFT_BREAK = \"softBreak\";\nvar createSoftBreakPlugin = createPluginFactory({\n  key: KEY_SOFT_BREAK,\n  handlers: {\n    onKeyDown: onKeyDownSoftBreak\n  },\n  options: {\n    rules: [{\n      hotkey: \"shift+enter\"\n    }]\n  }\n});\n\n// node_modules/@udecode/plate-horizontal-rule/dist/index.es.js\nvar ELEMENT_HR = \"hr\";\nvar createHorizontalRulePlugin = createPluginFactory({\n  key: ELEMENT_HR,\n  isElement: true,\n  isVoid: true,\n  deserializeHtml: {\n    rules: [{\n      validNodeName: \"HR\"\n    }]\n  }\n});\n\n// node_modules/@udecode/plate-table/dist/index.es.js\nvar keyShiftEdges = {\n  \"shift+up\": \"top\",\n  \"shift+right\": \"right\",\n  \"shift+down\": \"bottom\",\n  \"shift+left\": \"left\"\n};\nvar deleteColumn = (editor) => {\n  if (someNode(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_TABLE)\n    }\n  })) {\n    const currentCellItem = getAboveNode(editor, {\n      match: {\n        type: [getPluginType(editor, ELEMENT_TD), getPluginType(editor, ELEMENT_TH)]\n      }\n    });\n    const currentRowItem = getAboveNode(editor, {\n      match: {\n        type: getPluginType(editor, ELEMENT_TR)\n      }\n    });\n    const currentTableItem = getAboveNode(editor, {\n      match: {\n        type: getPluginType(editor, ELEMENT_TABLE)\n      }\n    });\n    if (currentCellItem && currentRowItem && currentTableItem && // Cannot delete the last cell\n    currentRowItem[0].children.length > 1) {\n      const currentCellPath = currentCellItem[1];\n      const pathToDelete = currentCellPath.slice();\n      const replacePathPos = pathToDelete.length - 2;\n      currentTableItem[0].children.forEach((row, rowIdx) => {\n        pathToDelete[replacePathPos] = rowIdx;\n        removeNodes(editor, {\n          at: pathToDelete\n        });\n      });\n    }\n  }\n};\nvar deleteRow = (editor) => {\n  if (someNode(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_TABLE)\n    }\n  })) {\n    const currentTableItem = getAboveNode(editor, {\n      match: {\n        type: getPluginType(editor, ELEMENT_TABLE)\n      }\n    });\n    const currentRowItem = getAboveNode(editor, {\n      match: {\n        type: getPluginType(editor, ELEMENT_TR)\n      }\n    });\n    if (currentRowItem && currentTableItem && // Cannot delete the last row\n    currentTableItem[0].children.length > 1) {\n      removeNodes(editor, {\n        at: currentRowItem[1]\n      });\n    }\n  }\n};\nvar deleteTable = (editor) => {\n  if (someNode(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_TABLE)\n    }\n  })) {\n    const tableItem = getAboveNode(editor, {\n      match: {\n        type: getPluginType(editor, ELEMENT_TABLE)\n      }\n    });\n    if (tableItem) {\n      removeNodes(editor, {\n        at: tableItem[1]\n      });\n    }\n  }\n};\nvar getEmptyCellNode = (editor, {\n  header,\n  newCellChildren = [{\n    type: getPluginType(editor, ELEMENT_DEFAULT),\n    children: [{\n      text: \"\"\n    }]\n  }]\n}) => {\n  return {\n    type: header ? getPluginType(editor, ELEMENT_TH) : getPluginType(editor, ELEMENT_TD),\n    children: newCellChildren\n  };\n};\nvar getEmptyRowNode = (editor, {\n  colCount,\n  ...options\n} = {}) => {\n  return {\n    type: getPluginType(editor, ELEMENT_TR),\n    children: Array(colCount).fill(colCount).map(() => getEmptyCellNode(editor, options))\n  };\n};\nvar getEmptyTableNode = (editor, {\n  header,\n  rowCount = 0,\n  colCount,\n  newCellChildren\n} = {}) => {\n  const rows = Array(rowCount).fill(rowCount).map(() => getEmptyRowNode(editor, {\n    header,\n    colCount,\n    newCellChildren\n  }));\n  return {\n    type: getPluginType(editor, ELEMENT_TABLE),\n    children: rows\n  };\n};\nvar insertTable = (editor, {\n  rowCount = 2,\n  colCount = 2,\n  header\n}) => {\n  withoutNormalizing(editor, () => {\n    if (!someNode(editor, {\n      match: {\n        type: getPluginType(editor, ELEMENT_TABLE)\n      }\n    })) {\n      insertNodes(editor, getEmptyTableNode(editor, {\n        header,\n        rowCount,\n        colCount\n      }));\n      if (editor.selection) {\n        const tableEntry = getBlockAbove(editor, {\n          match: {\n            type: getPluginType(editor, ELEMENT_TABLE)\n          }\n        });\n        if (!tableEntry)\n          return;\n        selectEditor(editor, {\n          at: getStartPoint(editor, tableEntry[1])\n        });\n      }\n    }\n  });\n};\nvar getCellTypes = (editor) => getPluginTypes(editor, [ELEMENT_TD, ELEMENT_TH]);\nvar insertTableColumn = (editor, {\n  disableSelect,\n  fromCell,\n  header\n} = {}) => {\n  const cellEntry = fromCell ? findNode(editor, {\n    at: fromCell,\n    match: {\n      type: getCellTypes(editor)\n    }\n  }) : getBlockAbove(editor, {\n    match: {\n      type: getCellTypes(editor)\n    }\n  });\n  if (!cellEntry)\n    return;\n  const [, cellPath] = cellEntry;\n  const tableEntry = getBlockAbove(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_TABLE)\n    },\n    at: cellPath\n  });\n  if (!tableEntry)\n    return;\n  const [tableNode] = tableEntry;\n  const nextCellPath = Path.next(cellPath);\n  const currentRowIndex = cellPath[cellPath.length - 2];\n  const {\n    newCellChildren\n  } = getPluginOptions(editor, ELEMENT_TABLE);\n  withoutNormalizing(editor, () => {\n    tableNode.children.forEach((row, rowIndex) => {\n      const insertCellPath = [...nextCellPath];\n      insertCellPath[cellPath.length - 2] = rowIndex;\n      const isHeaderRow = header === void 0 ? row.children[0].type === getPluginType(editor, ELEMENT_TH) : header;\n      insertElements(editor, getEmptyCellNode(editor, {\n        header: isHeaderRow,\n        newCellChildren\n      }), {\n        at: insertCellPath,\n        select: !disableSelect && rowIndex === currentRowIndex\n      });\n    });\n  });\n};\nvar insertTableRow = (editor, {\n  header,\n  fromRow,\n  disableSelect\n} = {}) => {\n  const trEntry = fromRow ? findNode(editor, {\n    at: fromRow,\n    match: {\n      type: getPluginType(editor, ELEMENT_TR)\n    }\n  }) : getBlockAbove(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_TR)\n    }\n  });\n  if (!trEntry)\n    return;\n  const [trNode, trPath] = trEntry;\n  const tableEntry = getBlockAbove(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_TABLE)\n    },\n    at: trPath\n  });\n  if (!tableEntry)\n    return;\n  const {\n    newCellChildren\n  } = getPluginOptions(editor, ELEMENT_TABLE);\n  withoutNormalizing(editor, () => {\n    insertElements(editor, getEmptyRowNode(editor, {\n      header,\n      colCount: trNode.children.length,\n      newCellChildren\n    }), {\n      at: Path.next(trPath)\n    });\n  });\n  if (!disableSelect) {\n    const cellEntry = getBlockAbove(editor, {\n      match: {\n        type: getCellTypes(editor)\n      }\n    });\n    if (!cellEntry)\n      return;\n    const [, nextCellPath] = cellEntry;\n    nextCellPath[nextCellPath.length - 2] += 1;\n    select(editor, nextCellPath);\n  }\n};\nvar getTableGridByRange = (editor, {\n  at,\n  format: format3 = \"table\"\n}) => {\n  const startCellPath = at.anchor.path;\n  const endCellPath = at.focus.path;\n  const _startRowIndex = startCellPath[startCellPath.length - 2];\n  const _endRowIndex = endCellPath[endCellPath.length - 2];\n  const _startColIndex = startCellPath[startCellPath.length - 1];\n  const _endColIndex = endCellPath[endCellPath.length - 1];\n  const startRowIndex = Math.min(_startRowIndex, _endRowIndex);\n  const endRowIndex = Math.max(_startRowIndex, _endRowIndex);\n  const startColIndex = Math.min(_startColIndex, _endColIndex);\n  const endColIndex = Math.max(_startColIndex, _endColIndex);\n  const tablePath = startCellPath.slice(0, -2);\n  const relativeRowIndex = endRowIndex - startRowIndex;\n  const relativeColIndex = endColIndex - startColIndex;\n  const table3 = getEmptyTableNode(editor, {\n    rowCount: relativeRowIndex + 1,\n    colCount: relativeColIndex + 1,\n    newCellChildren: []\n  });\n  let rowIndex = startRowIndex;\n  let colIndex = startColIndex;\n  const cellEntries = [];\n  while (true) {\n    const cellPath = tablePath.concat([rowIndex, colIndex]);\n    const cell = getNode(editor, cellPath);\n    if (!cell)\n      break;\n    const rows = table3.children[rowIndex - startRowIndex].children;\n    rows[colIndex - startColIndex] = cell;\n    cellEntries.push([cell, cellPath]);\n    if (colIndex + 1 <= endColIndex) {\n      colIndex += 1;\n    } else if (rowIndex + 1 <= endRowIndex) {\n      colIndex = startColIndex;\n      rowIndex += 1;\n    } else {\n      break;\n    }\n  }\n  if (format3 === \"cell\") {\n    return cellEntries;\n  }\n  return [[table3, tablePath]];\n};\nvar getTableGridAbove = (editor, {\n  format: format3 = \"table\",\n  ...options\n} = {}) => {\n  const edges = getEdgeBlocksAbove(editor, {\n    match: {\n      type: getCellTypes(editor)\n    },\n    ...options\n  });\n  if (edges) {\n    const [start2, end2] = edges;\n    if (!Path.equals(start2[1], end2[1])) {\n      return getTableGridByRange(editor, {\n        at: {\n          anchor: {\n            path: start2[1],\n            offset: 0\n          },\n          focus: {\n            path: end2[1],\n            offset: 0\n          }\n        },\n        format: format3\n      });\n    }\n    if (format3 === \"table\") {\n      const table3 = getEmptyTableNode(editor, {\n        rowCount: 1\n      });\n      table3.children[0].children = [start2[0]];\n      return [[table3, start2[1].slice(0, -2)]];\n    }\n    return [start2];\n  }\n  return [];\n};\nvar moveSelectionFromCell = (editor, {\n  at,\n  reverse,\n  edge,\n  fromOneCell\n} = {}) => {\n  if (edge) {\n    const cellEntries = getTableGridAbove(editor, {\n      at,\n      format: \"cell\"\n    });\n    const minCell = fromOneCell ? 0 : 1;\n    if (cellEntries.length > minCell) {\n      const [, firstCellPath] = cellEntries[0];\n      const [, lastCellPath] = cellEntries[cellEntries.length - 1];\n      const anchorPath = [...firstCellPath];\n      const focusPath = [...lastCellPath];\n      if (edge === \"bottom\") {\n        focusPath[focusPath.length - 2] += 1;\n      } else if (edge === \"top\") {\n        anchorPath[anchorPath.length - 2] -= 1;\n      } else if (edge === \"right\") {\n        focusPath[focusPath.length - 1] += 1;\n      } else if (edge === \"left\") {\n        anchorPath[anchorPath.length - 1] -= 1;\n      }\n      if (hasNode(editor, anchorPath) && hasNode(editor, focusPath)) {\n        select(editor, {\n          anchor: getStartPoint(editor, anchorPath),\n          focus: getStartPoint(editor, focusPath)\n        });\n      }\n      return true;\n    }\n    return;\n  }\n  const cellEntry = getBlockAbove(editor, {\n    at,\n    match: {\n      type: getCellTypes(editor)\n    }\n  });\n  if (cellEntry) {\n    const [, cellPath] = cellEntry;\n    const nextCellPath = [...cellPath];\n    const offset3 = reverse ? -1 : 1;\n    nextCellPath[nextCellPath.length - 2] += offset3;\n    if (hasNode(editor, nextCellPath)) {\n      select(editor, getStartPoint(editor, nextCellPath));\n    } else {\n      const tablePath = cellPath.slice(0, -2);\n      if (reverse) {\n        withoutNormalizing(editor, () => {\n          select(editor, getStartPoint(editor, tablePath));\n          moveSelection(editor, {\n            reverse: true\n          });\n        });\n      } else {\n        withoutNormalizing(editor, () => {\n          select(editor, getEndPoint(editor, tablePath));\n          moveSelection(editor);\n        });\n      }\n    }\n    return true;\n  }\n};\nvar overrideSelectionFromCell = (editor, newSelection) => {\n  var _editor$selection;\n  if (!editor.lastKeyDown || ![\"up\", \"down\", \"shift+up\", \"shift+right\", \"shift+down\", \"shift+left\"].includes(editor.lastKeyDown) || !((_editor$selection = editor.selection) !== null && _editor$selection !== void 0 && _editor$selection.focus) || !(newSelection !== null && newSelection !== void 0 && newSelection.focus) || !isRangeAcrossBlocks(editor, {\n    at: {\n      anchor: editor.selection.focus,\n      focus: newSelection.focus\n    },\n    match: {\n      type: getCellTypes(editor)\n    }\n  })) {\n    return;\n  }\n  const edge = keyShiftEdges[editor.lastKeyDown];\n  if (edge && !isRangeInSameBlock(editor, {\n    at: editor.selection,\n    match: {\n      type: getCellTypes(editor)\n    }\n  })) {\n    return;\n  }\n  const prevSelection = editor.selection;\n  const reverse = [\"up\", \"shift+up\"].includes(editor.lastKeyDown);\n  setTimeout(() => {\n    moveSelectionFromCell(editor, {\n      at: prevSelection,\n      reverse,\n      edge,\n      fromOneCell: true\n    });\n  }, 0);\n};\nvar getTableColumnCount = (tableNode) => {\n  var _$children$length, _2, _$children;\n  return (_$children$length = (_2 = tableNode.children[0]) === null || _2 === void 0 ? void 0 : (_$children = _2.children) === null || _$children === void 0 ? void 0 : _$children.length) !== null && _$children$length !== void 0 ? _$children$length : 0;\n};\nvar setTableColSize = (editor, {\n  colIndex,\n  width\n}, options = {}) => {\n  const table3 = findNode(editor, {\n    ...options,\n    match: {\n      type: ELEMENT_TABLE\n    }\n  });\n  if (!table3)\n    return;\n  const [tableNode, tablePath] = table3;\n  const colSizes = tableNode.colSizes ? [...tableNode.colSizes] : Array(getTableColumnCount(tableNode)).fill(0);\n  colSizes[colIndex] = width;\n  setNodes(editor, {\n    colSizes\n  }, {\n    at: tablePath\n  });\n};\nvar commonjsGlobal4 = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nfunction unwrapExports6(x4) {\n  return x4 && x4.__esModule && Object.prototype.hasOwnProperty.call(x4, \"default\") ? x4[\"default\"] : x4;\n}\nfunction createCommonjsModule8(fn4, module2) {\n  return module2 = { exports: {} }, fn4(module2, module2.exports), module2.exports;\n}\nvar lib6 = createCommonjsModule8(function(module2, exports2) {\n  Object.defineProperty(exports2, \"__esModule\", {\n    value: true\n  });\n  var IS_MAC = () => typeof window != \"undefined\" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n  var MODIFIERS = {\n    alt: \"altKey\",\n    control: \"ctrlKey\",\n    meta: \"metaKey\",\n    shift: \"shiftKey\"\n  };\n  var ALIASES = () => ({\n    add: \"+\",\n    break: \"pause\",\n    cmd: \"meta\",\n    command: \"meta\",\n    ctl: \"control\",\n    ctrl: \"control\",\n    del: \"delete\",\n    down: \"arrowdown\",\n    esc: \"escape\",\n    ins: \"insert\",\n    left: \"arrowleft\",\n    mod: IS_MAC() ? \"meta\" : \"control\",\n    opt: \"alt\",\n    option: \"alt\",\n    return: \"enter\",\n    right: \"arrowright\",\n    space: \" \",\n    spacebar: \" \",\n    up: \"arrowup\",\n    win: \"meta\",\n    windows: \"meta\"\n  });\n  var CODES = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    shift: 16,\n    control: 17,\n    alt: 18,\n    pause: 19,\n    capslock: 20,\n    escape: 27,\n    \" \": 32,\n    pageup: 33,\n    pagedown: 34,\n    end: 35,\n    home: 36,\n    arrowleft: 37,\n    arrowup: 38,\n    arrowright: 39,\n    arrowdown: 40,\n    insert: 45,\n    delete: 46,\n    meta: 91,\n    numlock: 144,\n    scrolllock: 145,\n    \";\": 186,\n    \"=\": 187,\n    \",\": 188,\n    \"-\": 189,\n    \".\": 190,\n    \"/\": 191,\n    \"`\": 192,\n    \"[\": 219,\n    \"\\\\\": 220,\n    \"]\": 221,\n    \"'\": 222\n  };\n  for (var f5 = 1; f5 < 20; f5++) {\n    CODES[\"f\" + f5] = 111 + f5;\n  }\n  function isHotkey9(hotkey, options, event) {\n    if (options && !(\"byKey\" in options)) {\n      event = options;\n      options = null;\n    }\n    if (!Array.isArray(hotkey)) {\n      hotkey = [hotkey];\n    }\n    var array = hotkey.map(function(string2) {\n      return parseHotkey(string2, options);\n    });\n    var check = function check2(e4) {\n      return array.some(function(object) {\n        return compareHotkey(object, e4);\n      });\n    };\n    var ret = event == null ? check : check(event);\n    return ret;\n  }\n  function isCodeHotkey(hotkey, event) {\n    return isHotkey9(hotkey, event);\n  }\n  function isKeyHotkey2(hotkey, event) {\n    return isHotkey9(hotkey, { byKey: true }, event);\n  }\n  function parseHotkey(hotkey, options) {\n    var byKey = options && options.byKey;\n    var ret = {};\n    hotkey = hotkey.replace(\"++\", \"+add\");\n    var values2 = hotkey.split(\"+\");\n    var length = values2.length;\n    for (var k3 in MODIFIERS) {\n      ret[MODIFIERS[k3]] = false;\n    }\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = void 0;\n    try {\n      for (var _iterator = values2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var value = _step.value;\n        var optional = value.endsWith(\"?\") && value.length > 1;\n        if (optional) {\n          value = value.slice(0, -1);\n        }\n        var name = toKeyName(value);\n        var modifier = MODIFIERS[name];\n        if (length === 1 || !modifier) {\n          if (byKey) {\n            ret.key = name;\n          } else {\n            ret.which = toKeyCode(value);\n          }\n        }\n        if (modifier) {\n          ret[modifier] = optional ? null : true;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    return ret;\n  }\n  function compareHotkey(object, event) {\n    for (var key in object) {\n      var expected = object[key];\n      var actual = void 0;\n      if (expected == null) {\n        continue;\n      }\n      if (key === \"key\" && event.key != null) {\n        actual = event.key.toLowerCase();\n      } else if (key === \"which\") {\n        actual = expected === 91 && event.which === 93 ? 91 : event.which;\n      } else {\n        actual = event[key];\n      }\n      if (actual == null && expected === false) {\n        continue;\n      }\n      if (actual !== expected) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function toKeyCode(name) {\n    name = toKeyName(name);\n    var code3 = CODES[name] || name.toUpperCase().charCodeAt(0);\n    return code3;\n  }\n  function toKeyName(name) {\n    name = name.toLowerCase();\n    name = ALIASES()[name] || name;\n    return name;\n  }\n  exports2.default = isHotkey9;\n  exports2.isHotkey = isHotkey9;\n  exports2.isCodeHotkey = isCodeHotkey;\n  exports2.isKeyHotkey = isKeyHotkey2;\n  exports2.parseHotkey = parseHotkey;\n  exports2.compareHotkey = compareHotkey;\n  exports2.toKeyCode = toKeyCode;\n  exports2.toKeyName = toKeyName;\n});\nvar isHotkey6 = unwrapExports6(lib6);\nlib6.isHotkey;\nlib6.isCodeHotkey;\nlib6.isKeyHotkey;\nlib6.parseHotkey;\nlib6.compareHotkey;\nlib6.toKeyCode;\nlib6.toKeyName;\nvar getCellInNextTableRow = (editor, currentRowPath) => {\n  try {\n    var _nextRowNode$children;\n    const nextRow = getNodeEntry(editor, Path.next(currentRowPath));\n    const [nextRowNode, nextRowPath] = nextRow;\n    const nextCell = nextRowNode === null || nextRowNode === void 0 ? void 0 : (_nextRowNode$children = nextRowNode.children) === null || _nextRowNode$children === void 0 ? void 0 : _nextRowNode$children[0];\n    const nextCellPath = nextRowPath.concat(0);\n    if (nextCell && nextCellPath) {\n      return getNodeEntry(editor, nextCellPath);\n    }\n  } catch (err) {\n  }\n};\nvar getCellInPreviousTableRow = (editor, currentRowPath) => {\n  try {\n    var _previousRowNode$chil;\n    const previousRow = getNodeEntry(editor, Path.previous(currentRowPath));\n    const [previousRowNode, previousRowPath] = previousRow;\n    const previousCell = previousRowNode === null || previousRowNode === void 0 ? void 0 : (_previousRowNode$chil = previousRowNode.children) === null || _previousRowNode$chil === void 0 ? void 0 : _previousRowNode$chil[previousRowNode.children.length - 1];\n    const previousCellPath = previousRowPath.concat(previousRowNode.children.length - 1);\n    if (previousCell && previousCellPath) {\n      return getNodeEntry(editor, previousCellPath);\n    }\n  } catch (err) {\n  }\n};\nvar getNextTableCell = (editor, currentCell, currentPath, currentRow) => {\n  try {\n    return getNodeEntry(editor, Path.next(currentPath));\n  } catch (err) {\n    const [, currentRowPath] = currentRow;\n    return getCellInNextTableRow(editor, currentRowPath);\n  }\n};\nvar getPreviousTableCell = (editor, currentCell, currentPath, currentRow) => {\n  try {\n    return getNodeEntry(editor, Path.previous(currentPath));\n  } catch (err) {\n    const [, currentRowPath] = currentRow;\n    return getCellInPreviousTableRow(editor, currentRowPath);\n  }\n};\nvar getTableAbove = (editor, options) => getBlockAbove(editor, {\n  match: {\n    type: getPluginType(editor, ELEMENT_TABLE)\n  },\n  ...options\n});\nvar getTableColumnIndex = (editor, {\n  node\n}) => {\n  var _getParentNode;\n  const path = findNodePath(editor, node);\n  if (!path)\n    return 0;\n  const [trNode] = (_getParentNode = getParentNode(editor, path)) !== null && _getParentNode !== void 0 ? _getParentNode : [];\n  if (!trNode)\n    return 0;\n  let colIndex = 0;\n  trNode.children.some((item, index5) => {\n    if (item === node) {\n      colIndex = index5;\n      return true;\n    }\n    return false;\n  });\n  return colIndex;\n};\nvar getTableEntries = (editor, {\n  at = editor.selection\n} = {}) => {\n  if (!at)\n    return;\n  const cellEntry = findNode(editor, {\n    at,\n    match: {\n      type: getCellTypes(editor)\n    }\n  });\n  if (!cellEntry)\n    return;\n  const [, cellPath] = cellEntry;\n  const rowEntry = getAboveNode(editor, {\n    at: cellPath,\n    match: {\n      type: getPluginType(editor, ELEMENT_TR)\n    }\n  });\n  if (!rowEntry)\n    return;\n  const [, rowPath] = rowEntry;\n  const tableEntry = getAboveNode(editor, {\n    at: rowPath,\n    match: {\n      type: getPluginType(editor, ELEMENT_TABLE)\n    }\n  });\n  if (!tableEntry)\n    return;\n  return {\n    table: tableEntry,\n    row: rowEntry,\n    cell: cellEntry\n  };\n};\nvar onKeyDownTable = (editor, {\n  type\n}) => (e4) => {\n  const setEditorLastKeyDown = (hotkey) => {\n    if (isHotkey6(hotkey, e4)) {\n      editor.lastKeyDown = hotkey;\n    }\n  };\n  const keys4 = [\"up\", \"down\", \"left\", \"right\"];\n  keys4.forEach((key) => {\n    setEditorLastKeyDown(key);\n  });\n  const isKeyDown = {\n    \"shift+up\": isHotkey6(\"shift+up\", e4),\n    \"shift+down\": isHotkey6(\"shift+down\", e4),\n    \"shift+left\": isHotkey6(\"shift+left\", e4),\n    \"shift+right\": isHotkey6(\"shift+right\", e4)\n  };\n  Object.keys(isKeyDown).forEach((key) => {\n    if (isKeyDown[key]) {\n      if (moveSelectionFromCell(editor, {\n        reverse: key === \"shift+up\",\n        edge: keyShiftEdges[key]\n      })) {\n        e4.preventDefault();\n        e4.stopPropagation();\n      } else {\n        setEditorLastKeyDown(key);\n      }\n    }\n  });\n  const isTab = Hotkeys2.isTab(editor, e4);\n  const isUntab = Hotkeys2.isUntab(editor, e4);\n  if (isTab || isUntab) {\n    const entries = getTableEntries(editor);\n    if (!entries)\n      return;\n    const {\n      row,\n      cell\n    } = entries;\n    const [, cellPath] = cell;\n    if (isUntab) {\n      const previousCell = getPreviousTableCell(editor, cell, cellPath, row);\n      if (previousCell) {\n        const [, previousCellPath] = previousCell;\n        select(editor, previousCellPath);\n      }\n    } else if (isTab) {\n      const nextCell = getNextTableCell(editor, cell, cellPath, row);\n      if (nextCell) {\n        const [, nextCellPath] = nextCell;\n        select(editor, nextCellPath);\n      }\n    }\n    e4.preventDefault();\n    e4.stopPropagation();\n  }\n  if (isHotkey6(\"mod+a\", e4)) {\n    const res = getAboveNode(editor, {\n      match: {\n        type\n      }\n    });\n    if (!res)\n      return;\n    const [, tablePath] = res;\n    select(editor, tablePath);\n    e4.preventDefault();\n    e4.stopPropagation();\n  }\n};\nvar preventDeleteTableCell = (editor, {\n  unit,\n  reverse\n}) => {\n  const {\n    selection\n  } = editor;\n  const getPoint2 = !reverse ? getStartPoint : getEndPoint;\n  const getNextPoint = !reverse ? getPointBefore : getPointAfter;\n  if (isCollapsed(selection)) {\n    const cellEntry = getBlockAbove(editor, {\n      match: {\n        type: getCellTypes(editor)\n      }\n    });\n    if (cellEntry) {\n      const [, cellPath] = cellEntry;\n      const start2 = getPoint2(editor, cellPath);\n      if (selection && Point.equals(selection.anchor, start2)) {\n        return true;\n      }\n    } else {\n      const nextPoint = getNextPoint(editor, selection, {\n        unit\n      });\n      const nextCellEntry = getBlockAbove(editor, {\n        match: {\n          type: getCellTypes(editor)\n        },\n        at: nextPoint\n      });\n      if (nextCellEntry) {\n        moveSelection(editor, {\n          reverse: !reverse\n        });\n        return true;\n      }\n    }\n  }\n};\nvar withDeleteTable = (editor) => {\n  const {\n    deleteBackward: deleteBackward2,\n    deleteForward,\n    deleteFragment\n  } = editor;\n  editor.deleteBackward = (unit) => {\n    if (preventDeleteTableCell(editor, {\n      unit\n    }))\n      return;\n    return deleteBackward2(unit);\n  };\n  editor.deleteForward = (unit) => {\n    if (preventDeleteTableCell(editor, {\n      unit,\n      reverse: true\n    }))\n      return;\n    return deleteForward(unit);\n  };\n  editor.deleteFragment = () => {\n    isRangeInSameBlock(editor, {\n      match: (n8) => n8.type === getPluginType(editor, ELEMENT_TABLE)\n    });\n    if (isRangeInSameBlock(editor, {\n      match: (n8) => n8.type === getPluginType(editor, ELEMENT_TABLE)\n    })) {\n      const cellEntries = getTableGridAbove(editor, {\n        format: \"cell\"\n      });\n      if (cellEntries.length > 1) {\n        withoutNormalizing(editor, () => {\n          cellEntries.forEach(([, cellPath]) => {\n            replaceNodeChildren(editor, {\n              at: cellPath,\n              nodes: {\n                type: getPluginType(editor, ELEMENT_DEFAULT),\n                children: [{\n                  text: \"\"\n                }]\n              }\n            });\n          });\n          select(editor, {\n            anchor: getStartPoint(editor, cellEntries[0][1]),\n            focus: getEndPoint(editor, cellEntries[cellEntries.length - 1][1])\n          });\n        });\n        return;\n      }\n    }\n    deleteFragment();\n  };\n  return editor;\n};\nvar withGetFragmentTable = (editor) => {\n  const {\n    getFragment\n  } = editor;\n  editor.getFragment = () => {\n    const fragment = getFragment();\n    const newFragment = [];\n    fragment.forEach((node) => {\n      if (node.type === getPluginType(editor, ELEMENT_TABLE)) {\n        const rows = node.children;\n        const rowCount = rows.length;\n        if (!rowCount)\n          return;\n        const colCount = rows[0].children.length;\n        const hasOneCell = rowCount <= 1 && colCount <= 1;\n        if (!hasOneCell) {\n          const subTable = getTableGridAbove(editor);\n          if (subTable.length) {\n            newFragment.push(subTable[0][0]);\n            return;\n          }\n        } else {\n          newFragment.push(...rows[0].children[0].children);\n          return;\n        }\n      }\n      newFragment.push(node);\n    });\n    return newFragment;\n  };\n  return editor;\n};\nfunction listCacheClear4() {\n  this.__data__ = [];\n  this.size = 0;\n}\nvar _listCacheClear4 = listCacheClear4;\nfunction eq4(value, other) {\n  return value === other || value !== value && other !== other;\n}\nvar eq_14 = eq4;\nfunction assocIndexOf4(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq_14(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\nvar _assocIndexOf4 = assocIndexOf4;\nvar arrayProto4 = Array.prototype;\nvar splice4 = arrayProto4.splice;\nfunction listCacheDelete4(key) {\n  var data = this.__data__, index5 = _assocIndexOf4(data, key);\n  if (index5 < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index5 == lastIndex) {\n    data.pop();\n  } else {\n    splice4.call(data, index5, 1);\n  }\n  --this.size;\n  return true;\n}\nvar _listCacheDelete4 = listCacheDelete4;\nfunction listCacheGet4(key) {\n  var data = this.__data__, index5 = _assocIndexOf4(data, key);\n  return index5 < 0 ? void 0 : data[index5][1];\n}\nvar _listCacheGet4 = listCacheGet4;\nfunction listCacheHas4(key) {\n  return _assocIndexOf4(this.__data__, key) > -1;\n}\nvar _listCacheHas4 = listCacheHas4;\nfunction listCacheSet4(key, value) {\n  var data = this.__data__, index5 = _assocIndexOf4(data, key);\n  if (index5 < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index5][1] = value;\n  }\n  return this;\n}\nvar _listCacheSet4 = listCacheSet4;\nfunction ListCache4(entries) {\n  var index5 = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index5 < length) {\n    var entry = entries[index5];\n    this.set(entry[0], entry[1]);\n  }\n}\nListCache4.prototype.clear = _listCacheClear4;\nListCache4.prototype[\"delete\"] = _listCacheDelete4;\nListCache4.prototype.get = _listCacheGet4;\nListCache4.prototype.has = _listCacheHas4;\nListCache4.prototype.set = _listCacheSet4;\nvar _ListCache4 = ListCache4;\nfunction stackClear4() {\n  this.__data__ = new _ListCache4();\n  this.size = 0;\n}\nvar _stackClear4 = stackClear4;\nfunction stackDelete4(key) {\n  var data = this.__data__, result = data[\"delete\"](key);\n  this.size = data.size;\n  return result;\n}\nvar _stackDelete4 = stackDelete4;\nfunction stackGet4(key) {\n  return this.__data__.get(key);\n}\nvar _stackGet4 = stackGet4;\nfunction stackHas4(key) {\n  return this.__data__.has(key);\n}\nvar _stackHas4 = stackHas4;\nvar freeGlobal4 = typeof commonjsGlobal4 == \"object\" && commonjsGlobal4 && commonjsGlobal4.Object === Object && commonjsGlobal4;\nvar _freeGlobal4 = freeGlobal4;\nvar freeSelf4 = typeof self == \"object\" && self && self.Object === Object && self;\nvar root4 = _freeGlobal4 || freeSelf4 || Function(\"return this\")();\nvar _root4 = root4;\nvar Symbol$12 = _root4.Symbol;\nvar _Symbol4 = Symbol$12;\nvar objectProto$c3 = Object.prototype;\nvar hasOwnProperty$93 = objectProto$c3.hasOwnProperty;\nvar nativeObjectToString$14 = objectProto$c3.toString;\nvar symToStringTag$14 = _Symbol4 ? _Symbol4.toStringTag : void 0;\nfunction getRawTag4(value) {\n  var isOwn = hasOwnProperty$93.call(value, symToStringTag$14), tag = value[symToStringTag$14];\n  try {\n    value[symToStringTag$14] = void 0;\n    var unmasked = true;\n  } catch (e4) {\n  }\n  var result = nativeObjectToString$14.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$14] = tag;\n    } else {\n      delete value[symToStringTag$14];\n    }\n  }\n  return result;\n}\nvar _getRawTag4 = getRawTag4;\nvar objectProto$b4 = Object.prototype;\nvar nativeObjectToString4 = objectProto$b4.toString;\nfunction objectToString4(value) {\n  return nativeObjectToString4.call(value);\n}\nvar _objectToString4 = objectToString4;\nvar nullTag4 = \"[object Null]\";\nvar undefinedTag4 = \"[object Undefined]\";\nvar symToStringTag4 = _Symbol4 ? _Symbol4.toStringTag : void 0;\nfunction baseGetTag4(value) {\n  if (value == null) {\n    return value === void 0 ? undefinedTag4 : nullTag4;\n  }\n  return symToStringTag4 && symToStringTag4 in Object(value) ? _getRawTag4(value) : _objectToString4(value);\n}\nvar _baseGetTag4 = baseGetTag4;\nfunction isObject6(value) {\n  var type = typeof value;\n  return value != null && (type == \"object\" || type == \"function\");\n}\nvar isObject_14 = isObject6;\nvar asyncTag4 = \"[object AsyncFunction]\";\nvar funcTag$23 = \"[object Function]\";\nvar genTag$13 = \"[object GeneratorFunction]\";\nvar proxyTag4 = \"[object Proxy]\";\nfunction isFunction5(value) {\n  if (!isObject_14(value)) {\n    return false;\n  }\n  var tag = _baseGetTag4(value);\n  return tag == funcTag$23 || tag == genTag$13 || tag == asyncTag4 || tag == proxyTag4;\n}\nvar isFunction_14 = isFunction5;\nvar coreJsData4 = _root4[\"__core-js_shared__\"];\nvar _coreJsData4 = coreJsData4;\nvar maskSrcKey4 = function() {\n  var uid = /[^.]+$/.exec(_coreJsData4 && _coreJsData4.keys && _coreJsData4.keys.IE_PROTO || \"\");\n  return uid ? \"Symbol(src)_1.\" + uid : \"\";\n}();\nfunction isMasked4(func) {\n  return !!maskSrcKey4 && maskSrcKey4 in func;\n}\nvar _isMasked4 = isMasked4;\nvar funcProto$14 = Function.prototype;\nvar funcToString$14 = funcProto$14.toString;\nfunction toSource4(func) {\n  if (func != null) {\n    try {\n      return funcToString$14.call(func);\n    } catch (e4) {\n    }\n    try {\n      return func + \"\";\n    } catch (e4) {\n    }\n  }\n  return \"\";\n}\nvar _toSource4 = toSource4;\nvar reRegExpChar4 = /[\\\\^$.*+?()[\\]{}|]/g;\nvar reIsHostCtor4 = /^\\[object .+?Constructor\\]$/;\nvar funcProto4 = Function.prototype;\nvar objectProto$a4 = Object.prototype;\nvar funcToString4 = funcProto4.toString;\nvar hasOwnProperty$84 = objectProto$a4.hasOwnProperty;\nvar reIsNative4 = RegExp(\n  \"^\" + funcToString4.call(hasOwnProperty$84).replace(reRegExpChar4, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n);\nfunction baseIsNative4(value) {\n  if (!isObject_14(value) || _isMasked4(value)) {\n    return false;\n  }\n  var pattern = isFunction_14(value) ? reIsNative4 : reIsHostCtor4;\n  return pattern.test(_toSource4(value));\n}\nvar _baseIsNative4 = baseIsNative4;\nfunction getValue4(object, key) {\n  return object == null ? void 0 : object[key];\n}\nvar _getValue4 = getValue4;\nfunction getNative4(object, key) {\n  var value = _getValue4(object, key);\n  return _baseIsNative4(value) ? value : void 0;\n}\nvar _getNative4 = getNative4;\nvar Map4 = _getNative4(_root4, \"Map\");\nvar _Map4 = Map4;\nvar nativeCreate4 = _getNative4(Object, \"create\");\nvar _nativeCreate4 = nativeCreate4;\nfunction hashClear4() {\n  this.__data__ = _nativeCreate4 ? _nativeCreate4(null) : {};\n  this.size = 0;\n}\nvar _hashClear4 = hashClear4;\nfunction hashDelete4(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\nvar _hashDelete4 = hashDelete4;\nvar HASH_UNDEFINED$14 = \"__lodash_hash_undefined__\";\nvar objectProto$94 = Object.prototype;\nvar hasOwnProperty$74 = objectProto$94.hasOwnProperty;\nfunction hashGet4(key) {\n  var data = this.__data__;\n  if (_nativeCreate4) {\n    var result = data[key];\n    return result === HASH_UNDEFINED$14 ? void 0 : result;\n  }\n  return hasOwnProperty$74.call(data, key) ? data[key] : void 0;\n}\nvar _hashGet4 = hashGet4;\nvar objectProto$84 = Object.prototype;\nvar hasOwnProperty$64 = objectProto$84.hasOwnProperty;\nfunction hashHas4(key) {\n  var data = this.__data__;\n  return _nativeCreate4 ? data[key] !== void 0 : hasOwnProperty$64.call(data, key);\n}\nvar _hashHas4 = hashHas4;\nvar HASH_UNDEFINED4 = \"__lodash_hash_undefined__\";\nfunction hashSet4(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = _nativeCreate4 && value === void 0 ? HASH_UNDEFINED4 : value;\n  return this;\n}\nvar _hashSet4 = hashSet4;\nfunction Hash4(entries) {\n  var index5 = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index5 < length) {\n    var entry = entries[index5];\n    this.set(entry[0], entry[1]);\n  }\n}\nHash4.prototype.clear = _hashClear4;\nHash4.prototype[\"delete\"] = _hashDelete4;\nHash4.prototype.get = _hashGet4;\nHash4.prototype.has = _hashHas4;\nHash4.prototype.set = _hashSet4;\nvar _Hash4 = Hash4;\nfunction mapCacheClear4() {\n  this.size = 0;\n  this.__data__ = {\n    \"hash\": new _Hash4(),\n    \"map\": new (_Map4 || _ListCache4)(),\n    \"string\": new _Hash4()\n  };\n}\nvar _mapCacheClear4 = mapCacheClear4;\nfunction isKeyable4(value) {\n  var type = typeof value;\n  return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n}\nvar _isKeyable4 = isKeyable4;\nfunction getMapData4(map2, key) {\n  var data = map2.__data__;\n  return _isKeyable4(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n}\nvar _getMapData4 = getMapData4;\nfunction mapCacheDelete4(key) {\n  var result = _getMapData4(this, key)[\"delete\"](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\nvar _mapCacheDelete4 = mapCacheDelete4;\nfunction mapCacheGet4(key) {\n  return _getMapData4(this, key).get(key);\n}\nvar _mapCacheGet4 = mapCacheGet4;\nfunction mapCacheHas4(key) {\n  return _getMapData4(this, key).has(key);\n}\nvar _mapCacheHas4 = mapCacheHas4;\nfunction mapCacheSet4(key, value) {\n  var data = _getMapData4(this, key), size = data.size;\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\nvar _mapCacheSet4 = mapCacheSet4;\nfunction MapCache4(entries) {\n  var index5 = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index5 < length) {\n    var entry = entries[index5];\n    this.set(entry[0], entry[1]);\n  }\n}\nMapCache4.prototype.clear = _mapCacheClear4;\nMapCache4.prototype[\"delete\"] = _mapCacheDelete4;\nMapCache4.prototype.get = _mapCacheGet4;\nMapCache4.prototype.has = _mapCacheHas4;\nMapCache4.prototype.set = _mapCacheSet4;\nvar _MapCache4 = MapCache4;\nvar LARGE_ARRAY_SIZE4 = 200;\nfunction stackSet4(key, value) {\n  var data = this.__data__;\n  if (data instanceof _ListCache4) {\n    var pairs = data.__data__;\n    if (!_Map4 || pairs.length < LARGE_ARRAY_SIZE4 - 1) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new _MapCache4(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\nvar _stackSet4 = stackSet4;\nfunction Stack4(entries) {\n  var data = this.__data__ = new _ListCache4(entries);\n  this.size = data.size;\n}\nStack4.prototype.clear = _stackClear4;\nStack4.prototype[\"delete\"] = _stackDelete4;\nStack4.prototype.get = _stackGet4;\nStack4.prototype.has = _stackHas4;\nStack4.prototype.set = _stackSet4;\nvar _Stack3 = Stack4;\nfunction arrayEach3(array, iteratee) {\n  var index5 = -1, length = array == null ? 0 : array.length;\n  while (++index5 < length) {\n    if (iteratee(array[index5], index5, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\nvar _arrayEach3 = arrayEach3;\nvar defineProperty4 = function() {\n  try {\n    var func = _getNative4(Object, \"defineProperty\");\n    func({}, \"\", {});\n    return func;\n  } catch (e4) {\n  }\n}();\nvar _defineProperty11 = defineProperty4;\nfunction baseAssignValue3(object, key, value) {\n  if (key == \"__proto__\" && _defineProperty11) {\n    _defineProperty11(object, key, {\n      \"configurable\": true,\n      \"enumerable\": true,\n      \"value\": value,\n      \"writable\": true\n    });\n  } else {\n    object[key] = value;\n  }\n}\nvar _baseAssignValue3 = baseAssignValue3;\nvar objectProto$74 = Object.prototype;\nvar hasOwnProperty$54 = objectProto$74.hasOwnProperty;\nfunction assignValue3(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty$54.call(object, key) && eq_14(objValue, value)) || value === void 0 && !(key in object)) {\n    _baseAssignValue3(object, key, value);\n  }\n}\nvar _assignValue3 = assignValue3;\nfunction copyObject3(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n  var index5 = -1, length = props.length;\n  while (++index5 < length) {\n    var key = props[index5];\n    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;\n    if (newValue === void 0) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      _baseAssignValue3(object, key, newValue);\n    } else {\n      _assignValue3(object, key, newValue);\n    }\n  }\n  return object;\n}\nvar _copyObject3 = copyObject3;\nfunction baseTimes3(n8, iteratee) {\n  var index5 = -1, result = Array(n8);\n  while (++index5 < n8) {\n    result[index5] = iteratee(index5);\n  }\n  return result;\n}\nvar _baseTimes3 = baseTimes3;\nfunction isObjectLike4(value) {\n  return value != null && typeof value == \"object\";\n}\nvar isObjectLike_14 = isObjectLike4;\nvar argsTag$24 = \"[object Arguments]\";\nfunction baseIsArguments4(value) {\n  return isObjectLike_14(value) && _baseGetTag4(value) == argsTag$24;\n}\nvar _baseIsArguments4 = baseIsArguments4;\nvar objectProto$64 = Object.prototype;\nvar hasOwnProperty$44 = objectProto$64.hasOwnProperty;\nvar propertyIsEnumerable$14 = objectProto$64.propertyIsEnumerable;\nvar isArguments4 = _baseIsArguments4(function() {\n  return arguments;\n}()) ? _baseIsArguments4 : function(value) {\n  return isObjectLike_14(value) && hasOwnProperty$44.call(value, \"callee\") && !propertyIsEnumerable$14.call(value, \"callee\");\n};\nvar isArguments_13 = isArguments4;\nvar isArray6 = Array.isArray;\nvar isArray_15 = isArray6;\nfunction stubFalse4() {\n  return false;\n}\nvar stubFalse_14 = stubFalse4;\nvar isBuffer_14 = createCommonjsModule8(function(module2, exports2) {\n  var freeExports = exports2 && !exports2.nodeType && exports2;\n  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n  var Buffer2 = moduleExports ? _root4.Buffer : void 0;\n  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;\n  var isBuffer = nativeIsBuffer || stubFalse_14;\n  module2.exports = isBuffer;\n});\nvar MAX_SAFE_INTEGER$13 = 9007199254740991;\nvar reIsUint3 = /^(?:0|[1-9]\\d*)$/;\nfunction isIndex3(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER$13 : length;\n  return !!length && (type == \"number\" || type != \"symbol\" && reIsUint3.test(value)) && (value > -1 && value % 1 == 0 && value < length);\n}\nvar _isIndex3 = isIndex3;\nvar MAX_SAFE_INTEGER4 = 9007199254740991;\nfunction isLength4(value) {\n  return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER4;\n}\nvar isLength_14 = isLength4;\nvar argsTag$14 = \"[object Arguments]\";\nvar arrayTag$14 = \"[object Array]\";\nvar boolTag$23 = \"[object Boolean]\";\nvar dateTag$23 = \"[object Date]\";\nvar errorTag$14 = \"[object Error]\";\nvar funcTag$14 = \"[object Function]\";\nvar mapTag$43 = \"[object Map]\";\nvar numberTag$23 = \"[object Number]\";\nvar objectTag$24 = \"[object Object]\";\nvar regexpTag$23 = \"[object RegExp]\";\nvar setTag$43 = \"[object Set]\";\nvar stringTag$23 = \"[object String]\";\nvar weakMapTag$23 = \"[object WeakMap]\";\nvar arrayBufferTag$23 = \"[object ArrayBuffer]\";\nvar dataViewTag$33 = \"[object DataView]\";\nvar float32Tag$23 = \"[object Float32Array]\";\nvar float64Tag$23 = \"[object Float64Array]\";\nvar int8Tag$23 = \"[object Int8Array]\";\nvar int16Tag$23 = \"[object Int16Array]\";\nvar int32Tag$23 = \"[object Int32Array]\";\nvar uint8Tag$23 = \"[object Uint8Array]\";\nvar uint8ClampedTag$23 = \"[object Uint8ClampedArray]\";\nvar uint16Tag$23 = \"[object Uint16Array]\";\nvar uint32Tag$23 = \"[object Uint32Array]\";\nvar typedArrayTags4 = {};\ntypedArrayTags4[float32Tag$23] = typedArrayTags4[float64Tag$23] = typedArrayTags4[int8Tag$23] = typedArrayTags4[int16Tag$23] = typedArrayTags4[int32Tag$23] = typedArrayTags4[uint8Tag$23] = typedArrayTags4[uint8ClampedTag$23] = typedArrayTags4[uint16Tag$23] = typedArrayTags4[uint32Tag$23] = true;\ntypedArrayTags4[argsTag$14] = typedArrayTags4[arrayTag$14] = typedArrayTags4[arrayBufferTag$23] = typedArrayTags4[boolTag$23] = typedArrayTags4[dataViewTag$33] = typedArrayTags4[dateTag$23] = typedArrayTags4[errorTag$14] = typedArrayTags4[funcTag$14] = typedArrayTags4[mapTag$43] = typedArrayTags4[numberTag$23] = typedArrayTags4[objectTag$24] = typedArrayTags4[regexpTag$23] = typedArrayTags4[setTag$43] = typedArrayTags4[stringTag$23] = typedArrayTags4[weakMapTag$23] = false;\nfunction baseIsTypedArray4(value) {\n  return isObjectLike_14(value) && isLength_14(value.length) && !!typedArrayTags4[_baseGetTag4(value)];\n}\nvar _baseIsTypedArray4 = baseIsTypedArray4;\nfunction baseUnary4(func) {\n  return function(value) {\n    return func(value);\n  };\n}\nvar _baseUnary4 = baseUnary4;\nvar _nodeUtil4 = createCommonjsModule8(function(module2, exports2) {\n  var freeExports = exports2 && !exports2.nodeType && exports2;\n  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n  var freeProcess = moduleExports && _freeGlobal4.process;\n  var nodeUtil = function() {\n    try {\n      var types = freeModule && freeModule.require && freeModule.require(\"util\").types;\n      if (types) {\n        return types;\n      }\n      return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n    } catch (e4) {\n    }\n  }();\n  module2.exports = nodeUtil;\n});\nvar nodeIsTypedArray4 = _nodeUtil4 && _nodeUtil4.isTypedArray;\nvar isTypedArray4 = nodeIsTypedArray4 ? _baseUnary4(nodeIsTypedArray4) : _baseIsTypedArray4;\nvar isTypedArray_13 = isTypedArray4;\nvar objectProto$54 = Object.prototype;\nvar hasOwnProperty$34 = objectProto$54.hasOwnProperty;\nfunction arrayLikeKeys3(value, inherited) {\n  var isArr = isArray_15(value), isArg = !isArr && isArguments_13(value), isBuff = !isArr && !isArg && isBuffer_14(value), isType3 = !isArr && !isArg && !isBuff && isTypedArray_13(value), skipIndexes = isArr || isArg || isBuff || isType3, result = skipIndexes ? _baseTimes3(value.length, String) : [], length = result.length;\n  for (var key in value) {\n    if ((inherited || hasOwnProperty$34.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.\n    (key == \"length\" || isBuff && (key == \"offset\" || key == \"parent\") || isType3 && (key == \"buffer\" || key == \"byteLength\" || key == \"byteOffset\") || // Skip index properties.\n    _isIndex3(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\nvar _arrayLikeKeys3 = arrayLikeKeys3;\nvar objectProto$44 = Object.prototype;\nfunction isPrototype3(value) {\n  var Ctor = value && value.constructor, proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto$44;\n  return value === proto;\n}\nvar _isPrototype3 = isPrototype3;\nfunction overArg4(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\nvar _overArg4 = overArg4;\nvar nativeKeys4 = _overArg4(Object.keys, Object);\nvar _nativeKeys3 = nativeKeys4;\nvar objectProto$34 = Object.prototype;\nvar hasOwnProperty$24 = objectProto$34.hasOwnProperty;\nfunction baseKeys3(object) {\n  if (!_isPrototype3(object)) {\n    return _nativeKeys3(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty$24.call(object, key) && key != \"constructor\") {\n      result.push(key);\n    }\n  }\n  return result;\n}\nvar _baseKeys3 = baseKeys3;\nfunction isArrayLike3(value) {\n  return value != null && isLength_14(value.length) && !isFunction_14(value);\n}\nvar isArrayLike_13 = isArrayLike3;\nfunction keys3(object) {\n  return isArrayLike_13(object) ? _arrayLikeKeys3(object) : _baseKeys3(object);\n}\nvar keys_13 = keys3;\nfunction baseAssign3(object, source) {\n  return object && _copyObject3(source, keys_13(source), object);\n}\nvar _baseAssign3 = baseAssign3;\nfunction nativeKeysIn3(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\nvar _nativeKeysIn3 = nativeKeysIn3;\nvar objectProto$24 = Object.prototype;\nvar hasOwnProperty$14 = objectProto$24.hasOwnProperty;\nfunction baseKeysIn3(object) {\n  if (!isObject_14(object)) {\n    return _nativeKeysIn3(object);\n  }\n  var isProto = _isPrototype3(object), result = [];\n  for (var key in object) {\n    if (!(key == \"constructor\" && (isProto || !hasOwnProperty$14.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\nvar _baseKeysIn3 = baseKeysIn3;\nfunction keysIn3(object) {\n  return isArrayLike_13(object) ? _arrayLikeKeys3(object, true) : _baseKeysIn3(object);\n}\nvar keysIn_13 = keysIn3;\nfunction baseAssignIn3(object, source) {\n  return object && _copyObject3(source, keysIn_13(source), object);\n}\nvar _baseAssignIn3 = baseAssignIn3;\nvar _cloneBuffer3 = createCommonjsModule8(function(module2, exports2) {\n  var freeExports = exports2 && !exports2.nodeType && exports2;\n  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n  var Buffer2 = moduleExports ? _root4.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;\n  function cloneBuffer(buffer, isDeep) {\n    if (isDeep) {\n      return buffer.slice();\n    }\n    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n    buffer.copy(result);\n    return result;\n  }\n  module2.exports = cloneBuffer;\n});\nfunction copyArray3(source, array) {\n  var index5 = -1, length = source.length;\n  array || (array = Array(length));\n  while (++index5 < length) {\n    array[index5] = source[index5];\n  }\n  return array;\n}\nvar _copyArray3 = copyArray3;\nfunction arrayFilter3(array, predicate) {\n  var index5 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];\n  while (++index5 < length) {\n    var value = array[index5];\n    if (predicate(value, index5, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\nvar _arrayFilter3 = arrayFilter3;\nfunction stubArray3() {\n  return [];\n}\nvar stubArray_13 = stubArray3;\nvar objectProto$14 = Object.prototype;\nvar propertyIsEnumerable4 = objectProto$14.propertyIsEnumerable;\nvar nativeGetSymbols$13 = Object.getOwnPropertySymbols;\nvar getSymbols3 = !nativeGetSymbols$13 ? stubArray_13 : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return _arrayFilter3(nativeGetSymbols$13(object), function(symbol) {\n    return propertyIsEnumerable4.call(object, symbol);\n  });\n};\nvar _getSymbols3 = getSymbols3;\nfunction copySymbols3(source, object) {\n  return _copyObject3(source, _getSymbols3(source), object);\n}\nvar _copySymbols3 = copySymbols3;\nfunction arrayPush3(array, values2) {\n  var index5 = -1, length = values2.length, offset3 = array.length;\n  while (++index5 < length) {\n    array[offset3 + index5] = values2[index5];\n  }\n  return array;\n}\nvar _arrayPush3 = arrayPush3;\nvar getPrototype3 = _overArg4(Object.getPrototypeOf, Object);\nvar _getPrototype3 = getPrototype3;\nvar nativeGetSymbols3 = Object.getOwnPropertySymbols;\nvar getSymbolsIn3 = !nativeGetSymbols3 ? stubArray_13 : function(object) {\n  var result = [];\n  while (object) {\n    _arrayPush3(result, _getSymbols3(object));\n    object = _getPrototype3(object);\n  }\n  return result;\n};\nvar _getSymbolsIn3 = getSymbolsIn3;\nfunction copySymbolsIn3(source, object) {\n  return _copyObject3(source, _getSymbolsIn3(source), object);\n}\nvar _copySymbolsIn3 = copySymbolsIn3;\nfunction baseGetAllKeys3(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray_15(object) ? result : _arrayPush3(result, symbolsFunc(object));\n}\nvar _baseGetAllKeys3 = baseGetAllKeys3;\nfunction getAllKeys3(object) {\n  return _baseGetAllKeys3(object, keys_13, _getSymbols3);\n}\nvar _getAllKeys3 = getAllKeys3;\nfunction getAllKeysIn3(object) {\n  return _baseGetAllKeys3(object, keysIn_13, _getSymbolsIn3);\n}\nvar _getAllKeysIn3 = getAllKeysIn3;\nvar DataView4 = _getNative4(_root4, \"DataView\");\nvar _DataView4 = DataView4;\nvar Promise$14 = _getNative4(_root4, \"Promise\");\nvar _Promise4 = Promise$14;\nvar Set5 = _getNative4(_root4, \"Set\");\nvar _Set4 = Set5;\nvar WeakMap4 = _getNative4(_root4, \"WeakMap\");\nvar _WeakMap4 = WeakMap4;\nvar mapTag$33 = \"[object Map]\";\nvar objectTag$14 = \"[object Object]\";\nvar promiseTag4 = \"[object Promise]\";\nvar setTag$33 = \"[object Set]\";\nvar weakMapTag$14 = \"[object WeakMap]\";\nvar dataViewTag$24 = \"[object DataView]\";\nvar dataViewCtorString4 = _toSource4(_DataView4);\nvar mapCtorString4 = _toSource4(_Map4);\nvar promiseCtorString4 = _toSource4(_Promise4);\nvar setCtorString4 = _toSource4(_Set4);\nvar weakMapCtorString4 = _toSource4(_WeakMap4);\nvar getTag4 = _baseGetTag4;\nif (_DataView4 && getTag4(new _DataView4(new ArrayBuffer(1))) != dataViewTag$24 || _Map4 && getTag4(new _Map4()) != mapTag$33 || _Promise4 && getTag4(_Promise4.resolve()) != promiseTag4 || _Set4 && getTag4(new _Set4()) != setTag$33 || _WeakMap4 && getTag4(new _WeakMap4()) != weakMapTag$14) {\n  getTag4 = function(value) {\n    var result = _baseGetTag4(value), Ctor = result == objectTag$14 ? value.constructor : void 0, ctorString = Ctor ? _toSource4(Ctor) : \"\";\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString4:\n          return dataViewTag$24;\n        case mapCtorString4:\n          return mapTag$33;\n        case promiseCtorString4:\n          return promiseTag4;\n        case setCtorString4:\n          return setTag$33;\n        case weakMapCtorString4:\n          return weakMapTag$14;\n      }\n    }\n    return result;\n  };\n}\nvar _getTag3 = getTag4;\nvar objectProto4 = Object.prototype;\nvar hasOwnProperty4 = objectProto4.hasOwnProperty;\nfunction initCloneArray3(array) {\n  var length = array.length, result = new array.constructor(length);\n  if (length && typeof array[0] == \"string\" && hasOwnProperty4.call(array, \"index\")) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\nvar _initCloneArray3 = initCloneArray3;\nvar Uint8Array5 = _root4.Uint8Array;\nvar _Uint8Array3 = Uint8Array5;\nfunction cloneArrayBuffer3(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new _Uint8Array3(result).set(new _Uint8Array3(arrayBuffer));\n  return result;\n}\nvar _cloneArrayBuffer3 = cloneArrayBuffer3;\nfunction cloneDataView3(dataView, isDeep) {\n  var buffer = isDeep ? _cloneArrayBuffer3(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\nvar _cloneDataView3 = cloneDataView3;\nvar reFlags3 = /\\w*$/;\nfunction cloneRegExp3(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags3.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\nvar _cloneRegExp3 = cloneRegExp3;\nvar symbolProto4 = _Symbol4 ? _Symbol4.prototype : void 0;\nvar symbolValueOf4 = symbolProto4 ? symbolProto4.valueOf : void 0;\nfunction cloneSymbol3(symbol) {\n  return symbolValueOf4 ? Object(symbolValueOf4.call(symbol)) : {};\n}\nvar _cloneSymbol3 = cloneSymbol3;\nfunction cloneTypedArray3(typedArray, isDeep) {\n  var buffer = isDeep ? _cloneArrayBuffer3(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\nvar _cloneTypedArray3 = cloneTypedArray3;\nvar boolTag$14 = \"[object Boolean]\";\nvar dateTag$14 = \"[object Date]\";\nvar mapTag$24 = \"[object Map]\";\nvar numberTag$14 = \"[object Number]\";\nvar regexpTag$14 = \"[object RegExp]\";\nvar setTag$24 = \"[object Set]\";\nvar stringTag$14 = \"[object String]\";\nvar symbolTag$13 = \"[object Symbol]\";\nvar arrayBufferTag$14 = \"[object ArrayBuffer]\";\nvar dataViewTag$13 = \"[object DataView]\";\nvar float32Tag$13 = \"[object Float32Array]\";\nvar float64Tag$13 = \"[object Float64Array]\";\nvar int8Tag$13 = \"[object Int8Array]\";\nvar int16Tag$13 = \"[object Int16Array]\";\nvar int32Tag$13 = \"[object Int32Array]\";\nvar uint8Tag$13 = \"[object Uint8Array]\";\nvar uint8ClampedTag$13 = \"[object Uint8ClampedArray]\";\nvar uint16Tag$13 = \"[object Uint16Array]\";\nvar uint32Tag$13 = \"[object Uint32Array]\";\nfunction initCloneByTag3(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag$14:\n      return _cloneArrayBuffer3(object);\n    case boolTag$14:\n    case dateTag$14:\n      return new Ctor(+object);\n    case dataViewTag$13:\n      return _cloneDataView3(object, isDeep);\n    case float32Tag$13:\n    case float64Tag$13:\n    case int8Tag$13:\n    case int16Tag$13:\n    case int32Tag$13:\n    case uint8Tag$13:\n    case uint8ClampedTag$13:\n    case uint16Tag$13:\n    case uint32Tag$13:\n      return _cloneTypedArray3(object, isDeep);\n    case mapTag$24:\n      return new Ctor();\n    case numberTag$14:\n    case stringTag$14:\n      return new Ctor(object);\n    case regexpTag$14:\n      return _cloneRegExp3(object);\n    case setTag$24:\n      return new Ctor();\n    case symbolTag$13:\n      return _cloneSymbol3(object);\n  }\n}\nvar _initCloneByTag3 = initCloneByTag3;\nvar objectCreate3 = Object.create;\nvar baseCreate3 = function() {\n  function object() {\n  }\n  return function(proto) {\n    if (!isObject_14(proto)) {\n      return {};\n    }\n    if (objectCreate3) {\n      return objectCreate3(proto);\n    }\n    object.prototype = proto;\n    var result = new object();\n    object.prototype = void 0;\n    return result;\n  };\n}();\nvar _baseCreate3 = baseCreate3;\nfunction initCloneObject3(object) {\n  return typeof object.constructor == \"function\" && !_isPrototype3(object) ? _baseCreate3(_getPrototype3(object)) : {};\n}\nvar _initCloneObject3 = initCloneObject3;\nvar mapTag$13 = \"[object Map]\";\nfunction baseIsMap3(value) {\n  return isObjectLike_14(value) && _getTag3(value) == mapTag$13;\n}\nvar _baseIsMap3 = baseIsMap3;\nvar nodeIsMap3 = _nodeUtil4 && _nodeUtil4.isMap;\nvar isMap3 = nodeIsMap3 ? _baseUnary4(nodeIsMap3) : _baseIsMap3;\nvar isMap_13 = isMap3;\nvar setTag$13 = \"[object Set]\";\nfunction baseIsSet3(value) {\n  return isObjectLike_14(value) && _getTag3(value) == setTag$13;\n}\nvar _baseIsSet3 = baseIsSet3;\nvar nodeIsSet3 = _nodeUtil4 && _nodeUtil4.isSet;\nvar isSet3 = nodeIsSet3 ? _baseUnary4(nodeIsSet3) : _baseIsSet3;\nvar isSet_13 = isSet3;\nvar CLONE_DEEP_FLAG$13 = 1;\nvar CLONE_FLAT_FLAG3 = 2;\nvar CLONE_SYMBOLS_FLAG$13 = 4;\nvar argsTag3 = \"[object Arguments]\";\nvar arrayTag3 = \"[object Array]\";\nvar boolTag3 = \"[object Boolean]\";\nvar dateTag3 = \"[object Date]\";\nvar errorTag3 = \"[object Error]\";\nvar funcTag4 = \"[object Function]\";\nvar genTag4 = \"[object GeneratorFunction]\";\nvar mapTag4 = \"[object Map]\";\nvar numberTag3 = \"[object Number]\";\nvar objectTag3 = \"[object Object]\";\nvar regexpTag3 = \"[object RegExp]\";\nvar setTag4 = \"[object Set]\";\nvar stringTag3 = \"[object String]\";\nvar symbolTag3 = \"[object Symbol]\";\nvar weakMapTag4 = \"[object WeakMap]\";\nvar arrayBufferTag3 = \"[object ArrayBuffer]\";\nvar dataViewTag4 = \"[object DataView]\";\nvar float32Tag4 = \"[object Float32Array]\";\nvar float64Tag4 = \"[object Float64Array]\";\nvar int8Tag4 = \"[object Int8Array]\";\nvar int16Tag4 = \"[object Int16Array]\";\nvar int32Tag4 = \"[object Int32Array]\";\nvar uint8Tag4 = \"[object Uint8Array]\";\nvar uint8ClampedTag4 = \"[object Uint8ClampedArray]\";\nvar uint16Tag4 = \"[object Uint16Array]\";\nvar uint32Tag4 = \"[object Uint32Array]\";\nvar cloneableTags3 = {};\ncloneableTags3[argsTag3] = cloneableTags3[arrayTag3] = cloneableTags3[arrayBufferTag3] = cloneableTags3[dataViewTag4] = cloneableTags3[boolTag3] = cloneableTags3[dateTag3] = cloneableTags3[float32Tag4] = cloneableTags3[float64Tag4] = cloneableTags3[int8Tag4] = cloneableTags3[int16Tag4] = cloneableTags3[int32Tag4] = cloneableTags3[mapTag4] = cloneableTags3[numberTag3] = cloneableTags3[objectTag3] = cloneableTags3[regexpTag3] = cloneableTags3[setTag4] = cloneableTags3[stringTag3] = cloneableTags3[symbolTag3] = cloneableTags3[uint8Tag4] = cloneableTags3[uint8ClampedTag4] = cloneableTags3[uint16Tag4] = cloneableTags3[uint32Tag4] = true;\ncloneableTags3[errorTag3] = cloneableTags3[funcTag4] = cloneableTags3[weakMapTag4] = false;\nfunction baseClone3(value, bitmask, customizer, key, object, stack) {\n  var result, isDeep = bitmask & CLONE_DEEP_FLAG$13, isFlat = bitmask & CLONE_FLAT_FLAG3, isFull = bitmask & CLONE_SYMBOLS_FLAG$13;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== void 0) {\n    return result;\n  }\n  if (!isObject_14(value)) {\n    return value;\n  }\n  var isArr = isArray_15(value);\n  if (isArr) {\n    result = _initCloneArray3(value);\n    if (!isDeep) {\n      return _copyArray3(value, result);\n    }\n  } else {\n    var tag = _getTag3(value), isFunc = tag == funcTag4 || tag == genTag4;\n    if (isBuffer_14(value)) {\n      return _cloneBuffer3(value, isDeep);\n    }\n    if (tag == objectTag3 || tag == argsTag3 || isFunc && !object) {\n      result = isFlat || isFunc ? {} : _initCloneObject3(value);\n      if (!isDeep) {\n        return isFlat ? _copySymbolsIn3(value, _baseAssignIn3(result, value)) : _copySymbols3(value, _baseAssign3(result, value));\n      }\n    } else {\n      if (!cloneableTags3[tag]) {\n        return object ? value : {};\n      }\n      result = _initCloneByTag3(value, tag, isDeep);\n    }\n  }\n  stack || (stack = new _Stack3());\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n  if (isSet_13(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone3(subValue, bitmask, customizer, subValue, value, stack));\n    });\n  } else if (isMap_13(value)) {\n    value.forEach(function(subValue, key2) {\n      result.set(key2, baseClone3(subValue, bitmask, customizer, key2, value, stack));\n    });\n  }\n  var keysFunc = isFull ? isFlat ? _getAllKeysIn3 : _getAllKeys3 : isFlat ? keysIn_13 : keys_13;\n  var props = isArr ? void 0 : keysFunc(value);\n  _arrayEach3(props || value, function(subValue, key2) {\n    if (props) {\n      key2 = subValue;\n      subValue = value[key2];\n    }\n    _assignValue3(result, key2, baseClone3(subValue, bitmask, customizer, key2, value, stack));\n  });\n  return result;\n}\nvar _baseClone3 = baseClone3;\nvar CLONE_DEEP_FLAG3 = 1;\nvar CLONE_SYMBOLS_FLAG3 = 4;\nfunction cloneDeep4(value) {\n  return _baseClone3(value, CLONE_DEEP_FLAG3 | CLONE_SYMBOLS_FLAG3);\n}\nvar cloneDeep_13 = cloneDeep4;\nvar withInsertFragmentTable = (editor, {\n  options\n}) => {\n  const {\n    insertFragment: insertFragment2\n  } = editor;\n  const {\n    disableExpandOnInsert,\n    insertColumn,\n    insertRow\n  } = options;\n  const myEditor = getTEditor(editor);\n  myEditor.insertFragment = (fragment) => {\n    const insertedTable = fragment.find((n8) => n8.type === getPluginType(editor, ELEMENT_TABLE));\n    if (!insertedTable) {\n      var _editor$selection;\n      const tableEntry = getTableAbove(editor, {\n        at: (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor\n      });\n      if (tableEntry) {\n        const cellEntries = getTableGridAbove(editor, {\n          format: \"cell\"\n        });\n        if (cellEntries.length > 1) {\n          cellEntries.forEach((cellEntry) => {\n            if (cellEntry) {\n              const [, cellPath] = cellEntry;\n              replaceNodeChildren(editor, {\n                at: cellPath,\n                nodes: cloneDeep_13(fragment)\n              });\n            }\n          });\n          select(editor, {\n            anchor: getStartPoint(editor, cellEntries[0][1]),\n            focus: getEndPoint(editor, cellEntries[cellEntries.length - 1][1])\n          });\n          return;\n        }\n      }\n    }\n    if (insertedTable) {\n      var _editor$selection2;\n      const tableEntry = getTableAbove(editor, {\n        at: (_editor$selection2 = editor.selection) === null || _editor$selection2 === void 0 ? void 0 : _editor$selection2.anchor\n      });\n      if (tableEntry) {\n        var _editor$selection3;\n        const [cellEntry] = getTableGridAbove(editor, {\n          at: (_editor$selection3 = editor.selection) === null || _editor$selection3 === void 0 ? void 0 : _editor$selection3.anchor,\n          format: \"cell\"\n        });\n        if (cellEntry) {\n          withoutNormalizing(editor, () => {\n            const [, startCellPath] = cellEntry;\n            const cellPath = [...startCellPath];\n            const startColIndex = cellPath[cellPath.length - 1];\n            let lastCellPath = null;\n            let initRow = true;\n            const insertedRows = insertedTable.children;\n            insertedRows.forEach((row) => {\n              cellPath[cellPath.length - 1] = startColIndex;\n              if (!initRow) {\n                const fromRow = cellPath.slice(0, -1);\n                cellPath[cellPath.length - 2] += 1;\n                if (!hasNode(editor, cellPath)) {\n                  if (!disableExpandOnInsert) {\n                    insertRow === null || insertRow === void 0 ? void 0 : insertRow(editor, {\n                      fromRow\n                    });\n                  } else {\n                    return;\n                  }\n                }\n              }\n              initRow = false;\n              const insertedCells = row.children;\n              let initCell = true;\n              insertedCells.forEach((cell) => {\n                if (!initCell) {\n                  const fromCell = [...cellPath];\n                  cellPath[cellPath.length - 1] += 1;\n                  if (!hasNode(editor, cellPath)) {\n                    if (!disableExpandOnInsert) {\n                      insertColumn === null || insertColumn === void 0 ? void 0 : insertColumn(editor, {\n                        fromCell\n                      });\n                    } else {\n                      return;\n                    }\n                  }\n                }\n                initCell = false;\n                replaceNodeChildren(editor, {\n                  at: cellPath,\n                  nodes: cloneDeep_13(cell.children)\n                });\n                lastCellPath = [...cellPath];\n              });\n            });\n            if (lastCellPath) {\n              select(editor, {\n                anchor: getStartPoint(editor, startCellPath),\n                focus: getEndPoint(editor, lastCellPath)\n              });\n            }\n          });\n          return;\n        }\n      }\n    }\n    insertFragment2(fragment);\n  };\n  return editor;\n};\nvar withInsertTextTable = (editor, plugin) => {\n  const {\n    insertText: insertText2\n  } = editor;\n  editor.insertText = (text4) => {\n    if (isExpanded(editor.selection)) {\n      var _editor$selection;\n      const entry = getTableAbove(editor, {\n        at: (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor\n      });\n      if (entry) {\n        const cellEntries = getTableGridAbove(editor, {\n          format: \"cell\"\n        });\n        if (cellEntries.length > 1) {\n          collapseSelection(editor, {\n            edge: \"focus\"\n          });\n        }\n      }\n    }\n    insertText2(text4);\n  };\n  return editor;\n};\nvar withNormalizeTable = (editor) => {\n  const {\n    normalizeNode\n  } = editor;\n  const myEditor = getTEditor(editor);\n  myEditor.normalizeNode = ([node, path]) => {\n    if (isElement2(node) && getCellTypes(editor).includes(node.type)) {\n      const {\n        children\n      } = node;\n      if (isText(children[0])) {\n        wrapNodeChildren(editor, {\n          type: getPluginType(editor, ELEMENT_DEFAULT),\n          children: [{\n            text: \"\"\n          }]\n        }, {\n          at: path\n        });\n        return;\n      }\n    }\n    return normalizeNode([node, path]);\n  };\n  return editor;\n};\nvar withSelectionTable = (editor) => {\n  const {\n    apply: apply2\n  } = editor;\n  editor.apply = (op) => {\n    if (op.type === \"set_selection\" && op.newProperties) {\n      const newSelection = {\n        ...editor.selection,\n        ...op.newProperties\n      };\n      if (Range.isRange(newSelection) && isRangeAcrossBlocks(editor, {\n        at: newSelection,\n        match: (n8) => n8.type === getPluginType(editor, ELEMENT_TABLE)\n      })) {\n        const anchorEntry = getBlockAbove(editor, {\n          at: newSelection.anchor,\n          match: (n8) => n8.type === getPluginType(editor, ELEMENT_TABLE)\n        });\n        if (!anchorEntry) {\n          const focusEntry = getBlockAbove(editor, {\n            at: newSelection.focus,\n            match: (n8) => n8.type === getPluginType(editor, ELEMENT_TABLE)\n          });\n          if (focusEntry) {\n            const [, focusPath] = focusEntry;\n            const isBackward = Range.isBackward(newSelection);\n            if (isBackward) {\n              const startPoint = getStartPoint(editor, focusPath);\n              const pointBefore = getPointBefore(editor, startPoint);\n              op.newProperties.focus = pointBefore !== null && pointBefore !== void 0 ? pointBefore : startPoint;\n            } else {\n              op.newProperties.focus = getEndPoint(editor, focusPath);\n            }\n          }\n        } else {\n          const [, anchorPath] = anchorEntry;\n          const isBackward = Range.isBackward(newSelection);\n          if (isBackward) {\n            op.newProperties.focus = getStartPoint(editor, anchorPath);\n          } else {\n            const pointBefore = getPointBefore(editor, anchorPath);\n            if (pointBefore) {\n              op.newProperties.focus = getEndPoint(editor, anchorPath);\n            }\n          }\n        }\n      }\n      overrideSelectionFromCell(editor, newSelection);\n      if (editor.lastKeyDown) {\n        editor.lastKeyDown = null;\n      }\n    }\n    apply2(op);\n  };\n  return editor;\n};\nvar withTable = (editor, plugin) => {\n  editor = withNormalizeTable(editor);\n  editor = withDeleteTable(editor);\n  editor = withGetFragmentTable(editor);\n  editor = withInsertFragmentTable(editor, plugin);\n  editor = withInsertTextTable(editor);\n  editor = withSelectionTable(editor);\n  return editor;\n};\nvar ELEMENT_TABLE = \"table\";\nvar ELEMENT_TH = \"th\";\nvar ELEMENT_TR = \"tr\";\nvar ELEMENT_TD = \"td\";\nvar createTablePlugin = createPluginFactory({\n  key: ELEMENT_TABLE,\n  isElement: true,\n  handlers: {\n    onKeyDown: onKeyDownTable\n  },\n  deserializeHtml: {\n    rules: [{\n      validNodeName: \"TABLE\"\n    }]\n  },\n  options: {\n    insertColumn: (e4, {\n      fromCell\n    }) => {\n      insertTableColumn(e4, {\n        fromCell,\n        disableSelect: true\n      });\n    },\n    insertRow: (e4, {\n      fromRow\n    }) => {\n      insertTableRow(e4, {\n        fromRow,\n        disableSelect: true\n      });\n    }\n  },\n  withOverrides: withTable,\n  plugins: [{\n    key: ELEMENT_TR,\n    isElement: true,\n    deserializeHtml: {\n      rules: [{\n        validNodeName: \"TR\"\n      }]\n    }\n  }, {\n    key: ELEMENT_TD,\n    isElement: true,\n    deserializeHtml: {\n      attributeNames: [\"rowspan\", \"colspan\"],\n      rules: [{\n        validNodeName: \"TD\"\n      }]\n    },\n    props: ({\n      element: element4\n    }) => {\n      var _element$attributes, _element$attributes2;\n      return {\n        nodeProps: {\n          colSpan: element4 === null || element4 === void 0 ? void 0 : (_element$attributes = element4.attributes) === null || _element$attributes === void 0 ? void 0 : _element$attributes.colspan,\n          rowSpan: element4 === null || element4 === void 0 ? void 0 : (_element$attributes2 = element4.attributes) === null || _element$attributes2 === void 0 ? void 0 : _element$attributes2.rowspan\n        }\n      };\n    }\n  }, {\n    key: ELEMENT_TH,\n    isElement: true,\n    deserializeHtml: {\n      attributeNames: [\"rowspan\", \"colspan\"],\n      rules: [{\n        validNodeName: \"TH\"\n      }]\n    },\n    props: ({\n      element: element4\n    }) => {\n      var _element$attributes3, _element$attributes4;\n      return {\n        nodeProps: {\n          colSpan: element4 === null || element4 === void 0 ? void 0 : (_element$attributes3 = element4.attributes) === null || _element$attributes3 === void 0 ? void 0 : _element$attributes3.colspan,\n          rowSpan: element4 === null || element4 === void 0 ? void 0 : (_element$attributes4 = element4.attributes) === null || _element$attributes4 === void 0 ? void 0 : _element$attributes4.rowspan\n        }\n      };\n    }\n  }]\n});\n\n// node_modules/@udecode/plate-indent-list/dist/index.es.js\nvar import_react28 = __toESM(require(\"react\"));\n\n// node_modules/@udecode/plate-indent/dist/index.es.js\nvar setIndent = (editor, {\n  offset: offset3 = 1,\n  getNodesOptions,\n  setNodesProps,\n  unsetNodesProps = []\n}) => {\n  const {\n    nodeKey\n  } = getPluginInjectProps(editor, KEY_INDENT);\n  const _nodes = getNodeEntries(editor, {\n    block: true,\n    ...getNodesOptions\n  });\n  const nodes = Array.from(_nodes);\n  withoutNormalizing(editor, () => {\n    nodes.forEach(([node, path]) => {\n      var _ref, _setNodesProps;\n      const blockIndent = (_ref = node[nodeKey]) !== null && _ref !== void 0 ? _ref : 0;\n      const newIndent = blockIndent + offset3;\n      const props = (_setNodesProps = setNodesProps === null || setNodesProps === void 0 ? void 0 : setNodesProps({\n        indent: newIndent\n      })) !== null && _setNodesProps !== void 0 ? _setNodesProps : {};\n      if (newIndent <= 0) {\n        unsetNodes(editor, [nodeKey, ...unsetNodesProps], {\n          at: path\n        });\n      } else {\n        setElements(editor, {\n          [nodeKey]: newIndent,\n          ...props\n        }, {\n          at: path\n        });\n      }\n    });\n  });\n};\nvar indent = (editor, options) => {\n  setIndent(editor, {\n    offset: 1,\n    ...options\n  });\n};\nvar outdent = (editor, options) => {\n  setIndent(editor, {\n    offset: -1,\n    ...options\n  });\n};\nvar onKeyDownIndent = (editor) => (e4) => {\n  if (Hotkeys2.isTab(editor, e4)) {\n    e4.preventDefault();\n    indent(editor);\n  }\n  if (Hotkeys2.isUntab(editor, e4)) {\n    e4.preventDefault();\n    outdent(editor);\n  }\n};\nvar withIndent = (editor, {\n  inject: {\n    props: {\n      validTypes\n    } = {}\n  },\n  options: {\n    indentMax\n  }\n}) => {\n  const {\n    normalizeNode\n  } = editor;\n  editor.normalizeNode = ([node, path]) => {\n    const element4 = node;\n    const {\n      type\n    } = element4;\n    if (type) {\n      if (validTypes.includes(type)) {\n        if (indentMax && element4.indent && element4.indent > indentMax) {\n          setElements(editor, {\n            indent: indentMax\n          }, {\n            at: path\n          });\n          return;\n        }\n      } else if (element4.indent) {\n        unsetNodes(editor, \"indent\", {\n          at: path\n        });\n        return;\n      }\n    }\n    return normalizeNode([node, path]);\n  };\n  return editor;\n};\nvar KEY_INDENT = \"indent\";\nvar createIndentPlugin = createPluginFactory({\n  key: KEY_INDENT,\n  withOverrides: withIndent,\n  handlers: {\n    onKeyDown: onKeyDownIndent\n  },\n  options: {\n    offset: 24,\n    unit: \"px\"\n  },\n  then: (editor, {\n    options: {\n      offset: offset3,\n      unit\n    } = {}\n  }) => ({\n    inject: {\n      props: {\n        nodeKey: KEY_INDENT,\n        styleKey: \"marginLeft\",\n        validTypes: [getPluginType(editor, ELEMENT_DEFAULT)],\n        transformNodeValue: ({\n          nodeValue\n        }) => nodeValue * offset3 + unit\n      }\n    }\n  })\n});\nvar KEY_TEXT_INDENT = \"textIndent\";\nvar createTextIndentPlugin = createPluginFactory({\n  key: KEY_TEXT_INDENT,\n  options: {\n    offset: 24,\n    unit: \"px\"\n  },\n  then: (editor, {\n    options: {\n      offset: offset3,\n      unit\n    } = {}\n  }) => ({\n    inject: {\n      props: {\n        nodeKey: KEY_TEXT_INDENT,\n        styleKey: \"textIndent\",\n        validTypes: [getPluginType(editor, ELEMENT_DEFAULT)],\n        transformNodeValue({\n          nodeValue\n        }) {\n          return nodeValue * offset3 + unit;\n        }\n      }\n    }\n  })\n});\n\n// node_modules/@udecode/plate-indent-list/dist/index.es.js\nfunction toVal(mix) {\n  var k3, y5, str = \"\";\n  if (typeof mix === \"string\" || typeof mix === \"number\") {\n    str += mix;\n  } else if (typeof mix === \"object\") {\n    if (Array.isArray(mix)) {\n      for (k3 = 0; k3 < mix.length; k3++) {\n        if (mix[k3]) {\n          if (y5 = toVal(mix[k3])) {\n            str && (str += \" \");\n            str += y5;\n          }\n        }\n      }\n    } else {\n      for (k3 in mix) {\n        if (mix[k3]) {\n          str && (str += \" \");\n          str += k3;\n        }\n      }\n    }\n  }\n  return str;\n}\nfunction clsx2() {\n  var i5 = 0, tmp, x4, str = \"\";\n  while (i5 < arguments.length) {\n    if (tmp = arguments[i5++]) {\n      if (x4 = toVal(tmp)) {\n        str && (str += \" \");\n        str += x4;\n      }\n    }\n  }\n  return str;\n}\nvar ListStyleType;\n(function(ListStyleType2) {\n  ListStyleType2[\"Armenian\"] = \"armenian\";\n  ListStyleType2[\"Circle\"] = \"circle\";\n  ListStyleType2[\"CjkIdeographic\"] = \"cjk-ideographic\";\n  ListStyleType2[\"Decimal\"] = \"decimal\";\n  ListStyleType2[\"DecimalLeadingZero\"] = \"decimal-leading-zero\";\n  ListStyleType2[\"Disc\"] = \"disc\";\n  ListStyleType2[\"Georgian\"] = \"georgian\";\n  ListStyleType2[\"Hebrew\"] = \"hebrew\";\n  ListStyleType2[\"Hiragana\"] = \"hiragana\";\n  ListStyleType2[\"HiraganaIroha\"] = \"hiragana-iroha\";\n  ListStyleType2[\"Katakana\"] = \"katakana\";\n  ListStyleType2[\"KatakanaIroha\"] = \"katakana-iroha\";\n  ListStyleType2[\"LowerAlpha\"] = \"lower-alpha\";\n  ListStyleType2[\"LowerGreek\"] = \"lower-greek\";\n  ListStyleType2[\"LowerLatin\"] = \"lower-latin\";\n  ListStyleType2[\"LowerRoman\"] = \"lower-roman\";\n  ListStyleType2[\"None\"] = \"none\";\n  ListStyleType2[\"Square\"] = \"square\";\n  ListStyleType2[\"UpperAlpha\"] = \"upper-alpha\";\n  ListStyleType2[\"UpperLatin\"] = \"upper-latin\";\n  ListStyleType2[\"UpperRoman\"] = \"upper-roman\";\n  ListStyleType2[\"Initial\"] = \"initial\";\n  ListStyleType2[\"Inherit\"] = \"inherit\";\n})(ListStyleType || (ListStyleType = {}));\nvar injectIndentListComponent = (props) => {\n  const {\n    element: element4\n  } = props;\n  const listStyleType = element4[KEY_LIST_STYLE_TYPE];\n  const listStart = element4[KEY_LIST_START];\n  if (listStyleType) {\n    let className = clsx2(`slate-${KEY_LIST_STYLE_TYPE}-${listStyleType}`);\n    const style = {\n      padding: 0,\n      margin: 0,\n      listStyleType\n    };\n    if ([ListStyleType.Disc, ListStyleType.Circle, ListStyleType.Square].includes(listStyleType)) {\n      className = clsx2(className, \"slate-list-bullet\");\n      return ({\n        children\n      }) => /* @__PURE__ */ import_react28.default.createElement(\"ul\", {\n        style,\n        className\n      }, /* @__PURE__ */ import_react28.default.createElement(\"li\", null, children));\n    }\n    className = clsx2(className, \"slate-list-number\");\n    return ({\n      children\n    }) => /* @__PURE__ */ import_react28.default.createElement(\"ol\", {\n      style,\n      className,\n      start: listStart\n    }, /* @__PURE__ */ import_react28.default.createElement(\"li\", null, children));\n  }\n};\nvar getSiblingIndentList = (editor, [node, path], {\n  getPreviousEntry,\n  getNextEntry,\n  query,\n  eqIndent = true,\n  breakQuery,\n  breakOnLowerIndent = true,\n  breakOnEqIndentNeqListStyleType = true\n}) => {\n  if (!getPreviousEntry && !getNextEntry)\n    return;\n  const getSiblingEntry = getNextEntry !== null && getNextEntry !== void 0 ? getNextEntry : getPreviousEntry;\n  let nextEntry = getSiblingEntry([node, path]);\n  while (true) {\n    if (!nextEntry)\n      return;\n    const [nextNode, nextPath] = nextEntry;\n    const indent2 = node[KEY_INDENT];\n    const nextIndent = nextNode[KEY_INDENT];\n    if (!nextIndent)\n      return;\n    if (breakQuery && breakQuery(nextNode))\n      return;\n    if (breakOnLowerIndent && nextIndent < indent2)\n      return;\n    if (breakOnEqIndentNeqListStyleType && nextIndent === indent2 && nextNode[KEY_LIST_STYLE_TYPE] !== node[KEY_LIST_STYLE_TYPE])\n      return;\n    let valid = !query || query(nextNode);\n    if (valid) {\n      valid = !eqIndent || nextIndent === indent2;\n      if (valid)\n        return [nextNode, nextPath];\n    }\n    nextEntry = getSiblingEntry(nextEntry);\n  }\n};\nvar getNextIndentList = (editor, entry, options) => {\n  return getSiblingIndentList(editor, entry, {\n    getNextEntry: ([, currPath]) => {\n      const nextPath = Path.next(currPath);\n      const nextNode = getNode(editor, nextPath);\n      if (!nextNode)\n        return;\n      return [nextNode, nextPath];\n    },\n    ...options,\n    getPreviousEntry: void 0\n  });\n};\nvar getPreviousIndentList = (editor, entry, options) => {\n  return getSiblingIndentList(editor, entry, {\n    getPreviousEntry: ([, currPath]) => {\n      const prevPath = getPreviousPath(currPath);\n      if (!prevPath)\n        return;\n      const prevNode = getNode(editor, prevPath);\n      if (!prevNode)\n        return;\n      return [prevNode, prevPath];\n    },\n    ...options,\n    getNextEntry: void 0\n  });\n};\nvar normalizeFirstIndentListStart = (editor, [node, path]) => {\n  if (isDefined(node[KEY_LIST_START])) {\n    unsetNodes(editor, KEY_LIST_START, {\n      at: path\n    });\n    return true;\n  }\n};\nvar normalizeNextIndentListStart = (editor, entry, prevEntry) => {\n  var _ref, _ref2;\n  const [node, path] = entry;\n  const [prevNode] = prevEntry !== null && prevEntry !== void 0 ? prevEntry : [null];\n  const prevListStart = (_ref = prevNode === null || prevNode === void 0 ? void 0 : prevNode[KEY_LIST_START]) !== null && _ref !== void 0 ? _ref : 1;\n  const currListStart = (_ref2 = node[KEY_LIST_START]) !== null && _ref2 !== void 0 ? _ref2 : 1;\n  const listStart = prevListStart + 1;\n  if (currListStart !== listStart) {\n    setElements(editor, {\n      [KEY_LIST_START]: listStart\n    }, {\n      at: path\n    });\n    return true;\n  }\n  return false;\n};\nvar normalizeIndentListStart = (editor, entry, options) => {\n  return withoutNormalizing(editor, () => {\n    const [node] = entry;\n    const listStyleType = node[KEY_LIST_STYLE_TYPE];\n    if (!listStyleType)\n      return;\n    let normalized = false;\n    let prevEntry = getPreviousIndentList(editor, entry, options);\n    if (!prevEntry) {\n      normalized = normalizeFirstIndentListStart(editor, entry);\n      if (!normalized)\n        return;\n    }\n    let normalizeNext = true;\n    let currEntry = entry;\n    while (normalizeNext) {\n      normalizeNext = normalizeNextIndentListStart(editor, currEntry, prevEntry) || normalized;\n      if (normalizeNext)\n        normalized = true;\n      prevEntry = [getNode(editor, currEntry[1]), currEntry[1]];\n      currEntry = getNextIndentList(editor, currEntry, options);\n      if (!currEntry)\n        break;\n    }\n    return normalized;\n  });\n};\nvar normalizeIndentListNotIndented = (editor, [node, path]) => {\n  if (!node[KEY_INDENT] && (node[KEY_LIST_STYLE_TYPE] || node[KEY_LIST_START])) {\n    unsetNodes(editor, [KEY_LIST_STYLE_TYPE, KEY_LIST_START], {\n      at: path\n    });\n    return true;\n  }\n};\nvar normalizeIndentList = (editor, {\n  getSiblingIndentListOptions\n} = {}) => {\n  const {\n    normalizeNode\n  } = editor;\n  return ([node, path]) => {\n    const normalized = withoutNormalizing(editor, () => {\n      if (normalizeIndentListNotIndented(editor, [node, path]))\n        return true;\n      if (normalizeIndentListStart(editor, [node, path], getSiblingIndentListOptions))\n        return true;\n    });\n    if (normalized)\n      return;\n    return normalizeNode([node, path]);\n  };\n};\nvar withIndentList = (editor, {\n  options\n}) => {\n  const {\n    apply: apply2\n  } = editor;\n  const {\n    getSiblingIndentListOptions\n  } = options;\n  editor.normalizeNode = normalizeIndentList(editor, options);\n  editor.apply = (operation) => {\n    const {\n      path\n    } = operation;\n    let nodeBefore = null;\n    if (operation.type === \"set_node\") {\n      nodeBefore = getNode(editor, path);\n    }\n    if (operation.type === \"insert_node\") {\n      const listStyleType = operation.node[KEY_LIST_STYLE_TYPE];\n      if (listStyleType && [\"lower-roman\", \"upper-roman\"].includes(listStyleType)) {\n        const prevNodeEntry = getPreviousIndentList(editor, [operation.node, path], {\n          eqIndent: false,\n          breakOnEqIndentNeqListStyleType: false,\n          ...getSiblingIndentListOptions\n        });\n        if (prevNodeEntry) {\n          const prevListStyleType = prevNodeEntry[0][KEY_LIST_STYLE_TYPE];\n          if (prevListStyleType === ListStyleType.LowerAlpha && listStyleType === ListStyleType.LowerRoman) {\n            operation.node[KEY_LIST_STYLE_TYPE] = ListStyleType.LowerAlpha;\n          } else if (prevListStyleType === ListStyleType.UpperAlpha && listStyleType === ListStyleType.UpperRoman) {\n            operation.node[KEY_LIST_STYLE_TYPE] = ListStyleType.UpperAlpha;\n          }\n        }\n      }\n    }\n    let nextIndentListPathRef = null;\n    if (operation.type === \"merge_node\" && operation.properties[KEY_LIST_STYLE_TYPE]) {\n      const node = getNode(editor, path);\n      if (node) {\n        const nextNodeEntryBefore = getNextIndentList(editor, [node, path], getSiblingIndentListOptions);\n        if (nextNodeEntryBefore) {\n          nextIndentListPathRef = createPathRef(editor, nextNodeEntryBefore[1]);\n        }\n      }\n    }\n    apply2(operation);\n    if (operation.type === \"merge_node\") {\n      const {\n        properties\n      } = operation;\n      if (properties[KEY_LIST_STYLE_TYPE]) {\n        const node = getNode(editor, path);\n        if (!node)\n          return;\n        normalizeIndentListStart(editor, [node, path], getSiblingIndentListOptions);\n        if (nextIndentListPathRef) {\n          const nextPath = nextIndentListPathRef.unref();\n          if (nextPath) {\n            const nextNode = getNode(editor, nextPath);\n            if (nextNode) {\n              normalizeIndentListStart(editor, [nextNode, nextPath], getSiblingIndentListOptions);\n            }\n          }\n        }\n      }\n    }\n    if (nodeBefore) {\n      if (operation.type === \"set_node\") {\n        const prevListStyleType = operation.properties[KEY_LIST_STYLE_TYPE];\n        const listStyleType = operation.newProperties[KEY_LIST_STYLE_TYPE];\n        if (prevListStyleType && !listStyleType) {\n          const node = getNode(editor, path);\n          if (!node)\n            return;\n          const nextNodeEntry = getNextIndentList(editor, [nodeBefore, path], getSiblingIndentListOptions);\n          if (!nextNodeEntry)\n            return;\n          normalizeIndentListStart(editor, nextNodeEntry, getSiblingIndentListOptions);\n        }\n        if ((prevListStyleType || listStyleType) && prevListStyleType !== listStyleType) {\n          const node = getNode(editor, path);\n          if (!node)\n            return;\n          let nextNodeEntry = getNextIndentList(editor, [nodeBefore, path], getSiblingIndentListOptions);\n          if (nextNodeEntry) {\n            normalizeIndentListStart(editor, nextNodeEntry, getSiblingIndentListOptions);\n          }\n          nextNodeEntry = getNextIndentList(editor, [node, path], getSiblingIndentListOptions);\n          if (nextNodeEntry) {\n            normalizeIndentListStart(editor, nextNodeEntry, getSiblingIndentListOptions);\n          }\n        }\n        const prevIndent = operation.properties[KEY_INDENT];\n        const indent2 = operation.newProperties[KEY_INDENT];\n        if (prevIndent !== indent2) {\n          const node = getNode(editor, path);\n          if (!node)\n            return;\n          let prevNodeEntry = getPreviousIndentList(editor, [nodeBefore, path], {\n            eqIndent: false,\n            breakOnLowerIndent: false,\n            breakOnEqIndentNeqListStyleType: false,\n            ...getSiblingIndentListOptions\n          });\n          if (prevNodeEntry) {\n            normalizeIndentListStart(editor, prevNodeEntry, getSiblingIndentListOptions);\n          }\n          prevNodeEntry = getPreviousIndentList(editor, [node, path], {\n            eqIndent: false,\n            breakOnLowerIndent: false,\n            breakOnEqIndentNeqListStyleType: false,\n            ...getSiblingIndentListOptions\n          });\n          if (prevNodeEntry) {\n            normalizeIndentListStart(editor, prevNodeEntry, getSiblingIndentListOptions);\n          }\n          let nextNodeEntry = getNextIndentList(editor, [nodeBefore, path], {\n            eqIndent: false,\n            breakOnLowerIndent: false,\n            breakOnEqIndentNeqListStyleType: false\n          });\n          if (nextNodeEntry) {\n            normalizeIndentListStart(editor, nextNodeEntry, getSiblingIndentListOptions);\n          }\n          nextNodeEntry = getNextIndentList(editor, [node, path], {\n            eqIndent: false,\n            breakOnLowerIndent: false,\n            breakOnEqIndentNeqListStyleType: false\n          });\n          if (nextNodeEntry) {\n            normalizeIndentListStart(editor, nextNodeEntry, getSiblingIndentListOptions);\n          }\n        }\n      }\n    }\n  };\n  return editor;\n};\nvar KEY_LIST_STYLE_TYPE = \"listStyleType\";\nvar KEY_LIST_START = \"listStart\";\nvar createIndentListPlugin = createPluginFactory({\n  key: KEY_LIST_STYLE_TYPE,\n  inject: {\n    belowComponent: injectIndentListComponent\n  },\n  withOverrides: withIndentList\n});\n\n// node_modules/@udecode/plate-kbd/dist/index.es.js\nvar MARK_KBD = \"kbd\";\nvar createKbdPlugin = createPluginFactory({\n  key: MARK_KBD,\n  isLeaf: true,\n  handlers: {\n    onKeyDown: onKeyDownToggleMark\n  },\n  deserializeHtml: {\n    rules: [{\n      validNodeName: [\"KBD\"]\n    }, {\n      validStyle: {\n        wordWrap: \"break-word\"\n      }\n    }]\n  }\n});\n\n// node_modules/@udecode/plate-normalizers/dist/index.es.js\nvar withNormalizeTypes = (editor, {\n  options: {\n    rules,\n    onError\n  }\n}) => {\n  const {\n    normalizeNode\n  } = editor;\n  editor.normalizeNode = ([currentNode, currentPath]) => {\n    if (!currentPath.length) {\n      const endCurrentNormalizationPass = rules.some(({\n        strictType,\n        type,\n        path\n      }) => {\n        const node = getNode(editor, path);\n        if (node) {\n          if (strictType && isElement2(node) && node.type !== strictType) {\n            setElements(editor, {\n              type: strictType\n            }, {\n              at: path\n            });\n            return true;\n          }\n        } else {\n          try {\n            insertElements(editor, {\n              type: strictType !== null && strictType !== void 0 ? strictType : type,\n              children: [{\n                text: \"\"\n              }]\n            }, {\n              at: path\n            });\n            return true;\n          } catch (err) {\n            onError === null || onError === void 0 ? void 0 : onError(err);\n          }\n        }\n        return false;\n      });\n      if (endCurrentNormalizationPass) {\n        return;\n      }\n    }\n    return normalizeNode([currentNode, currentPath]);\n  };\n  return editor;\n};\nvar KEY_NORMALIZE_TYPES = \"normalizeTypes\";\nvar createNormalizeTypesPlugin = createPluginFactory({\n  key: KEY_NORMALIZE_TYPES,\n  withOverrides: withNormalizeTypes,\n  options: {\n    rules: []\n  }\n});\nvar isArray7 = Array.isArray;\nvar isArray_16 = isArray7;\nfunction castArray4() {\n  if (!arguments.length) {\n    return [];\n  }\n  var value = arguments[0];\n  return isArray_16(value) ? value : [value];\n}\nvar castArray_14 = castArray4;\nvar withRemoveEmptyNodes = (editor, {\n  options: {\n    types: _types\n  }\n}) => {\n  const types = castArray_14(_types);\n  const {\n    normalizeNode\n  } = editor;\n  editor.normalizeNode = ([node, path]) => {\n    if (isElement2(node) && node.type && types.includes(node.type) && getNodeString(node) === \"\") {\n      removeNodes(editor, {\n        at: path\n      });\n      return;\n    }\n    normalizeNode([node, path]);\n  };\n  return editor;\n};\nvar createRemoveEmptyNodesPlugin = createPluginFactory({\n  key: \"removeEmptyNodes\",\n  withOverrides: withRemoveEmptyNodes\n});\n\n// node_modules/@udecode/plate-link/dist/index.es.js\nvar React5 = __toESM(require(\"react\"));\nvar import_react29 = __toESM(require(\"react\"));\n\n// node_modules/@udecode/plate-button/dist/index.es.js\nvar Button = createComponentAs((props) => createElementAs(\"button\", props));\n\n// node_modules/@udecode/plate-link/dist/index.es.js\nvar ReactDOM2 = __toESM(require(\"react-dom\"));\nvar createLinkNode = (editor, {\n  url,\n  text: text4 = \"\",\n  children\n}) => {\n  const type = getPluginType(editor, ELEMENT_LINK);\n  return {\n    type,\n    url,\n    children: children !== null && children !== void 0 ? children : [{\n      text: text4\n    }]\n  };\n};\nvar useLink = (props) => {\n  const _props = useElementProps({\n    ...props,\n    elementToAttributes: (element4) => ({\n      href: element4.url\n    })\n  });\n  return {\n    ..._props,\n    // quick fix: hovering <a> with href loses the editor focus\n    onMouseOver: (e4) => {\n      e4.stopPropagation();\n    }\n  };\n};\nvar LinkRoot = createComponentAs((props) => {\n  const htmlProps = useLink(props);\n  return createElementAs(\"a\", htmlProps);\n});\nvar Link = {\n  Root: LinkRoot\n};\nvar floatingLinkStore = createStore3(\"floatingLink\")({\n  open: false,\n  mouseDown: false,\n  updated: false,\n  url: \"\",\n  text: \"\",\n  mode: \"\",\n  isEditing: false\n}).extendActions((set4) => ({\n  reset: () => {\n    set4.url(\"\");\n    set4.text(\"\");\n    set4.mode(\"\");\n    set4.isEditing(false);\n  }\n})).extendActions((set4) => ({\n  show: (mode) => {\n    set4.mode(mode);\n    set4.isEditing(false);\n    set4.open(true);\n  },\n  hide: () => {\n    set4.open(false);\n    set4.reset();\n  }\n}));\nvar floatingLinkActions = floatingLinkStore.set;\nvar floatingLinkSelectors = floatingLinkStore.get;\nvar useFloatingLinkSelectors = () => floatingLinkStore.use;\nvar triggerFloatingLinkEdit = (editor) => {\n  const entry = findNode(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_LINK)\n    }\n  });\n  if (!entry)\n    return;\n  const [link3, path] = entry;\n  let text4 = getEditorString(editor, path);\n  floatingLinkActions.url(link3.url);\n  if (text4 === link3.url) {\n    text4 = \"\";\n  }\n  floatingLinkActions.text(text4);\n  floatingLinkActions.isEditing(true);\n};\nvar useFloatingLinkEditButton = (props) => {\n  const editor = useEditorRef();\n  return {\n    onClick: (0, import_react29.useCallback)(() => {\n      triggerFloatingLinkEdit(editor);\n    }, [editor]),\n    ...props\n  };\n};\nvar FloatingLinkEditButton = createComponentAs((props) => {\n  const htmlProps = useFloatingLinkEditButton(props);\n  return createElementAs(\"button\", htmlProps);\n});\nvar useFloatingLinkTextInput = (props) => {\n  const onChange = (0, import_react29.useCallback)((e4) => {\n    floatingLinkActions.text(e4.target.value);\n  }, []);\n  return mergeProps({\n    onChange,\n    defaultValue: floatingLinkSelectors.text()\n  }, props);\n};\nvar FloatingLinkTextInput = createComponentAs((props) => {\n  const htmlProps = useFloatingLinkTextInput(props);\n  return createElementAs(\"input\", htmlProps);\n});\nvar useFloatingLinkUrlInput = (props) => {\n  const updated = useFloatingLinkSelectors().updated();\n  const ref = (0, import_react29.useRef)(null);\n  (0, import_react29.useEffect)(() => {\n    if (ref.current && updated) {\n      setTimeout(() => {\n        var _ref$current;\n        (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.focus();\n      }, 0);\n    }\n  }, [updated]);\n  const onChange = (0, import_react29.useCallback)((e4) => {\n    floatingLinkActions.url(e4.target.value);\n  }, []);\n  return mergeProps({\n    onChange,\n    defaultValue: floatingLinkSelectors.url()\n  }, {\n    ...props,\n    ref: useComposedRef(props.ref, ref)\n  });\n};\nvar FloatingLinkUrlInput = createComponentAs((props) => {\n  const htmlProps = useFloatingLinkUrlInput(props);\n  return createElementAs(\"input\", htmlProps);\n});\nvar useOpenLinkButton = (props) => {\n  const editor = useEditorRef();\n  const entry = (0, import_react29.useMemo)(() => findNode(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_LINK)\n    }\n  }), [editor]);\n  if (!entry) {\n    return {};\n  }\n  const [link3] = entry;\n  return {\n    \"aria-label\": \"Open link in a new tab\",\n    target: \"_blank\",\n    href: link3.url,\n    onMouseOver: (e4) => {\n      e4.stopPropagation();\n    },\n    ...props\n  };\n};\nvar OpenLinkButton = createComponentAs((props) => {\n  const htmlProps = useOpenLinkButton(props);\n  return createElementAs(\"a\", htmlProps);\n});\nvar useUnlinkButton = (props) => {\n  const editor = useEditorRef();\n  return {\n    onClick: (0, import_react29.useCallback)(() => {\n      unwrapLink(editor);\n      focusEditor(editor, editor.selection);\n    }, [editor]),\n    ...props\n  };\n};\nvar UnlinkButton = createComponentAs((props) => {\n  const htmlProps = useUnlinkButton(props);\n  return createElementAs(Button, htmlProps);\n});\nvar global$1 = typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {};\nfunction defaultSetTimout() {\n  throw new Error(\"setTimeout has not been defined\");\n}\nfunction defaultClearTimeout() {\n  throw new Error(\"clearTimeout has not been defined\");\n}\nvar cachedSetTimeout = defaultSetTimout;\nvar cachedClearTimeout = defaultClearTimeout;\nif (typeof global$1.setTimeout === \"function\") {\n  cachedSetTimeout = setTimeout;\n}\nif (typeof global$1.clearTimeout === \"function\") {\n  cachedClearTimeout = clearTimeout;\n}\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    return setTimeout(fun, 0);\n  }\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n  try {\n    return cachedSetTimeout(fun, 0);\n  } catch (e4) {\n    try {\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e5) {\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    return clearTimeout(marker);\n  }\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n  try {\n    return cachedClearTimeout(marker);\n  } catch (e4) {\n    try {\n      return cachedClearTimeout.call(null, marker);\n    } catch (e5) {\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n  draining = false;\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n  if (queue.length) {\n    drainQueue();\n  }\n}\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n    queueIndex = -1;\n    len = queue.length;\n  }\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\nfunction nextTick(fun) {\n  var args = new Array(arguments.length - 1);\n  if (arguments.length > 1) {\n    for (var i5 = 1; i5 < arguments.length; i5++) {\n      args[i5 - 1] = arguments[i5];\n    }\n  }\n  queue.push(new Item(fun, args));\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n}\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\nItem.prototype.run = function() {\n  this.fun.apply(null, this.array);\n};\nvar title = \"browser\";\nvar platform$1 = \"browser\";\nvar browser = true;\nvar env = {};\nvar argv = [];\nvar version = \"\";\nvar versions = {};\nvar release = {};\nvar config = {};\nfunction noop() {\n}\nvar on2 = noop;\nvar addListener = noop;\nvar once = noop;\nvar off = noop;\nvar removeListener = noop;\nvar removeAllListeners = noop;\nvar emit = noop;\nfunction binding(name) {\n  throw new Error(\"process.binding is not supported\");\n}\nfunction cwd() {\n  return \"/\";\n}\nfunction chdir(dir) {\n  throw new Error(\"process.chdir is not supported\");\n}\nfunction umask() {\n  return 0;\n}\nvar performance2 = global$1.performance || {};\nvar performanceNow = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {\n  return new Date().getTime();\n};\nfunction hrtime(previousTimestamp) {\n  var clocktime = performanceNow.call(performance2) * 1e-3;\n  var seconds = Math.floor(clocktime);\n  var nanoseconds = Math.floor(clocktime % 1 * 1e9);\n  if (previousTimestamp) {\n    seconds = seconds - previousTimestamp[0];\n    nanoseconds = nanoseconds - previousTimestamp[1];\n    if (nanoseconds < 0) {\n      seconds--;\n      nanoseconds += 1e9;\n    }\n  }\n  return [seconds, nanoseconds];\n}\nvar startTime = new Date();\nfunction uptime() {\n  var currentTime = new Date();\n  var dif = currentTime - startTime;\n  return dif / 1e3;\n}\nvar process2 = {\n  nextTick,\n  title,\n  browser,\n  env,\n  argv,\n  version,\n  versions,\n  on: on2,\n  addListener,\n  once,\n  off,\n  removeListener,\n  removeAllListeners,\n  emit,\n  binding,\n  cwd,\n  chdir,\n  umask,\n  hrtime,\n  platform: platform$1,\n  release,\n  config,\n  uptime\n};\nfunction getSide(placement) {\n  return placement.split(\"-\")[0];\n}\nfunction getAlignment(placement) {\n  return placement.split(\"-\")[1];\n}\nfunction getMainAxisFromPlacement(placement) {\n  return [\"top\", \"bottom\"].includes(getSide(placement)) ? \"x\" : \"y\";\n}\nfunction getLengthFromAxis(axis) {\n  return axis === \"y\" ? \"height\" : \"width\";\n}\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference: reference2,\n    floating\n  } = _ref;\n  const commonX = reference2.x + reference2.width / 2 - floating.width / 2;\n  const commonY = reference2.y + reference2.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference2[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === \"x\";\n  let coords;\n  switch (side) {\n    case \"top\":\n      coords = {\n        x: commonX,\n        y: reference2.y - floating.height\n      };\n      break;\n    case \"bottom\":\n      coords = {\n        x: commonX,\n        y: reference2.y + reference2.height\n      };\n      break;\n    case \"right\":\n      coords = {\n        x: reference2.x + reference2.width,\n        y: commonY\n      };\n      break;\n    case \"left\":\n      coords = {\n        x: reference2.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference2.x,\n        y: reference2.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case \"start\":\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case \"end\":\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\nvar computePosition$1 = async (reference2, floating, config2) => {\n  const {\n    placement = \"bottom\",\n    strategy = \"absolute\",\n    middleware = [],\n    platform: platform2\n  } = config2;\n  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));\n  if (process2.env.NODE_ENV !== \"production\") {\n    if (platform2 == null) {\n      console.error([\"Floating UI: `platform` property was not passed to config. If you\", \"want to use Floating UI on the web, install @floating-ui/dom\", \"instead of the /core package. Otherwise, you can create your own\", \"`platform`: https://floating-ui.com/docs/platform\"].join(\" \"));\n    }\n    if (middleware.filter((_ref) => {\n      let {\n        name\n      } = _ref;\n      return name === \"autoPlacement\" || name === \"flip\";\n    }).length > 1) {\n      throw new Error([\"Floating UI: duplicate `flip` and/or `autoPlacement`\", \"middleware detected. This will lead to an infinite loop. Ensure only\", \"one of either has been passed to the `middleware` array.\"].join(\" \"));\n    }\n  }\n  let rects = await platform2.getElementRects({\n    reference: reference2,\n    floating,\n    strategy\n  });\n  let {\n    x: x4,\n    y: y5\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i5 = 0; i5 < middleware.length; i5++) {\n    const {\n      name,\n      fn: fn4\n    } = middleware[i5];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn4({\n      x: x4,\n      y: y5,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform: platform2,\n      elements: {\n        reference: reference2,\n        floating\n      }\n    });\n    x4 = nextX != null ? nextX : x4;\n    y5 = nextY != null ? nextY : y5;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (process2.env.NODE_ENV !== \"production\") {\n      if (resetCount > 50) {\n        console.warn([\"Floating UI: The middleware lifecycle appears to be running in an\", \"infinite loop. This is usually caused by a `reset` continually\", \"being returned without a break condition.\"].join(\" \"));\n      }\n    }\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === \"object\") {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform2.getElementRects({\n            reference: reference2,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x: x4,\n          y: y5\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i5 = -1;\n      continue;\n    }\n  }\n  return {\n    x: x4,\n    y: y5,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== \"number\" ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x: x4,\n    y: y5,\n    platform: platform2,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = \"clippingAncestors\",\n    rootBoundary = \"viewport\",\n    elementContext = \"floating\",\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n  const element4 = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({\n    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element4))) != null ? _await$platform$isEle : true) ? element4 : element4.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === \"floating\" ? {\n      ...rects.floating,\n      x: x4,\n      y: y5\n    } : rects.reference,\n    offsetParent: await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)),\n    strategy\n  }) : rects[elementContext]);\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\nvar hash$1 = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, (matched) => hash$1[matched]);\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === \"x\" ? alignment === (rtl ? \"end\" : \"start\") ? \"right\" : \"left\" : alignment === \"start\" ? \"bottom\" : \"top\";\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\nvar hash = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, (matched) => hash[matched]);\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nvar flip = function(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"flip\",\n    options,\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform: platform2,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = \"bestFit\",\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements2 = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const {\n          main: main2,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));\n        overflows.push(overflow[main2], overflow[cross]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n      if (!overflows.every((side2) => side2 <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements2[nextIndex];\n        if (nextPlacement) {\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n        let resetPlacement = \"bottom\";\n        switch (fallbackStrategy) {\n          case \"bestFit\": {\n            var _overflowsData$map$so;\n            const placement2 = (_overflowsData$map$so = overflowsData.map((d4) => [d4, d4.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a7, b4) => a7[1] - b4[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n            if (placement2) {\n              resetPlacement = placement2;\n            }\n            break;\n          }\n          case \"initialPlacement\":\n            resetPlacement = initialPlacement;\n            break;\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\nasync function convertValueToCoords(middlewareArguments, value) {\n  const {\n    placement,\n    platform: platform2,\n    elements\n  } = middlewareArguments;\n  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === \"x\";\n  const mainAxisMulti = [\"left\", \"top\"].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === \"function\" ? value(middlewareArguments) : value;\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === \"number\" ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === \"number\") {\n    crossAxis = alignment === \"end\" ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\nvar offset = function(value) {\n  if (value === void 0) {\n    value = 0;\n  }\n  return {\n    name: \"offset\",\n    options: value,\n    async fn(middlewareArguments) {\n      const {\n        x: x4,\n        y: y5\n      } = middlewareArguments;\n      const diffCoords = await convertValueToCoords(middlewareArguments, value);\n      return {\n        x: x4 + diffCoords.x,\n        y: y5 + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow$1(node) {\n  if (node == null) {\n    return window;\n  }\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n  return node;\n}\nfunction getComputedStyle$1(element4) {\n  return getWindow$1(element4).getComputedStyle(element4);\n}\nfunction getNodeName(node) {\n  return isWindow(node) ? \"\" : node ? (node.nodeName || \"\").toLowerCase() : \"\";\n}\nfunction getUAString() {\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map((item) => item.brand + \"/\" + item.version).join(\" \");\n  }\n  return navigator.userAgent;\n}\nfunction isHTMLElement(value) {\n  return value instanceof getWindow$1(value).HTMLElement;\n}\nfunction isElement$1(value) {\n  return value instanceof getWindow$1(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow$1(value).Node;\n}\nfunction isShadowRoot(node) {\n  if (typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n  const OwnElement = getWindow$1(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element4) {\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getComputedStyle$1(element4);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isTableElement(element4) {\n  return [\"table\", \"td\", \"th\"].includes(getNodeName(element4));\n}\nfunction isContainingBlock(element4) {\n  const isFirefox2 = /firefox/i.test(getUAString());\n  const css13 = getComputedStyle$1(element4);\n  return css13.transform !== \"none\" || css13.perspective !== \"none\" || // @ts-ignore (TS 4.1 compat)\n  css13.contain === \"paint\" || [\"transform\", \"perspective\"].includes(css13.willChange) || isFirefox2 && css13.willChange === \"filter\" || isFirefox2 && (css13.filter ? css13.filter !== \"none\" : false);\n}\nfunction isLayoutViewport() {\n  return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}\nvar min = Math.min;\nvar max = Math.max;\nvar round = Math.round;\nfunction getBoundingClientRect(element4, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element4.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n  if (includeScale && isHTMLElement(element4)) {\n    scaleX = element4.offsetWidth > 0 ? round(clientRect.width) / element4.offsetWidth || 1 : 1;\n    scaleY = element4.offsetHeight > 0 ? round(clientRect.height) / element4.offsetHeight || 1 : 1;\n  }\n  const win = isElement$1(element4) ? getWindow$1(element4) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x4 = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;\n  const y5 = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y5,\n    right: x4 + width,\n    bottom: y5 + height,\n    left: x4,\n    x: x4,\n    y: y5\n  };\n}\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\nfunction getNodeScroll(element4) {\n  if (isElement$1(element4)) {\n    return {\n      scrollLeft: element4.scrollLeft,\n      scrollTop: element4.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element4.pageXOffset,\n    scrollTop: element4.pageYOffset\n  };\n}\nfunction getWindowScrollBarX(element4) {\n  return getBoundingClientRect(getDocumentElement(element4)).left + getNodeScroll(element4).scrollLeft;\n}\nfunction isScaled(element4) {\n  const rect = getBoundingClientRect(element4);\n  return round(rect.width) !== element4.offsetWidth || round(rect.height) !== element4.offsetHeight;\n}\nfunction getRectRelativeToOffsetParent(element4, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(\n    element4,\n    // @ts-ignore - checked above (TS 4.1 compat)\n    isOffsetParentAnElement && isScaled(offsetParent),\n    strategy === \"fixed\"\n  );\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== \"fixed\") {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction getParentNode2(node) {\n  if (getNodeName(node) === \"html\") {\n    return node;\n  }\n  return (\n    // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || // DOM Element detected\n    (isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node)\n  );\n}\nfunction getTrueOffsetParent(element4) {\n  if (!isHTMLElement(element4) || getComputedStyle(element4).position === \"fixed\") {\n    return null;\n  }\n  return element4.offsetParent;\n}\nfunction getContainingBlock(element4) {\n  let currentNode = getParentNode2(element4);\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n  while (isHTMLElement(currentNode) && ![\"html\", \"body\"].includes(getNodeName(currentNode))) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n  return null;\n}\nfunction getOffsetParent(element4) {\n  const window2 = getWindow$1(element4);\n  let offsetParent = getTrueOffsetParent(element4);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === \"static\") {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === \"html\" || getNodeName(offsetParent) === \"body\" && getComputedStyle(offsetParent).position === \"static\" && !isContainingBlock(offsetParent))) {\n    return window2;\n  }\n  return offsetParent || getContainingBlock(element4) || window2;\n}\nfunction getDimensions(element4) {\n  if (isHTMLElement(element4)) {\n    return {\n      width: element4.offsetWidth,\n      height: element4.offsetHeight\n    };\n  }\n  const rect = getBoundingClientRect(element4);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== \"fixed\") {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\nfunction getViewportRect(element4, strategy) {\n  const win = getWindow$1(element4);\n  const html = getDocumentElement(element4);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x4 = 0;\n  let y5 = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n    if (layoutViewport || !layoutViewport && strategy === \"fixed\") {\n      x4 = visualViewport.offsetLeft;\n      y5 = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x: x4,\n    y: y5\n  };\n}\nfunction getDocumentRect(element4) {\n  var _element$ownerDocumen;\n  const html = getDocumentElement(element4);\n  const scroll = getNodeScroll(element4);\n  const body = (_element$ownerDocumen = element4.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x4 = -scroll.scrollLeft + getWindowScrollBarX(element4);\n  const y5 = -scroll.scrollTop;\n  if (getComputedStyle$1(body || html).direction === \"rtl\") {\n    x4 += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n  return {\n    width,\n    height,\n    x: x4,\n    y: y5\n  };\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode2(node);\n  if ([\"html\", \"body\", \"#document\"].includes(getNodeName(parentNode))) {\n    return node.ownerDocument.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow$1(scrollableAncestor);\n  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : (\n    // @ts-ignore: isBody tells us target will be an HTMLElement here\n    updatedList.concat(getOverflowAncestors(target))\n  );\n}\nfunction contains(parent2, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();\n  if (parent2.contains(child)) {\n    return true;\n  } else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    do {\n      if (next && parent2 === next) {\n        return true;\n      }\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n  return false;\n}\nfunction getInnerBoundingClientRect(element4, strategy) {\n  const clientRect = getBoundingClientRect(element4, false, strategy === \"fixed\");\n  const top2 = clientRect.top + element4.clientTop;\n  const left2 = clientRect.left + element4.clientLeft;\n  return {\n    top: top2,\n    left: left2,\n    x: left2,\n    y: top2,\n    right: left2 + element4.clientWidth,\n    bottom: top2 + element4.clientHeight,\n    width: element4.clientWidth,\n    height: element4.clientHeight\n  };\n}\nfunction getClientRectFromClippingAncestor(element4, clippingParent, strategy) {\n  if (clippingParent === \"viewport\") {\n    return rectToClientRect(getViewportRect(element4, strategy));\n  }\n  if (isElement$1(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n  return rectToClientRect(getDocumentRect(getDocumentElement(element4)));\n}\nfunction getClippingAncestors(element4) {\n  const clippingAncestors = getOverflowAncestors(element4);\n  const canEscapeClipping = [\"absolute\", \"fixed\"].includes(getComputedStyle$1(element4).position);\n  const clipperElement = canEscapeClipping && isHTMLElement(element4) ? getOffsetParent(element4) : element4;\n  if (!isElement$1(clipperElement)) {\n    return [];\n  }\n  return clippingAncestors.filter((clippingAncestors2) => isElement$1(clippingAncestors2) && contains(clippingAncestors2, clipperElement) && getNodeName(clippingAncestors2) !== \"body\");\n}\nfunction getClippingRect(_ref) {\n  let {\n    element: element4,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const mainClippingAncestors = boundary === \"clippingAncestors\" ? getClippingAncestors(element4) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element4, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element4, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\nvar platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement: isElement$1,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getElementRects: (_ref) => {\n    let {\n      reference: reference2,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference2, getOffsetParent(floating), strategy),\n      floating: {\n        ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  getClientRects: (element4) => Array.from(element4.getClientRects()),\n  isRTL: (element4) => getComputedStyle$1(element4).direction === \"rtl\"\n};\nfunction autoUpdate(reference2, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize: _ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestorResize = _ancestorResize && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...isElement$1(reference2) ? getOverflowAncestors(reference2) : [], ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach((ancestor) => {\n    ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener(\"resize\", update);\n  });\n  let observer = null;\n  if (elementResize) {\n    let initialUpdate = true;\n    observer = new ResizeObserver(() => {\n      if (!initialUpdate) {\n        update();\n      }\n      initialUpdate = false;\n    });\n    isElement$1(reference2) && !animationFrame && observer.observe(reference2);\n    observer.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference2) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference2);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _observer;\n    ancestors.forEach((ancestor) => {\n      ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n      ancestorResize && ancestor.removeEventListener(\"resize\", update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\nvar computePosition = (reference2, floating, options) => computePosition$1(reference2, floating, {\n  platform,\n  ...options\n});\nvar index$1 = typeof document !== \"undefined\" ? import_react29.useLayoutEffect : import_react29.useEffect;\nfunction deepEqual(a7, b4) {\n  if (a7 === b4) {\n    return true;\n  }\n  if (typeof a7 !== typeof b4) {\n    return false;\n  }\n  if (typeof a7 === \"function\" && a7.toString() === b4.toString()) {\n    return true;\n  }\n  let length, i5, keys4;\n  if (a7 && b4 && typeof a7 == \"object\") {\n    if (Array.isArray(a7)) {\n      length = a7.length;\n      if (length != b4.length)\n        return false;\n      for (i5 = length; i5-- !== 0; ) {\n        if (!deepEqual(a7[i5], b4[i5])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys4 = Object.keys(a7);\n    length = keys4.length;\n    if (length !== Object.keys(b4).length) {\n      return false;\n    }\n    for (i5 = length; i5-- !== 0; ) {\n      if (!Object.prototype.hasOwnProperty.call(b4, keys4[i5])) {\n        return false;\n      }\n    }\n    for (i5 = length; i5-- !== 0; ) {\n      const key = keys4[i5];\n      if (key === \"_owner\" && a7.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a7[key], b4[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a7 !== a7 && b4 !== b4;\n}\nfunction useLatestRef(value) {\n  const ref = React5.useRef(value);\n  index$1(() => {\n    ref.current = value;\n  });\n  return ref;\n}\nfunction useFloating$1(_temp) {\n  let {\n    middleware,\n    placement = \"bottom\",\n    strategy = \"absolute\",\n    whileElementsMounted\n  } = _temp === void 0 ? {} : _temp;\n  const reference2 = React5.useRef(null);\n  const floating = React5.useRef(null);\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const cleanupRef = React5.useRef(null);\n  const [data, setData] = React5.useState({\n    // Setting these to `null` will allow the consumer to determine if\n    // `computePosition()` has run yet\n    x: null,\n    y: null,\n    strategy,\n    placement,\n    middlewareData: {}\n  });\n  const [latestMiddleware, setLatestMiddleware] = React5.useState(middleware);\n  if (!deepEqual(latestMiddleware == null ? void 0 : latestMiddleware.map((_ref) => {\n    let {\n      options\n    } = _ref;\n    return options;\n  }), middleware == null ? void 0 : middleware.map((_ref2) => {\n    let {\n      options\n    } = _ref2;\n    return options;\n  }))) {\n    setLatestMiddleware(middleware);\n  }\n  const update = React5.useCallback(() => {\n    if (!reference2.current || !floating.current) {\n      return;\n    }\n    computePosition(reference2.current, floating.current, {\n      middleware: latestMiddleware,\n      placement,\n      strategy\n    }).then((data2) => {\n      if (isMountedRef.current) {\n        ReactDOM2.flushSync(() => {\n          setData(data2);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy]);\n  index$1(() => {\n    if (isMountedRef.current) {\n      update();\n    }\n  }, [update]);\n  const isMountedRef = React5.useRef(false);\n  index$1(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  const runElementMountCallback = React5.useCallback(() => {\n    if (typeof cleanupRef.current === \"function\") {\n      cleanupRef.current();\n      cleanupRef.current = null;\n    }\n    if (reference2.current && floating.current) {\n      if (whileElementsMountedRef.current) {\n        const cleanupFn = whileElementsMountedRef.current(reference2.current, floating.current, update);\n        cleanupRef.current = cleanupFn;\n      } else {\n        update();\n      }\n    }\n  }, [update, whileElementsMountedRef]);\n  const setReference = React5.useCallback((node) => {\n    reference2.current = node;\n    runElementMountCallback();\n  }, [runElementMountCallback]);\n  const setFloating = React5.useCallback((node) => {\n    floating.current = node;\n    runElementMountCallback();\n  }, [runElementMountCallback]);\n  const refs = React5.useMemo(() => ({\n    reference: reference2,\n    floating\n  }), []);\n  return React5.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    reference: setReference,\n    floating: setFloating\n  }), [data, update, refs, setReference, setFloating]);\n}\nvar index = typeof document !== \"undefined\" ? import_react29.useLayoutEffect : import_react29.useEffect;\nfunction createPubSub() {\n  const map2 = /* @__PURE__ */ new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n      (_map$get = map2.get(event)) == null ? void 0 : _map$get.forEach((handler) => handler(data));\n    },\n    on(event, listener) {\n      map2.set(event, [...map2.get(event) || [], listener]);\n    },\n    off(event, listener) {\n      map2.set(event, (map2.get(event) || []).filter((l6) => l6 !== listener));\n    }\n  };\n}\nvar FloatingTreeContext = /* @__PURE__ */ React5.createContext(null);\nvar useFloatingTree = () => React5.useContext(FloatingTreeContext);\nfunction getDocument(floating) {\n  var _floating$ownerDocume;\n  return (_floating$ownerDocume = floating == null ? void 0 : floating.ownerDocument) != null ? _floating$ownerDocume : document;\n}\nfunction getWindow(value) {\n  var _getDocument$defaultV;\n  return (_getDocument$defaultV = getDocument(value).defaultView) != null ? _getDocument$defaultV : window;\n}\nfunction isElement3(value) {\n  return value ? value instanceof getWindow(value).Element : false;\n}\nfunction useFloating(_temp) {\n  let {\n    open = false,\n    onOpenChange = () => {\n    },\n    whileElementsMounted,\n    placement,\n    middleware,\n    strategy,\n    nodeId\n  } = _temp === void 0 ? {} : _temp;\n  const tree = useFloatingTree();\n  const domReferenceRef = React5.useRef(null);\n  const dataRef = React5.useRef({});\n  const events = React5.useState(() => createPubSub())[0];\n  const floating = useFloating$1({\n    placement,\n    middleware,\n    strategy,\n    whileElementsMounted\n  });\n  const refs = React5.useMemo(() => ({\n    ...floating.refs,\n    domReference: domReferenceRef\n  }), [floating.refs]);\n  const context = React5.useMemo(() => ({\n    ...floating,\n    refs,\n    dataRef,\n    nodeId,\n    events,\n    open,\n    onOpenChange\n  }), [floating, nodeId, events, open, onOpenChange, refs]);\n  index(() => {\n    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);\n    if (node) {\n      node.context = context;\n    }\n  });\n  const {\n    reference: reference2\n  } = floating;\n  const setReference = React5.useCallback((node) => {\n    if (isElement3(node) || node === null) {\n      context.refs.domReference.current = node;\n    }\n    reference2(node);\n  }, [reference2, context.refs]);\n  return React5.useMemo(() => ({\n    ...floating,\n    context,\n    refs,\n    reference: setReference\n  }), [floating, refs, context, setReference]);\n}\nvar getDefaultBoundingClientRect = () => ({\n  width: 0,\n  height: 0,\n  x: 0,\n  y: 0,\n  top: -9999,\n  left: -9999,\n  right: 9999,\n  bottom: 9999\n});\nvar createVirtualElement = () => ({\n  getBoundingClientRect: getDefaultBoundingClientRect\n});\nvar getRangeBoundingClientRect = (editor, at) => {\n  if (!at)\n    return getDefaultBoundingClientRect();\n  const domRange = toDOMRange(editor, at);\n  if (!domRange)\n    return getDefaultBoundingClientRect();\n  return domRange.getBoundingClientRect();\n};\nvar getSelectionBoundingClientRect = () => {\n  const domSelection = window.getSelection();\n  if (!domSelection || domSelection.rangeCount < 1) {\n    return getDefaultBoundingClientRect();\n  }\n  const domRange = domSelection.getRangeAt(0);\n  return domRange.getBoundingClientRect();\n};\nvar useVirtualFloating = ({\n  getBoundingClientRect: getBoundingClientRect3 = getSelectionBoundingClientRect,\n  ...floatingOptions\n}) => {\n  const virtualElementRef = (0, import_react29.useRef)(createVirtualElement());\n  const [visible, setVisible] = (0, import_react29.useState)(true);\n  const floatingResult = useFloating({\n    // update on scroll and resize\n    whileElementsMounted: autoUpdate,\n    ...floatingOptions\n  });\n  const {\n    reference: reference2,\n    middlewareData,\n    strategy,\n    x: x4,\n    y: y5,\n    update\n  } = floatingResult;\n  (0, import_react29.useLayoutEffect)(() => {\n    virtualElementRef.current.getBoundingClientRect = getBoundingClientRect3;\n  }, [getBoundingClientRect3, update]);\n  (0, import_react29.useLayoutEffect)(() => {\n    reference2(virtualElementRef.current);\n  }, [reference2]);\n  (0, import_react29.useLayoutEffect)(() => {\n    if (!(middlewareData !== null && middlewareData !== void 0 && middlewareData.hide))\n      return;\n    const {\n      referenceHidden\n    } = middlewareData.hide;\n    setVisible(!referenceHidden);\n  }, [middlewareData.hide]);\n  return {\n    ...floatingResult,\n    virtualElementRef,\n    style: {\n      position: strategy,\n      top: y5 !== null && y5 !== void 0 ? y5 : 0,\n      left: x4 !== null && x4 !== void 0 ? x4 : 0,\n      display: floatingOptions.open === false ? \"none\" : void 0,\n      visibility: !visible ? \"hidden\" : void 0\n    }\n  };\n};\nvar submitFloatingLink = (editor) => {\n  if (!editor.selection)\n    return;\n  const {\n    isUrl: isUrl2\n  } = getPluginOptions(editor, ELEMENT_LINK);\n  const url = floatingLinkSelectors.url();\n  const isValid = isUrl2 === null || isUrl2 === void 0 ? void 0 : isUrl2(url);\n  if (!isValid)\n    return;\n  const text4 = floatingLinkSelectors.text();\n  floatingLinkActions.hide();\n  upsertLink(editor, {\n    url,\n    text: text4\n  });\n  setTimeout(() => {\n    focusEditor(editor, editor.selection);\n  }, 0);\n  return true;\n};\nvar useVirtualFloatingLink = (floatingOptions) => {\n  return useVirtualFloating({\n    placement: \"bottom-start\",\n    onOpenChange: floatingLinkActions.open,\n    middleware: [offset(12), flip({\n      padding: 96\n    })],\n    ...floatingOptions\n  });\n};\nvar useFloatingLinkEdit = ({\n  floatingOptions,\n  ...props\n}) => {\n  const editor = useEditorRef();\n  const keyEditor = usePlateSelectors(editor.id).keyEditor();\n  const mode = useFloatingLinkSelectors().mode();\n  const open = useFloatingLinkSelectors().open();\n  const {\n    triggerFloatingLinkHotkeys\n  } = getPluginOptions(editor, ELEMENT_LINK);\n  const getBoundingClientRect3 = (0, import_react29.useCallback)(() => {\n    const entry = getAboveNode(editor, {\n      match: {\n        type: getPluginType(editor, ELEMENT_LINK)\n      }\n    });\n    if (entry) {\n      const [, path] = entry;\n      return getRangeBoundingClientRect(editor, {\n        anchor: getStartPoint(editor, path),\n        focus: getEndPoint(editor, path)\n      });\n    }\n    return getDefaultBoundingClientRect();\n  }, [editor]);\n  const isOpen = open && mode === \"edit\";\n  const {\n    update,\n    style,\n    floating\n  } = useVirtualFloatingLink({\n    open: isOpen,\n    getBoundingClientRect: getBoundingClientRect3,\n    ...floatingOptions\n  });\n  (0, import_react29.useEffect)(() => {\n    if (editor.selection && someNode(editor, {\n      match: {\n        type: getPluginType(editor, ELEMENT_LINK)\n      }\n    })) {\n      floatingLinkActions.show(\"edit\");\n      update();\n      return;\n    }\n    if (floatingLinkSelectors.mode() === \"edit\") {\n      floatingLinkActions.hide();\n    }\n  }, [editor, keyEditor, update]);\n  useHotkeys(triggerFloatingLinkHotkeys, () => {\n    if (floatingLinkSelectors.mode() === \"edit\") {\n      triggerFloatingLinkEdit(editor);\n    }\n  }, {\n    enableOnContentEditable: true\n  }, []);\n  useHotkeys(\"enter\", (e4) => {\n    if (submitFloatingLink(editor)) {\n      e4.preventDefault();\n    }\n  }, {\n    enableOnTags: [\"INPUT\"]\n  }, []);\n  useHotkeys(\"escape\", () => {\n    if (floatingLinkSelectors.mode() !== \"edit\")\n      return;\n    if (floatingLinkSelectors.isEditing()) {\n      floatingLinkActions.show(\"edit\");\n      focusEditor(editor, editor.selection);\n      return;\n    }\n    floatingLinkActions.hide();\n  }, {\n    enableOnTags: [\"INPUT\"],\n    enableOnContentEditable: true\n  }, []);\n  return {\n    style: {\n      ...style,\n      zIndex: 1\n    },\n    ...props,\n    ref: useComposedRef(props.ref, floating)\n  };\n};\nvar triggerFloatingLinkInsert = (editor, {\n  focused\n} = {}) => {\n  if (floatingLinkSelectors.mode())\n    return;\n  if (!focused)\n    return;\n  if (isRangeAcrossBlocks(editor, {\n    at: editor.selection\n  }))\n    return;\n  const hasLink = someNode(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_LINK)\n    }\n  });\n  if (hasLink)\n    return;\n  floatingLinkActions.text(getEditorString(editor, editor.selection));\n  floatingLinkActions.show(\"insert\");\n};\nvar useFloatingLinkEscape = () => {\n  const editor = useEditorRef();\n  useHotkeys(\"escape\", () => {\n    if (floatingLinkSelectors.mode() !== \"insert\")\n      return;\n    floatingLinkActions.hide();\n    focusEditor(editor, editor.selection);\n  }, {\n    enableOnContentEditable: true,\n    enableOnTags: [\"INPUT\"]\n  }, []);\n};\nvar useFloatingLinkInsert = ({\n  floatingOptions,\n  ...props\n}) => {\n  const editor = useEditorRef();\n  const focused = useFocused();\n  const mode = useFloatingLinkSelectors().mode();\n  const open = useFloatingLinkSelectors().open();\n  const {\n    triggerFloatingLinkHotkeys\n  } = getPluginOptions(editor, ELEMENT_LINK);\n  useHotkeys(triggerFloatingLinkHotkeys, () => {\n    triggerFloatingLinkInsert(editor, {\n      focused\n    });\n  }, {\n    enableOnContentEditable: true\n  }, [focused]);\n  const ref = useOnClickOutside(() => {\n    if (floatingLinkSelectors.mode() === \"insert\") {\n      floatingLinkActions.hide();\n      focusEditor(editor, editor.selection);\n    }\n  });\n  const {\n    update,\n    style,\n    floating\n  } = useVirtualFloatingLink({\n    open: open && mode === \"insert\",\n    getBoundingClientRect: getSelectionBoundingClientRect,\n    whileElementsMounted: () => {\n    },\n    ...floatingOptions\n  });\n  (0, import_react29.useEffect)(() => {\n    if (open) {\n      update();\n      floatingLinkActions.updated(true);\n    } else {\n      floatingLinkActions.updated(false);\n    }\n  }, [open, update]);\n  useFloatingLinkEscape();\n  return {\n    style: {\n      ...style,\n      zIndex: 1\n    },\n    ...props,\n    ref: useComposedRef(props.ref, floating, ref)\n  };\n};\nvar FloatingLinkEditRoot = createComponentAs((props) => {\n  var _htmlProps$style;\n  const htmlProps = useFloatingLinkEdit(props);\n  if (((_htmlProps$style = htmlProps.style) === null || _htmlProps$style === void 0 ? void 0 : _htmlProps$style.display) === \"none\") {\n    return null;\n  }\n  return createElementAs(\"div\", htmlProps);\n});\nvar FloatingLinkInsertRoot = createComponentAs((props) => {\n  var _htmlProps$style2;\n  const htmlProps = useFloatingLinkInsert(props);\n  if (((_htmlProps$style2 = htmlProps.style) === null || _htmlProps$style2 === void 0 ? void 0 : _htmlProps$style2.display) === \"none\") {\n    return null;\n  }\n  return createElementAs(\"div\", htmlProps);\n});\nvar FloatingLink = {\n  EditRoot: FloatingLinkEditRoot,\n  InsertRoot: FloatingLinkInsertRoot,\n  UrlInput: FloatingLinkUrlInput,\n  TextInput: FloatingLinkTextInput,\n  EditButton: FloatingLinkEditButton,\n  UnlinkButton,\n  OpenLinkButton\n};\nvar triggerFloatingLink = (editor, {\n  focused\n} = {}) => {\n  if (floatingLinkSelectors.mode() === \"edit\") {\n    triggerFloatingLinkEdit(editor);\n    return;\n  }\n  triggerFloatingLinkInsert(editor, {\n    focused\n  });\n};\nvar insertLink = (editor, createLinkNodeOptions, options) => {\n  insertNodes(editor, [createLinkNode(editor, createLinkNodeOptions)], options);\n};\nvar unwrapLink = (editor, options) => {\n  return withoutNormalizing(editor, () => {\n    if (options !== null && options !== void 0 && options.split) {\n      var _editor$selection, _editor$selection4;\n      const linkAboveAnchor = getAboveNode(editor, {\n        at: (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor,\n        match: {\n          type: getPluginType(editor, ELEMENT_LINK)\n        }\n      });\n      if (linkAboveAnchor) {\n        var _editor$selection2, _editor$selection3;\n        splitNodes(editor, {\n          at: (_editor$selection2 = editor.selection) === null || _editor$selection2 === void 0 ? void 0 : _editor$selection2.anchor,\n          match: (n8) => isElement2(n8) && n8.type === getPluginType(editor, ELEMENT_LINK)\n        });\n        unwrapLink(editor, {\n          at: (_editor$selection3 = editor.selection) === null || _editor$selection3 === void 0 ? void 0 : _editor$selection3.anchor\n        });\n        return true;\n      }\n      const linkAboveFocus = getAboveNode(editor, {\n        at: (_editor$selection4 = editor.selection) === null || _editor$selection4 === void 0 ? void 0 : _editor$selection4.focus,\n        match: {\n          type: getPluginType(editor, ELEMENT_LINK)\n        }\n      });\n      if (linkAboveFocus) {\n        var _editor$selection5, _editor$selection6;\n        splitNodes(editor, {\n          at: (_editor$selection5 = editor.selection) === null || _editor$selection5 === void 0 ? void 0 : _editor$selection5.focus,\n          match: (n8) => isElement2(n8) && n8.type === getPluginType(editor, ELEMENT_LINK)\n        });\n        unwrapLink(editor, {\n          at: (_editor$selection6 = editor.selection) === null || _editor$selection6 === void 0 ? void 0 : _editor$selection6.focus\n        });\n        return true;\n      }\n    }\n    unwrapNodes(editor, {\n      match: {\n        type: getPluginType(editor, ELEMENT_LINK)\n      },\n      ...options\n    });\n  });\n};\nvar upsertLinkText = (editor, {\n  text: text4\n}) => {\n  const newLink = getAboveNode(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_LINK)\n    }\n  });\n  if (newLink) {\n    const [newLinkNode, newLinkPath] = newLink;\n    if (text4 !== null && text4 !== void 0 && text4.length && text4 !== getEditorString(editor, newLinkPath)) {\n      const firstText = newLinkNode.children[0];\n      replaceNodeChildren(editor, {\n        at: newLinkPath,\n        nodes: {\n          ...firstText,\n          text: text4\n        },\n        insertOptions: {\n          select: true\n        }\n      });\n    }\n  }\n};\nvar wrapLink = (editor, {\n  url,\n  ...options\n}) => {\n  wrapNodes(editor, {\n    type: getPluginType(editor, ELEMENT_LINK),\n    url,\n    children: []\n  }, {\n    split: true,\n    ...options\n  });\n};\nvar upsertLink = (editor, {\n  url,\n  text: text4,\n  insertTextInLink,\n  insertNodesOptions\n}) => {\n  var _text, _editor$selection, _text2;\n  const at = editor.selection;\n  if (!at)\n    return;\n  const linkAbove = getAboveNode(editor, {\n    at,\n    match: {\n      type: getPluginType(editor, ELEMENT_LINK)\n    }\n  });\n  if (insertTextInLink && linkAbove) {\n    editor.insertText(url);\n    return true;\n  }\n  const {\n    isUrl: isUrl2\n  } = getPluginOptions(editor, ELEMENT_LINK);\n  if (!(isUrl2 !== null && isUrl2 !== void 0 && isUrl2(url))) {\n    return;\n  }\n  if (isDefined(text4) && !text4.length) {\n    text4 = url;\n  }\n  if (linkAbove) {\n    var _linkAbove$;\n    if (url !== ((_linkAbove$ = linkAbove[0]) === null || _linkAbove$ === void 0 ? void 0 : _linkAbove$.url)) {\n      setNodes(editor, {\n        url\n      }, {\n        at: linkAbove[1]\n      });\n    }\n    upsertLinkText(editor, {\n      url,\n      text: text4\n    });\n    return true;\n  }\n  const linkEntry = findNode(editor, {\n    at,\n    match: {\n      type: getPluginType(editor, ELEMENT_LINK)\n    }\n  });\n  const [linkNode, linkPath] = linkEntry !== null && linkEntry !== void 0 ? linkEntry : [];\n  let shouldReplaceText = false;\n  if (linkPath && (_text = text4) !== null && _text !== void 0 && _text.length) {\n    const linkText = getEditorString(editor, linkPath);\n    if (text4 !== linkText) {\n      shouldReplaceText = true;\n    }\n  }\n  if (isExpanded(at)) {\n    if (linkAbove) {\n      unwrapLink(editor, {\n        at: linkAbove[1]\n      });\n    } else {\n      unwrapLink(editor, {\n        split: true\n      });\n    }\n    wrapLink(editor, {\n      url\n    });\n    upsertLinkText(editor, {\n      url,\n      text: text4\n    });\n    return true;\n  }\n  if (shouldReplaceText) {\n    removeNodes(editor, {\n      at: linkPath\n    });\n  }\n  const props = getNodeProps(linkNode !== null && linkNode !== void 0 ? linkNode : {});\n  const path = (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.focus.path;\n  if (!path)\n    return;\n  const leaf = getNodeLeaf(editor, path);\n  if (!((_text2 = text4) !== null && _text2 !== void 0 && _text2.length)) {\n    text4 = url;\n  }\n  insertLink(editor, {\n    ...props,\n    url,\n    children: [{\n      ...leaf,\n      text: text4\n    }]\n  }, insertNodesOptions);\n  return true;\n};\nvar withLink = (editor, {\n  type,\n  options: {\n    isUrl: isUrl2,\n    getUrlHref,\n    rangeBeforeOptions\n  }\n}) => {\n  const {\n    insertData,\n    insertText: insertText2,\n    apply: apply2,\n    normalizeNode\n  } = editor;\n  editor.insertText = (text4) => {\n    if (text4 === \" \" && isCollapsed(editor.selection)) {\n      withoutNormalizing(editor, () => {\n        var _getUrlHref;\n        const selection = editor.selection;\n        let beforeWordRange = getRangeBefore(editor, selection, rangeBeforeOptions);\n        if (!beforeWordRange) {\n          beforeWordRange = getRangeFromBlockStart(editor);\n        }\n        if (!beforeWordRange)\n          return;\n        const hasLink = someNode(editor, {\n          at: beforeWordRange,\n          match: {\n            type: getPluginType(editor, ELEMENT_LINK)\n          }\n        });\n        if (hasLink)\n          return;\n        let beforeWordText = getEditorString(editor, beforeWordRange);\n        beforeWordText = (_getUrlHref = getUrlHref === null || getUrlHref === void 0 ? void 0 : getUrlHref(beforeWordText)) !== null && _getUrlHref !== void 0 ? _getUrlHref : beforeWordText;\n        if (!isUrl2(beforeWordText))\n          return;\n        select(editor, beforeWordRange);\n        upsertLink(editor, {\n          url: beforeWordText\n        });\n        collapseSelection(editor, {\n          edge: \"end\"\n        });\n      });\n    }\n    insertText2(text4);\n  };\n  editor.insertData = (data) => {\n    const text4 = data.getData(\"text/plain\");\n    const textHref = getUrlHref === null || getUrlHref === void 0 ? void 0 : getUrlHref(text4);\n    if (text4) {\n      const inserted = upsertLink(editor, {\n        url: textHref || text4,\n        insertTextInLink: true\n      });\n      if (inserted)\n        return;\n    }\n    insertData(data);\n  };\n  editor.apply = (operation) => {\n    if (operation.type === \"set_selection\") {\n      const range = operation.newProperties;\n      if (range && range.focus && range.anchor && isCollapsed(range)) {\n        const entry = getAboveNode(editor, {\n          at: range,\n          match: {\n            type: getPluginType(editor, ELEMENT_LINK)\n          }\n        });\n        if (entry) {\n          const [, path] = entry;\n          let newPoint;\n          if (isStartPoint(editor, range.focus, path)) {\n            newPoint = getPreviousNodeEndPoint(editor, path);\n          }\n          if (isEndPoint(editor, range.focus, path)) {\n            newPoint = getNextNodeStartPoint(editor, path);\n          }\n          if (newPoint) {\n            operation.newProperties = {\n              anchor: newPoint,\n              focus: newPoint\n            };\n          }\n        }\n      }\n    }\n    apply2(operation);\n  };\n  editor.normalizeNode = ([node, path]) => {\n    if (node.type === getPluginType(editor, ELEMENT_LINK)) {\n      const range = editor.selection;\n      if (range && isCollapsed(range)) {\n        if (isEndPoint(editor, range.focus, path)) {\n          const nextPoint = getNextNodeStartPoint(editor, path);\n          if (nextPoint) {\n            select(editor, nextPoint);\n          } else {\n            const nextPath = Path.next(path);\n            insertNodes(editor, {\n              text: \"\"\n            }, {\n              at: nextPath\n            });\n            select(editor, nextPath);\n          }\n        }\n      }\n    }\n    normalizeNode([node, path]);\n  };\n  editor = withRemoveEmptyNodes(editor, mockPlugin({\n    options: {\n      types: type\n    }\n  }));\n  return editor;\n};\nvar ELEMENT_LINK = \"a\";\nvar createLinkPlugin = createPluginFactory({\n  key: ELEMENT_LINK,\n  isElement: true,\n  isInline: true,\n  props: ({\n    element: element4\n  }) => ({\n    nodeProps: {\n      href: element4 === null || element4 === void 0 ? void 0 : element4.url\n    }\n  }),\n  withOverrides: withLink,\n  options: {\n    isUrl,\n    rangeBeforeOptions: {\n      matchString: \" \",\n      skipInvalid: true,\n      afterMatch: true\n    },\n    triggerFloatingLinkHotkeys: \"command+k, ctrl+k\"\n  },\n  then: (editor, {\n    type\n  }) => ({\n    deserializeHtml: {\n      rules: [{\n        validNodeName: \"A\"\n      }],\n      getNode: (el) => ({\n        type,\n        url: el.getAttribute(\"href\")\n      })\n    }\n  })\n});\n\n// node_modules/@udecode/plate-paragraph/dist/index.es.js\nvar ELEMENT_PARAGRAPH = \"p\";\nvar createParagraphPlugin = createPluginFactory({\n  key: ELEMENT_PARAGRAPH,\n  isElement: true,\n  handlers: {\n    onKeyDown: onKeyDownToggleElement\n  },\n  options: {\n    hotkey: [\"mod+opt+0\", \"mod+shift+0\"]\n  },\n  deserializeHtml: {\n    rules: [{\n      validNodeName: \"P\"\n    }],\n    query: (el) => el.style.fontFamily !== \"Consolas\"\n  }\n});\n\n// node_modules/@udecode/plate-select/dist/index.es.js\nvar withSelectOnBackspace = (editor, {\n  options: {\n    query\n  }\n}) => {\n  const {\n    deleteBackward: deleteBackward2\n  } = editor;\n  editor.deleteBackward = (unit) => {\n    const {\n      selection\n    } = editor;\n    if (unit === \"character\" && isCollapsed(selection)) {\n      const pointBefore = getPointBefore(editor, selection, {\n        unit\n      });\n      if (pointBefore) {\n        const [prevCell] = getNodeEntries(editor, {\n          match: (node) => queryNode([node, pointBefore.path], query),\n          at: pointBefore\n        });\n        if (!!prevCell && pointBefore) {\n          select(editor, pointBefore);\n        } else {\n          deleteBackward2(unit);\n        }\n      } else {\n        deleteBackward2(unit);\n      }\n    } else {\n      deleteBackward2(unit);\n    }\n  };\n  return editor;\n};\nvar KEY_SELECT_ON_BACKSPACE = \"selectOnBackspace\";\nvar createSelectOnBackspacePlugin = createPluginFactory({\n  key: KEY_SELECT_ON_BACKSPACE,\n  withOverrides: withSelectOnBackspace\n});\n\n// node_modules/@udecode/plate-heading/dist/index.es.js\nvar ELEMENT_H1 = \"h1\";\nvar ELEMENT_H2 = \"h2\";\nvar ELEMENT_H3 = \"h3\";\nvar ELEMENT_H4 = \"h4\";\nvar ELEMENT_H5 = \"h5\";\nvar ELEMENT_H6 = \"h6\";\nvar KEYS_HEADING = [ELEMENT_H1, ELEMENT_H2, ELEMENT_H3, ELEMENT_H4, ELEMENT_H5, ELEMENT_H6];\nvar createHeadingPlugin = createPluginFactory({\n  key: \"heading\",\n  options: {\n    levels: 6\n  },\n  then: (editor, {\n    options: {\n      levels\n    } = {}\n  }) => {\n    const plugins = [];\n    for (let level = 1; level <= levels; level++) {\n      const key = KEYS_HEADING[level - 1];\n      const plugin = {\n        key,\n        isElement: true,\n        deserializeHtml: {\n          rules: [{\n            validNodeName: `H${level}`\n          }]\n        },\n        handlers: {\n          onKeyDown: onKeyDownToggleElement\n        },\n        options: {}\n      };\n      if (level < 4) {\n        plugin.options.hotkey = [`mod+opt+${level}`, `mod+shift+${level}`];\n      }\n      plugins.push(plugin);\n    }\n    return {\n      plugins\n    };\n  }\n});\n\n// src/editor/config/autoformat/autoformatUtils.ts\nvar clearBlockFormat = (editor) => unwrapList(editor);\nvar format = (editor, customFormatting) => {\n  if (editor.selection) {\n    const parentEntry = getParentNode(editor, editor.selection);\n    if (!parentEntry)\n      return;\n    const [node] = parentEntry;\n    if (isElement2(node) && !isType(editor, node, ELEMENT_CODE_BLOCK) && !isType(editor, node, ELEMENT_CODE_LINE)) {\n      customFormatting();\n    }\n  }\n};\nvar formatList = (editor, elementType) => {\n  format(\n    editor,\n    () => toggleList(editor, {\n      type: elementType\n    })\n  );\n};\n\n// src/editor/plugins/codeblock/options/getCodeLineType.ts\nvar getCodeLineType = (editor) => getPluginType(editor, ELEMENT_CODE_LINE);\n\n// src/editor/plugins/codeblock/transforms/insertCodeBlock.ts\nvar insertCodeBlock = (editor, insertNodesOptions = {}) => {\n  if (!editor.selection || isExpanded(editor.selection))\n    return;\n  const matchCodeElements = (node) => node.type === getPluginType(editor, ELEMENT_CODE_BLOCK) || node.type === getCodeLineType(editor);\n  if (someNode(editor, {\n    match: matchCodeElements\n  })) {\n    return;\n  }\n  if (!isSelectionAtBlockStart(editor)) {\n    editor.insertBreak();\n  }\n  setElements(\n    editor,\n    {\n      type: getCodeLineType(editor),\n      children: [{ text: \"\" }]\n    },\n    insertNodesOptions\n  );\n  wrapNodes(\n    editor,\n    {\n      type: getPluginType(editor, ELEMENT_CODE_BLOCK),\n      children: []\n    },\n    insertNodesOptions\n  );\n};\n\n// src/editor/plugins/codeblock/transforms/insertEmptyCodeBlock.ts\nvar insertEmptyCodeBlock = (editor, { defaultType = getPluginType(editor, ELEMENT_DEFAULT), insertNodesOptions, level = 0 }) => {\n  if (!editor.selection)\n    return;\n  if (isExpanded(editor.selection) || !isBlockAboveEmpty(editor)) {\n    const selectionPath = getPath(editor, editor.selection);\n    const insertPath = Path.next(selectionPath.slice(0, level + 1));\n    insertElements(\n      editor,\n      { type: defaultType, children: [{ text: \"\" }] },\n      {\n        at: insertPath,\n        select: true\n      }\n    );\n  }\n  insertCodeBlock(editor, insertNodesOptions);\n};\n\n// src/editor/config/autoformat/autoformatBlocks.ts\nvar autoformatBlocks = [\n  {\n    mode: \"block\",\n    type: ELEMENT_H1,\n    match: [\"! \", \"\\uFF01 \"],\n    preFormat: clearBlockFormat\n  },\n  {\n    mode: \"block\",\n    type: ELEMENT_H2,\n    match: [\"!! \", \"\\uFF01\\uFF01 \"],\n    preFormat: clearBlockFormat\n  },\n  {\n    mode: \"block\",\n    type: ELEMENT_H3,\n    match: [\"!!! \", \"\\uFF01\\uFF01\\uFF01 \"],\n    preFormat: clearBlockFormat\n  },\n  {\n    mode: \"block\",\n    type: ELEMENT_H4,\n    match: [\"!!!! \", \"\\uFF01\\uFF01\\uFF01\\uFF01 \"],\n    preFormat: clearBlockFormat\n  },\n  {\n    mode: \"block\",\n    type: ELEMENT_H5,\n    match: [\"!!!!! \", \"\\uFF01\\uFF01\\uFF01\\uFF01\\uFF01 \"],\n    preFormat: clearBlockFormat\n  },\n  {\n    mode: \"block\",\n    type: ELEMENT_H6,\n    match: [\"!!!!!! \", \"\\uFF01\\uFF01\\uFF01\\uFF01\\uFF01\\uFF01 \"],\n    preFormat: clearBlockFormat\n  },\n  {\n    mode: \"block\",\n    type: ELEMENT_BLOCKQUOTE,\n    match: [\"> \", \"\\u300B \"],\n    preFormat: clearBlockFormat\n  },\n  {\n    mode: \"block\",\n    type: ELEMENT_HR,\n    match: [\"---\", \"\\u2014-\"],\n    preFormat: clearBlockFormat,\n    format: (editor) => {\n      setElements(editor, { type: ELEMENT_HR });\n      insertNodes(editor, {\n        type: ELEMENT_DEFAULT,\n        children: [{ text: \"\" }]\n      });\n    }\n  },\n  {\n    mode: \"block\",\n    type: ELEMENT_CODE_BLOCK,\n    match: \"```\",\n    triggerAtBlockStart: false,\n    preFormat: clearBlockFormat,\n    format: (editor) => {\n      insertEmptyCodeBlock(editor, {\n        defaultType: getPluginType(editor, ELEMENT_DEFAULT),\n        insertNodesOptions: { select: true }\n      });\n    }\n  }\n];\n\n// src/editor/config/autoformat/autoformatLists.ts\nvar autoformatLists = [\n  {\n    mode: \"block\",\n    type: ELEMENT_LI,\n    match: [\"* \", \"- \"],\n    preFormat: clearBlockFormat,\n    format: (editor) => formatList(editor, ELEMENT_UL)\n  },\n  {\n    mode: \"block\",\n    type: ELEMENT_LI,\n    match: [\"1. \", \"1) \", \"# \"],\n    preFormat: clearBlockFormat,\n    format: (editor) => formatList(editor, ELEMENT_OL)\n  }\n];\n\n// src/editor/config/autoformat/autoformatMarks.ts\nvar autoformatMarks = [\n  // {\n  //   mode: 'mark',\n  //   type: [MARK_BOLD, MARK_ITALIC],\n  //   match: '***',\n  // },\n  // {\n  //   mode: 'mark',\n  //   type: [MARK_UNDERLINE, MARK_ITALIC],\n  //   match: '__*',\n  // },\n  // {\n  //   mode: 'mark',\n  //   type: [MARK_UNDERLINE, MARK_BOLD],\n  //   match: '__**',\n  // },\n  // {\n  //   mode: 'mark',\n  //   type: [MARK_UNDERLINE, MARK_BOLD, MARK_ITALIC],\n  //   match: '___***',\n  // },\n  {\n    mode: \"mark\",\n    type: MARK_BOLD,\n    match: [\"''\"]\n  },\n  {\n    mode: \"mark\",\n    type: MARK_UNDERLINE,\n    match: \"__\"\n  },\n  {\n    mode: \"mark\",\n    type: MARK_ITALIC,\n    match: [\"//\"]\n  },\n  {\n    mode: \"mark\",\n    type: MARK_STRIKETHROUGH,\n    match: \"~~\"\n  },\n  {\n    mode: \"mark\",\n    type: MARK_SUPERSCRIPT,\n    match: \"^^\"\n  },\n  {\n    mode: \"mark\",\n    type: MARK_SUBSCRIPT$1,\n    match: [\",,\", \"\\uFF0C\\uFF0C\"]\n  },\n  {\n    mode: \"mark\",\n    type: MARK_CODE,\n    match: \"`\"\n  }\n];\n\n// src/editor/config/autoformat/index.ts\nvar autoformatRules = [...autoformatBlocks, ...autoformatLists, ...autoformatMarks];\n\n// src/editor/config/config.ts\nvar SAVE_DEBOUNCE_INTERVAL = 1e3;\nvar resetBlockTypesCommonRule = {\n  types: [ELEMENT_BLOCKQUOTE, ELEMENT_TODO_LI],\n  defaultType: ELEMENT_PARAGRAPH\n};\nvar CONFIG = {\n  link: {\n    options: {\n      triggerFloatingLinkHotkeys: \"ctrl+l\"\n    }\n  },\n  snippetComboBox: {\n    key: \"/\"\n  },\n  wikiLinkComboBox: {\n    key: \"[[\",\n    options: {\n      needSpaceBeforeTrigger: false,\n      keepTrigger: true,\n      textToInsertAfter: \"]]\",\n      createAutoCompleteNode: (item) => {\n        return { text: item.text };\n      }\n    }\n  },\n  wikiTransclusionComboBox: {\n    key: \"{{\",\n    options: {\n      needSpaceBeforeTrigger: false,\n      keepTrigger: true,\n      textToInsertAfter: \"}}\",\n      createAutoCompleteNode: (item) => {\n        return { text: item.text };\n      }\n    }\n  },\n  macrosComboBox: {\n    key: \"<<\",\n    options: {\n      needSpaceBeforeTrigger: false,\n      createAutoCompleteNode: (item) => {\n        return { text: item.text };\n      }\n    }\n  },\n  widgetComboBox: {\n    key: \"<$\",\n    options: {\n      needSpaceBeforeTrigger: false,\n      createAutoCompleteNode: (item) => {\n        return { text: item.text };\n      }\n    }\n  },\n  editableProps: {\n    // we need this to reset cursor selection on every remount of widget, otherwise there will be IME problem, don't know why... https://github.com/tiddly-gittly/slate-write/issues/3#issuecomment-1114274656\n    autoFocus: true,\n    spellCheck: false,\n    placeholder: \"Type / for commands, or write down what is in your mind\"\n  },\n  align: {\n    inject: {\n      props: {\n        validTypes: [ELEMENT_PARAGRAPH, ELEMENT_H1, ELEMENT_H2, ELEMENT_H3, ELEMENT_H4, ELEMENT_H5, ELEMENT_H6]\n      }\n    }\n  },\n  indent: {\n    inject: {\n      props: {\n        validTypes: [ELEMENT_PARAGRAPH, ELEMENT_H1, ELEMENT_H2, ELEMENT_H3, ELEMENT_H4, ELEMENT_H5, ELEMENT_H6, ELEMENT_BLOCKQUOTE, ELEMENT_CODE_BLOCK]\n      }\n    }\n  },\n  lineHeight: {\n    inject: {\n      props: {\n        defaultNodeValue: \"normal\",\n        validTypes: [ELEMENT_PARAGRAPH, ELEMENT_H1, ELEMENT_H2, ELEMENT_H3, ELEMENT_H4, ELEMENT_H5, ELEMENT_H6]\n      }\n    }\n  },\n  resetBlockType: {\n    options: {\n      rules: [\n        {\n          ...resetBlockTypesCommonRule,\n          hotkey: \"Enter\",\n          predicate: isBlockAboveEmpty\n        },\n        {\n          ...resetBlockTypesCommonRule,\n          hotkey: \"Backspace\",\n          predicate: isSelectionAtBlockStart\n        }\n      ]\n    }\n  },\n  trailingBlock: { type: ELEMENT_PARAGRAPH },\n  softBreak: {\n    options: {\n      rules: [\n        { hotkey: \"shift+enter\" },\n        {\n          hotkey: \"enter\",\n          query: {\n            allow: [ELEMENT_CODE_BLOCK, ELEMENT_BLOCKQUOTE]\n          }\n        }\n      ]\n    }\n  },\n  exitBreak: {\n    options: {\n      rules: [\n        {\n          hotkey: \"mod+enter\"\n        },\n        {\n          hotkey: \"mod+shift+enter\",\n          before: true\n        },\n        {\n          hotkey: \"enter\",\n          query: {\n            start: true,\n            end: true,\n            allow: KEYS_HEADING\n          }\n        }\n      ]\n    }\n  },\n  selectOnBackspace: {\n    options: {\n      query: {\n        allow: [ELEMENT_WIDGET]\n      }\n    }\n  },\n  autoformat: {\n    options: {\n      rules: autoformatRules\n    }\n  },\n  forceLayout: {\n    options: {\n      rules: [{ path: [0], strictType: ELEMENT_H1 }]\n    }\n  }\n};\n\n// src/editor/plugins/heading/index.ts\nvar createHeadingPlugin2 = createPluginFactory({\n  key: \"heading\",\n  options: {\n    levels: 6\n  },\n  then: (editor, { options: { levels = 0 } = {} }) => {\n    const plugins = [];\n    for (let level = 1; level <= levels; level++) {\n      const key = KEYS_HEADING[level - 1];\n      const plugin = {\n        key,\n        isElement: true,\n        deserializeHtml: {\n          rules: [\n            {\n              validNodeName: `H${level}`\n            }\n          ]\n        },\n        handlers: {\n          onKeyDown: onKeyDownToggleElement\n        },\n        options: {\n          // we need to change this, so fork the code\n          hotkey: [`ctrl+${level}`, `mod+shift+${level}`]\n        }\n      };\n      plugins.push(plugin);\n    }\n    return {\n      plugins\n    };\n  }\n});\n\n// src/editor/plugins/codeblock/createCodeBlockPlugin.ts\nvar createCodeBlockPlugin = createPluginFactory({\n  key: ELEMENT_CODE_BLOCK,\n  isElement: true,\n  isVoid: true,\n  handlers: {\n    // onKeyDown: onKeyDownCodeBlock,\n  },\n  options: {\n    // hotkey: ['mod+opt+8', 'mod+shift+8'],\n    syntaxPopularFirst: true,\n    showSyntaxSwitcher: true\n  }\n});\n\n// src/editor/plugins/codeblock/CodeBlockElement/CodeBlockElement.tsx\nvar import_react32 = __toESM(require(\"react\"));\nvar import_styled_components3 = __toESM(require_styled_components_browser_cjs());\n\n// node_modules/@udecode/plate-styled-components/dist/index.es.js\nvar import_styled_components = __toESM(require_styled_components_browser_cjs());\nvar import_react30 = __toESM(require(\"react\"));\nvar import_react_dom2 = __toESM(require(\"react-dom\"));\nvar _StyledDiv$1 = (0, import_styled_components.default)(\"div\").withConfig({\n  displayName: \"Divider___StyledDiv\",\n  componentId: \"sc-n6iu2k-0\"\n})({\n  \"marginLeft\": \"0.5rem\",\n  \"marginRight\": \"0.5rem\",\n  \"marginTop\": \"0.125rem\",\n  \"marginBottom\": \"0.125rem\",\n  \"width\": \"1px\",\n  \"--tw-bg-opacity\": \"1\",\n  \"backgroundColor\": \"rgba(229, 231, 235, var(--tw-bg-opacity))\"\n});\nvar PortalBody = ({\n  children,\n  element: element4\n}) => /* @__PURE__ */ import_react_dom2.default.createPortal(children, element4 || document.body);\nfunction _extends3() {\n  _extends3 = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i5 = 1; i5 < arguments.length; i5++) {\n      var source = arguments[i5];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends3.apply(this, arguments);\n}\nvar isArray8 = Array.isArray;\nvar isArray_17 = isArray8;\nfunction castArray5() {\n  if (!arguments.length) {\n    return [];\n  }\n  var value = arguments[0];\n  return isArray_17(value) ? value : [value];\n}\nvar castArray_15 = castArray5;\nvar getRootProps = (props) => {\n  const {\n    editor,\n    attributes,\n    children,\n    nodeProps,\n    styles: styles2,\n    classNames,\n    prefixClassNames,\n    element: element4,\n    leaf,\n    text: text4,\n    ...rootProps\n  } = props;\n  return rootProps;\n};\nvar createStyles = (props, styles2) => {\n  const stylesArray = castArray_15(styles2);\n  const allStyles = {};\n  stylesArray.forEach((_styles) => {\n    Object.keys(_styles).forEach((key) => {\n      var _props$classNames, _props$styles;\n      const cssProp = castArray_15(_styles[key]);\n      if (!allStyles[key]) {\n        let className = \"\";\n        if (props.prefixClassNames) {\n          if (key === \"root\") {\n            className = `slate-${props.prefixClassNames}`;\n          } else {\n            className = `slate-${props.prefixClassNames}-${key}`;\n          }\n        }\n        allStyles[key] = {\n          css: cssProp,\n          className: clsx_m_default(props.prefixClassNames && className)\n        };\n      }\n      const classNameProp = props === null || props === void 0 ? void 0 : (_props$classNames = props.classNames) === null || _props$classNames === void 0 ? void 0 : _props$classNames[key];\n      if (classNameProp) {\n        allStyles[key].className = clsx_m_default(allStyles[key].className, classNameProp);\n      }\n      const cssPropOverride = props === null || props === void 0 ? void 0 : (_props$styles = props.styles) === null || _props$styles === void 0 ? void 0 : _props$styles[key];\n      if (!cssPropOverride)\n        return;\n      const cssPropOverrideArray = castArray_15(cssPropOverride);\n      allStyles[key].css.push(...cssPropOverrideArray);\n    });\n  });\n  return allStyles;\n};\nvar getStyledNodeStyles = (props) => createStyles(props, {\n  root: [{}]\n});\nvar StyledElement = (props) => {\n  var _styles$root, _nodeProps$styles$roo, _nodeProps$styles, _nodeProps$styles$roo2;\n  const {\n    attributes,\n    children,\n    nodeProps,\n    styles: styles2\n  } = props;\n  const rootProps = getRootProps(props);\n  const rootStyles = castArray_15((_styles$root = styles2 === null || styles2 === void 0 ? void 0 : styles2.root) !== null && _styles$root !== void 0 ? _styles$root : []);\n  const nodePropsStyles = (_nodeProps$styles$roo = nodeProps === null || nodeProps === void 0 ? void 0 : (_nodeProps$styles = nodeProps.styles) === null || _nodeProps$styles === void 0 ? void 0 : (_nodeProps$styles$roo2 = _nodeProps$styles.root) === null || _nodeProps$styles$roo2 === void 0 ? void 0 : _nodeProps$styles$roo2.css) !== null && _nodeProps$styles$roo !== void 0 ? _nodeProps$styles$roo : [];\n  const {\n    root: root5\n  } = getStyledNodeStyles({\n    ...nodeProps,\n    styles: {\n      root: [...rootStyles, ...nodePropsStyles]\n    }\n  });\n  return /* @__PURE__ */ import_react30.default.createElement(_StyledDiv, _extends3({}, attributes, rootProps, nodeProps, {\n    $_css: root5.css\n  }), children);\n};\nvar _StyledDiv = (0, import_styled_components.default)(\"div\").withConfig({\n  displayName: \"StyledElement___StyledDiv\",\n  componentId: \"sc-2e063k-0\"\n})([\"\", \"\"], (p6) => p6.$_css);\nvar StyledLeaf = (props) => {\n  var _styles$root, _nodeProps$styles$roo, _nodeProps$styles, _nodeProps$styles$roo2;\n  const {\n    attributes,\n    children,\n    nodeProps,\n    styles: styles2\n  } = props;\n  const rootProps = getRootProps(props);\n  const rootStyles = castArray_15((_styles$root = styles2 === null || styles2 === void 0 ? void 0 : styles2.root) !== null && _styles$root !== void 0 ? _styles$root : []);\n  const nodePropsStyles = (_nodeProps$styles$roo = nodeProps === null || nodeProps === void 0 ? void 0 : (_nodeProps$styles = nodeProps.styles) === null || _nodeProps$styles === void 0 ? void 0 : (_nodeProps$styles$roo2 = _nodeProps$styles.root) === null || _nodeProps$styles$roo2 === void 0 ? void 0 : _nodeProps$styles$roo2.css) !== null && _nodeProps$styles$roo !== void 0 ? _nodeProps$styles$roo : [];\n  const {\n    root: root5\n  } = getStyledNodeStyles({\n    ...nodeProps,\n    styles: {\n      root: [...rootStyles, ...nodePropsStyles]\n    }\n  });\n  return /* @__PURE__ */ import_react30.default.createElement(_StyledSpan, _extends3({}, attributes, rootProps, nodeProps, {\n    $_css: root5.css\n  }), children);\n};\nvar _StyledSpan = (0, import_styled_components.default)(\"span\").withConfig({\n  displayName: \"StyledLeaf___StyledSpan\",\n  componentId: \"sc-129cvv1-0\"\n})([\"\", \"\"], (p6) => p6.$_css);\n\n// src/editor/plugins/codeblock/CodeBlockElement/CodeBlockSelectElement.tsx\nvar import_react31 = __toESM(require(\"react\"));\nvar import_styled_components2 = __toESM(require_styled_components_browser_cjs());\nvar CodeSyntaxSelect = import_styled_components2.default.select`\n  opacity: 20%;\n  &:hover {\n    opacity: 100%;\n  }\n  transition: opacity 0.2s;\n`;\nfunction CodeBlockSelectElement({\n  language,\n  onChange,\n  ...props\n}) {\n  const [value, setValue] = import_react31.default.useState(language);\n  const editor = useEditorRef();\n  if (useReadOnly())\n    return null;\n  const { syntaxPopularFirst } = getPluginOptions(editor, ELEMENT_CODE_BLOCK);\n  return /* @__PURE__ */ import_react31.default.createElement(\n    CodeSyntaxSelect,\n    {\n      value: value && normalizeLanguage(value),\n      style: { float: \"right\" },\n      onClick: (event) => {\n        event.stopPropagation();\n      },\n      onChange: (event) => {\n        onChange(event.target.value);\n        setValue(event.target.value);\n      },\n      contentEditable: false,\n      ...props\n    },\n    /* @__PURE__ */ import_react31.default.createElement(\"option\", { value: \"\" }, \"txt\"),\n    syntaxPopularFirst && CODE_BLOCK_LANGUAGES_POPULAR.map((displayName) => {\n      const values2 = CODE_BLOCK_LANGUAGES[displayName];\n      const value2 = Array.isArray(values2) ? values2[0] : values2;\n      return /* @__PURE__ */ import_react31.default.createElement(\"option\", { key: displayName, value: value2 }, displayName);\n    }),\n    Object.entries(CODE_BLOCK_LANGUAGES).map(([displayName, values2]) => {\n      const value2 = Array.isArray(values2) ? values2[0] : values2;\n      return /* @__PURE__ */ import_react31.default.createElement(\"option\", { key: displayName, value: value2 }, displayName);\n    })\n  );\n}\n\n// src/editor/plugins/codeblock/CodeBlockElement/CodeBlockElement.tsx\nvar CodeContainer = import_styled_components3.default.div`\n  margin-top: 1em;\n  margin-bottom: 1em;\n`;\nvar CodeTextArea = import_styled_components3.default.textarea`\n  width: 100%;\n  height: max-content;\n`;\nfunction useCodeMirror(textAreaReference, options) {\n  const codeMirrorReference = (0, import_react32.useRef)(null);\n  const codeMirrorInitialized = (0, import_react32.useRef)(false);\n  (0, import_react32.useEffect)(() => {\n    if (\"CodeMirror\" in window && textAreaReference.current !== null && !codeMirrorInitialized.current) {\n      const codeMirrorDefaultOptions = {\n        lineNumbers: $tw.wiki.getTiddlerText(\"$:/config/codemirror/lineNumbers\") === \"true\",\n        keyMap: $tw.wiki.getTiddlerText(\"$:/config/codemirror/keyMap\"),\n        lineWrapping: $tw.wiki.getTiddlerText(\"$:/config/codemirror/lineWrapping\") === \"true\",\n        theme: $tw.wiki.getTiddlerText(\"$:/config/codemirror/theme\"),\n        autofocus: false,\n        readOnly: false,\n        cursorBlinkRate: Number($tw.wiki.getTiddlerText(\"$:/config/codemirror/cursorBlinkRate\") ?? \"500\"),\n        indentUnit: Number($tw.wiki.getTiddlerText(\"$:/config/codemirror/indentUnit\") ?? \"2\"),\n        indentWithTabs: $tw.wiki.getTiddlerText(\"$:/config/codemirror/indentWithTabs\") === \"true\",\n        showCursorWhenSelecting: $tw.wiki.getTiddlerText(\"$:/config/codemirror/showCursorWhenSelecting\") === \"true\"\n      };\n      const codeMirror = window.CodeMirror.fromTextArea(textAreaReference.current, { ...codeMirrorDefaultOptions, ...options });\n      codeMirrorReference.current = codeMirror;\n      codeMirrorInitialized.current = true;\n    }\n  }, [textAreaReference, options]);\n  return codeMirrorReference;\n}\nfunction useCodeMirrorEventListenerSettled(onCodeChange, codeMirror) {\n  const hasCodeMirrorEventListenerSettled = (0, import_react32.useRef)(false);\n  (0, import_react32.useEffect)(() => {\n    if (codeMirror?.current !== null && !hasCodeMirrorEventListenerSettled.current) {\n      codeMirror.current.on(\"change\", (instance) => {\n        const latestText = instance.getDoc().getValue();\n        onCodeChange(latestText);\n      });\n      hasCodeMirrorEventListenerSettled.current = true;\n    }\n  }, [onCodeChange, codeMirror]);\n}\nfunction CodeBlockElement(props) {\n  const { attributes, nodeProps, element: element4, children, editor } = props;\n  const rootProps = getRootProps(props);\n  const textAreaReference = (0, import_react32.useRef)(null);\n  const { language, code: code3 } = element4;\n  const { showSyntaxSwitcher } = getPluginOptions(editor, ELEMENT_CODE_BLOCK);\n  const cmOptions = (0, import_react32.useMemo)(() => ({ mode: language && normalizeLanguage(language), value: code3 }), [language, code3]);\n  const codeMirror = useCodeMirror(textAreaReference, cmOptions);\n  const path = (0, import_react32.useMemo)(() => findNodePath(editor, element4), [editor, element4]);\n  const onLanguageChange = (0, import_react32.useCallback)(\n    (language2) => {\n      if (path !== void 0) {\n        setNodes(editor, { language: language2 }, { at: path });\n        codeMirror.current?.setOption(\"mode\", language2);\n      }\n    },\n    [editor, path, codeMirror]\n  );\n  const onCodeChange = useDebouncedCallback_default(\n    (eventOrString) => {\n      if (path !== void 0) {\n        setNodes(editor, { code: typeof eventOrString === \"string\" ? eventOrString : eventOrString.target.value }, { at: path });\n      }\n    },\n    [editor, path]\n  );\n  useCodeMirrorEventListenerSettled(onCodeChange, codeMirror);\n  return /* @__PURE__ */ import_react32.default.createElement(\"div\", { ...attributes, ...rootProps, ...nodeProps }, showSyntaxSwitcher === true && /* @__PURE__ */ import_react32.default.createElement(CodeBlockSelectElement, { \"data-testid\": \"CodeBlockSelectElement\", language, onChange: onLanguageChange }), /* @__PURE__ */ import_react32.default.createElement(CodeContainer, { style: { userSelect: \"none\" }, contentEditable: false, className: \"tw-codeblock-container\" }, /* @__PURE__ */ import_react32.default.createElement(CodeTextArea, { ref: textAreaReference, onChange: onCodeChange, defaultValue: code3, className: \"CodeMirror\" })), children);\n}\n\n// src/editor/plugins/dnd/createDndPlugin.ts\nvar KEY_DND = \"dnd\";\nvar createDndPlugin = createPluginFactory({\n  key: KEY_DND,\n  handlers: {\n    onDrop: (editor) => () => editor.isDragging\n  }\n});\n\n// src/editor/plugins/dnd/components/Draggable.tsx\nvar import_react37 = __toESM(require(\"react\"));\n\n// node_modules/@popperjs/core/lib/enums.js\nvar top = \"top\";\nvar bottom = \"bottom\";\nvar right = \"right\";\nvar left = \"left\";\nvar auto = \"auto\";\nvar basePlacements = [top, bottom, right, left];\nvar start = \"start\";\nvar end = \"end\";\nvar clippingParents = \"clippingParents\";\nvar viewport = \"viewport\";\nvar popper = \"popper\";\nvar reference = \"reference\";\nvar variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nvar placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nvar beforeRead = \"beforeRead\";\nvar read = \"read\";\nvar afterRead = \"afterRead\";\nvar beforeMain = \"beforeMain\";\nvar main = \"main\";\nvar afterMain = \"afterMain\";\nvar beforeWrite = \"beforeWrite\";\nvar write = \"write\";\nvar afterWrite = \"afterWrite\";\nvar modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n\n// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\nfunction getNodeName2(element4) {\n  return element4 ? (element4.nodeName || \"\").toLowerCase() : null;\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/getWindow.js\nfunction getWindow2(node) {\n  if (node == null) {\n    return window;\n  }\n  if (node.toString() !== \"[object Window]\") {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n  return node;\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\nfunction isElement4(node) {\n  var OwnElement = getWindow2(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\nfunction isHTMLElement2(node) {\n  var OwnElement = getWindow2(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\nfunction isShadowRoot2(node) {\n  if (typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n  var OwnElement = getWindow2(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\n// node_modules/@popperjs/core/lib/modifiers/applyStyles.js\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function(name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element4 = state.elements[name];\n    if (!isHTMLElement2(element4) || !getNodeName2(element4)) {\n      return;\n    }\n    Object.assign(element4.style, style);\n    Object.keys(attributes).forEach(function(name2) {\n      var value = attributes[name2];\n      if (value === false) {\n        element4.removeAttribute(name2);\n      } else {\n        element4.setAttribute(name2, value === true ? \"\" : value);\n      }\n    });\n  });\n}\nfunction effect(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: \"0\",\n      top: \"0\",\n      margin: \"0\"\n    },\n    arrow: {\n      position: \"absolute\"\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  state.styles = initialStyles;\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n  return function() {\n    Object.keys(state.elements).forEach(function(name) {\n      var element4 = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);\n      var style = styleProperties.reduce(function(style2, property2) {\n        style2[property2] = \"\";\n        return style2;\n      }, {});\n      if (!isHTMLElement2(element4) || !getNodeName2(element4)) {\n        return;\n      }\n      Object.assign(element4.style, style);\n      Object.keys(attributes).forEach(function(attribute) {\n        element4.removeAttribute(attribute);\n      });\n    });\n  };\n}\nvar applyStyles_default = {\n  name: \"applyStyles\",\n  enabled: true,\n  phase: \"write\",\n  fn: applyStyles,\n  effect,\n  requires: [\"computeStyles\"]\n};\n\n// node_modules/@popperjs/core/lib/utils/getBasePlacement.js\nfunction getBasePlacement(placement) {\n  return placement.split(\"-\")[0];\n}\n\n// node_modules/@popperjs/core/lib/utils/math.js\nvar max2 = Math.max;\nvar min2 = Math.min;\nvar round2 = Math.round;\n\n// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\nfunction getBoundingClientRect2(element4, includeScale) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  var rect = element4.getBoundingClientRect();\n  var scaleX = 1;\n  var scaleY = 1;\n  if (isHTMLElement2(element4) && includeScale) {\n    var offsetHeight = element4.offsetHeight;\n    var offsetWidth = element4.offsetWidth;\n    if (offsetWidth > 0) {\n      scaleX = round2(rect.width) / offsetWidth || 1;\n    }\n    if (offsetHeight > 0) {\n      scaleY = round2(rect.height) / offsetHeight || 1;\n    }\n  }\n  return {\n    width: rect.width / scaleX,\n    height: rect.height / scaleY,\n    top: rect.top / scaleY,\n    right: rect.right / scaleX,\n    bottom: rect.bottom / scaleY,\n    left: rect.left / scaleX,\n    x: rect.left / scaleX,\n    y: rect.top / scaleY\n  };\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\nfunction getLayoutRect(element4) {\n  var clientRect = getBoundingClientRect2(element4);\n  var width = element4.offsetWidth;\n  var height = element4.offsetHeight;\n  if (Math.abs(clientRect.width - width) <= 1) {\n    width = clientRect.width;\n  }\n  if (Math.abs(clientRect.height - height) <= 1) {\n    height = clientRect.height;\n  }\n  return {\n    x: element4.offsetLeft,\n    y: element4.offsetTop,\n    width,\n    height\n  };\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/contains.js\nfunction contains2(parent2, child) {\n  var rootNode = child.getRootNode && child.getRootNode();\n  if (parent2.contains(child)) {\n    return true;\n  } else if (rootNode && isShadowRoot2(rootNode)) {\n    var next = child;\n    do {\n      if (next && parent2.isSameNode(next)) {\n        return true;\n      }\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n  return false;\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\nfunction getComputedStyle2(element4) {\n  return getWindow2(element4).getComputedStyle(element4);\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js\nfunction isTableElement2(element4) {\n  return [\"table\", \"td\", \"th\"].indexOf(getNodeName2(element4)) >= 0;\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\nfunction getDocumentElement2(element4) {\n  return ((isElement4(element4) ? element4.ownerDocument : (\n    // $FlowFixMe[prop-missing]\n    element4.document\n  )) || window.document).documentElement;\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\nfunction getParentNode3(element4) {\n  if (getNodeName2(element4) === \"html\") {\n    return element4;\n  }\n  return (\n    // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element4.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element4.parentNode || // DOM Element detected\n    (isShadowRoot2(element4) ? element4.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement2(element4)\n  );\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\nfunction getTrueOffsetParent2(element4) {\n  if (!isHTMLElement2(element4) || // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle2(element4).position === \"fixed\") {\n    return null;\n  }\n  return element4.offsetParent;\n}\nfunction getContainingBlock2(element4) {\n  var isFirefox2 = navigator.userAgent.toLowerCase().indexOf(\"firefox\") !== -1;\n  var isIE = navigator.userAgent.indexOf(\"Trident\") !== -1;\n  if (isIE && isHTMLElement2(element4)) {\n    var elementCss = getComputedStyle2(element4);\n    if (elementCss.position === \"fixed\") {\n      return null;\n    }\n  }\n  var currentNode = getParentNode3(element4);\n  if (isShadowRoot2(currentNode)) {\n    currentNode = currentNode.host;\n  }\n  while (isHTMLElement2(currentNode) && [\"html\", \"body\"].indexOf(getNodeName2(currentNode)) < 0) {\n    var css13 = getComputedStyle2(currentNode);\n    if (css13.transform !== \"none\" || css13.perspective !== \"none\" || css13.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(css13.willChange) !== -1 || isFirefox2 && css13.willChange === \"filter\" || isFirefox2 && css13.filter && css13.filter !== \"none\") {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n  return null;\n}\nfunction getOffsetParent2(element4) {\n  var window2 = getWindow2(element4);\n  var offsetParent = getTrueOffsetParent2(element4);\n  while (offsetParent && isTableElement2(offsetParent) && getComputedStyle2(offsetParent).position === \"static\") {\n    offsetParent = getTrueOffsetParent2(offsetParent);\n  }\n  if (offsetParent && (getNodeName2(offsetParent) === \"html\" || getNodeName2(offsetParent) === \"body\" && getComputedStyle2(offsetParent).position === \"static\")) {\n    return window2;\n  }\n  return offsetParent || getContainingBlock2(element4) || window2;\n}\n\n// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\nfunction getMainAxisFromPlacement2(placement) {\n  return [\"top\", \"bottom\"].indexOf(placement) >= 0 ? \"x\" : \"y\";\n}\n\n// node_modules/@popperjs/core/lib/utils/within.js\nfunction within(min3, value, max3) {\n  return max2(min3, min2(value, max3));\n}\nfunction withinMaxClamp(min3, value, max3) {\n  var v4 = within(min3, value, max3);\n  return v4 > max3 ? max3 : v4;\n}\n\n// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\n\n// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, getFreshSideObject(), paddingObject);\n}\n\n// node_modules/@popperjs/core/lib/utils/expandToHashMap.js\nfunction expandToHashMap(value, keys4) {\n  return keys4.reduce(function(hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}\n\n// node_modules/@popperjs/core/lib/modifiers/arrow.js\nvar toPaddingObject = function toPaddingObject2(padding, state) {\n  padding = typeof padding === \"function\" ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding;\n  return mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n};\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n  var state = _ref.state, name = _ref.name, options = _ref.options;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets2 = state.modifiersData.popperOffsets;\n  var basePlacement = getBasePlacement(state.placement);\n  var axis = getMainAxisFromPlacement2(basePlacement);\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? \"height\" : \"width\";\n  if (!arrowElement || !popperOffsets2) {\n    return;\n  }\n  var paddingObject = toPaddingObject(options.padding, state);\n  var arrowRect = getLayoutRect(arrowElement);\n  var minProp = axis === \"y\" ? top : left;\n  var maxProp = axis === \"y\" ? bottom : right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = getOffsetParent2(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === \"y\" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2;\n  var min3 = paddingObject[minProp];\n  var max3 = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset3 = within(min3, center, max3);\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset3, _state$modifiersData$.centerOffset = offset3 - center, _state$modifiersData$);\n}\nfunction effect2(_ref2) {\n  var state = _ref2.state, options = _ref2.options;\n  var _options$element = options.element, arrowElement = _options$element === void 0 ? \"[data-popper-arrow]\" : _options$element;\n  if (arrowElement == null) {\n    return;\n  }\n  if (typeof arrowElement === \"string\") {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n    if (!arrowElement) {\n      return;\n    }\n  }\n  if (true) {\n    if (!isHTMLElement2(arrowElement)) {\n      console.error(['Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).', \"To use an SVG arrow, wrap it in an HTMLElement that will be used as\", \"the arrow.\"].join(\" \"));\n    }\n  }\n  if (!contains2(state.elements.popper, arrowElement)) {\n    if (true) {\n      console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', \"element.\"].join(\" \"));\n    }\n    return;\n  }\n  state.elements.arrow = arrowElement;\n}\nvar arrow_default = {\n  name: \"arrow\",\n  enabled: true,\n  phase: \"main\",\n  fn: arrow,\n  effect: effect2,\n  requires: [\"popperOffsets\"],\n  requiresIfExists: [\"preventOverflow\"]\n};\n\n// node_modules/@popperjs/core/lib/utils/getVariation.js\nfunction getVariation(placement) {\n  return placement.split(\"-\")[1];\n}\n\n// node_modules/@popperjs/core/lib/modifiers/computeStyles.js\nvar unsetSides = {\n  top: \"auto\",\n  right: \"auto\",\n  bottom: \"auto\",\n  left: \"auto\"\n};\nfunction roundOffsetsByDPR(_ref) {\n  var x4 = _ref.x, y5 = _ref.y;\n  var win = window;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: round2(x4 * dpr) / dpr || 0,\n    y: round2(y5 * dpr) / dpr || 0\n  };\n}\nfunction mapToStyles(_ref2) {\n  var _Object$assign2;\n  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;\n  var _offsets$x = offsets.x, x4 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y5 = _offsets$y === void 0 ? 0 : _offsets$y;\n  var _ref3 = typeof roundOffsets === \"function\" ? roundOffsets({\n    x: x4,\n    y: y5\n  }) : {\n    x: x4,\n    y: y5\n  };\n  x4 = _ref3.x;\n  y5 = _ref3.y;\n  var hasX = offsets.hasOwnProperty(\"x\");\n  var hasY = offsets.hasOwnProperty(\"y\");\n  var sideX = left;\n  var sideY = top;\n  var win = window;\n  if (adaptive) {\n    var offsetParent = getOffsetParent2(popper2);\n    var heightProp = \"clientHeight\";\n    var widthProp = \"clientWidth\";\n    if (offsetParent === getWindow2(popper2)) {\n      offsetParent = getDocumentElement2(popper2);\n      if (getComputedStyle2(offsetParent).position !== \"static\" && position === \"absolute\") {\n        heightProp = \"scrollHeight\";\n        widthProp = \"scrollWidth\";\n      }\n    }\n    offsetParent = offsetParent;\n    if (placement === top || (placement === left || placement === right) && variation === end) {\n      sideY = bottom;\n      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (\n        // $FlowFixMe[prop-missing]\n        offsetParent[heightProp]\n      );\n      y5 -= offsetY - popperRect.height;\n      y5 *= gpuAcceleration ? 1 : -1;\n    }\n    if (placement === left || (placement === top || placement === bottom) && variation === end) {\n      sideX = right;\n      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (\n        // $FlowFixMe[prop-missing]\n        offsetParent[widthProp]\n      );\n      x4 -= offsetX - popperRect.width;\n      x4 *= gpuAcceleration ? 1 : -1;\n    }\n  }\n  var commonStyles = Object.assign({\n    position\n  }, adaptive && unsetSides);\n  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n    x: x4,\n    y: y5\n  }) : {\n    x: x4,\n    y: y5\n  };\n  x4 = _ref4.x;\n  y5 = _ref4.y;\n  if (gpuAcceleration) {\n    var _Object$assign;\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? \"0\" : \"\", _Object$assign[sideX] = hasX ? \"0\" : \"\", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x4 + \"px, \" + y5 + \"px)\" : \"translate3d(\" + x4 + \"px, \" + y5 + \"px, 0)\", _Object$assign));\n  }\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y5 + \"px\" : \"\", _Object$assign2[sideX] = hasX ? x4 + \"px\" : \"\", _Object$assign2.transform = \"\", _Object$assign2));\n}\nfunction computeStyles(_ref5) {\n  var state = _ref5.state, options = _ref5.options;\n  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n  if (true) {\n    var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || \"\";\n    if (adaptive && [\"transform\", \"top\", \"right\", \"bottom\", \"left\"].some(function(property2) {\n      return transitionProperty.indexOf(property2) >= 0;\n    })) {\n      console.warn([\"Popper: Detected CSS transitions on at least one of the following\", 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', \"\\n\\n\", 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', \"for smooth transitions, or remove these properties from the CSS\", \"transition declaration on the popper element if only transitioning\", \"opacity or background-color for example.\", \"\\n\\n\", \"We recommend using the popper element as a wrapper around an inner\", \"element that can have any CSS property transitioned for animations.\"].join(\" \"));\n    }\n  }\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    variation: getVariation(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration,\n    isFixed: state.options.strategy === \"fixed\"\n  };\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive,\n      roundOffsets\n    })));\n  }\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: \"absolute\",\n      adaptive: false,\n      roundOffsets\n    })));\n  }\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    \"data-popper-placement\": state.placement\n  });\n}\nvar computeStyles_default = {\n  name: \"computeStyles\",\n  enabled: true,\n  phase: \"beforeWrite\",\n  fn: computeStyles,\n  data: {}\n};\n\n// node_modules/@popperjs/core/lib/modifiers/eventListeners.js\nvar passive = {\n  passive: true\n};\nfunction effect3(_ref) {\n  var state = _ref.state, instance = _ref.instance, options = _ref.options;\n  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;\n  var window2 = getWindow2(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n  if (scroll) {\n    scrollParents.forEach(function(scrollParent) {\n      scrollParent.addEventListener(\"scroll\", instance.update, passive);\n    });\n  }\n  if (resize) {\n    window2.addEventListener(\"resize\", instance.update, passive);\n  }\n  return function() {\n    if (scroll) {\n      scrollParents.forEach(function(scrollParent) {\n        scrollParent.removeEventListener(\"scroll\", instance.update, passive);\n      });\n    }\n    if (resize) {\n      window2.removeEventListener(\"resize\", instance.update, passive);\n    }\n  };\n}\nvar eventListeners_default = {\n  name: \"eventListeners\",\n  enabled: true,\n  phase: \"write\",\n  fn: function fn2() {\n  },\n  effect: effect3,\n  data: {}\n};\n\n// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js\nvar hash2 = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nfunction getOppositePlacement2(placement) {\n  return placement.replace(/left|right|bottom|top/g, function(matched) {\n    return hash2[matched];\n  });\n}\n\n// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js\nvar hash3 = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function(matched) {\n    return hash3[matched];\n  });\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\nfunction getWindowScroll(node) {\n  var win = getWindow2(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft,\n    scrollTop\n  };\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\nfunction getWindowScrollBarX2(element4) {\n  return getBoundingClientRect2(getDocumentElement2(element4)).left + getWindowScroll(element4).scrollLeft;\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js\nfunction getViewportRect2(element4) {\n  var win = getWindow2(element4);\n  var html = getDocumentElement2(element4);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x4 = 0;\n  var y5 = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n      x4 = visualViewport.offsetLeft;\n      y5 = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x: x4 + getWindowScrollBarX2(element4),\n    y: y5\n  };\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js\nfunction getDocumentRect2(element4) {\n  var _element$ownerDocumen;\n  var html = getDocumentElement2(element4);\n  var winScroll = getWindowScroll(element4);\n  var body = (_element$ownerDocumen = element4.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x4 = -winScroll.scrollLeft + getWindowScrollBarX2(element4);\n  var y5 = -winScroll.scrollTop;\n  if (getComputedStyle2(body || html).direction === \"rtl\") {\n    x4 += max2(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n  return {\n    width,\n    height,\n    x: x4,\n    y: y5\n  };\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\nfunction isScrollParent(element4) {\n  var _getComputedStyle = getComputedStyle2(element4), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js\nfunction getScrollParent(node) {\n  if ([\"html\", \"body\", \"#document\"].indexOf(getNodeName2(node)) >= 0) {\n    return node.ownerDocument.body;\n  }\n  if (isHTMLElement2(node) && isScrollParent(node)) {\n    return node;\n  }\n  return getScrollParent(getParentNode3(node));\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js\nfunction listScrollParents(element4, list) {\n  var _element$ownerDocumen;\n  if (list === void 0) {\n    list = [];\n  }\n  var scrollParent = getScrollParent(element4);\n  var isBody = scrollParent === ((_element$ownerDocumen = element4.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n  var win = getWindow2(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : (\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    updatedList.concat(listScrollParents(getParentNode3(target)))\n  );\n}\n\n// node_modules/@popperjs/core/lib/utils/rectToClientRect.js\nfunction rectToClientRect2(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js\nfunction getInnerBoundingClientRect2(element4) {\n  var rect = getBoundingClientRect2(element4);\n  rect.top = rect.top + element4.clientTop;\n  rect.left = rect.left + element4.clientLeft;\n  rect.bottom = rect.top + element4.clientHeight;\n  rect.right = rect.left + element4.clientWidth;\n  rect.width = element4.clientWidth;\n  rect.height = element4.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\nfunction getClientRectFromMixedType(element4, clippingParent) {\n  return clippingParent === viewport ? rectToClientRect2(getViewportRect2(element4)) : isElement4(clippingParent) ? getInnerBoundingClientRect2(clippingParent) : rectToClientRect2(getDocumentRect2(getDocumentElement2(element4)));\n}\nfunction getClippingParents(element4) {\n  var clippingParents2 = listScrollParents(getParentNode3(element4));\n  var canEscapeClipping = [\"absolute\", \"fixed\"].indexOf(getComputedStyle2(element4).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement2(element4) ? getOffsetParent2(element4) : element4;\n  if (!isElement4(clipperElement)) {\n    return [];\n  }\n  return clippingParents2.filter(function(clippingParent) {\n    return isElement4(clippingParent) && contains2(clippingParent, clipperElement) && getNodeName2(clippingParent) !== \"body\";\n  });\n}\nfunction getClippingRect2(element4, boundary, rootBoundary) {\n  var mainClippingParents = boundary === \"clippingParents\" ? getClippingParents(element4) : [].concat(boundary);\n  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents2[0];\n  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element4, clippingParent);\n    accRect.top = max2(rect.top, accRect.top);\n    accRect.right = min2(rect.right, accRect.right);\n    accRect.bottom = min2(rect.bottom, accRect.bottom);\n    accRect.left = max2(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element4, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\n\n// node_modules/@popperjs/core/lib/utils/computeOffsets.js\nfunction computeOffsets(_ref) {\n  var reference2 = _ref.reference, element4 = _ref.element, placement = _ref.placement;\n  var basePlacement = placement ? getBasePlacement(placement) : null;\n  var variation = placement ? getVariation(placement) : null;\n  var commonX = reference2.x + reference2.width / 2 - element4.width / 2;\n  var commonY = reference2.y + reference2.height / 2 - element4.height / 2;\n  var offsets;\n  switch (basePlacement) {\n    case top:\n      offsets = {\n        x: commonX,\n        y: reference2.y - element4.height\n      };\n      break;\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference2.y + reference2.height\n      };\n      break;\n    case right:\n      offsets = {\n        x: reference2.x + reference2.width,\n        y: commonY\n      };\n      break;\n    case left:\n      offsets = {\n        x: reference2.x - element4.width,\n        y: commonY\n      };\n      break;\n    default:\n      offsets = {\n        x: reference2.x,\n        y: reference2.y\n      };\n  }\n  var mainAxis = basePlacement ? getMainAxisFromPlacement2(basePlacement) : null;\n  if (mainAxis != null) {\n    var len = mainAxis === \"y\" ? \"height\" : \"width\";\n    switch (variation) {\n      case start:\n        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element4[len] / 2);\n        break;\n      case end:\n        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element4[len] / 2);\n        break;\n      default:\n    }\n  }\n  return offsets;\n}\n\n// node_modules/@popperjs/core/lib/utils/detectOverflow.js\nfunction detectOverflow2(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var popperRect = state.rects.popper;\n  var element4 = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect2(isElement4(element4) ? element4 : element4.contextElement || getDocumentElement2(state.elements.popper), boundary, rootBoundary);\n  var referenceClientRect = getBoundingClientRect2(state.elements.reference);\n  var popperOffsets2 = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: \"absolute\",\n    placement\n  });\n  var popperClientRect = rectToClientRect2(Object.assign({}, popperRect, popperOffsets2));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset;\n  if (elementContext === popper && offsetData) {\n    var offset3 = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function(key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [top, bottom].indexOf(key) >= 0 ? \"y\" : \"x\";\n      overflowOffsets[key] += offset3[axis] * multiply;\n    });\n  }\n  return overflowOffsets;\n}\n\n// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {\n    return getVariation(placement2) === variation;\n  }) : basePlacements;\n  var allowedPlacements = placements2.filter(function(placement2) {\n    return allowedAutoPlacements.indexOf(placement2) >= 0;\n  });\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements2;\n    if (true) {\n      console.error([\"Popper: The `allowedAutoPlacements` option did not allow any\", \"placements. Ensure the `placement` option matches the variation\", \"of the allowed placements.\", 'For example, \"auto\" cannot be used to allow \"bottom-start\".', 'Use \"auto-start\" instead.'].join(\" \"));\n    }\n  }\n  var overflows = allowedPlacements.reduce(function(acc, placement2) {\n    acc[placement2] = detectOverflow2(state, {\n      placement: placement2,\n      boundary,\n      rootBoundary,\n      padding\n    })[getBasePlacement(placement2)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function(a7, b4) {\n    return overflows[a7] - overflows[b4];\n  });\n}\n\n// node_modules/@popperjs/core/lib/modifiers/flip.js\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n  var oppositePlacement = getOppositePlacement2(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\nfunction flip2(_ref) {\n  var state = _ref.state, options = _ref.options, name = _ref.name;\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement2(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {\n    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {\n      placement: placement2,\n      boundary,\n      rootBoundary,\n      padding,\n      flipVariations,\n      allowedAutoPlacements\n    }) : placement2);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = /* @__PURE__ */ new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements2[0];\n  for (var i5 = 0; i5 < placements2.length; i5++) {\n    var placement = placements2[i5];\n    var _basePlacement = getBasePlacement(placement);\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? \"width\" : \"height\";\n    var overflow = detectOverflow2(state, {\n      placement,\n      boundary,\n      rootBoundary,\n      altBoundary,\n      padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement2(mainVariationSide);\n    }\n    var altVariationSide = getOppositePlacement2(mainVariationSide);\n    var checks = [];\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n    if (checks.every(function(check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n    checksMap.set(placement, checks);\n  }\n  if (makeFallbackChecks) {\n    var numberOfChecks = flipVariations ? 3 : 1;\n    var _loop = function _loop2(_i2) {\n      var fittingPlacement = placements2.find(function(placement2) {\n        var checks2 = checksMap.get(placement2);\n        if (checks2) {\n          return checks2.slice(0, _i2).every(function(check) {\n            return check;\n          });\n        }\n      });\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n      if (_ret === \"break\")\n        break;\n    }\n  }\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n}\nvar flip_default = {\n  name: \"flip\",\n  enabled: true,\n  phase: \"main\",\n  fn: flip2,\n  requiresIfExists: [\"offset\"],\n  data: {\n    _skip: false\n  }\n};\n\n// node_modules/@popperjs/core/lib/modifiers/hide.js\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return [top, right, bottom, left].some(function(side) {\n    return overflow[side] >= 0;\n  });\n}\nfunction hide(_ref) {\n  var state = _ref.state, name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = detectOverflow2(state, {\n    elementContext: \"reference\"\n  });\n  var popperAltOverflow = detectOverflow2(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets,\n    popperEscapeOffsets,\n    isReferenceHidden,\n    hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    \"data-popper-reference-hidden\": isReferenceHidden,\n    \"data-popper-escaped\": hasPopperEscaped\n  });\n}\nvar hide_default = {\n  name: \"hide\",\n  enabled: true,\n  phase: \"main\",\n  requiresIfExists: [\"preventOverflow\"],\n  fn: hide\n};\n\n// node_modules/@popperjs/core/lib/modifiers/offset.js\nfunction distanceAndSkiddingToXY(placement, rects, offset3) {\n  var basePlacement = getBasePlacement(placement);\n  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n  var _ref = typeof offset3 === \"function\" ? offset3(Object.assign({}, rects, {\n    placement\n  })) : offset3, skidding = _ref[0], distance = _ref[1];\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\nfunction offset2(_ref2) {\n  var state = _ref2.state, options = _ref2.options, name = _ref2.name;\n  var _options$offset = options.offset, offset3 = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = placements.reduce(function(acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset3);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement], x4 = _data$state$placement.x, y5 = _data$state$placement.y;\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x4;\n    state.modifiersData.popperOffsets.y += y5;\n  }\n  state.modifiersData[name] = data;\n}\nvar offset_default = {\n  name: \"offset\",\n  enabled: true,\n  phase: \"main\",\n  requires: [\"popperOffsets\"],\n  fn: offset2\n};\n\n// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\nfunction popperOffsets(_ref) {\n  var state = _ref.state, name = _ref.name;\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: \"absolute\",\n    placement: state.placement\n  });\n}\nvar popperOffsets_default = {\n  name: \"popperOffsets\",\n  enabled: true,\n  phase: \"read\",\n  fn: popperOffsets,\n  data: {}\n};\n\n// node_modules/@popperjs/core/lib/utils/getAltAxis.js\nfunction getAltAxis(axis) {\n  return axis === \"x\" ? \"y\" : \"x\";\n}\n\n// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js\nfunction preventOverflow(_ref) {\n  var state = _ref.state, options = _ref.options, name = _ref.name;\n  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow2(state, {\n    boundary,\n    rootBoundary,\n    padding,\n    altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement2(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets2 = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === \"function\" ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === \"number\" ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n  if (!popperOffsets2) {\n    return;\n  }\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n    var mainSide = mainAxis === \"y\" ? top : left;\n    var altSide = mainAxis === \"y\" ? bottom : right;\n    var len = mainAxis === \"y\" ? \"height\" : \"width\";\n    var offset3 = popperOffsets2[mainAxis];\n    var min3 = offset3 + overflow[mainSide];\n    var max3 = offset3 - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData[\"arrow#persistent\"] ? state.modifiersData[\"arrow#persistent\"].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide];\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent2(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === \"y\" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset3 + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset3 + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? min2(min3, tetherMin) : min3, offset3, tether ? max2(max3, tetherMax) : max3);\n    popperOffsets2[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset3;\n  }\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n    var _mainSide = mainAxis === \"x\" ? top : left;\n    var _altSide = mainAxis === \"x\" ? bottom : right;\n    var _offset = popperOffsets2[altAxis];\n    var _len = altAxis === \"y\" ? \"height\" : \"width\";\n    var _min = _offset + overflow[_mainSide];\n    var _max = _offset - overflow[_altSide];\n    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n    popperOffsets2[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n  state.modifiersData[name] = data;\n}\nvar preventOverflow_default = {\n  name: \"preventOverflow\",\n  enabled: true,\n  phase: \"main\",\n  fn: preventOverflow,\n  requiresIfExists: [\"offset\"]\n};\n\n// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js\nfunction getHTMLElementScroll(element4) {\n  return {\n    scrollLeft: element4.scrollLeft,\n    scrollTop: element4.scrollTop\n  };\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js\nfunction getNodeScroll2(node) {\n  if (node === getWindow2(node) || !isHTMLElement2(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\n\n// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js\nfunction isElementScaled(element4) {\n  var rect = element4.getBoundingClientRect();\n  var scaleX = round2(rect.width) / element4.offsetWidth || 1;\n  var scaleY = round2(rect.height) / element4.offsetHeight || 1;\n  return scaleX !== 1 || scaleY !== 1;\n}\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  var isOffsetParentAnElement = isHTMLElement2(offsetParent);\n  var offsetParentIsScaled = isHTMLElement2(offsetParent) && isElementScaled(offsetParent);\n  var documentElement = getDocumentElement2(offsetParent);\n  var rect = getBoundingClientRect2(elementOrVirtualElement, offsetParentIsScaled);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName2(offsetParent) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n    isScrollParent(documentElement)) {\n      scroll = getNodeScroll2(offsetParent);\n    }\n    if (isHTMLElement2(offsetParent)) {\n      offsets = getBoundingClientRect2(offsetParent, true);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX2(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\n// node_modules/@popperjs/core/lib/utils/orderModifiers.js\nfunction order(modifiers) {\n  var map2 = /* @__PURE__ */ new Map();\n  var visited = /* @__PURE__ */ new Set();\n  var result = [];\n  modifiers.forEach(function(modifier) {\n    map2.set(modifier.name, modifier);\n  });\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function(dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map2.get(dep);\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n  modifiers.forEach(function(modifier) {\n    if (!visited.has(modifier.name)) {\n      sort(modifier);\n    }\n  });\n  return result;\n}\nfunction orderModifiers(modifiers) {\n  var orderedModifiers = order(modifiers);\n  return modifierPhases.reduce(function(acc, phase) {\n    return acc.concat(orderedModifiers.filter(function(modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}\n\n// node_modules/@popperjs/core/lib/utils/debounce.js\nfunction debounce3(fn4) {\n  var pending;\n  return function() {\n    if (!pending) {\n      pending = new Promise(function(resolve) {\n        Promise.resolve().then(function() {\n          pending = void 0;\n          resolve(fn4());\n        });\n      });\n    }\n    return pending;\n  };\n}\n\n// node_modules/@popperjs/core/lib/utils/format.js\nfunction format2(str) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  return [].concat(args).reduce(function(p6, c5) {\n    return p6.replace(/%s/, c5);\n  }, str);\n}\n\n// node_modules/@popperjs/core/lib/utils/validateModifiers.js\nvar INVALID_MODIFIER_ERROR = 'Popper: modifier \"%s\" provided an invalid %s property, expected %s but got %s';\nvar MISSING_DEPENDENCY_ERROR = 'Popper: modifier \"%s\" requires \"%s\", but \"%s\" modifier is not available';\nvar VALID_PROPERTIES = [\"name\", \"enabled\", \"phase\", \"fn\", \"effect\", \"requires\", \"options\"];\nfunction validateModifiers(modifiers) {\n  modifiers.forEach(function(modifier) {\n    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index5, self2) {\n      return self2.indexOf(value) === index5;\n    }).forEach(function(key) {\n      switch (key) {\n        case \"name\":\n          if (typeof modifier.name !== \"string\") {\n            console.error(format2(INVALID_MODIFIER_ERROR, String(modifier.name), '\"name\"', '\"string\"', '\"' + String(modifier.name) + '\"'));\n          }\n          break;\n        case \"enabled\":\n          if (typeof modifier.enabled !== \"boolean\") {\n            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '\"enabled\"', '\"boolean\"', '\"' + String(modifier.enabled) + '\"'));\n          }\n          break;\n        case \"phase\":\n          if (modifierPhases.indexOf(modifier.phase) < 0) {\n            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '\"phase\"', \"either \" + modifierPhases.join(\", \"), '\"' + String(modifier.phase) + '\"'));\n          }\n          break;\n        case \"fn\":\n          if (typeof modifier.fn !== \"function\") {\n            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '\"fn\"', '\"function\"', '\"' + String(modifier.fn) + '\"'));\n          }\n          break;\n        case \"effect\":\n          if (modifier.effect != null && typeof modifier.effect !== \"function\") {\n            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '\"effect\"', '\"function\"', '\"' + String(modifier.fn) + '\"'));\n          }\n          break;\n        case \"requires\":\n          if (modifier.requires != null && !Array.isArray(modifier.requires)) {\n            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '\"requires\"', '\"array\"', '\"' + String(modifier.requires) + '\"'));\n          }\n          break;\n        case \"requiresIfExists\":\n          if (!Array.isArray(modifier.requiresIfExists)) {\n            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '\"requiresIfExists\"', '\"array\"', '\"' + String(modifier.requiresIfExists) + '\"'));\n          }\n          break;\n        case \"options\":\n        case \"data\":\n          break;\n        default:\n          console.error('PopperJS: an invalid property has been provided to the \"' + modifier.name + '\" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s5) {\n            return '\"' + s5 + '\"';\n          }).join(\", \") + '; but \"' + key + '\" was provided.');\n      }\n      modifier.requires && modifier.requires.forEach(function(requirement) {\n        if (modifiers.find(function(mod) {\n          return mod.name === requirement;\n        }) == null) {\n          console.error(format2(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));\n        }\n      });\n    });\n  });\n}\n\n// node_modules/@popperjs/core/lib/utils/uniqueBy.js\nfunction uniqueBy(arr, fn4) {\n  var identifiers = /* @__PURE__ */ new Set();\n  return arr.filter(function(item) {\n    var identifier = fn4(item);\n    if (!identifiers.has(identifier)) {\n      identifiers.add(identifier);\n      return true;\n    }\n  });\n}\n\n// node_modules/@popperjs/core/lib/utils/mergeByName.js\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function(merged2, current) {\n    var existing = merged2[current.name];\n    merged2[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current;\n    return merged2;\n  }, {});\n  return Object.keys(merged).map(function(key) {\n    return merged[key];\n  });\n}\n\n// node_modules/@popperjs/core/lib/createPopper.js\nvar INVALID_ELEMENT_ERROR = \"Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.\";\nvar INFINITE_LOOP_ERROR = \"Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.\";\nvar DEFAULT_OPTIONS = {\n  placement: \"bottom\",\n  modifiers: [],\n  strategy: \"absolute\"\n};\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return !args.some(function(element4) {\n    return !(element4 && typeof element4.getBoundingClientRect === \"function\");\n  });\n}\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper2(reference2, popper2, options) {\n    if (options === void 0) {\n      options = defaultOptions2;\n    }\n    var state = {\n      placement: \"bottom\",\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),\n      modifiersData: {},\n      elements: {\n        reference: reference2,\n        popper: popper2\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options2 = typeof setOptionsAction === \"function\" ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions2, state.options, options2);\n        state.scrollParents = {\n          reference: isElement4(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],\n          popper: listScrollParents(popper2)\n        };\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));\n        state.orderedModifiers = orderedModifiers.filter(function(m4) {\n          return m4.enabled;\n        });\n        if (true) {\n          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {\n            var name = _ref.name;\n            return name;\n          });\n          validateModifiers(modifiers);\n          if (getBasePlacement(state.options.placement) === auto) {\n            var flipModifier = state.orderedModifiers.find(function(_ref2) {\n              var name = _ref2.name;\n              return name === \"flip\";\n            });\n            if (!flipModifier) {\n              console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', \"present and enabled to work.\"].join(\" \"));\n            }\n          }\n          var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {\n            return parseFloat(margin);\n          })) {\n            console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', \"between the popper and its reference element or boundary.\", \"To replicate margin, use the `offset` modifier, as well as\", \"the `padding` option in the `preventOverflow` and `flip`\", \"modifiers.\"].join(\" \"));\n          }\n        }\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;\n        if (!areValidElements(reference3, popper3)) {\n          if (true) {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n          return;\n        }\n        state.rects = {\n          reference: getCompositeRect(reference3, getOffsetParent2(popper3), state.options.strategy === \"fixed\"),\n          popper: getLayoutRect(popper3)\n        };\n        state.reset = false;\n        state.placement = state.options.placement;\n        state.orderedModifiers.forEach(function(modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n        for (var index5 = 0; index5 < state.orderedModifiers.length; index5++) {\n          if (true) {\n            __debug_loops__ += 1;\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n          if (state.reset === true) {\n            state.reset = false;\n            index5 = -1;\n            continue;\n          }\n          var _state$orderedModifie = state.orderedModifiers[index5], fn4 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;\n          if (typeof fn4 === \"function\") {\n            state = fn4({\n              state,\n              options: _options,\n              name,\n              instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce3(function() {\n        return new Promise(function(resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n    if (!areValidElements(reference2, popper2)) {\n      if (true) {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n      return instance;\n    }\n    instance.setOptions(options).then(function(state2) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state2);\n      }\n    });\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function(_ref3) {\n        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect5 = _ref3.effect;\n        if (typeof effect5 === \"function\") {\n          var cleanupFn = effect5({\n            state,\n            name,\n            instance,\n            options: options2\n          });\n          var noopFn = function noopFn2() {\n          };\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function(fn4) {\n        return fn4();\n      });\n      effectCleanupFns = [];\n    }\n    return instance;\n  };\n}\n\n// node_modules/@popperjs/core/lib/popper.js\nvar defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];\nvar createPopper = /* @__PURE__ */ popperGenerator({\n  defaultModifiers\n});\n\n// node_modules/tippy.js/dist/tippy.esm.js\nvar BOX_CLASS = \"tippy-box\";\nvar CONTENT_CLASS = \"tippy-content\";\nvar BACKDROP_CLASS = \"tippy-backdrop\";\nvar ARROW_CLASS = \"tippy-arrow\";\nvar SVG_ARROW_CLASS = \"tippy-svg-arrow\";\nvar TOUCH_OPTIONS = {\n  passive: true,\n  capture: true\n};\nvar TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {\n  return document.body;\n};\nfunction hasOwnProperty5(obj, key) {\n  return {}.hasOwnProperty.call(obj, key);\n}\nfunction getValueAtIndexOrReturn(value, index5, defaultValue) {\n  if (Array.isArray(value)) {\n    var v4 = value[index5];\n    return v4 == null ? Array.isArray(defaultValue) ? defaultValue[index5] : defaultValue : v4;\n  }\n  return value;\n}\nfunction isType2(value, type) {\n  var str = {}.toString.call(value);\n  return str.indexOf(\"[object\") === 0 && str.indexOf(type + \"]\") > -1;\n}\nfunction invokeWithArgsOrReturn(value, args) {\n  return typeof value === \"function\" ? value.apply(void 0, args) : value;\n}\nfunction debounce4(fn4, ms) {\n  if (ms === 0) {\n    return fn4;\n  }\n  var timeout;\n  return function(arg) {\n    clearTimeout(timeout);\n    timeout = setTimeout(function() {\n      fn4(arg);\n    }, ms);\n  };\n}\nfunction removeProperties(obj, keys4) {\n  var clone = Object.assign({}, obj);\n  keys4.forEach(function(key) {\n    delete clone[key];\n  });\n  return clone;\n}\nfunction splitBySpaces(value) {\n  return value.split(/\\s+/).filter(Boolean);\n}\nfunction normalizeToArray(value) {\n  return [].concat(value);\n}\nfunction pushIfUnique(arr, value) {\n  if (arr.indexOf(value) === -1) {\n    arr.push(value);\n  }\n}\nfunction unique(arr) {\n  return arr.filter(function(item, index5) {\n    return arr.indexOf(item) === index5;\n  });\n}\nfunction getBasePlacement2(placement) {\n  return placement.split(\"-\")[0];\n}\nfunction arrayFrom(value) {\n  return [].slice.call(value);\n}\nfunction removeUndefinedProps(obj) {\n  return Object.keys(obj).reduce(function(acc, key) {\n    if (obj[key] !== void 0) {\n      acc[key] = obj[key];\n    }\n    return acc;\n  }, {});\n}\nfunction div2() {\n  return document.createElement(\"div\");\n}\nfunction isElement5(value) {\n  return [\"Element\", \"Fragment\"].some(function(type) {\n    return isType2(value, type);\n  });\n}\nfunction isNodeList(value) {\n  return isType2(value, \"NodeList\");\n}\nfunction isMouseEvent(value) {\n  return isType2(value, \"MouseEvent\");\n}\nfunction isReferenceElement(value) {\n  return !!(value && value._tippy && value._tippy.reference === value);\n}\nfunction getArrayOfElements(value) {\n  if (isElement5(value)) {\n    return [value];\n  }\n  if (isNodeList(value)) {\n    return arrayFrom(value);\n  }\n  if (Array.isArray(value)) {\n    return value;\n  }\n  return arrayFrom(document.querySelectorAll(value));\n}\nfunction setTransitionDuration(els, value) {\n  els.forEach(function(el) {\n    if (el) {\n      el.style.transitionDuration = value + \"ms\";\n    }\n  });\n}\nfunction setVisibilityState(els, state) {\n  els.forEach(function(el) {\n    if (el) {\n      el.setAttribute(\"data-state\", state);\n    }\n  });\n}\nfunction getOwnerDocument(elementOrElements) {\n  var _element$ownerDocumen;\n  var _normalizeToArray = normalizeToArray(elementOrElements), element4 = _normalizeToArray[0];\n  return element4 != null && (_element$ownerDocumen = element4.ownerDocument) != null && _element$ownerDocumen.body ? element4.ownerDocument : document;\n}\nfunction isCursorOutsideInteractiveBorder(popperTreeData, event) {\n  var clientX = event.clientX, clientY = event.clientY;\n  return popperTreeData.every(function(_ref) {\n    var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;\n    var interactiveBorder = props.interactiveBorder;\n    var basePlacement = getBasePlacement2(popperState.placement);\n    var offsetData = popperState.modifiersData.offset;\n    if (!offsetData) {\n      return true;\n    }\n    var topDistance = basePlacement === \"bottom\" ? offsetData.top.y : 0;\n    var bottomDistance = basePlacement === \"top\" ? offsetData.bottom.y : 0;\n    var leftDistance = basePlacement === \"right\" ? offsetData.left.x : 0;\n    var rightDistance = basePlacement === \"left\" ? offsetData.right.x : 0;\n    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;\n    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;\n    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;\n    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;\n    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;\n  });\n}\nfunction updateTransitionEndListener(box, action, listener) {\n  var method = action + \"EventListener\";\n  [\"transitionend\", \"webkitTransitionEnd\"].forEach(function(event) {\n    box[method](event, listener);\n  });\n}\nfunction actualContains(parent2, child) {\n  var target = child;\n  while (target) {\n    var _target$getRootNode;\n    if (parent2.contains(target)) {\n      return true;\n    }\n    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;\n  }\n  return false;\n}\nvar currentInput = {\n  isTouch: false\n};\nvar lastMouseMoveTime = 0;\nfunction onDocumentTouchStart() {\n  if (currentInput.isTouch) {\n    return;\n  }\n  currentInput.isTouch = true;\n  if (window.performance) {\n    document.addEventListener(\"mousemove\", onDocumentMouseMove);\n  }\n}\nfunction onDocumentMouseMove() {\n  var now = performance.now();\n  if (now - lastMouseMoveTime < 20) {\n    currentInput.isTouch = false;\n    document.removeEventListener(\"mousemove\", onDocumentMouseMove);\n  }\n  lastMouseMoveTime = now;\n}\nfunction onWindowBlur() {\n  var activeElement = document.activeElement;\n  if (isReferenceElement(activeElement)) {\n    var instance = activeElement._tippy;\n    if (activeElement.blur && !instance.state.isVisible) {\n      activeElement.blur();\n    }\n  }\n}\nfunction bindGlobalEventListeners() {\n  document.addEventListener(\"touchstart\", onDocumentTouchStart, TOUCH_OPTIONS);\n  window.addEventListener(\"blur\", onWindowBlur);\n}\nvar isBrowser = typeof window !== \"undefined\" && typeof document !== \"undefined\";\nvar isIE11 = isBrowser ? (\n  // @ts-ignore\n  !!window.msCrypto\n) : false;\nfunction createMemoryLeakWarning(method) {\n  var txt = method === \"destroy\" ? \"n already-\" : \" \";\n  return [method + \"() was called on a\" + txt + \"destroyed instance. This is a no-op but\", \"indicates a potential memory leak.\"].join(\" \");\n}\nfunction clean(value) {\n  var spacesAndTabs = /[ \\t]{2,}/g;\n  var lineStartWithSpaces = /^[ \\t]*/gm;\n  return value.replace(spacesAndTabs, \" \").replace(lineStartWithSpaces, \"\").trim();\n}\nfunction getDevMessage(message) {\n  return clean(\"\\n  %ctippy.js\\n\\n  %c\" + clean(message) + \"\\n\\n  %c\\u{1F477}\\u200D This is a development-only message. It will be removed in production.\\n  \");\n}\nfunction getFormattedMessage(message) {\n  return [\n    getDevMessage(message),\n    // title\n    \"color: #00C584; font-size: 1.3em; font-weight: bold;\",\n    // message\n    \"line-height: 1.5\",\n    // footer\n    \"color: #a6a095;\"\n  ];\n}\nvar visitedMessages;\nif (true) {\n  resetVisitedMessages();\n}\nfunction resetVisitedMessages() {\n  visitedMessages = /* @__PURE__ */ new Set();\n}\nfunction warnWhen(condition, message) {\n  if (condition && !visitedMessages.has(message)) {\n    var _console;\n    visitedMessages.add(message);\n    (_console = console).warn.apply(_console, getFormattedMessage(message));\n  }\n}\nfunction errorWhen(condition, message) {\n  if (condition && !visitedMessages.has(message)) {\n    var _console2;\n    visitedMessages.add(message);\n    (_console2 = console).error.apply(_console2, getFormattedMessage(message));\n  }\n}\nfunction validateTargets(targets) {\n  var didPassFalsyValue = !targets;\n  var didPassPlainObject = Object.prototype.toString.call(targets) === \"[object Object]\" && !targets.addEventListener;\n  errorWhen(didPassFalsyValue, [\"tippy() was passed\", \"`\" + String(targets) + \"`\", \"as its targets (first) argument. Valid types are: String, Element,\", \"Element[], or NodeList.\"].join(\" \"));\n  errorWhen(didPassPlainObject, [\"tippy() was passed a plain object which is not supported as an argument\", \"for virtual positioning. Use props.getReferenceClientRect instead.\"].join(\" \"));\n}\nvar pluginProps = {\n  animateFill: false,\n  followCursor: false,\n  inlinePositioning: false,\n  sticky: false\n};\nvar renderProps = {\n  allowHTML: false,\n  animation: \"fade\",\n  arrow: true,\n  content: \"\",\n  inertia: false,\n  maxWidth: 350,\n  role: \"tooltip\",\n  theme: \"\",\n  zIndex: 9999\n};\nvar defaultProps = Object.assign({\n  appendTo: TIPPY_DEFAULT_APPEND_TO,\n  aria: {\n    content: \"auto\",\n    expanded: \"auto\"\n  },\n  delay: 0,\n  duration: [300, 250],\n  getReferenceClientRect: null,\n  hideOnClick: true,\n  ignoreAttributes: false,\n  interactive: false,\n  interactiveBorder: 2,\n  interactiveDebounce: 0,\n  moveTransition: \"\",\n  offset: [0, 10],\n  onAfterUpdate: function onAfterUpdate() {\n  },\n  onBeforeUpdate: function onBeforeUpdate() {\n  },\n  onCreate: function onCreate() {\n  },\n  onDestroy: function onDestroy() {\n  },\n  onHidden: function onHidden() {\n  },\n  onHide: function onHide() {\n  },\n  onMount: function onMount() {\n  },\n  onShow: function onShow() {\n  },\n  onShown: function onShown() {\n  },\n  onTrigger: function onTrigger() {\n  },\n  onUntrigger: function onUntrigger() {\n  },\n  onClickOutside: function onClickOutside() {\n  },\n  placement: \"top\",\n  plugins: [],\n  popperOptions: {},\n  render: null,\n  showOnCreate: false,\n  touch: true,\n  trigger: \"mouseenter focus\",\n  triggerTarget: null\n}, pluginProps, renderProps);\nvar defaultKeys = Object.keys(defaultProps);\nvar setDefaultProps = function setDefaultProps2(partialProps) {\n  if (true) {\n    validateProps(partialProps, []);\n  }\n  var keys4 = Object.keys(partialProps);\n  keys4.forEach(function(key) {\n    defaultProps[key] = partialProps[key];\n  });\n};\nfunction getExtendedPassedProps(passedProps) {\n  var plugins = passedProps.plugins || [];\n  var pluginProps2 = plugins.reduce(function(acc, plugin) {\n    var name = plugin.name, defaultValue = plugin.defaultValue;\n    if (name) {\n      var _name;\n      acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;\n    }\n    return acc;\n  }, {});\n  return Object.assign({}, passedProps, pluginProps2);\n}\nfunction getDataAttributeProps(reference2, plugins) {\n  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {\n    plugins\n  }))) : defaultKeys;\n  var props = propKeys.reduce(function(acc, key) {\n    var valueAsString = (reference2.getAttribute(\"data-tippy-\" + key) || \"\").trim();\n    if (!valueAsString) {\n      return acc;\n    }\n    if (key === \"content\") {\n      acc[key] = valueAsString;\n    } else {\n      try {\n        acc[key] = JSON.parse(valueAsString);\n      } catch (e4) {\n        acc[key] = valueAsString;\n      }\n    }\n    return acc;\n  }, {});\n  return props;\n}\nfunction evaluateProps(reference2, props) {\n  var out = Object.assign({}, props, {\n    content: invokeWithArgsOrReturn(props.content, [reference2])\n  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));\n  out.aria = Object.assign({}, defaultProps.aria, out.aria);\n  out.aria = {\n    expanded: out.aria.expanded === \"auto\" ? props.interactive : out.aria.expanded,\n    content: out.aria.content === \"auto\" ? props.interactive ? null : \"describedby\" : out.aria.content\n  };\n  return out;\n}\nfunction validateProps(partialProps, plugins) {\n  if (partialProps === void 0) {\n    partialProps = {};\n  }\n  if (plugins === void 0) {\n    plugins = [];\n  }\n  var keys4 = Object.keys(partialProps);\n  keys4.forEach(function(prop) {\n    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));\n    var didPassUnknownProp = !hasOwnProperty5(nonPluginProps, prop);\n    if (didPassUnknownProp) {\n      didPassUnknownProp = plugins.filter(function(plugin) {\n        return plugin.name === prop;\n      }).length === 0;\n    }\n    warnWhen(didPassUnknownProp, [\"`\" + prop + \"`\", \"is not a valid prop. You may have spelled it incorrectly, or if it's\", \"a plugin, forgot to pass it in an array as props.plugins.\", \"\\n\\n\", \"All props: https://atomiks.github.io/tippyjs/v6/all-props/\\n\", \"Plugins: https://atomiks.github.io/tippyjs/v6/plugins/\"].join(\" \"));\n  });\n}\nvar innerHTML = function innerHTML2() {\n  return \"innerHTML\";\n};\nfunction dangerouslySetInnerHTML(element4, html) {\n  element4[innerHTML()] = html;\n}\nfunction createArrowElement(value) {\n  var arrow3 = div2();\n  if (value === true) {\n    arrow3.className = ARROW_CLASS;\n  } else {\n    arrow3.className = SVG_ARROW_CLASS;\n    if (isElement5(value)) {\n      arrow3.appendChild(value);\n    } else {\n      dangerouslySetInnerHTML(arrow3, value);\n    }\n  }\n  return arrow3;\n}\nfunction setContent(content, props) {\n  if (isElement5(props.content)) {\n    dangerouslySetInnerHTML(content, \"\");\n    content.appendChild(props.content);\n  } else if (typeof props.content !== \"function\") {\n    if (props.allowHTML) {\n      dangerouslySetInnerHTML(content, props.content);\n    } else {\n      content.textContent = props.content;\n    }\n  }\n}\nfunction getChildren2(popper2) {\n  var box = popper2.firstElementChild;\n  var boxChildren = arrayFrom(box.children);\n  return {\n    box,\n    content: boxChildren.find(function(node) {\n      return node.classList.contains(CONTENT_CLASS);\n    }),\n    arrow: boxChildren.find(function(node) {\n      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);\n    }),\n    backdrop: boxChildren.find(function(node) {\n      return node.classList.contains(BACKDROP_CLASS);\n    })\n  };\n}\nfunction render(instance) {\n  var popper2 = div2();\n  var box = div2();\n  box.className = BOX_CLASS;\n  box.setAttribute(\"data-state\", \"hidden\");\n  box.setAttribute(\"tabindex\", \"-1\");\n  var content = div2();\n  content.className = CONTENT_CLASS;\n  content.setAttribute(\"data-state\", \"hidden\");\n  setContent(content, instance.props);\n  popper2.appendChild(box);\n  box.appendChild(content);\n  onUpdate(instance.props, instance.props);\n  function onUpdate(prevProps, nextProps) {\n    var _getChildren = getChildren2(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow3 = _getChildren.arrow;\n    if (nextProps.theme) {\n      box2.setAttribute(\"data-theme\", nextProps.theme);\n    } else {\n      box2.removeAttribute(\"data-theme\");\n    }\n    if (typeof nextProps.animation === \"string\") {\n      box2.setAttribute(\"data-animation\", nextProps.animation);\n    } else {\n      box2.removeAttribute(\"data-animation\");\n    }\n    if (nextProps.inertia) {\n      box2.setAttribute(\"data-inertia\", \"\");\n    } else {\n      box2.removeAttribute(\"data-inertia\");\n    }\n    box2.style.maxWidth = typeof nextProps.maxWidth === \"number\" ? nextProps.maxWidth + \"px\" : nextProps.maxWidth;\n    if (nextProps.role) {\n      box2.setAttribute(\"role\", nextProps.role);\n    } else {\n      box2.removeAttribute(\"role\");\n    }\n    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {\n      setContent(content2, instance.props);\n    }\n    if (nextProps.arrow) {\n      if (!arrow3) {\n        box2.appendChild(createArrowElement(nextProps.arrow));\n      } else if (prevProps.arrow !== nextProps.arrow) {\n        box2.removeChild(arrow3);\n        box2.appendChild(createArrowElement(nextProps.arrow));\n      }\n    } else if (arrow3) {\n      box2.removeChild(arrow3);\n    }\n  }\n  return {\n    popper: popper2,\n    onUpdate\n  };\n}\nrender.$$tippy = true;\nvar idCounter = 1;\nvar mouseMoveListeners = [];\nvar mountedInstances = [];\nfunction createTippy(reference2, passedProps) {\n  var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));\n  var showTimeout;\n  var hideTimeout;\n  var scheduleHideAnimationFrame;\n  var isVisibleFromClick = false;\n  var didHideDueToDocumentMouseDown = false;\n  var didTouchMove = false;\n  var ignoreOnFirstUpdate = false;\n  var lastTriggerEvent;\n  var currentTransitionEndListener;\n  var onFirstUpdate;\n  var listeners = [];\n  var debouncedOnMouseMove = debounce4(onMouseMove, props.interactiveDebounce);\n  var currentTarget;\n  var id = idCounter++;\n  var popperInstance = null;\n  var plugins = unique(props.plugins);\n  var state = {\n    // Is the instance currently enabled?\n    isEnabled: true,\n    // Is the tippy currently showing and not transitioning out?\n    isVisible: false,\n    // Has the instance been destroyed?\n    isDestroyed: false,\n    // Is the tippy currently mounted to the DOM?\n    isMounted: false,\n    // Has the tippy finished transitioning in?\n    isShown: false\n  };\n  var instance = {\n    // properties\n    id,\n    reference: reference2,\n    popper: div2(),\n    popperInstance,\n    props,\n    state,\n    plugins,\n    // methods\n    clearDelayTimeouts,\n    setProps,\n    setContent: setContent2,\n    show,\n    hide: hide2,\n    hideWithInteractivity,\n    enable,\n    disable,\n    unmount,\n    destroy\n  };\n  if (!props.render) {\n    if (true) {\n      errorWhen(true, \"render() function has not been supplied.\");\n    }\n    return instance;\n  }\n  var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;\n  popper2.setAttribute(\"data-tippy-root\", \"\");\n  popper2.id = \"tippy-\" + instance.id;\n  instance.popper = popper2;\n  reference2._tippy = instance;\n  popper2._tippy = instance;\n  var pluginsHooks = plugins.map(function(plugin) {\n    return plugin.fn(instance);\n  });\n  var hasAriaExpanded = reference2.hasAttribute(\"aria-expanded\");\n  addListeners();\n  handleAriaExpandedAttribute();\n  handleStyles();\n  invokeHook(\"onCreate\", [instance]);\n  if (props.showOnCreate) {\n    scheduleShow();\n  }\n  popper2.addEventListener(\"mouseenter\", function() {\n    if (instance.props.interactive && instance.state.isVisible) {\n      instance.clearDelayTimeouts();\n    }\n  });\n  popper2.addEventListener(\"mouseleave\", function() {\n    if (instance.props.interactive && instance.props.trigger.indexOf(\"mouseenter\") >= 0) {\n      getDocument3().addEventListener(\"mousemove\", debouncedOnMouseMove);\n    }\n  });\n  return instance;\n  function getNormalizedTouchSettings() {\n    var touch = instance.props.touch;\n    return Array.isArray(touch) ? touch : [touch, 0];\n  }\n  function getIsCustomTouchBehavior() {\n    return getNormalizedTouchSettings()[0] === \"hold\";\n  }\n  function getIsDefaultRenderFn() {\n    var _instance$props$rende;\n    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);\n  }\n  function getCurrentTarget() {\n    return currentTarget || reference2;\n  }\n  function getDocument3() {\n    var parent2 = getCurrentTarget().parentNode;\n    return parent2 ? getOwnerDocument(parent2) : document;\n  }\n  function getDefaultTemplateChildren() {\n    return getChildren2(popper2);\n  }\n  function getDelay(isShow) {\n    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === \"focus\") {\n      return 0;\n    }\n    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);\n  }\n  function handleStyles(fromHide) {\n    if (fromHide === void 0) {\n      fromHide = false;\n    }\n    popper2.style.pointerEvents = instance.props.interactive && !fromHide ? \"\" : \"none\";\n    popper2.style.zIndex = \"\" + instance.props.zIndex;\n  }\n  function invokeHook(hook, args, shouldInvokePropsHook) {\n    if (shouldInvokePropsHook === void 0) {\n      shouldInvokePropsHook = true;\n    }\n    pluginsHooks.forEach(function(pluginHooks) {\n      if (pluginHooks[hook]) {\n        pluginHooks[hook].apply(pluginHooks, args);\n      }\n    });\n    if (shouldInvokePropsHook) {\n      var _instance$props;\n      (_instance$props = instance.props)[hook].apply(_instance$props, args);\n    }\n  }\n  function handleAriaContentAttribute() {\n    var aria = instance.props.aria;\n    if (!aria.content) {\n      return;\n    }\n    var attr = \"aria-\" + aria.content;\n    var id2 = popper2.id;\n    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);\n    nodes.forEach(function(node) {\n      var currentValue = node.getAttribute(attr);\n      if (instance.state.isVisible) {\n        node.setAttribute(attr, currentValue ? currentValue + \" \" + id2 : id2);\n      } else {\n        var nextValue = currentValue && currentValue.replace(id2, \"\").trim();\n        if (nextValue) {\n          node.setAttribute(attr, nextValue);\n        } else {\n          node.removeAttribute(attr);\n        }\n      }\n    });\n  }\n  function handleAriaExpandedAttribute() {\n    if (hasAriaExpanded || !instance.props.aria.expanded) {\n      return;\n    }\n    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);\n    nodes.forEach(function(node) {\n      if (instance.props.interactive) {\n        node.setAttribute(\"aria-expanded\", instance.state.isVisible && node === getCurrentTarget() ? \"true\" : \"false\");\n      } else {\n        node.removeAttribute(\"aria-expanded\");\n      }\n    });\n  }\n  function cleanupInteractiveMouseListeners() {\n    getDocument3().removeEventListener(\"mousemove\", debouncedOnMouseMove);\n    mouseMoveListeners = mouseMoveListeners.filter(function(listener) {\n      return listener !== debouncedOnMouseMove;\n    });\n  }\n  function onDocumentPress(event) {\n    if (currentInput.isTouch) {\n      if (didTouchMove || event.type === \"mousedown\") {\n        return;\n      }\n    }\n    var actualTarget = event.composedPath && event.composedPath()[0] || event.target;\n    if (instance.props.interactive && actualContains(popper2, actualTarget)) {\n      return;\n    }\n    if (normalizeToArray(instance.props.triggerTarget || reference2).some(function(el) {\n      return actualContains(el, actualTarget);\n    })) {\n      if (currentInput.isTouch) {\n        return;\n      }\n      if (instance.state.isVisible && instance.props.trigger.indexOf(\"click\") >= 0) {\n        return;\n      }\n    } else {\n      invokeHook(\"onClickOutside\", [instance, event]);\n    }\n    if (instance.props.hideOnClick === true) {\n      instance.clearDelayTimeouts();\n      instance.hide();\n      didHideDueToDocumentMouseDown = true;\n      setTimeout(function() {\n        didHideDueToDocumentMouseDown = false;\n      });\n      if (!instance.state.isMounted) {\n        removeDocumentPress();\n      }\n    }\n  }\n  function onTouchMove() {\n    didTouchMove = true;\n  }\n  function onTouchStart() {\n    didTouchMove = false;\n  }\n  function addDocumentPress() {\n    var doc = getDocument3();\n    doc.addEventListener(\"mousedown\", onDocumentPress, true);\n    doc.addEventListener(\"touchend\", onDocumentPress, TOUCH_OPTIONS);\n    doc.addEventListener(\"touchstart\", onTouchStart, TOUCH_OPTIONS);\n    doc.addEventListener(\"touchmove\", onTouchMove, TOUCH_OPTIONS);\n  }\n  function removeDocumentPress() {\n    var doc = getDocument3();\n    doc.removeEventListener(\"mousedown\", onDocumentPress, true);\n    doc.removeEventListener(\"touchend\", onDocumentPress, TOUCH_OPTIONS);\n    doc.removeEventListener(\"touchstart\", onTouchStart, TOUCH_OPTIONS);\n    doc.removeEventListener(\"touchmove\", onTouchMove, TOUCH_OPTIONS);\n  }\n  function onTransitionedOut(duration, callback) {\n    onTransitionEnd(duration, function() {\n      if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {\n        callback();\n      }\n    });\n  }\n  function onTransitionedIn(duration, callback) {\n    onTransitionEnd(duration, callback);\n  }\n  function onTransitionEnd(duration, callback) {\n    var box = getDefaultTemplateChildren().box;\n    function listener(event) {\n      if (event.target === box) {\n        updateTransitionEndListener(box, \"remove\", listener);\n        callback();\n      }\n    }\n    if (duration === 0) {\n      return callback();\n    }\n    updateTransitionEndListener(box, \"remove\", currentTransitionEndListener);\n    updateTransitionEndListener(box, \"add\", listener);\n    currentTransitionEndListener = listener;\n  }\n  function on3(eventType, handler, options) {\n    if (options === void 0) {\n      options = false;\n    }\n    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);\n    nodes.forEach(function(node) {\n      node.addEventListener(eventType, handler, options);\n      listeners.push({\n        node,\n        eventType,\n        handler,\n        options\n      });\n    });\n  }\n  function addListeners() {\n    if (getIsCustomTouchBehavior()) {\n      on3(\"touchstart\", onTrigger2, {\n        passive: true\n      });\n      on3(\"touchend\", onMouseLeave, {\n        passive: true\n      });\n    }\n    splitBySpaces(instance.props.trigger).forEach(function(eventType) {\n      if (eventType === \"manual\") {\n        return;\n      }\n      on3(eventType, onTrigger2);\n      switch (eventType) {\n        case \"mouseenter\":\n          on3(\"mouseleave\", onMouseLeave);\n          break;\n        case \"focus\":\n          on3(isIE11 ? \"focusout\" : \"blur\", onBlurOrFocusOut);\n          break;\n        case \"focusin\":\n          on3(\"focusout\", onBlurOrFocusOut);\n          break;\n      }\n    });\n  }\n  function removeListeners() {\n    listeners.forEach(function(_ref) {\n      var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;\n      node.removeEventListener(eventType, handler, options);\n    });\n    listeners = [];\n  }\n  function onTrigger2(event) {\n    var _lastTriggerEvent;\n    var shouldScheduleClickHide = false;\n    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {\n      return;\n    }\n    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === \"focus\";\n    lastTriggerEvent = event;\n    currentTarget = event.currentTarget;\n    handleAriaExpandedAttribute();\n    if (!instance.state.isVisible && isMouseEvent(event)) {\n      mouseMoveListeners.forEach(function(listener) {\n        return listener(event);\n      });\n    }\n    if (event.type === \"click\" && (instance.props.trigger.indexOf(\"mouseenter\") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {\n      shouldScheduleClickHide = true;\n    } else {\n      scheduleShow(event);\n    }\n    if (event.type === \"click\") {\n      isVisibleFromClick = !shouldScheduleClickHide;\n    }\n    if (shouldScheduleClickHide && !wasFocused) {\n      scheduleHide(event);\n    }\n  }\n  function onMouseMove(event) {\n    var target = event.target;\n    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);\n    if (event.type === \"mousemove\" && isCursorOverReferenceOrPopper) {\n      return;\n    }\n    var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {\n      var _instance$popperInsta;\n      var instance2 = popper3._tippy;\n      var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;\n      if (state2) {\n        return {\n          popperRect: popper3.getBoundingClientRect(),\n          popperState: state2,\n          props\n        };\n      }\n      return null;\n    }).filter(Boolean);\n    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {\n      cleanupInteractiveMouseListeners();\n      scheduleHide(event);\n    }\n  }\n  function onMouseLeave(event) {\n    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf(\"click\") >= 0 && isVisibleFromClick;\n    if (shouldBail) {\n      return;\n    }\n    if (instance.props.interactive) {\n      instance.hideWithInteractivity(event);\n      return;\n    }\n    scheduleHide(event);\n  }\n  function onBlurOrFocusOut(event) {\n    if (instance.props.trigger.indexOf(\"focusin\") < 0 && event.target !== getCurrentTarget()) {\n      return;\n    }\n    if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {\n      return;\n    }\n    scheduleHide(event);\n  }\n  function isEventListenerStopped(event) {\n    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf(\"touch\") >= 0 : false;\n  }\n  function createPopperInstance() {\n    destroyPopperInstance();\n    var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset3 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;\n    var arrow3 = getIsDefaultRenderFn() ? getChildren2(popper2).arrow : null;\n    var computedReference = getReferenceClientRect ? {\n      getBoundingClientRect: getReferenceClientRect,\n      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()\n    } : reference2;\n    var tippyModifier = {\n      name: \"$$tippy\",\n      enabled: true,\n      phase: \"beforeWrite\",\n      requires: [\"computeStyles\"],\n      fn: function fn4(_ref2) {\n        var state2 = _ref2.state;\n        if (getIsDefaultRenderFn()) {\n          var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;\n          [\"placement\", \"reference-hidden\", \"escaped\"].forEach(function(attr) {\n            if (attr === \"placement\") {\n              box.setAttribute(\"data-placement\", state2.placement);\n            } else {\n              if (state2.attributes.popper[\"data-popper-\" + attr]) {\n                box.setAttribute(\"data-\" + attr, \"\");\n              } else {\n                box.removeAttribute(\"data-\" + attr);\n              }\n            }\n          });\n          state2.attributes.popper = {};\n        }\n      }\n    };\n    var modifiers = [{\n      name: \"offset\",\n      options: {\n        offset: offset3\n      }\n    }, {\n      name: \"preventOverflow\",\n      options: {\n        padding: {\n          top: 2,\n          bottom: 2,\n          left: 5,\n          right: 5\n        }\n      }\n    }, {\n      name: \"flip\",\n      options: {\n        padding: 5\n      }\n    }, {\n      name: \"computeStyles\",\n      options: {\n        adaptive: !moveTransition\n      }\n    }, tippyModifier];\n    if (getIsDefaultRenderFn() && arrow3) {\n      modifiers.push({\n        name: \"arrow\",\n        options: {\n          element: arrow3,\n          padding: 3\n        }\n      });\n    }\n    modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);\n    instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {\n      placement,\n      onFirstUpdate,\n      modifiers\n    }));\n  }\n  function destroyPopperInstance() {\n    if (instance.popperInstance) {\n      instance.popperInstance.destroy();\n      instance.popperInstance = null;\n    }\n  }\n  function mount() {\n    var appendTo = instance.props.appendTo;\n    var parentNode;\n    var node = getCurrentTarget();\n    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === \"parent\") {\n      parentNode = node.parentNode;\n    } else {\n      parentNode = invokeWithArgsOrReturn(appendTo, [node]);\n    }\n    if (!parentNode.contains(popper2)) {\n      parentNode.appendChild(popper2);\n    }\n    instance.state.isMounted = true;\n    createPopperInstance();\n    if (true) {\n      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper2, [\"Interactive tippy element may not be accessible via keyboard\", \"navigation because it is not directly after the reference element\", \"in the DOM source order.\", \"\\n\\n\", \"Using a wrapper <div> or <span> tag around the reference element\", \"solves this by creating a new parentNode context.\", \"\\n\\n\", \"Specifying `appendTo: document.body` silences this warning, but it\", \"assumes you are using a focus management solution to handle\", \"keyboard navigation.\", \"\\n\\n\", \"See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity\"].join(\" \"));\n    }\n  }\n  function getNestedPopperTree() {\n    return arrayFrom(popper2.querySelectorAll(\"[data-tippy-root]\"));\n  }\n  function scheduleShow(event) {\n    instance.clearDelayTimeouts();\n    if (event) {\n      invokeHook(\"onTrigger\", [instance, event]);\n    }\n    addDocumentPress();\n    var delay = getDelay(true);\n    var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];\n    if (currentInput.isTouch && touchValue === \"hold\" && touchDelay) {\n      delay = touchDelay;\n    }\n    if (delay) {\n      showTimeout = setTimeout(function() {\n        instance.show();\n      }, delay);\n    } else {\n      instance.show();\n    }\n  }\n  function scheduleHide(event) {\n    instance.clearDelayTimeouts();\n    invokeHook(\"onUntrigger\", [instance, event]);\n    if (!instance.state.isVisible) {\n      removeDocumentPress();\n      return;\n    }\n    if (instance.props.trigger.indexOf(\"mouseenter\") >= 0 && instance.props.trigger.indexOf(\"click\") >= 0 && [\"mouseleave\", \"mousemove\"].indexOf(event.type) >= 0 && isVisibleFromClick) {\n      return;\n    }\n    var delay = getDelay(false);\n    if (delay) {\n      hideTimeout = setTimeout(function() {\n        if (instance.state.isVisible) {\n          instance.hide();\n        }\n      }, delay);\n    } else {\n      scheduleHideAnimationFrame = requestAnimationFrame(function() {\n        instance.hide();\n      });\n    }\n  }\n  function enable() {\n    instance.state.isEnabled = true;\n  }\n  function disable() {\n    instance.hide();\n    instance.state.isEnabled = false;\n  }\n  function clearDelayTimeouts() {\n    clearTimeout(showTimeout);\n    clearTimeout(hideTimeout);\n    cancelAnimationFrame(scheduleHideAnimationFrame);\n  }\n  function setProps(partialProps) {\n    if (true) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"setProps\"));\n    }\n    if (instance.state.isDestroyed) {\n      return;\n    }\n    invokeHook(\"onBeforeUpdate\", [instance, partialProps]);\n    removeListeners();\n    var prevProps = instance.props;\n    var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {\n      ignoreAttributes: true\n    }));\n    instance.props = nextProps;\n    addListeners();\n    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {\n      cleanupInteractiveMouseListeners();\n      debouncedOnMouseMove = debounce4(onMouseMove, nextProps.interactiveDebounce);\n    }\n    if (prevProps.triggerTarget && !nextProps.triggerTarget) {\n      normalizeToArray(prevProps.triggerTarget).forEach(function(node) {\n        node.removeAttribute(\"aria-expanded\");\n      });\n    } else if (nextProps.triggerTarget) {\n      reference2.removeAttribute(\"aria-expanded\");\n    }\n    handleAriaExpandedAttribute();\n    handleStyles();\n    if (onUpdate) {\n      onUpdate(prevProps, nextProps);\n    }\n    if (instance.popperInstance) {\n      createPopperInstance();\n      getNestedPopperTree().forEach(function(nestedPopper) {\n        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);\n      });\n    }\n    invokeHook(\"onAfterUpdate\", [instance, partialProps]);\n  }\n  function setContent2(content) {\n    instance.setProps({\n      content\n    });\n  }\n  function show() {\n    if (true) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"show\"));\n    }\n    var isAlreadyVisible = instance.state.isVisible;\n    var isDestroyed = instance.state.isDestroyed;\n    var isDisabled = !instance.state.isEnabled;\n    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;\n    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);\n    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {\n      return;\n    }\n    if (getCurrentTarget().hasAttribute(\"disabled\")) {\n      return;\n    }\n    invokeHook(\"onShow\", [instance], false);\n    if (instance.props.onShow(instance) === false) {\n      return;\n    }\n    instance.state.isVisible = true;\n    if (getIsDefaultRenderFn()) {\n      popper2.style.visibility = \"visible\";\n    }\n    handleStyles();\n    addDocumentPress();\n    if (!instance.state.isMounted) {\n      popper2.style.transition = \"none\";\n    }\n    if (getIsDefaultRenderFn()) {\n      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;\n      setTransitionDuration([box, content], 0);\n    }\n    onFirstUpdate = function onFirstUpdate2() {\n      var _instance$popperInsta2;\n      if (!instance.state.isVisible || ignoreOnFirstUpdate) {\n        return;\n      }\n      ignoreOnFirstUpdate = true;\n      void popper2.offsetHeight;\n      popper2.style.transition = instance.props.moveTransition;\n      if (getIsDefaultRenderFn() && instance.props.animation) {\n        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;\n        setTransitionDuration([_box, _content], duration);\n        setVisibilityState([_box, _content], \"visible\");\n      }\n      handleAriaContentAttribute();\n      handleAriaExpandedAttribute();\n      pushIfUnique(mountedInstances, instance);\n      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();\n      invokeHook(\"onMount\", [instance]);\n      if (instance.props.animation && getIsDefaultRenderFn()) {\n        onTransitionedIn(duration, function() {\n          instance.state.isShown = true;\n          invokeHook(\"onShown\", [instance]);\n        });\n      }\n    };\n    mount();\n  }\n  function hide2() {\n    if (true) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"hide\"));\n    }\n    var isAlreadyHidden = !instance.state.isVisible;\n    var isDestroyed = instance.state.isDestroyed;\n    var isDisabled = !instance.state.isEnabled;\n    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);\n    if (isAlreadyHidden || isDestroyed || isDisabled) {\n      return;\n    }\n    invokeHook(\"onHide\", [instance], false);\n    if (instance.props.onHide(instance) === false) {\n      return;\n    }\n    instance.state.isVisible = false;\n    instance.state.isShown = false;\n    ignoreOnFirstUpdate = false;\n    isVisibleFromClick = false;\n    if (getIsDefaultRenderFn()) {\n      popper2.style.visibility = \"hidden\";\n    }\n    cleanupInteractiveMouseListeners();\n    removeDocumentPress();\n    handleStyles(true);\n    if (getIsDefaultRenderFn()) {\n      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;\n      if (instance.props.animation) {\n        setTransitionDuration([box, content], duration);\n        setVisibilityState([box, content], \"hidden\");\n      }\n    }\n    handleAriaContentAttribute();\n    handleAriaExpandedAttribute();\n    if (instance.props.animation) {\n      if (getIsDefaultRenderFn()) {\n        onTransitionedOut(duration, instance.unmount);\n      }\n    } else {\n      instance.unmount();\n    }\n  }\n  function hideWithInteractivity(event) {\n    if (true) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"hideWithInteractivity\"));\n    }\n    getDocument3().addEventListener(\"mousemove\", debouncedOnMouseMove);\n    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);\n    debouncedOnMouseMove(event);\n  }\n  function unmount() {\n    if (true) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"unmount\"));\n    }\n    if (instance.state.isVisible) {\n      instance.hide();\n    }\n    if (!instance.state.isMounted) {\n      return;\n    }\n    destroyPopperInstance();\n    getNestedPopperTree().forEach(function(nestedPopper) {\n      nestedPopper._tippy.unmount();\n    });\n    if (popper2.parentNode) {\n      popper2.parentNode.removeChild(popper2);\n    }\n    mountedInstances = mountedInstances.filter(function(i5) {\n      return i5 !== instance;\n    });\n    instance.state.isMounted = false;\n    invokeHook(\"onHidden\", [instance]);\n  }\n  function destroy() {\n    if (true) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"destroy\"));\n    }\n    if (instance.state.isDestroyed) {\n      return;\n    }\n    instance.clearDelayTimeouts();\n    instance.unmount();\n    removeListeners();\n    delete reference2._tippy;\n    instance.state.isDestroyed = true;\n    invokeHook(\"onDestroy\", [instance]);\n  }\n}\nfunction tippy(targets, optionalProps) {\n  if (optionalProps === void 0) {\n    optionalProps = {};\n  }\n  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);\n  if (true) {\n    validateTargets(targets);\n    validateProps(optionalProps, plugins);\n  }\n  bindGlobalEventListeners();\n  var passedProps = Object.assign({}, optionalProps, {\n    plugins\n  });\n  var elements = getArrayOfElements(targets);\n  if (true) {\n    var isSingleContentElement = isElement5(passedProps.content);\n    var isMoreThanOneReferenceElement = elements.length > 1;\n    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, [\"tippy() was passed an Element as the `content` prop, but more than\", \"one tippy instance was created by this invocation. This means the\", \"content element will only be appended to the last tippy instance.\", \"\\n\\n\", \"Instead, pass the .innerHTML of the element, or use a function that\", \"returns a cloned version of the element instead.\", \"\\n\\n\", \"1) content: element.innerHTML\\n\", \"2) content: () => element.cloneNode(true)\"].join(\" \"));\n  }\n  var instances = elements.reduce(function(acc, reference2) {\n    var instance = reference2 && createTippy(reference2, passedProps);\n    if (instance) {\n      acc.push(instance);\n    }\n    return acc;\n  }, []);\n  return isElement5(targets) ? instances[0] : instances;\n}\ntippy.defaultProps = defaultProps;\ntippy.setDefaultProps = setDefaultProps;\ntippy.currentInput = currentInput;\nvar applyStylesModifier = Object.assign({}, applyStyles_default, {\n  effect: function effect4(_ref) {\n    var state = _ref.state;\n    var initialStyles = {\n      popper: {\n        position: state.options.strategy,\n        left: \"0\",\n        top: \"0\",\n        margin: \"0\"\n      },\n      arrow: {\n        position: \"absolute\"\n      },\n      reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n    if (state.elements.arrow) {\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    }\n  }\n});\ntippy.setDefaultProps({\n  render\n});\nvar tippy_esm_default = tippy;\n\n// node_modules/@tippyjs/react/dist/tippy-react.esm.js\nvar import_react33 = __toESM(require(\"react\"));\nvar import_react_dom3 = require(\"react-dom\");\nfunction _objectWithoutPropertiesLoose4(source, excluded) {\n  if (source == null)\n    return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i5;\n  for (i5 = 0; i5 < sourceKeys.length; i5++) {\n    key = sourceKeys[i5];\n    if (excluded.indexOf(key) >= 0)\n      continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nvar isBrowser2 = typeof window !== \"undefined\" && typeof document !== \"undefined\";\nfunction preserveRef(ref, node) {\n  if (ref) {\n    if (typeof ref === \"function\") {\n      ref(node);\n    }\n    if ({}.hasOwnProperty.call(ref, \"current\")) {\n      ref.current = node;\n    }\n  }\n}\nfunction ssrSafeCreateDiv() {\n  return isBrowser2 && document.createElement(\"div\");\n}\nfunction toDataAttributes(attrs) {\n  var dataAttrs = {\n    \"data-placement\": attrs.placement\n  };\n  if (attrs.referenceHidden) {\n    dataAttrs[\"data-reference-hidden\"] = \"\";\n  }\n  if (attrs.escaped) {\n    dataAttrs[\"data-escaped\"] = \"\";\n  }\n  return dataAttrs;\n}\nfunction deepEqual2(x4, y5) {\n  if (x4 === y5) {\n    return true;\n  } else if (typeof x4 === \"object\" && x4 != null && typeof y5 === \"object\" && y5 != null) {\n    if (Object.keys(x4).length !== Object.keys(y5).length) {\n      return false;\n    }\n    for (var prop in x4) {\n      if (y5.hasOwnProperty(prop)) {\n        if (!deepEqual2(x4[prop], y5[prop])) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction uniqueByShape(arr) {\n  var output = [];\n  arr.forEach(function(item) {\n    if (!output.find(function(outputItem) {\n      return deepEqual2(item, outputItem);\n    })) {\n      output.push(item);\n    }\n  });\n  return output;\n}\nfunction deepPreserveProps(instanceProps, componentProps) {\n  var _instanceProps$popper, _componentProps$poppe;\n  return Object.assign({}, componentProps, {\n    popperOptions: Object.assign({}, instanceProps.popperOptions, componentProps.popperOptions, {\n      modifiers: uniqueByShape([].concat(((_instanceProps$popper = instanceProps.popperOptions) == null ? void 0 : _instanceProps$popper.modifiers) || [], ((_componentProps$poppe = componentProps.popperOptions) == null ? void 0 : _componentProps$poppe.modifiers) || []))\n    })\n  });\n}\nvar useIsomorphicLayoutEffect3 = isBrowser2 ? import_react33.useLayoutEffect : import_react33.useEffect;\nfunction useMutableBox(initialValue) {\n  var ref = (0, import_react33.useRef)();\n  if (!ref.current) {\n    ref.current = typeof initialValue === \"function\" ? initialValue() : initialValue;\n  }\n  return ref.current;\n}\nfunction updateClassName(box, action, classNames) {\n  classNames.split(/\\s+/).forEach(function(name) {\n    if (name) {\n      box.classList[action](name);\n    }\n  });\n}\nvar classNamePlugin = {\n  name: \"className\",\n  defaultValue: \"\",\n  fn: function fn3(instance) {\n    var box = instance.popper.firstElementChild;\n    var isDefaultRenderFn = function isDefaultRenderFn2() {\n      var _instance$props$rende;\n      return !!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy);\n    };\n    function add2() {\n      if (instance.props.className && !isDefaultRenderFn()) {\n        if (true) {\n          console.warn([\"@tippyjs/react: Cannot use `className` prop in conjunction with\", \"`render` prop. Place the className on the element you are\", \"rendering.\"].join(\" \"));\n        }\n        return;\n      }\n      updateClassName(box, \"add\", instance.props.className);\n    }\n    function remove() {\n      if (isDefaultRenderFn()) {\n        updateClassName(box, \"remove\", instance.props.className);\n      }\n    }\n    return {\n      onCreate: add2,\n      onBeforeUpdate: remove,\n      onAfterUpdate: add2\n    };\n  }\n};\nfunction TippyGenerator(tippy2) {\n  function Tippy(_ref) {\n    var children = _ref.children, content = _ref.content, visible = _ref.visible, singleton = _ref.singleton, render2 = _ref.render, reference2 = _ref.reference, _ref$disabled = _ref.disabled, disabled = _ref$disabled === void 0 ? false : _ref$disabled, _ref$ignoreAttributes = _ref.ignoreAttributes, ignoreAttributes = _ref$ignoreAttributes === void 0 ? true : _ref$ignoreAttributes, __source = _ref.__source, __self = _ref.__self, restOfNativeProps = _objectWithoutPropertiesLoose4(_ref, [\"children\", \"content\", \"visible\", \"singleton\", \"render\", \"reference\", \"disabled\", \"ignoreAttributes\", \"__source\", \"__self\"]);\n    var isControlledMode = visible !== void 0;\n    var isSingletonMode = singleton !== void 0;\n    var _useState = (0, import_react33.useState)(false), mounted = _useState[0], setMounted = _useState[1];\n    var _useState2 = (0, import_react33.useState)({}), attrs = _useState2[0], setAttrs = _useState2[1];\n    var _useState3 = (0, import_react33.useState)(), singletonContent = _useState3[0], setSingletonContent = _useState3[1];\n    var mutableBox = useMutableBox(function() {\n      return {\n        container: ssrSafeCreateDiv(),\n        renders: 1\n      };\n    });\n    var props = Object.assign({\n      ignoreAttributes\n    }, restOfNativeProps, {\n      content: mutableBox.container\n    });\n    if (isControlledMode) {\n      if (true) {\n        [\"trigger\", \"hideOnClick\", \"showOnCreate\"].forEach(function(nativeStateProp) {\n          if (props[nativeStateProp] !== void 0) {\n            console.warn([\"@tippyjs/react: Cannot specify `\" + nativeStateProp + \"` prop in\", \"controlled mode (`visible` prop)\"].join(\" \"));\n          }\n        });\n      }\n      props.trigger = \"manual\";\n      props.hideOnClick = false;\n    }\n    if (isSingletonMode) {\n      disabled = true;\n    }\n    var computedProps = props;\n    var plugins = props.plugins || [];\n    if (render2) {\n      computedProps = Object.assign({}, props, {\n        plugins: isSingletonMode && singleton.data != null ? [].concat(plugins, [{\n          fn: function fn4() {\n            return {\n              onTrigger: function onTrigger2(instance, event) {\n                var node = singleton.data.children.find(function(_ref2) {\n                  var instance2 = _ref2.instance;\n                  return instance2.reference === event.currentTarget;\n                });\n                instance.state.$$activeSingletonInstance = node.instance;\n                setSingletonContent(node.content);\n              }\n            };\n          }\n        }]) : plugins,\n        render: function render3() {\n          return {\n            popper: mutableBox.container\n          };\n        }\n      });\n    }\n    var deps = [reference2].concat(children ? [children.type] : []);\n    useIsomorphicLayoutEffect3(function() {\n      var element4 = reference2;\n      if (reference2 && reference2.hasOwnProperty(\"current\")) {\n        element4 = reference2.current;\n      }\n      var instance = tippy2(element4 || mutableBox.ref || ssrSafeCreateDiv(), Object.assign({}, computedProps, {\n        plugins: [classNamePlugin].concat(props.plugins || [])\n      }));\n      mutableBox.instance = instance;\n      if (disabled) {\n        instance.disable();\n      }\n      if (visible) {\n        instance.show();\n      }\n      if (isSingletonMode) {\n        singleton.hook({\n          instance,\n          content,\n          props: computedProps,\n          setSingletonContent\n        });\n      }\n      setMounted(true);\n      return function() {\n        instance.destroy();\n        singleton == null ? void 0 : singleton.cleanup(instance);\n      };\n    }, deps);\n    useIsomorphicLayoutEffect3(function() {\n      var _instance$popperInsta;\n      if (mutableBox.renders === 1) {\n        mutableBox.renders++;\n        return;\n      }\n      var instance = mutableBox.instance;\n      instance.setProps(deepPreserveProps(instance.props, computedProps));\n      (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.forceUpdate();\n      if (disabled) {\n        instance.disable();\n      } else {\n        instance.enable();\n      }\n      if (isControlledMode) {\n        if (visible) {\n          instance.show();\n        } else {\n          instance.hide();\n        }\n      }\n      if (isSingletonMode) {\n        singleton.hook({\n          instance,\n          content,\n          props: computedProps,\n          setSingletonContent\n        });\n      }\n    });\n    useIsomorphicLayoutEffect3(function() {\n      var _instance$props$poppe;\n      if (!render2) {\n        return;\n      }\n      var instance = mutableBox.instance;\n      instance.setProps({\n        popperOptions: Object.assign({}, instance.props.popperOptions, {\n          modifiers: [].concat((((_instance$props$poppe = instance.props.popperOptions) == null ? void 0 : _instance$props$poppe.modifiers) || []).filter(function(_ref3) {\n            var name = _ref3.name;\n            return name !== \"$$tippyReact\";\n          }), [{\n            name: \"$$tippyReact\",\n            enabled: true,\n            phase: \"beforeWrite\",\n            requires: [\"computeStyles\"],\n            fn: function fn4(_ref4) {\n              var _state$modifiersData;\n              var state = _ref4.state;\n              var hideData = (_state$modifiersData = state.modifiersData) == null ? void 0 : _state$modifiersData.hide;\n              if (attrs.placement !== state.placement || attrs.referenceHidden !== (hideData == null ? void 0 : hideData.isReferenceHidden) || attrs.escaped !== (hideData == null ? void 0 : hideData.hasPopperEscaped)) {\n                setAttrs({\n                  placement: state.placement,\n                  referenceHidden: hideData == null ? void 0 : hideData.isReferenceHidden,\n                  escaped: hideData == null ? void 0 : hideData.hasPopperEscaped\n                });\n              }\n              state.attributes.popper = {};\n            }\n          }])\n        })\n      });\n    }, [attrs.placement, attrs.referenceHidden, attrs.escaped].concat(deps));\n    return /* @__PURE__ */ import_react33.default.createElement(import_react33.default.Fragment, null, children ? /* @__PURE__ */ (0, import_react33.cloneElement)(children, {\n      ref: function ref(node) {\n        mutableBox.ref = node;\n        preserveRef(children.ref, node);\n      }\n    }) : null, mounted && /* @__PURE__ */ (0, import_react_dom3.createPortal)(render2 ? render2(toDataAttributes(attrs), singletonContent, mutableBox.instance) : content, mutableBox.container));\n  }\n  return Tippy;\n}\nvar forwardRef4 = function(Tippy, defaultProps3) {\n  return /* @__PURE__ */ (0, import_react33.forwardRef)(function TippyWrapper(_ref, _ref2) {\n    var children = _ref.children, props = _objectWithoutPropertiesLoose4(_ref, [\"children\"]);\n    return (\n      // If I spread them separately here, Babel adds the _extends ponyfill for\n      // some reason\n      /* @__PURE__ */ import_react33.default.createElement(Tippy, Object.assign({}, defaultProps3, props), children ? /* @__PURE__ */ (0, import_react33.cloneElement)(children, {\n        ref: function ref(node) {\n          preserveRef(_ref2, node);\n          preserveRef(children.ref, node);\n        }\n      }) : null)\n    );\n  });\n};\nvar index2 = /* @__PURE__ */ forwardRef4(/* @__PURE__ */ TippyGenerator(tippy_esm_default));\nvar tippy_react_esm_default = index2;\n\n// src/editor/plugins/dnd/components/Draggable.tsx\nvar import_styled_components6 = __toESM(require_styled_components_browser_cjs());\nvar import_typescript_styled_is = __toESM(require_dist());\n\n// node_modules/@react-hook/merged-ref/dist/module/index.js\nvar React10 = __toESM(require(\"react\"));\nfunction useMergedRef(...refs) {\n  return React10.useCallback(\n    (element4) => {\n      for (let i5 = 0; i5 < refs.length; i5++) {\n        const ref = refs[i5];\n        if (typeof ref === \"function\")\n          ref(element4);\n        else if (ref && typeof ref === \"object\")\n          ref.current = element4;\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    refs\n  );\n}\nvar module_default = useMergedRef;\n\n// node_modules/@styled-icons/material/DragIndicator/DragIndicator.esm.js\nvar React12 = __toESM(require(\"react\"));\n\n// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nfunction _objectWithoutPropertiesLoose5(source, excluded) {\n  if (source == null)\n    return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i5;\n  for (i5 = 0; i5 < sourceKeys.length; i5++) {\n    key = sourceKeys[i5];\n    if (excluded.indexOf(key) >= 0)\n      continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\n// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\nfunction _objectWithoutProperties4(source, excluded) {\n  if (source == null)\n    return {};\n  var target = _objectWithoutPropertiesLoose5(source, excluded);\n  var key, i5;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i5 = 0; i5 < sourceSymbolKeys.length; i5++) {\n      key = sourceSymbolKeys[i5];\n      if (excluded.indexOf(key) >= 0)\n        continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key))\n        continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\n// node_modules/@styled-icons/styled-icon/index.esm.js\nvar React11 = __toESM(require(\"react\"));\nvar import_styled_components4 = __toESM(require_styled_components_browser_cjs());\nvar _excluded4 = [\"children\", \"iconAttrs\", \"iconVerticalAlign\", \"iconViewBox\", \"size\", \"title\"];\nfunction ownKeys4(object, enumerableOnly) {\n  var keys4 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function(sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys4.push.apply(keys4, symbols);\n  }\n  return keys4;\n}\nfunction _objectSpread9(target) {\n  for (var i5 = 1; i5 < arguments.length; i5++) {\n    var source = null != arguments[i5] ? arguments[i5] : {};\n    i5 % 2 ? ownKeys4(Object(source), true).forEach(function(key) {\n      _defineProperty5(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys4(Object(source)).forEach(function(key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar StyledIconBaseBase = /* @__PURE__ */ React11.forwardRef(function(props, ref) {\n  var children = props.children, iconAttrs = props.iconAttrs, iconVerticalAlign = props.iconVerticalAlign, iconViewBox = props.iconViewBox, size = props.size, title2 = props.title, otherProps = _objectWithoutProperties4(props, _excluded4);\n  var iconProps = _objectSpread9(_objectSpread9({\n    viewBox: iconViewBox,\n    height: props.height !== void 0 ? props.height : size,\n    width: props.width !== void 0 ? props.width : size,\n    \"aria-hidden\": title2 == null ? \"true\" : void 0,\n    focusable: \"false\",\n    role: title2 != null ? \"img\" : void 0\n  }, iconAttrs), otherProps);\n  return /* @__PURE__ */ React11.createElement(\"svg\", _extends({}, iconProps, {\n    ref\n  }), title2 && /* @__PURE__ */ React11.createElement(\"title\", {\n    key: \"icon-title\"\n  }, title2), children);\n});\nvar StyledIconBase = /* @__PURE__ */ (0, import_styled_components4.default)(StyledIconBaseBase).withConfig({\n  displayName: \"StyledIconBase\",\n  componentId: \"sc-ea9ulj-0\"\n})([\"display:inline-block;vertical-align:\", \";overflow:hidden;\"], function(props) {\n  return props.iconVerticalAlign;\n});\n\n// node_modules/@styled-icons/material/DragIndicator/DragIndicator.esm.js\nvar DragIndicator = /* @__PURE__ */ React12.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React12.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React12.createElement(\"path\", {\n    d: \"M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z\"\n  }));\n});\nDragIndicator.displayName = \"DragIndicator\";\n\n// src/editor/plugins/dnd/hooks/useDndBlock.ts\nvar import_react35 = require(\"react\");\n\n// src/editor/plugins/dnd/hooks/useDragBlock.ts\nvar useDragBlock = (editor, element4, path) => {\n  return useDrag(\n    () => ({\n      type: \"block\",\n      item() {\n        $tw.dragInProgress = true;\n        editor.isDragging = true;\n        document.body.classList.add(\"dragging\");\n        const parentNode = Editor.above(editor, { at: path })?.[0];\n        return { id: element4.id, type: element4.type, parentType: parentNode?.type };\n      },\n      collect: (monitor) => ({\n        isDragging: monitor.isDragging()\n      }),\n      end: () => {\n        $tw.dragInProgress = false;\n        editor.isDragging = false;\n        document.body.classList.remove(\"dragging\");\n      }\n    }),\n    []\n  );\n};\n\n// src/editor/plugins/dnd/hooks/postDropNormalize.ts\nfunction postDropNormalize(editor, dragItem, path) {\n  if (\"parentType\" in dragItem) {\n    const dragItemWithParent = dragItem;\n    if (dragItemWithParent.type === \"li\" && (dragItemWithParent.parentType === \"ol\" || dragItemWithParent.parentType === \"ul\")) {\n      Transforms.wrapNodes(editor, { type: dragItemWithParent.parentType }, { at: path });\n    }\n  }\n}\n\n// node_modules/@udecode/plate-ui-dnd/dist/index.es.js\nvar import_styled_components5 = __toESM(require_styled_components_browser_cjs());\nvar import_react34 = __toESM(require(\"react\"));\nvar KEY_DND2 = \"dnd\";\nvar createDndPlugin2 = createPluginFactory({\n  key: KEY_DND2,\n  handlers: {\n    onDrop: (editor) => () => editor.isDragging\n  }\n});\nvar getDraggableStyles = (props) => createStyles({\n  prefixClassNames: \"Draggable\",\n  ...props\n}, {\n  root: [{\n    \"position\": \"relative\"\n  }, props.isDragging && {\n    \"opacity\": \"0.5\"\n  }, props.selected && {\n    \"backgroundColor\": \"rgb(181, 215, 255)\"\n  }, (0, import_styled_components5.css)([\":hover .slate-Draggable-gutterLeft{\", \"}\"], {\n    \"opacity\": \"1\"\n  })],\n  block: {\n    \"overflow\": \"auto\"\n  },\n  gutterLeft: [{\n    \"position\": \"absolute\",\n    \"top\": \"0px\",\n    \"display\": \"flex\",\n    \"height\": \"100%\",\n    \"opacity\": \"0\"\n  }, (0, import_styled_components5.css)([\"transform:translateX(-100%);\"])],\n  blockToolbarWrapper: {\n    \"display\": \"flex\",\n    \"height\": \"1.5em\"\n  },\n  blockToolbar: {\n    \"display\": \"flex\",\n    \"alignItems\": \"center\",\n    \"marginRight\": \"0.25rem\",\n    \"pointerEvents\": \"auto\"\n  },\n  dragHandle: [{\n    \"padding\": \"0px\",\n    \"backgroundColor\": \"rgba(0, 0, 0, 0)\",\n    \"backgroundRepeat\": \"no-repeat\",\n    \"cursor\": \"pointer\",\n    \"overflow\": \"hidden\",\n    \"outline\": \"2px solid transparent\",\n    \"outlineOffset\": \"2px\",\n    \"borderStyle\": \"none\"\n  }, {\n    \"minWidth\": \"18px\",\n    \"height\": \"18px\"\n  }],\n  dropLine: [{\n    \"position\": \"absolute\",\n    \"left\": \"0px\",\n    \"right\": \"0px\",\n    \"height\": \"0.125rem\",\n    \"opacity\": \"1\"\n  }, {\n    \"background\": \"#B4D5FF\"\n  }, props.direction === \"top\" && {\n    \"top\": \"-1px\"\n  }, props.direction === \"bottom\" && {\n    \"bottom\": \"-1px\"\n  }]\n});\nfunction _extends4() {\n  _extends4 = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i5 = 1; i5 < arguments.length; i5++) {\n      var source = arguments[i5];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends4.apply(this, arguments);\n}\nvar useDragNode = (editor, {\n  id,\n  item,\n  ...options\n}) => {\n  return useDrag(() => ({\n    item(monitor) {\n      editor.isDragging = true;\n      document.body.classList.add(\"dragging\");\n      const _item = typeof item === \"function\" ? item(monitor) : item;\n      return {\n        id,\n        ..._item\n      };\n    },\n    collect: (monitor) => ({\n      isDragging: monitor.isDragging()\n    }),\n    end: () => {\n      editor.isDragging = false;\n      document.body.classList.remove(\"dragging\");\n    },\n    ...options\n  }), []);\n};\nvar getHoverDirection = ({\n  dragItem,\n  id,\n  monitor,\n  nodeRef\n}) => {\n  var _nodeRef$current;\n  if (!nodeRef.current)\n    return;\n  const dragId = dragItem.id;\n  if (dragId === id)\n    return;\n  const hoverBoundingRect = (_nodeRef$current = nodeRef.current) === null || _nodeRef$current === void 0 ? void 0 : _nodeRef$current.getBoundingClientRect();\n  const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;\n  const clientOffset = monitor.getClientOffset();\n  if (!clientOffset)\n    return;\n  const hoverClientY = clientOffset.y - hoverBoundingRect.top;\n  if (hoverClientY < hoverMiddleY) {\n    return \"top\";\n  }\n  if (hoverClientY >= hoverMiddleY) {\n    return \"bottom\";\n  }\n};\nvar getNewDirection = (previousDir, dir) => {\n  if (!dir && previousDir) {\n    return \"\";\n  }\n  if (dir === \"top\" && previousDir !== \"top\") {\n    return \"top\";\n  }\n  if (dir === \"bottom\" && previousDir !== \"bottom\") {\n    return \"bottom\";\n  }\n};\nvar onDropNode = (editor, {\n  dragItem,\n  monitor,\n  nodeRef,\n  id\n}) => {\n  const direction = getHoverDirection({\n    dragItem,\n    monitor,\n    nodeRef,\n    id\n  });\n  if (!direction)\n    return;\n  const dragEntry = findNode(editor, {\n    at: [],\n    match: {\n      id: dragItem.id\n    }\n  });\n  if (!dragEntry)\n    return;\n  const [, dragPath] = dragEntry;\n  focusEditor(editor);\n  let dropPath;\n  if (direction === \"bottom\") {\n    var _findNode;\n    dropPath = (_findNode = findNode(editor, {\n      at: [],\n      match: {\n        id\n      }\n    })) === null || _findNode === void 0 ? void 0 : _findNode[1];\n    if (!dropPath)\n      return;\n    if (Path.equals(dragPath, Path.next(dropPath)))\n      return;\n  }\n  if (direction === \"top\") {\n    var _findNode2;\n    const nodePath = (_findNode2 = findNode(editor, {\n      at: [],\n      match: {\n        id\n      }\n    })) === null || _findNode2 === void 0 ? void 0 : _findNode2[1];\n    if (!nodePath)\n      return;\n    dropPath = [...nodePath.slice(0, -1), nodePath[nodePath.length - 1] - 1];\n    if (Path.equals(dragPath, dropPath))\n      return;\n  }\n  if (direction) {\n    const _dropPath = dropPath;\n    const before = Path.isBefore(dragPath, _dropPath) && Path.isSibling(dragPath, _dropPath);\n    const to = before ? _dropPath : Path.next(_dropPath);\n    moveNodes(editor, {\n      at: dragPath,\n      to\n    });\n  }\n};\nvar onHoverNode = (editor, {\n  dragItem,\n  monitor,\n  nodeRef,\n  onChangeDropLine,\n  dropLine,\n  id\n}) => {\n  const direction = getHoverDirection({\n    dragItem,\n    monitor,\n    nodeRef,\n    id\n  });\n  const dropLineDir = getNewDirection(dropLine, direction);\n  if (dropLineDir)\n    onChangeDropLine(dropLineDir);\n  if (direction && isExpanded(editor.selection)) {\n    focusEditor(editor);\n    collapseSelection(editor);\n  }\n};\nvar useDropNode = (editor, {\n  nodeRef,\n  id,\n  dropLine,\n  onChangeDropLine,\n  ...options\n}) => {\n  return useDrop({\n    drop: (dragItem, monitor) => {\n      onDropNode(editor, {\n        nodeRef,\n        id,\n        dragItem,\n        monitor\n      });\n    },\n    collect: (monitor) => ({\n      isOver: monitor.isOver()\n    }),\n    hover(item, monitor) {\n      onHoverNode(editor, {\n        nodeRef,\n        id,\n        dropLine,\n        onChangeDropLine,\n        dragItem: item,\n        monitor\n      });\n    },\n    ...options\n  });\n};\nvar useDndNode = ({\n  id,\n  type,\n  nodeRef,\n  preview: previewOptions = {},\n  drag: dragOptions,\n  drop: dropOptions\n}) => {\n  const editor = useEditorRef();\n  const [dropLine, setDropLine] = (0, import_react34.useState)(\"\");\n  const [{\n    isDragging\n  }, dragRef, preview] = useDragNode(editor, {\n    id,\n    type,\n    ...dragOptions\n  });\n  const [{\n    isOver\n  }, drop] = useDropNode(editor, {\n    accept: type,\n    id,\n    nodeRef,\n    dropLine,\n    onChangeDropLine: setDropLine,\n    ...dropOptions\n  });\n  if (previewOptions.disable) {\n    drop(nodeRef);\n    preview(getEmptyImage(), {\n      captureDraggingState: true\n    });\n  } else if (previewOptions.ref) {\n    drop(nodeRef);\n    preview(previewOptions.ref);\n  } else {\n    preview(drop(nodeRef));\n  }\n  if (!isOver && dropLine) {\n    setDropLine(\"\");\n  }\n  return {\n    isDragging,\n    isOver,\n    dropLine,\n    dragRef\n  };\n};\nvar DRAG_ITEM_BLOCK = \"block\";\nvar useDndBlock = (options) => useDndNode({\n  type: DRAG_ITEM_BLOCK,\n  ...options\n});\nvar DefaultDragHandle = ({\n  styles: styles2,\n  ...props\n}) => /* @__PURE__ */ import_react34.default.createElement(_StyledButton, _extends4({\n  type: \"button\"\n}, props, {\n  $_css: styles2\n}));\nvar Draggable = (props) => {\n  var _styles$blockAndGutte, _styles$blockAndGutte2, _styles$block$css, _styles$block, _styles$dropLine, _styles$dropLine2, _styles$gutterLeft, _styles$blockAndGutte3, _styles$blockAndGutte4, _styles$gutterLeft$cs, _styles$gutterLeft2, _styles$blockToolbarW, _styles$blockToolbarW2, _styles$blockToolbar, _styles$blockToolbar2, _styles$dragHandle, _styles$dragHandle2;\n  const {\n    children,\n    element: element4,\n    componentRef,\n    onRenderDragHandle\n  } = props;\n  const DragHandle2 = onRenderDragHandle !== null && onRenderDragHandle !== void 0 ? onRenderDragHandle : DefaultDragHandle;\n  const blockRef = (0, import_react34.useRef)(null);\n  const rootRef = (0, import_react34.useRef)(null);\n  const dragWrapperRef = (0, import_react34.useRef)(null);\n  const multiRootRef = module_default(componentRef, rootRef);\n  const {\n    dropLine,\n    dragRef,\n    isDragging\n  } = useDndBlock({\n    id: element4.id,\n    nodeRef: rootRef\n  });\n  const multiDragRef = module_default(dragRef, dragWrapperRef);\n  const styles2 = getDraggableStyles({\n    ...props,\n    direction: dropLine,\n    isDragging\n  });\n  return /* @__PURE__ */ import_react34.default.createElement(_StyledDiv2, {\n    className: styles2.root.className,\n    ref: multiRootRef,\n    $_css2: styles2.root.css\n  }, /* @__PURE__ */ import_react34.default.createElement(_StyledDiv22, {\n    ref: blockRef,\n    $_css3: [...(_styles$blockAndGutte = (_styles$blockAndGutte2 = styles2.blockAndGutter) === null || _styles$blockAndGutte2 === void 0 ? void 0 : _styles$blockAndGutte2.css) !== null && _styles$blockAndGutte !== void 0 ? _styles$blockAndGutte : [], ...(_styles$block$css = (_styles$block = styles2.block) === null || _styles$block === void 0 ? void 0 : _styles$block.css) !== null && _styles$block$css !== void 0 ? _styles$block$css : []]\n  }, children, !!dropLine && /* @__PURE__ */ import_react34.default.createElement(_StyledDiv3, {\n    className: (_styles$dropLine = styles2.dropLine) === null || _styles$dropLine === void 0 ? void 0 : _styles$dropLine.className,\n    contentEditable: false,\n    $_css4: (_styles$dropLine2 = styles2.dropLine) === null || _styles$dropLine2 === void 0 ? void 0 : _styles$dropLine2.css\n  })), /* @__PURE__ */ import_react34.default.createElement(_StyledDiv4, {\n    className: (_styles$gutterLeft = styles2.gutterLeft) === null || _styles$gutterLeft === void 0 ? void 0 : _styles$gutterLeft.className,\n    contentEditable: false,\n    $_css5: [...(_styles$blockAndGutte3 = (_styles$blockAndGutte4 = styles2.blockAndGutter) === null || _styles$blockAndGutte4 === void 0 ? void 0 : _styles$blockAndGutte4.css) !== null && _styles$blockAndGutte3 !== void 0 ? _styles$blockAndGutte3 : [], ...(_styles$gutterLeft$cs = (_styles$gutterLeft2 = styles2.gutterLeft) === null || _styles$gutterLeft2 === void 0 ? void 0 : _styles$gutterLeft2.css) !== null && _styles$gutterLeft$cs !== void 0 ? _styles$gutterLeft$cs : []]\n  }, /* @__PURE__ */ import_react34.default.createElement(_StyledDiv5, {\n    className: (_styles$blockToolbarW = styles2.blockToolbarWrapper) === null || _styles$blockToolbarW === void 0 ? void 0 : _styles$blockToolbarW.className,\n    $_css6: (_styles$blockToolbarW2 = styles2.blockToolbarWrapper) === null || _styles$blockToolbarW2 === void 0 ? void 0 : _styles$blockToolbarW2.css\n  }, /* @__PURE__ */ import_react34.default.createElement(_StyledDiv6, {\n    className: (_styles$blockToolbar = styles2.blockToolbar) === null || _styles$blockToolbar === void 0 ? void 0 : _styles$blockToolbar.className,\n    ref: multiDragRef,\n    $_css7: (_styles$blockToolbar2 = styles2.blockToolbar) === null || _styles$blockToolbar2 === void 0 ? void 0 : _styles$blockToolbar2.css\n  }, /* @__PURE__ */ import_react34.default.createElement(DragHandle2, {\n    element: element4,\n    styles: (_styles$dragHandle = styles2.dragHandle) === null || _styles$dragHandle === void 0 ? void 0 : _styles$dragHandle.css,\n    className: (_styles$dragHandle2 = styles2.dragHandle) === null || _styles$dragHandle2 === void 0 ? void 0 : _styles$dragHandle2.className,\n    onMouseDown: (e4) => e4.stopPropagation()\n  })))));\n};\nvar _StyledButton = (0, import_styled_components5.default)(\"button\").withConfig({\n  displayName: \"Draggable___StyledButton\",\n  componentId: \"sc-fk3pif-0\"\n})([\"\", \"\"], (p6) => p6.$_css);\nvar _StyledDiv2 = (0, import_styled_components5.default)(\"div\").withConfig({\n  displayName: \"Draggable___StyledDiv\",\n  componentId: \"sc-fk3pif-1\"\n})([\"\", \"\"], (p6) => p6.$_css2);\nvar _StyledDiv22 = (0, import_styled_components5.default)(\"div\").withConfig({\n  displayName: \"Draggable___StyledDiv2\",\n  componentId: \"sc-fk3pif-2\"\n})([\"\", \"\"], (p6) => p6.$_css3);\nvar _StyledDiv3 = (0, import_styled_components5.default)(\"div\").withConfig({\n  displayName: \"Draggable___StyledDiv3\",\n  componentId: \"sc-fk3pif-3\"\n})([\"\", \"\"], (p6) => p6.$_css4);\nvar _StyledDiv4 = (0, import_styled_components5.default)(\"div\").withConfig({\n  displayName: \"Draggable___StyledDiv4\",\n  componentId: \"sc-fk3pif-4\"\n})([\"\", \"\"], (p6) => p6.$_css5);\nvar _StyledDiv5 = (0, import_styled_components5.default)(\"div\").withConfig({\n  displayName: \"Draggable___StyledDiv5\",\n  componentId: \"sc-fk3pif-5\"\n})([\"\", \"\"], (p6) => p6.$_css6);\nvar _StyledDiv6 = (0, import_styled_components5.default)(\"div\").withConfig({\n  displayName: \"Draggable___StyledDiv6\",\n  componentId: \"sc-fk3pif-6\"\n})([\"\", \"\"], (p6) => p6.$_css7);\nvar withDraggable = (Component3, {\n  styles: styles2,\n  level = 0,\n  filter: filter3,\n  allowReadOnly = false,\n  onRenderDragHandle\n} = {}) => {\n  return /* @__PURE__ */ (0, import_react34.forwardRef)((props, ref) => {\n    const {\n      attributes,\n      element: element4,\n      editor\n    } = props;\n    const readOnly = useReadOnly();\n    const path = (0, import_react34.useMemo)(() => findNodePath(editor, element4), [editor, element4]);\n    const filteredOut = (0, import_react34.useMemo)(() => path && (Number.isInteger(level) && level !== path.length - 1 || filter3 && filter3(editor, path)), [path, editor]);\n    if (filteredOut || !allowReadOnly && readOnly) {\n      return /* @__PURE__ */ import_react34.default.createElement(Component3, props);\n    }\n    return /* @__PURE__ */ import_react34.default.createElement(Draggable, {\n      editor,\n      attributes,\n      element: element4,\n      componentRef: ref,\n      styles: styles2,\n      onRenderDragHandle\n    }, /* @__PURE__ */ import_react34.default.createElement(Component3, props));\n  });\n};\nvar withDraggables = createNodesWithHOC(withDraggable);\n\n// src/editor/plugins/dnd/hooks/useDropBlockOnEditor.ts\nvar useDropBlockOnEditor = (editor, {\n  nodeRef,\n  element: element4,\n  dropLine,\n  setDropLine\n}) => {\n  const id = element4.id;\n  return useDrop({\n    accept: \"block\",\n    drop: (dragItem, monitor) => {\n      const direction = getHoverDirection({ dragItem, monitor, nodeRef, id });\n      if (!direction)\n        return;\n      const dragEntry = findNode(editor, {\n        at: [],\n        match: { id: dragItem.id }\n      });\n      if (dragEntry === void 0)\n        return;\n      const [, dragPath] = dragEntry;\n      ReactEditor.focus(editor);\n      let dropPath;\n      if (direction) {\n        if (direction === \"bottom\") {\n          dropPath = findNode(editor, { at: [], match: { id } })?.[1];\n          if (dropPath === void 0)\n            return;\n          if (Path.equals(dragPath, Path.next(dropPath)))\n            return;\n        }\n        if (direction === \"top\") {\n          const nodePath = findNode(editor, { at: [], match: { id } })?.[1];\n          if (nodePath === void 0)\n            return;\n          const parentPath = nodePath.slice(0, -1);\n          dropPath = [...parentPath, nodePath[nodePath.length - 1] - 1];\n          if (Path.equals(dragPath, dropPath))\n            return;\n        }\n        if (!dropPath)\n          return;\n        const before = Path.isBefore(dragPath, dropPath) && Path.isSibling(dragPath, dropPath);\n        const to = before ? dropPath : Path.next(dropPath);\n        withoutNormalizing(editor, () => {\n          Transforms.moveNodes(editor, {\n            at: dragPath,\n            to\n          });\n          postDropNormalize(editor, dragItem, to);\n        });\n      }\n    },\n    collect: (monitor) => {\n      return {\n        isOver: monitor.isOver()\n      };\n    },\n    hover(dragItem, monitor) {\n      const direction = getHoverDirection({ dragItem, monitor, nodeRef, id });\n      const dropLineDirection = getNewDirection(dropLine, direction);\n      if (dropLineDirection)\n        setDropLine(dropLineDirection);\n      if (direction && isExpanded(editor.selection)) {\n        ReactEditor.focus(editor);\n        Transforms.collapse(editor);\n      }\n    }\n  });\n};\n\n// src/editor/plugins/dnd/hooks/useDndBlock.ts\nvar useDndBlock2 = ({\n  element: element4,\n  nodeRef,\n  path,\n  removePreview\n}) => {\n  const editor = useEditorRef();\n  const [dropLine, setDropLine] = (0, import_react35.useState)(\"\");\n  const [{ isDragging }, dragReference, preview] = useDragBlock(editor, element4, path);\n  const [{ isOver }, drop] = useDropBlockOnEditor(editor, {\n    element: element4,\n    nodeRef,\n    dropLine,\n    setDropLine\n  });\n  if (removePreview === true) {\n    drop(nodeRef);\n    preview(getEmptyImage(), { captureDraggingState: true });\n  } else {\n    preview(drop(nodeRef));\n  }\n  if (!isOver && dropLine !== \"\") {\n    setDropLine(\"\");\n  }\n  return {\n    isDragging,\n    dropLine,\n    dragRef: dragReference\n  };\n};\n\n// src/editor/plugins/dnd/components/grabberTooltipProps.tsx\nvar import_react36 = __toESM(require(\"react\"));\nvar GrabberTooltipContent = () => /* @__PURE__ */ import_react36.default.createElement(\"div\", { style: { fontSize: 12 } }, /* @__PURE__ */ import_react36.default.createElement(\"div\", null, \"Drag \", /* @__PURE__ */ import_react36.default.createElement(\"span\", { style: { color: \"rgba(255, 255, 255, 0.45)\" } }, \"to move\")));\nvar grabberTooltipProps = {\n  content: /* @__PURE__ */ import_react36.default.createElement(GrabberTooltipContent, null),\n  placement: \"bottom\",\n  arrow: false,\n  offset: [0, 0],\n  delay: [300, 0],\n  duration: [0, 0],\n  hideOnClick: true,\n  theme: \"small\"\n};\n\n// src/editor/plugins/dnd/components/Draggable.tsx\nvar DragHandle = import_styled_components6.default.button`\n  outline: 2px solid transparent;\n  outline-offset: 2px;\n  padding: 0px;\n  background-repeat: no-repeat;\n  background-color: transparent;\n  border-style: none;\n  overflow: hidden;\n  cursor: pointer;\n`;\nvar GutterLeft = import_styled_components6.default.div`\n  position: absolute;\n  top: 0px;\n  display: flex;\n  height: 100%;\n  opacity: 0;\n  transform: translateX(-100%);\n  ${({ mod }) => mod}\n`;\nvar DraggableRoot = import_styled_components6.default.div`\n  position: relative;\n  ${(0, import_typescript_styled_is.default)(\"isDragging\")`\n    opacity: 50%;\n  `}\n  & .slate-Draggable-gutterLeft:hover {\n    opacity: 100%;\n  }\n`;\nvar BlockAndGutter = import_styled_components6.default.div`\n  /* overflow: auto; */\n`;\nvar BlockToolbarWrapper = import_styled_components6.default.div`\n  display: flex;\n  height: 1.5em;\n  ${({ mod }) => mod}\n`;\nvar BlockToolbar = import_styled_components6.default.div`\n  display: flex;\n  align-items: center;\n  margin-right: 0.25rem;\n  pointer-events: auto;\n`;\nvar DropLine = import_styled_components6.default.div`\n  position: absolute;\n  margin-left: 0;\n  margin-right: 0;\n  opacity: 100%;\n  height: 0.125rem;\n  background: #b4d5ff;\n  width: 100%;\n  ${({ dropLine }) => dropLine === \"top\" ? \"top: -1px;\" : dropLine === \"bottom\" ? \"bottom: -1px;\" : \"\"}\n`;\nvar Draggable2 = (props) => {\n  const { children, element: element4, componentRef, styles: styles2, path } = props;\n  const blockReference = (0, import_react37.useRef)(null);\n  const rootReference = (0, import_react37.useRef)(null);\n  const dragWrapperReference = (0, import_react37.useRef)(null);\n  const multiRootReference = module_default(componentRef, rootReference);\n  const { dropLine, dragRef, isDragging } = useDndBlock2({\n    element: element4,\n    path,\n    nodeRef: rootReference\n  });\n  const multiDragReference = module_default(dragRef, dragWrapperReference);\n  return /* @__PURE__ */ import_react37.default.createElement(DraggableRoot, { ref: multiRootReference, isDragging }, /* @__PURE__ */ import_react37.default.createElement(BlockAndGutter, { ref: blockReference }, children, !!dropLine && /* @__PURE__ */ import_react37.default.createElement(DropLine, { contentEditable: false, dropLine })), /* @__PURE__ */ import_react37.default.createElement(GutterLeft, { className: \"slate-Draggable-gutterLeft\", mod: styles2?.gutterLeft, contentEditable: false }, /* @__PURE__ */ import_react37.default.createElement(BlockToolbarWrapper, { mod: styles2?.blockToolbarWrapper }, /* @__PURE__ */ import_react37.default.createElement(BlockToolbar, { ref: multiDragReference }, /* @__PURE__ */ import_react37.default.createElement(tippy_react_esm_default, { ...grabberTooltipProps }, /* @__PURE__ */ import_react37.default.createElement(DragHandle, { type: \"button\", onMouseDown: (event) => event.stopPropagation() }, /* @__PURE__ */ import_react37.default.createElement(\n    DragIndicator,\n    {\n      style: {\n        width: 18,\n        height: 18,\n        color: \"rgba(55, 53, 47, 0.3)\"\n      }\n    }\n  )))))));\n};\n\n// src/editor/plugins/dnd/components/withDraggable.tsx\nvar import_react39 = __toESM(require(\"react\"));\nvar withDraggable2 = (Component3, { styles: styles2, level, filter: filter3 } = {}) => {\n  return (0, import_react39.forwardRef)((props, reference2) => {\n    const { attributes, element: element4, editor } = props;\n    const readOnly = useReadOnly();\n    const path = (0, import_react39.useMemo)(() => ReactEditor.findPath(editor, element4), [editor, element4]);\n    const filteredOut = (0, import_react39.useMemo)(() => Number.isInteger(level) && level !== path.length - 1 || filter3?.(editor, path), [editor, path]);\n    if (filteredOut ?? readOnly) {\n      return /* @__PURE__ */ import_react39.default.createElement(Component3, { ...props });\n    }\n    return /* @__PURE__ */ import_react39.default.createElement(Draggable2, { editor, attributes, element: element4, componentRef: reference2, styles: styles2, path }, /* @__PURE__ */ import_react39.default.createElement(Component3, { ...props }));\n  });\n};\nvar withDraggables2 = createNodesWithHOC(withDraggable2);\n\n// node_modules/@udecode/plate-combobox/dist/index.es.js\nvar import_react41 = require(\"react\");\n\n// node_modules/downshift/dist/downshift.esm.js\nvar import_prop_types = __toESM(require_prop_types());\nvar import_react40 = require(\"react\");\nvar import_react_is = __toESM(require_react_is2());\n\n// node_modules/downshift/node_modules/tslib/tslib.es6.js\nvar __assign = function() {\n  __assign = Object.assign || function __assign4(t6) {\n    for (var s5, i5 = 1, n8 = arguments.length; i5 < n8; i5++) {\n      s5 = arguments[i5];\n      for (var p6 in s5)\n        if (Object.prototype.hasOwnProperty.call(s5, p6))\n          t6[p6] = s5[p6];\n    }\n    return t6;\n  };\n  return __assign.apply(this, arguments);\n};\n\n// node_modules/downshift/dist/downshift.esm.js\nvar idCounter2 = 0;\nfunction cbToCb(cb) {\n  return typeof cb === \"function\" ? cb : noop2;\n}\nfunction noop2() {\n}\nfunction scrollIntoView2(node, menuNode) {\n  if (!node) {\n    return;\n  }\n  const actions = index_module_default(node, {\n    boundary: menuNode,\n    block: \"nearest\",\n    scrollMode: \"if-needed\"\n  });\n  actions.forEach((_ref) => {\n    let {\n      el,\n      top: top2,\n      left: left2\n    } = _ref;\n    el.scrollTop = top2;\n    el.scrollLeft = left2;\n  });\n}\nfunction isOrContainsNode(parent2, child, environment) {\n  const result = parent2 === child || child instanceof environment.Node && parent2.contains && parent2.contains(child);\n  return result;\n}\nfunction debounce5(fn4, time) {\n  let timeoutId;\n  function cancel() {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n  }\n  function wrapper() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    cancel();\n    timeoutId = setTimeout(() => {\n      timeoutId = null;\n      fn4(...args);\n    }, time);\n  }\n  wrapper.cancel = cancel;\n  return wrapper;\n}\nfunction callAllEventHandlers() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n  return function(event) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    return fns.some((fn4) => {\n      if (fn4) {\n        fn4(event, ...args);\n      }\n      return event.preventDownshiftDefault || event.hasOwnProperty(\"nativeEvent\") && event.nativeEvent.preventDownshiftDefault;\n    });\n  };\n}\nfunction handleRefs() {\n  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    refs[_key4] = arguments[_key4];\n  }\n  return (node) => {\n    refs.forEach((ref) => {\n      if (typeof ref === \"function\") {\n        ref(node);\n      } else if (ref) {\n        ref.current = node;\n      }\n    });\n  };\n}\nfunction generateId() {\n  return String(idCounter2++);\n}\nfunction getA11yStatusMessage$1(_ref2) {\n  let {\n    isOpen,\n    resultCount,\n    previousResultCount\n  } = _ref2;\n  if (!isOpen) {\n    return \"\";\n  }\n  if (!resultCount) {\n    return \"No results are available.\";\n  }\n  if (resultCount !== previousResultCount) {\n    return resultCount + \" result\" + (resultCount === 1 ? \" is\" : \"s are\") + \" available, use up and down arrow keys to navigate. Press Enter key to select.\";\n  }\n  return \"\";\n}\nfunction unwrapArray(arg, defaultValue) {\n  arg = Array.isArray(arg) ? (\n    /* istanbul ignore next (preact) */\n    arg[0]\n  ) : arg;\n  if (!arg && defaultValue) {\n    return defaultValue;\n  } else {\n    return arg;\n  }\n}\nfunction isDOMElement2(element4) {\n  return typeof element4.type === \"string\";\n}\nfunction getElementProps(element4) {\n  return element4.props;\n}\nfunction requiredProp(fnName, propName) {\n  console.error('The property \"' + propName + '\" is required in \"' + fnName + '\"');\n}\nvar stateKeys = [\"highlightedIndex\", \"inputValue\", \"isOpen\", \"selectedItem\", \"type\"];\nfunction pickState(state) {\n  if (state === void 0) {\n    state = {};\n  }\n  const result = {};\n  stateKeys.forEach((k3) => {\n    if (state.hasOwnProperty(k3)) {\n      result[k3] = state[k3];\n    }\n  });\n  return result;\n}\nfunction getState(state, props) {\n  return Object.keys(state).reduce((prevState, key) => {\n    prevState[key] = isControlledProp(props, key) ? props[key] : state[key];\n    return prevState;\n  }, {});\n}\nfunction isControlledProp(props, key) {\n  return props[key] !== void 0;\n}\nfunction normalizeArrowKey(event) {\n  const {\n    key,\n    keyCode\n  } = event;\n  if (keyCode >= 37 && keyCode <= 40 && key.indexOf(\"Arrow\") !== 0) {\n    return \"Arrow\" + key;\n  }\n  return key;\n}\nfunction isPlainObject4(obj) {\n  return Object.prototype.toString.call(obj) === \"[object Object]\";\n}\nfunction getNextWrappingIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {\n  if (circular === void 0) {\n    circular = true;\n  }\n  if (itemCount === 0) {\n    return -1;\n  }\n  const itemsLastIndex = itemCount - 1;\n  if (typeof baseIndex !== \"number\" || baseIndex < 0 || baseIndex >= itemCount) {\n    baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;\n  }\n  let newIndex = baseIndex + moveAmount;\n  if (newIndex < 0) {\n    newIndex = circular ? itemsLastIndex : 0;\n  } else if (newIndex > itemsLastIndex) {\n    newIndex = circular ? 0 : itemsLastIndex;\n  }\n  const nonDisabledNewIndex = getNextNonDisabledIndex(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular);\n  if (nonDisabledNewIndex === -1) {\n    return baseIndex >= itemCount ? -1 : baseIndex;\n  }\n  return nonDisabledNewIndex;\n}\nfunction getNextNonDisabledIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {\n  const currentElementNode = getItemNodeFromIndex(baseIndex);\n  if (!currentElementNode || !currentElementNode.hasAttribute(\"disabled\")) {\n    return baseIndex;\n  }\n  if (moveAmount > 0) {\n    for (let index5 = baseIndex + 1; index5 < itemCount; index5++) {\n      if (!getItemNodeFromIndex(index5).hasAttribute(\"disabled\")) {\n        return index5;\n      }\n    }\n  } else {\n    for (let index5 = baseIndex - 1; index5 >= 0; index5--) {\n      if (!getItemNodeFromIndex(index5).hasAttribute(\"disabled\")) {\n        return index5;\n      }\n    }\n  }\n  if (circular) {\n    return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);\n  }\n  return -1;\n}\nfunction targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {\n  if (checkActiveElement === void 0) {\n    checkActiveElement = true;\n  }\n  return downshiftElements.some((contextNode) => contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment)));\n}\nvar validateControlledUnchanged = noop2;\nif (true) {\n  validateControlledUnchanged = (state, prevProps, nextProps) => {\n    const warningDescription = \"This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/downshift-js/downshift#control-props\";\n    Object.keys(state).forEach((propKey) => {\n      if (prevProps[propKey] !== void 0 && nextProps[propKey] === void 0) {\n        console.error('downshift: A component has changed the controlled prop \"' + propKey + '\" to be uncontrolled. ' + warningDescription);\n      } else if (prevProps[propKey] === void 0 && nextProps[propKey] !== void 0) {\n        console.error('downshift: A component has changed the uncontrolled prop \"' + propKey + '\" to be controlled. ' + warningDescription);\n      }\n    });\n  };\n}\nvar cleanupStatus = debounce5((documentProp) => {\n  getStatusDiv(documentProp).textContent = \"\";\n}, 500);\nfunction setStatus(status, documentProp) {\n  const div3 = getStatusDiv(documentProp);\n  if (!status) {\n    return;\n  }\n  div3.textContent = status;\n  cleanupStatus(documentProp);\n}\nfunction getStatusDiv(documentProp) {\n  if (documentProp === void 0) {\n    documentProp = document;\n  }\n  let statusDiv = documentProp.getElementById(\"a11y-status-message\");\n  if (statusDiv) {\n    return statusDiv;\n  }\n  statusDiv = documentProp.createElement(\"div\");\n  statusDiv.setAttribute(\"id\", \"a11y-status-message\");\n  statusDiv.setAttribute(\"role\", \"status\");\n  statusDiv.setAttribute(\"aria-live\", \"polite\");\n  statusDiv.setAttribute(\"aria-relevant\", \"additions text\");\n  Object.assign(statusDiv.style, {\n    border: \"0\",\n    clip: \"rect(0 0 0 0)\",\n    height: \"1px\",\n    margin: \"-1px\",\n    overflow: \"hidden\",\n    padding: \"0\",\n    position: \"absolute\",\n    width: \"1px\"\n  });\n  documentProp.body.appendChild(statusDiv);\n  return statusDiv;\n}\nvar unknown = true ? \"__autocomplete_unknown__\" : 0;\nvar mouseUp = true ? \"__autocomplete_mouseup__\" : 1;\nvar itemMouseEnter = true ? \"__autocomplete_item_mouseenter__\" : 2;\nvar keyDownArrowUp = true ? \"__autocomplete_keydown_arrow_up__\" : 3;\nvar keyDownArrowDown = true ? \"__autocomplete_keydown_arrow_down__\" : 4;\nvar keyDownEscape = true ? \"__autocomplete_keydown_escape__\" : 5;\nvar keyDownEnter = true ? \"__autocomplete_keydown_enter__\" : 6;\nvar keyDownHome = true ? \"__autocomplete_keydown_home__\" : 7;\nvar keyDownEnd = true ? \"__autocomplete_keydown_end__\" : 8;\nvar clickItem = true ? \"__autocomplete_click_item__\" : 9;\nvar blurInput = true ? \"__autocomplete_blur_input__\" : 10;\nvar changeInput = true ? \"__autocomplete_change_input__\" : 11;\nvar keyDownSpaceButton = true ? \"__autocomplete_keydown_space_button__\" : 12;\nvar clickButton = true ? \"__autocomplete_click_button__\" : 13;\nvar blurButton = true ? \"__autocomplete_blur_button__\" : 14;\nvar controlledPropUpdatedSelectedItem = true ? \"__autocomplete_controlled_prop_updated_selected_item__\" : 15;\nvar touchEnd = true ? \"__autocomplete_touchend__\" : 16;\nvar stateChangeTypes$3 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  unknown,\n  mouseUp,\n  itemMouseEnter,\n  keyDownArrowUp,\n  keyDownArrowDown,\n  keyDownEscape,\n  keyDownEnter,\n  keyDownHome,\n  keyDownEnd,\n  clickItem,\n  blurInput,\n  changeInput,\n  keyDownSpaceButton,\n  clickButton,\n  blurButton,\n  controlledPropUpdatedSelectedItem,\n  touchEnd\n});\nvar Downshift = /* @__PURE__ */ (() => {\n  class Downshift2 extends import_react40.Component {\n    constructor(_props) {\n      var _this;\n      super(_props);\n      _this = this;\n      this.id = this.props.id || \"downshift-\" + generateId();\n      this.menuId = this.props.menuId || this.id + \"-menu\";\n      this.labelId = this.props.labelId || this.id + \"-label\";\n      this.inputId = this.props.inputId || this.id + \"-input\";\n      this.getItemId = this.props.getItemId || ((index5) => this.id + \"-item-\" + index5);\n      this.input = null;\n      this.items = [];\n      this.itemCount = null;\n      this.previousResultCount = 0;\n      this.timeoutIds = [];\n      this.internalSetTimeout = (fn4, time) => {\n        const id = setTimeout(() => {\n          this.timeoutIds = this.timeoutIds.filter((i5) => i5 !== id);\n          fn4();\n        }, time);\n        this.timeoutIds.push(id);\n      };\n      this.setItemCount = (count2) => {\n        this.itemCount = count2;\n      };\n      this.unsetItemCount = () => {\n        this.itemCount = null;\n      };\n      this.setHighlightedIndex = function(highlightedIndex, otherStateToSet) {\n        if (highlightedIndex === void 0) {\n          highlightedIndex = _this.props.defaultHighlightedIndex;\n        }\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n        otherStateToSet = pickState(otherStateToSet);\n        _this.internalSetState({\n          highlightedIndex,\n          ...otherStateToSet\n        });\n      };\n      this.clearSelection = (cb) => {\n        this.internalSetState({\n          selectedItem: null,\n          inputValue: \"\",\n          highlightedIndex: this.props.defaultHighlightedIndex,\n          isOpen: this.props.defaultIsOpen\n        }, cb);\n      };\n      this.selectItem = (item, otherStateToSet, cb) => {\n        otherStateToSet = pickState(otherStateToSet);\n        this.internalSetState({\n          isOpen: this.props.defaultIsOpen,\n          highlightedIndex: this.props.defaultHighlightedIndex,\n          selectedItem: item,\n          inputValue: this.props.itemToString(item),\n          ...otherStateToSet\n        }, cb);\n      };\n      this.selectItemAtIndex = (itemIndex, otherStateToSet, cb) => {\n        const item = this.items[itemIndex];\n        if (item == null) {\n          return;\n        }\n        this.selectItem(item, otherStateToSet, cb);\n      };\n      this.selectHighlightedItem = (otherStateToSet, cb) => {\n        return this.selectItemAtIndex(this.getState().highlightedIndex, otherStateToSet, cb);\n      };\n      this.internalSetState = (stateToSet, cb) => {\n        let isItemSelected, onChangeArg;\n        const onStateChangeArg = {};\n        const isStateToSetFunction = typeof stateToSet === \"function\";\n        if (!isStateToSetFunction && stateToSet.hasOwnProperty(\"inputValue\")) {\n          this.props.onInputValueChange(stateToSet.inputValue, {\n            ...this.getStateAndHelpers(),\n            ...stateToSet\n          });\n        }\n        return this.setState((state) => {\n          state = this.getState(state);\n          let newStateToSet = isStateToSetFunction ? stateToSet(state) : stateToSet;\n          newStateToSet = this.props.stateReducer(state, newStateToSet);\n          isItemSelected = newStateToSet.hasOwnProperty(\"selectedItem\");\n          const nextState = {};\n          if (isItemSelected && newStateToSet.selectedItem !== state.selectedItem) {\n            onChangeArg = newStateToSet.selectedItem;\n          }\n          newStateToSet.type = newStateToSet.type || unknown;\n          Object.keys(newStateToSet).forEach((key) => {\n            if (state[key] !== newStateToSet[key]) {\n              onStateChangeArg[key] = newStateToSet[key];\n            }\n            if (key === \"type\") {\n              return;\n            }\n            newStateToSet[key];\n            if (!isControlledProp(this.props, key)) {\n              nextState[key] = newStateToSet[key];\n            }\n          });\n          if (isStateToSetFunction && newStateToSet.hasOwnProperty(\"inputValue\")) {\n            this.props.onInputValueChange(newStateToSet.inputValue, {\n              ...this.getStateAndHelpers(),\n              ...newStateToSet\n            });\n          }\n          return nextState;\n        }, () => {\n          cbToCb(cb)();\n          const hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;\n          if (hasMoreStateThanType) {\n            this.props.onStateChange(onStateChangeArg, this.getStateAndHelpers());\n          }\n          if (isItemSelected) {\n            this.props.onSelect(stateToSet.selectedItem, this.getStateAndHelpers());\n          }\n          if (onChangeArg !== void 0) {\n            this.props.onChange(onChangeArg, this.getStateAndHelpers());\n          }\n          this.props.onUserAction(onStateChangeArg, this.getStateAndHelpers());\n        });\n      };\n      this.rootRef = (node) => this._rootNode = node;\n      this.getRootProps = function(_temp, _temp2) {\n        let {\n          refKey = \"ref\",\n          ref,\n          ...rest\n        } = _temp === void 0 ? {} : _temp;\n        let {\n          suppressRefError = false\n        } = _temp2 === void 0 ? {} : _temp2;\n        _this.getRootProps.called = true;\n        _this.getRootProps.refKey = refKey;\n        _this.getRootProps.suppressRefError = suppressRefError;\n        const {\n          isOpen\n        } = _this.getState();\n        return {\n          [refKey]: handleRefs(ref, _this.rootRef),\n          role: \"combobox\",\n          \"aria-expanded\": isOpen,\n          \"aria-haspopup\": \"listbox\",\n          \"aria-owns\": isOpen ? _this.menuId : null,\n          \"aria-labelledby\": _this.labelId,\n          ...rest\n        };\n      };\n      this.keyDownHandlers = {\n        ArrowDown(event) {\n          event.preventDefault();\n          if (this.getState().isOpen) {\n            const amount = event.shiftKey ? 5 : 1;\n            this.moveHighlightedIndex(amount, {\n              type: keyDownArrowDown\n            });\n          } else {\n            this.internalSetState({\n              isOpen: true,\n              type: keyDownArrowDown\n            }, () => {\n              const itemCount = this.getItemCount();\n              if (itemCount > 0) {\n                const {\n                  highlightedIndex\n                } = this.getState();\n                const nextHighlightedIndex = getNextWrappingIndex(1, highlightedIndex, itemCount, (index5) => this.getItemNodeFromIndex(index5));\n                this.setHighlightedIndex(nextHighlightedIndex, {\n                  type: keyDownArrowDown\n                });\n              }\n            });\n          }\n        },\n        ArrowUp(event) {\n          event.preventDefault();\n          if (this.getState().isOpen) {\n            const amount = event.shiftKey ? -5 : -1;\n            this.moveHighlightedIndex(amount, {\n              type: keyDownArrowUp\n            });\n          } else {\n            this.internalSetState({\n              isOpen: true,\n              type: keyDownArrowUp\n            }, () => {\n              const itemCount = this.getItemCount();\n              if (itemCount > 0) {\n                const {\n                  highlightedIndex\n                } = this.getState();\n                const nextHighlightedIndex = getNextWrappingIndex(-1, highlightedIndex, itemCount, (index5) => this.getItemNodeFromIndex(index5));\n                this.setHighlightedIndex(nextHighlightedIndex, {\n                  type: keyDownArrowUp\n                });\n              }\n            });\n          }\n        },\n        Enter(event) {\n          if (event.which === 229) {\n            return;\n          }\n          const {\n            isOpen,\n            highlightedIndex\n          } = this.getState();\n          if (isOpen && highlightedIndex != null) {\n            event.preventDefault();\n            const item = this.items[highlightedIndex];\n            const itemNode = this.getItemNodeFromIndex(highlightedIndex);\n            if (item == null || itemNode && itemNode.hasAttribute(\"disabled\")) {\n              return;\n            }\n            this.selectHighlightedItem({\n              type: keyDownEnter\n            });\n          }\n        },\n        Escape(event) {\n          event.preventDefault();\n          this.reset({\n            type: keyDownEscape,\n            ...!this.state.isOpen && {\n              selectedItem: null,\n              inputValue: \"\"\n            }\n          });\n        }\n      };\n      this.buttonKeyDownHandlers = {\n        ...this.keyDownHandlers,\n        \" \"(event) {\n          event.preventDefault();\n          this.toggleMenu({\n            type: keyDownSpaceButton\n          });\n        }\n      };\n      this.inputKeyDownHandlers = {\n        ...this.keyDownHandlers,\n        Home(event) {\n          const {\n            isOpen\n          } = this.getState();\n          if (!isOpen) {\n            return;\n          }\n          event.preventDefault();\n          const itemCount = this.getItemCount();\n          if (itemCount <= 0 || !isOpen) {\n            return;\n          }\n          const newHighlightedIndex = getNextNonDisabledIndex(1, 0, itemCount, (index5) => this.getItemNodeFromIndex(index5), false);\n          this.setHighlightedIndex(newHighlightedIndex, {\n            type: keyDownHome\n          });\n        },\n        End(event) {\n          const {\n            isOpen\n          } = this.getState();\n          if (!isOpen) {\n            return;\n          }\n          event.preventDefault();\n          const itemCount = this.getItemCount();\n          if (itemCount <= 0 || !isOpen) {\n            return;\n          }\n          const newHighlightedIndex = getNextNonDisabledIndex(-1, itemCount - 1, itemCount, (index5) => this.getItemNodeFromIndex(index5), false);\n          this.setHighlightedIndex(newHighlightedIndex, {\n            type: keyDownEnd\n          });\n        }\n      };\n      this.getToggleButtonProps = function(_temp3) {\n        let {\n          onClick,\n          onPress,\n          onKeyDown,\n          onKeyUp,\n          onBlur,\n          ...rest\n        } = _temp3 === void 0 ? {} : _temp3;\n        const {\n          isOpen\n        } = _this.getState();\n        const enabledEventHandlers = {\n          onClick: callAllEventHandlers(onClick, _this.buttonHandleClick),\n          onKeyDown: callAllEventHandlers(onKeyDown, _this.buttonHandleKeyDown),\n          onKeyUp: callAllEventHandlers(onKeyUp, _this.buttonHandleKeyUp),\n          onBlur: callAllEventHandlers(onBlur, _this.buttonHandleBlur)\n        };\n        const eventHandlers = rest.disabled ? {} : enabledEventHandlers;\n        return {\n          type: \"button\",\n          role: \"button\",\n          \"aria-label\": isOpen ? \"close menu\" : \"open menu\",\n          \"aria-haspopup\": true,\n          \"data-toggle\": true,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n      this.buttonHandleKeyUp = (event) => {\n        event.preventDefault();\n      };\n      this.buttonHandleKeyDown = (event) => {\n        const key = normalizeArrowKey(event);\n        if (this.buttonKeyDownHandlers[key]) {\n          this.buttonKeyDownHandlers[key].call(this, event);\n        }\n      };\n      this.buttonHandleClick = (event) => {\n        event.preventDefault();\n        if (this.props.environment.document.activeElement === this.props.environment.document.body) {\n          event.target.focus();\n        }\n        if (false) {\n          this.toggleMenu({\n            type: clickButton\n          });\n        } else {\n          this.internalSetTimeout(() => this.toggleMenu({\n            type: clickButton\n          }));\n        }\n      };\n      this.buttonHandleBlur = (event) => {\n        const blurTarget = event.target;\n        this.internalSetTimeout(() => {\n          if (!this.isMouseDown && (this.props.environment.document.activeElement == null || this.props.environment.document.activeElement.id !== this.inputId) && this.props.environment.document.activeElement !== blurTarget) {\n            this.reset({\n              type: blurButton\n            });\n          }\n        });\n      };\n      this.getLabelProps = (props) => {\n        return {\n          htmlFor: this.inputId,\n          id: this.labelId,\n          ...props\n        };\n      };\n      this.getInputProps = function(_temp4) {\n        let {\n          onKeyDown,\n          onBlur,\n          onChange,\n          onInput,\n          onChangeText,\n          ...rest\n        } = _temp4 === void 0 ? {} : _temp4;\n        let onChangeKey;\n        let eventHandlers = {};\n        {\n          onChangeKey = \"onChange\";\n        }\n        const {\n          inputValue,\n          isOpen,\n          highlightedIndex\n        } = _this.getState();\n        if (!rest.disabled) {\n          eventHandlers = {\n            [onChangeKey]: callAllEventHandlers(onChange, onInput, _this.inputHandleChange),\n            onKeyDown: callAllEventHandlers(onKeyDown, _this.inputHandleKeyDown),\n            onBlur: callAllEventHandlers(onBlur, _this.inputHandleBlur)\n          };\n        }\n        return {\n          \"aria-autocomplete\": \"list\",\n          \"aria-activedescendant\": isOpen && typeof highlightedIndex === \"number\" && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : null,\n          \"aria-controls\": isOpen ? _this.menuId : null,\n          \"aria-labelledby\": _this.labelId,\n          // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion\n          // revert back since autocomplete=\"nope\" is ignored on latest Chrome and Opera\n          autoComplete: \"off\",\n          value: inputValue,\n          id: _this.inputId,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n      this.inputHandleKeyDown = (event) => {\n        const key = normalizeArrowKey(event);\n        if (key && this.inputKeyDownHandlers[key]) {\n          this.inputKeyDownHandlers[key].call(this, event);\n        }\n      };\n      this.inputHandleChange = (event) => {\n        this.internalSetState({\n          type: changeInput,\n          isOpen: true,\n          inputValue: event.target.value,\n          highlightedIndex: this.props.defaultHighlightedIndex\n        });\n      };\n      this.inputHandleBlur = () => {\n        this.internalSetTimeout(() => {\n          const downshiftButtonIsActive = this.props.environment.document && !!this.props.environment.document.activeElement && !!this.props.environment.document.activeElement.dataset && this.props.environment.document.activeElement.dataset.toggle && this._rootNode && this._rootNode.contains(this.props.environment.document.activeElement);\n          if (!this.isMouseDown && !downshiftButtonIsActive) {\n            this.reset({\n              type: blurInput\n            });\n          }\n        });\n      };\n      this.menuRef = (node) => {\n        this._menuNode = node;\n      };\n      this.getMenuProps = function(_temp5, _temp6) {\n        let {\n          refKey = \"ref\",\n          ref,\n          ...props\n        } = _temp5 === void 0 ? {} : _temp5;\n        let {\n          suppressRefError = false\n        } = _temp6 === void 0 ? {} : _temp6;\n        _this.getMenuProps.called = true;\n        _this.getMenuProps.refKey = refKey;\n        _this.getMenuProps.suppressRefError = suppressRefError;\n        return {\n          [refKey]: handleRefs(ref, _this.menuRef),\n          role: \"listbox\",\n          \"aria-labelledby\": props && props[\"aria-label\"] ? null : _this.labelId,\n          id: _this.menuId,\n          ...props\n        };\n      };\n      this.getItemProps = function(_temp7) {\n        let {\n          onMouseMove,\n          onMouseDown,\n          onClick,\n          onPress,\n          index: index5,\n          item = false ? (\n            /* istanbul ignore next */\n            void 0\n          ) : requiredProp(\"getItemProps\", \"item\"),\n          ...rest\n        } = _temp7 === void 0 ? {} : _temp7;\n        if (index5 === void 0) {\n          _this.items.push(item);\n          index5 = _this.items.indexOf(item);\n        } else {\n          _this.items[index5] = item;\n        }\n        const onSelectKey = \"onClick\";\n        const customClickHandler = onClick;\n        const enabledEventHandlers = {\n          // onMouseMove is used over onMouseEnter here. onMouseMove\n          // is only triggered on actual mouse movement while onMouseEnter\n          // can fire on DOM changes, interrupting keyboard navigation\n          onMouseMove: callAllEventHandlers(onMouseMove, () => {\n            if (index5 === _this.getState().highlightedIndex) {\n              return;\n            }\n            _this.setHighlightedIndex(index5, {\n              type: itemMouseEnter\n            });\n            _this.avoidScrolling = true;\n            _this.internalSetTimeout(() => _this.avoidScrolling = false, 250);\n          }),\n          onMouseDown: callAllEventHandlers(onMouseDown, (event) => {\n            event.preventDefault();\n          }),\n          [onSelectKey]: callAllEventHandlers(customClickHandler, () => {\n            _this.selectItemAtIndex(index5, {\n              type: clickItem\n            });\n          })\n        };\n        const eventHandlers = rest.disabled ? {\n          onMouseDown: enabledEventHandlers.onMouseDown\n        } : enabledEventHandlers;\n        return {\n          id: _this.getItemId(index5),\n          role: \"option\",\n          \"aria-selected\": _this.getState().highlightedIndex === index5,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n      this.clearItems = () => {\n        this.items = [];\n      };\n      this.reset = function(otherStateToSet, cb) {\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n        otherStateToSet = pickState(otherStateToSet);\n        _this.internalSetState((_ref) => {\n          let {\n            selectedItem\n          } = _ref;\n          return {\n            isOpen: _this.props.defaultIsOpen,\n            highlightedIndex: _this.props.defaultHighlightedIndex,\n            inputValue: _this.props.itemToString(selectedItem),\n            ...otherStateToSet\n          };\n        }, cb);\n      };\n      this.toggleMenu = function(otherStateToSet, cb) {\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n        otherStateToSet = pickState(otherStateToSet);\n        _this.internalSetState((_ref2) => {\n          let {\n            isOpen\n          } = _ref2;\n          return {\n            isOpen: !isOpen,\n            ...isOpen && {\n              highlightedIndex: _this.props.defaultHighlightedIndex\n            },\n            ...otherStateToSet\n          };\n        }, () => {\n          const {\n            isOpen,\n            highlightedIndex\n          } = _this.getState();\n          if (isOpen) {\n            if (_this.getItemCount() > 0 && typeof highlightedIndex === \"number\") {\n              _this.setHighlightedIndex(highlightedIndex, otherStateToSet);\n            }\n          }\n          cbToCb(cb)();\n        });\n      };\n      this.openMenu = (cb) => {\n        this.internalSetState({\n          isOpen: true\n        }, cb);\n      };\n      this.closeMenu = (cb) => {\n        this.internalSetState({\n          isOpen: false\n        }, cb);\n      };\n      this.updateStatus = debounce5(() => {\n        const state = this.getState();\n        const item = this.items[state.highlightedIndex];\n        const resultCount = this.getItemCount();\n        const status = this.props.getA11yStatusMessage({\n          itemToString: this.props.itemToString,\n          previousResultCount: this.previousResultCount,\n          resultCount,\n          highlightedItem: item,\n          ...state\n        });\n        this.previousResultCount = resultCount;\n        setStatus(status, this.props.environment.document);\n      }, 200);\n      const {\n        defaultHighlightedIndex,\n        initialHighlightedIndex: _highlightedIndex = defaultHighlightedIndex,\n        defaultIsOpen,\n        initialIsOpen: _isOpen = defaultIsOpen,\n        initialInputValue: _inputValue = \"\",\n        initialSelectedItem: _selectedItem = null\n      } = this.props;\n      const _state = this.getState({\n        highlightedIndex: _highlightedIndex,\n        isOpen: _isOpen,\n        inputValue: _inputValue,\n        selectedItem: _selectedItem\n      });\n      if (_state.selectedItem != null && this.props.initialInputValue === void 0) {\n        _state.inputValue = this.props.itemToString(_state.selectedItem);\n      }\n      this.state = _state;\n    }\n    /**\n     * Clear all running timeouts\n     */\n    internalClearTimeouts() {\n      this.timeoutIds.forEach((id) => {\n        clearTimeout(id);\n      });\n      this.timeoutIds = [];\n    }\n    /**\n     * Gets the state based on internal state or props\n     * If a state value is passed via props, then that\n     * is the value given, otherwise it's retrieved from\n     * stateToMerge\n     *\n     * @param {Object} stateToMerge defaults to this.state\n     * @return {Object} the state\n     */\n    getState(stateToMerge) {\n      if (stateToMerge === void 0) {\n        stateToMerge = this.state;\n      }\n      return getState(stateToMerge, this.props);\n    }\n    getItemCount() {\n      let itemCount = this.items.length;\n      if (this.itemCount != null) {\n        itemCount = this.itemCount;\n      } else if (this.props.itemCount !== void 0) {\n        itemCount = this.props.itemCount;\n      }\n      return itemCount;\n    }\n    getItemNodeFromIndex(index5) {\n      return this.props.environment.document.getElementById(this.getItemId(index5));\n    }\n    scrollHighlightedItemIntoView() {\n      {\n        const node = this.getItemNodeFromIndex(this.getState().highlightedIndex);\n        this.props.scrollIntoView(node, this._menuNode);\n      }\n    }\n    moveHighlightedIndex(amount, otherStateToSet) {\n      const itemCount = this.getItemCount();\n      const {\n        highlightedIndex\n      } = this.getState();\n      if (itemCount > 0) {\n        const nextHighlightedIndex = getNextWrappingIndex(amount, highlightedIndex, itemCount, (index5) => this.getItemNodeFromIndex(index5));\n        this.setHighlightedIndex(nextHighlightedIndex, otherStateToSet);\n      }\n    }\n    getStateAndHelpers() {\n      const {\n        highlightedIndex,\n        inputValue,\n        selectedItem,\n        isOpen\n      } = this.getState();\n      const {\n        itemToString: itemToString2\n      } = this.props;\n      const {\n        id\n      } = this;\n      const {\n        getRootProps: getRootProps2,\n        getToggleButtonProps,\n        getLabelProps,\n        getMenuProps,\n        getInputProps,\n        getItemProps,\n        openMenu,\n        closeMenu,\n        toggleMenu,\n        selectItem,\n        selectItemAtIndex,\n        selectHighlightedItem,\n        setHighlightedIndex,\n        clearSelection,\n        clearItems,\n        reset,\n        setItemCount,\n        unsetItemCount,\n        internalSetState: setState\n      } = this;\n      return {\n        // prop getters\n        getRootProps: getRootProps2,\n        getToggleButtonProps,\n        getLabelProps,\n        getMenuProps,\n        getInputProps,\n        getItemProps,\n        // actions\n        reset,\n        openMenu,\n        closeMenu,\n        toggleMenu,\n        selectItem,\n        selectItemAtIndex,\n        selectHighlightedItem,\n        setHighlightedIndex,\n        clearSelection,\n        clearItems,\n        setItemCount,\n        unsetItemCount,\n        setState,\n        // props\n        itemToString: itemToString2,\n        // derived\n        id,\n        // state\n        highlightedIndex,\n        inputValue,\n        isOpen,\n        selectedItem\n      };\n    }\n    //////////////////////////// ROOT\n    componentDidMount() {\n      if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {\n        validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);\n      }\n      {\n        const onMouseDown = () => {\n          this.isMouseDown = true;\n        };\n        const onMouseUp = (event) => {\n          this.isMouseDown = false;\n          const contextWithinDownshift = targetWithinDownshift(event.target, [this._rootNode, this._menuNode], this.props.environment);\n          if (!contextWithinDownshift && this.getState().isOpen) {\n            this.reset({\n              type: mouseUp\n            }, () => this.props.onOuterClick(this.getStateAndHelpers()));\n          }\n        };\n        const onTouchStart = () => {\n          this.isTouchMove = false;\n        };\n        const onTouchMove = () => {\n          this.isTouchMove = true;\n        };\n        const onTouchEnd = (event) => {\n          const contextWithinDownshift = targetWithinDownshift(event.target, [this._rootNode, this._menuNode], this.props.environment, false);\n          if (!this.isTouchMove && !contextWithinDownshift && this.getState().isOpen) {\n            this.reset({\n              type: touchEnd\n            }, () => this.props.onOuterClick(this.getStateAndHelpers()));\n          }\n        };\n        const {\n          environment\n        } = this.props;\n        environment.addEventListener(\"mousedown\", onMouseDown);\n        environment.addEventListener(\"mouseup\", onMouseUp);\n        environment.addEventListener(\"touchstart\", onTouchStart);\n        environment.addEventListener(\"touchmove\", onTouchMove);\n        environment.addEventListener(\"touchend\", onTouchEnd);\n        this.cleanup = () => {\n          this.internalClearTimeouts();\n          this.updateStatus.cancel();\n          environment.removeEventListener(\"mousedown\", onMouseDown);\n          environment.removeEventListener(\"mouseup\", onMouseUp);\n          environment.removeEventListener(\"touchstart\", onTouchStart);\n          environment.removeEventListener(\"touchmove\", onTouchMove);\n          environment.removeEventListener(\"touchend\", onTouchEnd);\n        };\n      }\n    }\n    shouldScroll(prevState, prevProps) {\n      const {\n        highlightedIndex: currentHighlightedIndex\n      } = this.props.highlightedIndex === void 0 ? this.getState() : this.props;\n      const {\n        highlightedIndex: prevHighlightedIndex\n      } = prevProps.highlightedIndex === void 0 ? prevState : prevProps;\n      const scrollWhenOpen = currentHighlightedIndex && this.getState().isOpen && !prevState.isOpen;\n      const scrollWhenNavigating = currentHighlightedIndex !== prevHighlightedIndex;\n      return scrollWhenOpen || scrollWhenNavigating;\n    }\n    componentDidUpdate(prevProps, prevState) {\n      if (true) {\n        validateControlledUnchanged(this.state, prevProps, this.props);\n        if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {\n          validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);\n        }\n      }\n      if (isControlledProp(this.props, \"selectedItem\") && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {\n        this.internalSetState({\n          type: controlledPropUpdatedSelectedItem,\n          inputValue: this.props.itemToString(this.props.selectedItem)\n        });\n      }\n      if (!this.avoidScrolling && this.shouldScroll(prevState, prevProps)) {\n        this.scrollHighlightedItemIntoView();\n      }\n      {\n        this.updateStatus();\n      }\n    }\n    componentWillUnmount() {\n      this.cleanup();\n    }\n    render() {\n      const children = unwrapArray(this.props.children, noop2);\n      this.clearItems();\n      this.getRootProps.called = false;\n      this.getRootProps.refKey = void 0;\n      this.getRootProps.suppressRefError = void 0;\n      this.getMenuProps.called = false;\n      this.getMenuProps.refKey = void 0;\n      this.getMenuProps.suppressRefError = void 0;\n      this.getLabelProps.called = false;\n      this.getInputProps.called = false;\n      const element4 = unwrapArray(children(this.getStateAndHelpers()));\n      if (!element4) {\n        return null;\n      }\n      if (this.getRootProps.called || this.props.suppressRefError) {\n        if (!this.getRootProps.suppressRefError && !this.props.suppressRefError) {\n          validateGetRootPropsCalledCorrectly(element4, this.getRootProps);\n        }\n        return element4;\n      } else if (isDOMElement2(element4)) {\n        return /* @__PURE__ */ (0, import_react40.cloneElement)(element4, this.getRootProps(getElementProps(element4)));\n      }\n      if (true) {\n        throw new Error(\"downshift: If you return a non-DOM element, you must apply the getRootProps function\");\n      }\n      return void 0;\n    }\n  }\n  Downshift2.defaultProps = {\n    defaultHighlightedIndex: null,\n    defaultIsOpen: false,\n    getA11yStatusMessage: getA11yStatusMessage$1,\n    itemToString: (i5) => {\n      if (i5 == null) {\n        return \"\";\n      }\n      if (isPlainObject4(i5) && !i5.hasOwnProperty(\"toString\")) {\n        console.warn(\"downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.\", \"The object that was passed:\", i5);\n      }\n      return String(i5);\n    },\n    onStateChange: noop2,\n    onInputValueChange: noop2,\n    onUserAction: noop2,\n    onChange: noop2,\n    onSelect: noop2,\n    onOuterClick: noop2,\n    selectedItemChanged: (prevItem, item) => prevItem !== item,\n    environment: (\n      /* istanbul ignore next (ssr) */\n      typeof window === \"undefined\" ? {} : window\n    ),\n    stateReducer: (state, stateToSet) => stateToSet,\n    suppressRefError: false,\n    scrollIntoView: scrollIntoView2\n  };\n  Downshift2.stateChangeTypes = stateChangeTypes$3;\n  return Downshift2;\n})();\ntrue ? Downshift.propTypes = {\n  children: import_prop_types.default.func,\n  defaultHighlightedIndex: import_prop_types.default.number,\n  defaultIsOpen: import_prop_types.default.bool,\n  initialHighlightedIndex: import_prop_types.default.number,\n  initialSelectedItem: import_prop_types.default.any,\n  initialInputValue: import_prop_types.default.string,\n  initialIsOpen: import_prop_types.default.bool,\n  getA11yStatusMessage: import_prop_types.default.func,\n  itemToString: import_prop_types.default.func,\n  onChange: import_prop_types.default.func,\n  onSelect: import_prop_types.default.func,\n  onStateChange: import_prop_types.default.func,\n  onInputValueChange: import_prop_types.default.func,\n  onUserAction: import_prop_types.default.func,\n  onOuterClick: import_prop_types.default.func,\n  selectedItemChanged: import_prop_types.default.func,\n  stateReducer: import_prop_types.default.func,\n  itemCount: import_prop_types.default.number,\n  id: import_prop_types.default.string,\n  environment: import_prop_types.default.shape({\n    addEventListener: import_prop_types.default.func,\n    removeEventListener: import_prop_types.default.func,\n    document: import_prop_types.default.shape({\n      getElementById: import_prop_types.default.func,\n      activeElement: import_prop_types.default.any,\n      body: import_prop_types.default.any\n    })\n  }),\n  suppressRefError: import_prop_types.default.bool,\n  scrollIntoView: import_prop_types.default.func,\n  // things we keep in state for uncontrolled components\n  // but can accept as props for controlled components\n  /* eslint-disable react/no-unused-prop-types */\n  selectedItem: import_prop_types.default.any,\n  isOpen: import_prop_types.default.bool,\n  inputValue: import_prop_types.default.string,\n  highlightedIndex: import_prop_types.default.number,\n  labelId: import_prop_types.default.string,\n  inputId: import_prop_types.default.string,\n  menuId: import_prop_types.default.string,\n  getItemId: import_prop_types.default.func\n  /* eslint-enable react/no-unused-prop-types */\n} : void 0;\nfunction validateGetMenuPropsCalledCorrectly(node, _ref3) {\n  let {\n    refKey\n  } = _ref3;\n  if (!node) {\n    console.error('downshift: The ref prop \"' + refKey + '\" from getMenuProps was not applied correctly on your menu element.');\n  }\n}\nfunction validateGetRootPropsCalledCorrectly(element4, _ref4) {\n  let {\n    refKey\n  } = _ref4;\n  const refKeySpecified = refKey !== \"ref\";\n  const isComposite = !isDOMElement2(element4);\n  if (isComposite && !refKeySpecified && !(0, import_react_is.isForwardRef)(element4)) {\n    console.error(\"downshift: You returned a non-DOM element. You must specify a refKey in getRootProps\");\n  } else if (!isComposite && refKeySpecified) {\n    console.error('downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified \"' + refKey + '\"');\n  }\n  if (!(0, import_react_is.isForwardRef)(element4) && !getElementProps(element4)[refKey]) {\n    console.error('downshift: You must apply the ref prop \"' + refKey + '\" from getRootProps onto your root element.');\n  }\n}\nvar dropdownDefaultStateValues = {\n  highlightedIndex: -1,\n  isOpen: false,\n  selectedItem: null,\n  inputValue: \"\"\n};\nfunction callOnChangeProps(action, state, newState) {\n  const {\n    props,\n    type\n  } = action;\n  const changes = {};\n  Object.keys(state).forEach((key) => {\n    invokeOnChangeHandler(key, action, state, newState);\n    if (newState[key] !== state[key]) {\n      changes[key] = newState[key];\n    }\n  });\n  if (props.onStateChange && Object.keys(changes).length) {\n    props.onStateChange({\n      type,\n      ...changes\n    });\n  }\n}\nfunction invokeOnChangeHandler(key, action, state, newState) {\n  const {\n    props,\n    type\n  } = action;\n  const handler = \"on\" + capitalizeString(key) + \"Change\";\n  if (props[handler] && newState[key] !== void 0 && newState[key] !== state[key]) {\n    props[handler]({\n      type,\n      ...newState\n    });\n  }\n}\nfunction stateReducer(s5, a7) {\n  return a7.changes;\n}\nfunction getA11ySelectionMessage(selectionParameters) {\n  const {\n    selectedItem,\n    itemToString: itemToStringLocal\n  } = selectionParameters;\n  return selectedItem ? itemToStringLocal(selectedItem) + \" has been selected.\" : \"\";\n}\nvar updateA11yStatus = debounce5((getA11yMessage, document2) => {\n  setStatus(getA11yMessage(), document2);\n}, 200);\nvar useIsomorphicLayoutEffect4 = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\" ? import_react40.useLayoutEffect : import_react40.useEffect;\nfunction useElementIds(_ref) {\n  let {\n    id = \"downshift-\" + generateId(),\n    labelId,\n    menuId,\n    getItemId,\n    toggleButtonId,\n    inputId\n  } = _ref;\n  const elementIdsRef = (0, import_react40.useRef)({\n    labelId: labelId || id + \"-label\",\n    menuId: menuId || id + \"-menu\",\n    getItemId: getItemId || ((index5) => id + \"-item-\" + index5),\n    toggleButtonId: toggleButtonId || id + \"-toggle-button\",\n    inputId: inputId || id + \"-input\"\n  });\n  return elementIdsRef.current;\n}\nfunction getItemIndex(index5, item, items) {\n  if (index5 !== void 0) {\n    return index5;\n  }\n  if (items.length === 0) {\n    return -1;\n  }\n  return items.indexOf(item);\n}\nfunction itemToString(item) {\n  return item ? String(item) : \"\";\n}\nfunction isAcceptedCharacterKey(key) {\n  return /^\\S{1}$/.test(key);\n}\nfunction capitalizeString(string2) {\n  return \"\" + string2.slice(0, 1).toUpperCase() + string2.slice(1);\n}\nfunction useLatestRef2(val) {\n  const ref = (0, import_react40.useRef)(val);\n  ref.current = val;\n  return ref;\n}\nfunction useEnhancedReducer(reducer, initialState3, props) {\n  const prevStateRef = (0, import_react40.useRef)();\n  const actionRef = (0, import_react40.useRef)();\n  const enhancedReducer = (0, import_react40.useCallback)((state2, action2) => {\n    actionRef.current = action2;\n    state2 = getState(state2, action2.props);\n    const changes = reducer(state2, action2);\n    const newState = action2.props.stateReducer(state2, {\n      ...action2,\n      changes\n    });\n    return newState;\n  }, [reducer]);\n  const [state, dispatch2] = (0, import_react40.useReducer)(enhancedReducer, initialState3);\n  const propsRef = useLatestRef2(props);\n  const dispatchWithProps = (0, import_react40.useCallback)((action2) => dispatch2({\n    props: propsRef.current,\n    ...action2\n  }), [propsRef]);\n  const action = actionRef.current;\n  (0, import_react40.useEffect)(() => {\n    if (action && prevStateRef.current && prevStateRef.current !== state) {\n      callOnChangeProps(action, getState(prevStateRef.current, action.props), state);\n    }\n    prevStateRef.current = state;\n  }, [state, props, action]);\n  return [state, dispatchWithProps];\n}\nfunction useControlledReducer$1(reducer, initialState3, props) {\n  const [state, dispatch2] = useEnhancedReducer(reducer, initialState3, props);\n  return [getState(state, props), dispatch2];\n}\nvar defaultProps$3 = {\n  itemToString,\n  stateReducer,\n  getA11ySelectionMessage,\n  scrollIntoView: scrollIntoView2,\n  circularNavigation: false,\n  environment: (\n    /* istanbul ignore next (ssr) */\n    typeof window === \"undefined\" ? {} : window\n  )\n};\nfunction getDefaultValue$1(props, propKey, defaultStateValues2) {\n  if (defaultStateValues2 === void 0) {\n    defaultStateValues2 = dropdownDefaultStateValues;\n  }\n  const defaultValue = props[\"default\" + capitalizeString(propKey)];\n  if (defaultValue !== void 0) {\n    return defaultValue;\n  }\n  return defaultStateValues2[propKey];\n}\nfunction getInitialValue$1(props, propKey, defaultStateValues2) {\n  if (defaultStateValues2 === void 0) {\n    defaultStateValues2 = dropdownDefaultStateValues;\n  }\n  const value = props[propKey];\n  if (value !== void 0) {\n    return value;\n  }\n  const initialValue = props[\"initial\" + capitalizeString(propKey)];\n  if (initialValue !== void 0) {\n    return initialValue;\n  }\n  return getDefaultValue$1(props, propKey, defaultStateValues2);\n}\nfunction getInitialState$2(props) {\n  const selectedItem = getInitialValue$1(props, \"selectedItem\");\n  const isOpen = getInitialValue$1(props, \"isOpen\");\n  const highlightedIndex = getInitialValue$1(props, \"highlightedIndex\");\n  const inputValue = getInitialValue$1(props, \"inputValue\");\n  return {\n    highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.indexOf(selectedItem) : highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\nfunction getHighlightedIndexOnOpen(props, state, offset3, getItemNodeFromIndex) {\n  const {\n    items,\n    initialHighlightedIndex,\n    defaultHighlightedIndex\n  } = props;\n  const {\n    selectedItem,\n    highlightedIndex\n  } = state;\n  if (items.length === 0) {\n    return -1;\n  }\n  if (initialHighlightedIndex !== void 0 && highlightedIndex === initialHighlightedIndex) {\n    return initialHighlightedIndex;\n  }\n  if (defaultHighlightedIndex !== void 0) {\n    return defaultHighlightedIndex;\n  }\n  if (selectedItem) {\n    if (offset3 === 0) {\n      return items.indexOf(selectedItem);\n    }\n    return getNextWrappingIndex(offset3, items.indexOf(selectedItem), items.length, getItemNodeFromIndex, false);\n  }\n  if (offset3 === 0) {\n    return -1;\n  }\n  return offset3 < 0 ? items.length - 1 : 0;\n}\nfunction useMouseAndTouchTracker(isOpen, downshiftElementRefs, environment, handleBlur) {\n  const mouseAndTouchTrackersRef = (0, import_react40.useRef)({\n    isMouseDown: false,\n    isTouchMove: false\n  });\n  (0, import_react40.useEffect)(() => {\n    const onMouseDown = () => {\n      mouseAndTouchTrackersRef.current.isMouseDown = true;\n    };\n    const onMouseUp = (event) => {\n      mouseAndTouchTrackersRef.current.isMouseDown = false;\n      if (isOpen && !targetWithinDownshift(event.target, downshiftElementRefs.map((ref) => ref.current), environment)) {\n        handleBlur();\n      }\n    };\n    const onTouchStart = () => {\n      mouseAndTouchTrackersRef.current.isTouchMove = false;\n    };\n    const onTouchMove = () => {\n      mouseAndTouchTrackersRef.current.isTouchMove = true;\n    };\n    const onTouchEnd = (event) => {\n      if (isOpen && !mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event.target, downshiftElementRefs.map((ref) => ref.current), environment, false)) {\n        handleBlur();\n      }\n    };\n    environment.addEventListener(\"mousedown\", onMouseDown);\n    environment.addEventListener(\"mouseup\", onMouseUp);\n    environment.addEventListener(\"touchstart\", onTouchStart);\n    environment.addEventListener(\"touchmove\", onTouchMove);\n    environment.addEventListener(\"touchend\", onTouchEnd);\n    return function cleanup() {\n      environment.removeEventListener(\"mousedown\", onMouseDown);\n      environment.removeEventListener(\"mouseup\", onMouseUp);\n      environment.removeEventListener(\"touchstart\", onTouchStart);\n      environment.removeEventListener(\"touchmove\", onTouchMove);\n      environment.removeEventListener(\"touchend\", onTouchEnd);\n    };\n  }, [isOpen, environment]);\n  return mouseAndTouchTrackersRef;\n}\nvar useGetterPropsCalledChecker = () => noop2;\nif (true) {\n  useGetterPropsCalledChecker = function() {\n    const isInitialMountRef = (0, import_react40.useRef)(true);\n    for (var _len = arguments.length, propKeys = new Array(_len), _key = 0; _key < _len; _key++) {\n      propKeys[_key] = arguments[_key];\n    }\n    const getterPropsCalledRef = (0, import_react40.useRef)(propKeys.reduce((acc, propKey) => {\n      acc[propKey] = {};\n      return acc;\n    }, {}));\n    (0, import_react40.useEffect)(() => {\n      Object.keys(getterPropsCalledRef.current).forEach((propKey) => {\n        const propCallInfo = getterPropsCalledRef.current[propKey];\n        if (isInitialMountRef.current) {\n          if (!Object.keys(propCallInfo).length) {\n            console.error(\"downshift: You forgot to call the \" + propKey + \" getter function on your component / element.\");\n            return;\n          }\n        }\n        const {\n          suppressRefError,\n          refKey,\n          elementRef\n        } = propCallInfo;\n        if ((!elementRef || !elementRef.current) && !suppressRefError) {\n          console.error('downshift: The ref prop \"' + refKey + '\" from ' + propKey + \" was not applied correctly on your element.\");\n        }\n      });\n      isInitialMountRef.current = false;\n    });\n    const setGetterPropCallInfo = (0, import_react40.useCallback)((propKey, suppressRefError, refKey, elementRef) => {\n      getterPropsCalledRef.current[propKey] = {\n        suppressRefError,\n        refKey,\n        elementRef\n      };\n    }, []);\n    return setGetterPropCallInfo;\n  };\n}\nfunction useA11yMessageSetter(getA11yMessage, dependencyArray, _ref2) {\n  let {\n    isInitialMount,\n    highlightedIndex,\n    items,\n    environment,\n    ...rest\n  } = _ref2;\n  (0, import_react40.useEffect)(() => {\n    if (isInitialMount || false) {\n      return;\n    }\n    updateA11yStatus(() => getA11yMessage({\n      highlightedIndex,\n      highlightedItem: items[highlightedIndex],\n      resultCount: items.length,\n      ...rest\n    }), environment.document);\n  }, dependencyArray);\n}\nfunction useScrollIntoView(_ref3) {\n  let {\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    getItemNodeFromIndex,\n    menuElement,\n    scrollIntoView: scrollIntoViewProp\n  } = _ref3;\n  const shouldScrollRef = (0, import_react40.useRef)(true);\n  useIsomorphicLayoutEffect4(() => {\n    if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {\n      return;\n    }\n    if (shouldScrollRef.current === false) {\n      shouldScrollRef.current = true;\n    } else {\n      scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);\n    }\n  }, [highlightedIndex]);\n  return shouldScrollRef;\n}\nvar useControlPropsValidator = noop2;\nif (true) {\n  useControlPropsValidator = (_ref4) => {\n    let {\n      isInitialMount,\n      props,\n      state\n    } = _ref4;\n    const prevPropsRef = (0, import_react40.useRef)(props);\n    (0, import_react40.useEffect)(() => {\n      if (isInitialMount) {\n        return;\n      }\n      validateControlledUnchanged(state, prevPropsRef.current, props);\n      prevPropsRef.current = props;\n    }, [state, props, isInitialMount]);\n  };\n}\nfunction downshiftCommonReducer(state, action, stateChangeTypes2) {\n  const {\n    type,\n    props\n  } = action;\n  let changes;\n  switch (type) {\n    case stateChangeTypes2.ItemMouseMove:\n      changes = {\n        highlightedIndex: action.index\n      };\n      break;\n    case stateChangeTypes2.MenuMouseLeave:\n      changes = {\n        highlightedIndex: -1\n      };\n      break;\n    case stateChangeTypes2.ToggleButtonClick:\n    case stateChangeTypes2.FunctionToggleMenu:\n      changes = {\n        isOpen: !state.isOpen,\n        highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)\n      };\n      break;\n    case stateChangeTypes2.FunctionOpenMenu:\n      changes = {\n        isOpen: true,\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)\n      };\n      break;\n    case stateChangeTypes2.FunctionCloseMenu:\n      changes = {\n        isOpen: false\n      };\n      break;\n    case stateChangeTypes2.FunctionSetHighlightedIndex:\n      changes = {\n        highlightedIndex: action.highlightedIndex\n      };\n      break;\n    case stateChangeTypes2.FunctionSetInputValue:\n      changes = {\n        inputValue: action.inputValue\n      };\n      break;\n    case stateChangeTypes2.FunctionReset:\n      changes = {\n        highlightedIndex: getDefaultValue$1(props, \"highlightedIndex\"),\n        isOpen: getDefaultValue$1(props, \"isOpen\"),\n        selectedItem: getDefaultValue$1(props, \"selectedItem\"),\n        inputValue: getDefaultValue$1(props, \"inputValue\")\n      };\n      break;\n    default:\n      throw new Error(\"Reducer called without proper action type.\");\n  }\n  return {\n    ...state,\n    ...changes\n  };\n}\nfunction getItemIndexByCharacterKey(_a) {\n  var keysSoFar = _a.keysSoFar, highlightedIndex = _a.highlightedIndex, items = _a.items, itemToString2 = _a.itemToString, getItemNodeFromIndex = _a.getItemNodeFromIndex;\n  var lowerCasedKeysSoFar = keysSoFar.toLowerCase();\n  for (var index5 = 0; index5 < items.length; index5++) {\n    var offsetIndex = (index5 + highlightedIndex + 1) % items.length;\n    var item = items[offsetIndex];\n    if (item !== void 0 && itemToString2(item).toLowerCase().startsWith(lowerCasedKeysSoFar)) {\n      var element4 = getItemNodeFromIndex(offsetIndex);\n      if (!(element4 === null || element4 === void 0 ? void 0 : element4.hasAttribute(\"disabled\"))) {\n        return offsetIndex;\n      }\n    }\n  }\n  return highlightedIndex;\n}\nvar propTypes$2 = {\n  items: import_prop_types.default.array.isRequired,\n  itemToString: import_prop_types.default.func,\n  getA11yStatusMessage: import_prop_types.default.func,\n  getA11ySelectionMessage: import_prop_types.default.func,\n  circularNavigation: import_prop_types.default.bool,\n  highlightedIndex: import_prop_types.default.number,\n  defaultHighlightedIndex: import_prop_types.default.number,\n  initialHighlightedIndex: import_prop_types.default.number,\n  isOpen: import_prop_types.default.bool,\n  defaultIsOpen: import_prop_types.default.bool,\n  initialIsOpen: import_prop_types.default.bool,\n  selectedItem: import_prop_types.default.any,\n  initialSelectedItem: import_prop_types.default.any,\n  defaultSelectedItem: import_prop_types.default.any,\n  id: import_prop_types.default.string,\n  labelId: import_prop_types.default.string,\n  menuId: import_prop_types.default.string,\n  getItemId: import_prop_types.default.func,\n  toggleButtonId: import_prop_types.default.string,\n  stateReducer: import_prop_types.default.func,\n  onSelectedItemChange: import_prop_types.default.func,\n  onHighlightedIndexChange: import_prop_types.default.func,\n  onStateChange: import_prop_types.default.func,\n  onIsOpenChange: import_prop_types.default.func,\n  environment: import_prop_types.default.shape({\n    addEventListener: import_prop_types.default.func,\n    removeEventListener: import_prop_types.default.func,\n    document: import_prop_types.default.shape({\n      getElementById: import_prop_types.default.func,\n      activeElement: import_prop_types.default.any,\n      body: import_prop_types.default.any\n    })\n  })\n};\nfunction getA11yStatusMessage(_a) {\n  var isOpen = _a.isOpen, resultCount = _a.resultCount, previousResultCount = _a.previousResultCount;\n  if (!isOpen) {\n    return \"\";\n  }\n  if (!resultCount) {\n    return \"No results are available.\";\n  }\n  if (resultCount !== previousResultCount) {\n    return \"\".concat(resultCount, \" result\").concat(resultCount === 1 ? \" is\" : \"s are\", \" available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.\");\n  }\n  return \"\";\n}\nvar defaultProps$2 = __assign(__assign({}, defaultProps$3), { getA11yStatusMessage });\nvar validatePropTypes$2 = noop2;\nif (true) {\n  validatePropTypes$2 = function(options, caller) {\n    import_prop_types.default.checkPropTypes(propTypes$2, options, \"prop\", caller.name);\n  };\n}\nvar MenuKeyDownArrowDown = true ? \"__menu_keydown_arrow_down__\" : 0;\nvar MenuKeyDownArrowUp = true ? \"__menu_keydown_arrow_up__\" : 1;\nvar MenuKeyDownEscape = true ? \"__menu_keydown_escape__\" : 2;\nvar MenuKeyDownHome = true ? \"__menu_keydown_home__\" : 3;\nvar MenuKeyDownEnd = true ? \"__menu_keydown_end__\" : 4;\nvar MenuKeyDownEnter = true ? \"__menu_keydown_enter__\" : 5;\nvar MenuKeyDownSpaceButton = true ? \"__menu_keydown_space_button__\" : 6;\nvar MenuKeyDownCharacter = true ? \"__menu_keydown_character__\" : 7;\nvar MenuBlur = true ? \"__menu_blur__\" : 8;\nvar MenuMouseLeave$1 = true ? \"__menu_mouse_leave__\" : 9;\nvar ItemMouseMove$1 = true ? \"__item_mouse_move__\" : 10;\nvar ItemClick$1 = true ? \"__item_click__\" : 11;\nvar ToggleButtonClick$1 = true ? \"__togglebutton_click__\" : 12;\nvar ToggleButtonKeyDownArrowDown = true ? \"__togglebutton_keydown_arrow_down__\" : 13;\nvar ToggleButtonKeyDownArrowUp = true ? \"__togglebutton_keydown_arrow_up__\" : 14;\nvar ToggleButtonKeyDownCharacter = true ? \"__togglebutton_keydown_character__\" : 15;\nvar FunctionToggleMenu$1 = true ? \"__function_toggle_menu__\" : 16;\nvar FunctionOpenMenu$1 = true ? \"__function_open_menu__\" : 17;\nvar FunctionCloseMenu$1 = true ? \"__function_close_menu__\" : 18;\nvar FunctionSetHighlightedIndex$1 = true ? \"__function_set_highlighted_index__\" : 19;\nvar FunctionSelectItem$1 = true ? \"__function_select_item__\" : 20;\nvar FunctionSetInputValue$1 = true ? \"__function_set_input_value__\" : 21;\nvar FunctionReset$2 = true ? \"__function_reset__\" : 22;\nvar stateChangeTypes$2 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  MenuKeyDownArrowDown,\n  MenuKeyDownArrowUp,\n  MenuKeyDownEscape,\n  MenuKeyDownHome,\n  MenuKeyDownEnd,\n  MenuKeyDownEnter,\n  MenuKeyDownSpaceButton,\n  MenuKeyDownCharacter,\n  MenuBlur,\n  MenuMouseLeave: MenuMouseLeave$1,\n  ItemMouseMove: ItemMouseMove$1,\n  ItemClick: ItemClick$1,\n  ToggleButtonClick: ToggleButtonClick$1,\n  ToggleButtonKeyDownArrowDown,\n  ToggleButtonKeyDownArrowUp,\n  ToggleButtonKeyDownCharacter,\n  FunctionToggleMenu: FunctionToggleMenu$1,\n  FunctionOpenMenu: FunctionOpenMenu$1,\n  FunctionCloseMenu: FunctionCloseMenu$1,\n  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex$1,\n  FunctionSelectItem: FunctionSelectItem$1,\n  FunctionSetInputValue: FunctionSetInputValue$1,\n  FunctionReset: FunctionReset$2\n});\nfunction downshiftSelectReducer(state, action) {\n  const {\n    type,\n    props,\n    shiftKey\n  } = action;\n  let changes;\n  switch (type) {\n    case ItemClick$1:\n      changes = {\n        isOpen: getDefaultValue$1(props, \"isOpen\"),\n        highlightedIndex: getDefaultValue$1(props, \"highlightedIndex\"),\n        selectedItem: props.items[action.index]\n      };\n      break;\n    case ToggleButtonKeyDownCharacter:\n      {\n        const lowercasedKey = action.key;\n        const inputValue = \"\" + state.inputValue + lowercasedKey;\n        const itemIndex = getItemIndexByCharacterKey({\n          keysSoFar: inputValue,\n          highlightedIndex: state.selectedItem ? props.items.indexOf(state.selectedItem) : -1,\n          items: props.items,\n          itemToString: props.itemToString,\n          getItemNodeFromIndex: action.getItemNodeFromIndex\n        });\n        changes = {\n          inputValue,\n          ...itemIndex >= 0 && {\n            selectedItem: props.items[itemIndex]\n          }\n        };\n      }\n      break;\n    case ToggleButtonKeyDownArrowDown:\n      changes = {\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),\n        isOpen: true\n      };\n      break;\n    case ToggleButtonKeyDownArrowUp:\n      changes = {\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),\n        isOpen: true\n      };\n      break;\n    case MenuKeyDownEnter:\n    case MenuKeyDownSpaceButton:\n      changes = {\n        isOpen: getDefaultValue$1(props, \"isOpen\"),\n        highlightedIndex: getDefaultValue$1(props, \"highlightedIndex\"),\n        ...state.highlightedIndex >= 0 && {\n          selectedItem: props.items[state.highlightedIndex]\n        }\n      };\n      break;\n    case MenuKeyDownHome:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n    case MenuKeyDownEnd:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n    case MenuKeyDownEscape:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1\n      };\n      break;\n    case MenuBlur:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1\n      };\n      break;\n    case MenuKeyDownCharacter:\n      {\n        const lowercasedKey = action.key;\n        const inputValue = \"\" + state.inputValue + lowercasedKey;\n        const highlightedIndex = getItemIndexByCharacterKey({\n          keysSoFar: inputValue,\n          highlightedIndex: state.highlightedIndex,\n          items: props.items,\n          itemToString: props.itemToString,\n          getItemNodeFromIndex: action.getItemNodeFromIndex\n        });\n        changes = {\n          inputValue,\n          ...highlightedIndex >= 0 && {\n            highlightedIndex\n          }\n        };\n      }\n      break;\n    case MenuKeyDownArrowDown:\n      changes = {\n        highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n      };\n      break;\n    case MenuKeyDownArrowUp:\n      changes = {\n        highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n      };\n      break;\n    case FunctionSelectItem$1:\n      changes = {\n        selectedItem: action.selectedItem\n      };\n      break;\n    default:\n      return downshiftCommonReducer(state, action, stateChangeTypes$2);\n  }\n  return {\n    ...state,\n    ...changes\n  };\n}\nuseSelect.stateChangeTypes = stateChangeTypes$2;\nfunction useSelect(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n  validatePropTypes$2(userProps, useSelect);\n  const props = {\n    ...defaultProps$2,\n    ...userProps\n  };\n  const {\n    items,\n    scrollIntoView: scrollIntoView3,\n    environment,\n    initialIsOpen,\n    defaultIsOpen,\n    itemToString: itemToString2,\n    getA11ySelectionMessage: getA11ySelectionMessage2,\n    getA11yStatusMessage: getA11yStatusMessage2\n  } = props;\n  const initialState3 = getInitialState$2(props);\n  const [state, dispatch2] = useControlledReducer$1(downshiftSelectReducer, initialState3, props);\n  const {\n    isOpen,\n    highlightedIndex,\n    selectedItem,\n    inputValue\n  } = state;\n  const toggleButtonRef = (0, import_react40.useRef)(null);\n  const menuRef = (0, import_react40.useRef)(null);\n  const itemRefs = (0, import_react40.useRef)({});\n  const shouldBlurRef = (0, import_react40.useRef)(true);\n  const clearTimeoutRef = (0, import_react40.useRef)(null);\n  const elementIds = useElementIds(props);\n  const previousResultCountRef = (0, import_react40.useRef)();\n  const isInitialMountRef = (0, import_react40.useRef)(true);\n  const latest = useLatestRef2({\n    state,\n    props\n  });\n  const getItemNodeFromIndex = (0, import_react40.useCallback)((index5) => itemRefs.current[elementIds.getItemId(index5)], [elementIds]);\n  useA11yMessageSetter(getA11yStatusMessage2, [isOpen, highlightedIndex, inputValue, items], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString: itemToString2,\n    ...state\n  });\n  useA11yMessageSetter(getA11ySelectionMessage2, [selectedItem], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString: itemToString2,\n    ...state\n  });\n  const shouldScrollRef = useScrollIntoView({\n    menuElement: menuRef.current,\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    scrollIntoView: scrollIntoView3,\n    getItemNodeFromIndex\n  });\n  (0, import_react40.useEffect)(() => {\n    clearTimeoutRef.current = debounce5((outerDispatch) => {\n      outerDispatch({\n        type: FunctionSetInputValue$1,\n        inputValue: \"\"\n      });\n    }, 500);\n    return () => {\n      clearTimeoutRef.current.cancel();\n    };\n  }, []);\n  (0, import_react40.useEffect)(() => {\n    if (!inputValue) {\n      return;\n    }\n    clearTimeoutRef.current(dispatch2);\n  }, [dispatch2, inputValue]);\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  });\n  (0, import_react40.useEffect)(() => {\n    if (isInitialMountRef.current) {\n      if ((initialIsOpen || defaultIsOpen || isOpen) && menuRef.current) {\n        menuRef.current.focus();\n      }\n      return;\n    }\n    if (isOpen) {\n      if (menuRef.current) {\n        menuRef.current.focus();\n      }\n      return;\n    }\n    if (environment.document.activeElement === menuRef.current) {\n      if (toggleButtonRef.current) {\n        shouldBlurRef.current = false;\n        toggleButtonRef.current.focus();\n      }\n    }\n  }, [isOpen]);\n  (0, import_react40.useEffect)(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n    previousResultCountRef.current = items.length;\n  });\n  const mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [menuRef, toggleButtonRef], environment, () => {\n    dispatch2({\n      type: MenuBlur\n    });\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker(\"getMenuProps\", \"getToggleButtonProps\");\n  (0, import_react40.useEffect)(() => {\n    isInitialMountRef.current = false;\n  }, []);\n  (0, import_react40.useEffect)(() => {\n    if (!isOpen) {\n      itemRefs.current = {};\n    }\n  }, [isOpen]);\n  const toggleButtonKeyDownHandlers = (0, import_react40.useMemo)(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch2({\n        type: ToggleButtonKeyDownArrowDown,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch2({\n        type: ToggleButtonKeyDownArrowUp,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    }\n  }), [dispatch2, getItemNodeFromIndex]);\n  const menuKeyDownHandlers = (0, import_react40.useMemo)(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch2({\n        type: MenuKeyDownArrowDown,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch2({\n        type: MenuKeyDownArrowUp,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n    Home(event) {\n      event.preventDefault();\n      dispatch2({\n        type: MenuKeyDownHome,\n        getItemNodeFromIndex\n      });\n    },\n    End(event) {\n      event.preventDefault();\n      dispatch2({\n        type: MenuKeyDownEnd,\n        getItemNodeFromIndex\n      });\n    },\n    Escape() {\n      dispatch2({\n        type: MenuKeyDownEscape\n      });\n    },\n    Enter(event) {\n      event.preventDefault();\n      dispatch2({\n        type: MenuKeyDownEnter\n      });\n    },\n    \" \"(event) {\n      event.preventDefault();\n      dispatch2({\n        type: MenuKeyDownSpaceButton\n      });\n    }\n  }), [dispatch2, getItemNodeFromIndex]);\n  const toggleMenu = (0, import_react40.useCallback)(() => {\n    dispatch2({\n      type: FunctionToggleMenu$1\n    });\n  }, [dispatch2]);\n  const closeMenu = (0, import_react40.useCallback)(() => {\n    dispatch2({\n      type: FunctionCloseMenu$1\n    });\n  }, [dispatch2]);\n  const openMenu = (0, import_react40.useCallback)(() => {\n    dispatch2({\n      type: FunctionOpenMenu$1\n    });\n  }, [dispatch2]);\n  const setHighlightedIndex = (0, import_react40.useCallback)((newHighlightedIndex) => {\n    dispatch2({\n      type: FunctionSetHighlightedIndex$1,\n      highlightedIndex: newHighlightedIndex\n    });\n  }, [dispatch2]);\n  const selectItem = (0, import_react40.useCallback)((newSelectedItem) => {\n    dispatch2({\n      type: FunctionSelectItem$1,\n      selectedItem: newSelectedItem\n    });\n  }, [dispatch2]);\n  const reset = (0, import_react40.useCallback)(() => {\n    dispatch2({\n      type: FunctionReset$2\n    });\n  }, [dispatch2]);\n  const setInputValue = (0, import_react40.useCallback)((newInputValue) => {\n    dispatch2({\n      type: FunctionSetInputValue$1,\n      inputValue: newInputValue\n    });\n  }, [dispatch2]);\n  const getLabelProps = (0, import_react40.useCallback)((labelProps) => ({\n    id: elementIds.labelId,\n    htmlFor: elementIds.toggleButtonId,\n    ...labelProps\n  }), [elementIds]);\n  const getMenuProps = (0, import_react40.useCallback)(function(_temp, _temp2) {\n    let {\n      onMouseLeave,\n      refKey = \"ref\",\n      onKeyDown,\n      onBlur,\n      ref,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    let {\n      suppressRefError = false\n    } = _temp2 === void 0 ? {} : _temp2;\n    const latestState = latest.current.state;\n    const menuHandleKeyDown = (event) => {\n      const key = normalizeArrowKey(event);\n      if (key && menuKeyDownHandlers[key]) {\n        menuKeyDownHandlers[key](event);\n      } else if (isAcceptedCharacterKey(key)) {\n        dispatch2({\n          type: MenuKeyDownCharacter,\n          key,\n          getItemNodeFromIndex\n        });\n      }\n    };\n    const menuHandleBlur = () => {\n      if (shouldBlurRef.current === false) {\n        shouldBlurRef.current = true;\n        return;\n      }\n      const shouldBlur = !mouseAndTouchTrackersRef.current.isMouseDown;\n      if (shouldBlur) {\n        dispatch2({\n          type: MenuBlur\n        });\n      }\n    };\n    const menuHandleMouseLeave = () => {\n      dispatch2({\n        type: MenuMouseLeave$1\n      });\n    };\n    setGetterPropCallInfo(\"getMenuProps\", suppressRefError, refKey, menuRef);\n    return {\n      [refKey]: handleRefs(ref, (menuNode) => {\n        menuRef.current = menuNode;\n      }),\n      id: elementIds.menuId,\n      role: \"listbox\",\n      \"aria-labelledby\": elementIds.labelId,\n      tabIndex: -1,\n      ...latestState.isOpen && latestState.highlightedIndex > -1 && {\n        \"aria-activedescendant\": elementIds.getItemId(latestState.highlightedIndex)\n      },\n      onMouseLeave: callAllEventHandlers(onMouseLeave, menuHandleMouseLeave),\n      onKeyDown: callAllEventHandlers(onKeyDown, menuHandleKeyDown),\n      onBlur: callAllEventHandlers(onBlur, menuHandleBlur),\n      ...rest\n    };\n  }, [dispatch2, latest, menuKeyDownHandlers, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds, getItemNodeFromIndex]);\n  const getToggleButtonProps = (0, import_react40.useCallback)(function(_temp3, _temp4) {\n    let {\n      onClick,\n      onKeyDown,\n      refKey = \"ref\",\n      ref,\n      ...rest\n    } = _temp3 === void 0 ? {} : _temp3;\n    let {\n      suppressRefError = false\n    } = _temp4 === void 0 ? {} : _temp4;\n    const toggleButtonHandleClick = () => {\n      dispatch2({\n        type: ToggleButtonClick$1\n      });\n    };\n    const toggleButtonHandleKeyDown = (event) => {\n      const key = normalizeArrowKey(event);\n      if (key && toggleButtonKeyDownHandlers[key]) {\n        toggleButtonKeyDownHandlers[key](event);\n      } else if (isAcceptedCharacterKey(key)) {\n        dispatch2({\n          type: ToggleButtonKeyDownCharacter,\n          key,\n          getItemNodeFromIndex\n        });\n      }\n    };\n    const toggleProps = {\n      [refKey]: handleRefs(ref, (toggleButtonNode) => {\n        toggleButtonRef.current = toggleButtonNode;\n      }),\n      id: elementIds.toggleButtonId,\n      \"aria-haspopup\": \"listbox\",\n      \"aria-expanded\": latest.current.state.isOpen,\n      \"aria-labelledby\": elementIds.labelId + \" \" + elementIds.toggleButtonId,\n      ...rest\n    };\n    if (!rest.disabled) {\n      toggleProps.onClick = callAllEventHandlers(onClick, toggleButtonHandleClick);\n      toggleProps.onKeyDown = callAllEventHandlers(onKeyDown, toggleButtonHandleKeyDown);\n    }\n    setGetterPropCallInfo(\"getToggleButtonProps\", suppressRefError, refKey, toggleButtonRef);\n    return toggleProps;\n  }, [dispatch2, latest, toggleButtonKeyDownHandlers, setGetterPropCallInfo, elementIds, getItemNodeFromIndex]);\n  const getItemProps = (0, import_react40.useCallback)(function(_temp5) {\n    let {\n      item,\n      index: index5,\n      onMouseMove,\n      onClick,\n      refKey = \"ref\",\n      ref,\n      ...rest\n    } = _temp5 === void 0 ? {} : _temp5;\n    const {\n      state: latestState,\n      props: latestProps\n    } = latest.current;\n    const itemHandleMouseMove = () => {\n      if (index5 === latestState.highlightedIndex) {\n        return;\n      }\n      shouldScrollRef.current = false;\n      dispatch2({\n        type: ItemMouseMove$1,\n        index: index5\n      });\n    };\n    const itemHandleClick = () => {\n      dispatch2({\n        type: ItemClick$1,\n        index: index5\n      });\n    };\n    const itemIndex = getItemIndex(index5, item, latestProps.items);\n    if (itemIndex < 0) {\n      throw new Error(\"Pass either item or item index in getItemProps!\");\n    }\n    const itemProps = {\n      role: \"option\",\n      \"aria-selected\": \"\" + (itemIndex === latestState.highlightedIndex),\n      id: elementIds.getItemId(itemIndex),\n      [refKey]: handleRefs(ref, (itemNode) => {\n        if (itemNode) {\n          itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;\n        }\n      }),\n      ...rest\n    };\n    if (!rest.disabled) {\n      itemProps.onMouseMove = callAllEventHandlers(onMouseMove, itemHandleMouseMove);\n      itemProps.onClick = callAllEventHandlers(onClick, itemHandleClick);\n    }\n    return itemProps;\n  }, [dispatch2, latest, shouldScrollRef, elementIds]);\n  return {\n    // prop getters.\n    getToggleButtonProps,\n    getLabelProps,\n    getMenuProps,\n    getItemProps,\n    // actions.\n    toggleMenu,\n    openMenu,\n    closeMenu,\n    setHighlightedIndex,\n    selectItem,\n    reset,\n    setInputValue,\n    // state.\n    highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\nvar InputKeyDownArrowDown = true ? \"__input_keydown_arrow_down__\" : 0;\nvar InputKeyDownArrowUp = true ? \"__input_keydown_arrow_up__\" : 1;\nvar InputKeyDownEscape = true ? \"__input_keydown_escape__\" : 2;\nvar InputKeyDownHome = true ? \"__input_keydown_home__\" : 3;\nvar InputKeyDownEnd = true ? \"__input_keydown_end__\" : 4;\nvar InputKeyDownEnter = true ? \"__input_keydown_enter__\" : 5;\nvar InputChange = true ? \"__input_change__\" : 6;\nvar InputBlur = true ? \"__input_blur__\" : 7;\nvar MenuMouseLeave = true ? \"__menu_mouse_leave__\" : 8;\nvar ItemMouseMove = true ? \"__item_mouse_move__\" : 9;\nvar ItemClick = true ? \"__item_click__\" : 10;\nvar ToggleButtonClick = true ? \"__togglebutton_click__\" : 11;\nvar FunctionToggleMenu = true ? \"__function_toggle_menu__\" : 12;\nvar FunctionOpenMenu = true ? \"__function_open_menu__\" : 13;\nvar FunctionCloseMenu = true ? \"__function_close_menu__\" : 14;\nvar FunctionSetHighlightedIndex = true ? \"__function_set_highlighted_index__\" : 15;\nvar FunctionSelectItem = true ? \"__function_select_item__\" : 16;\nvar FunctionSetInputValue = true ? \"__function_set_input_value__\" : 17;\nvar FunctionReset$1 = true ? \"__function_reset__\" : 18;\nvar ControlledPropUpdatedSelectedItem = true ? \"__controlled_prop_updated_selected_item__\" : 19;\nvar stateChangeTypes$1 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  InputKeyDownArrowDown,\n  InputKeyDownArrowUp,\n  InputKeyDownEscape,\n  InputKeyDownHome,\n  InputKeyDownEnd,\n  InputKeyDownEnter,\n  InputChange,\n  InputBlur,\n  MenuMouseLeave,\n  ItemMouseMove,\n  ItemClick,\n  ToggleButtonClick,\n  FunctionToggleMenu,\n  FunctionOpenMenu,\n  FunctionCloseMenu,\n  FunctionSetHighlightedIndex,\n  FunctionSelectItem,\n  FunctionSetInputValue,\n  FunctionReset: FunctionReset$1,\n  ControlledPropUpdatedSelectedItem\n});\nfunction getInitialState$1(props) {\n  const initialState3 = getInitialState$2(props);\n  const {\n    selectedItem\n  } = initialState3;\n  let {\n    inputValue\n  } = initialState3;\n  if (inputValue === \"\" && selectedItem && props.defaultInputValue === void 0 && props.initialInputValue === void 0 && props.inputValue === void 0) {\n    inputValue = props.itemToString(selectedItem);\n  }\n  return {\n    ...initialState3,\n    inputValue\n  };\n}\nvar propTypes$1 = {\n  items: import_prop_types.default.array.isRequired,\n  itemToString: import_prop_types.default.func,\n  getA11yStatusMessage: import_prop_types.default.func,\n  getA11ySelectionMessage: import_prop_types.default.func,\n  circularNavigation: import_prop_types.default.bool,\n  highlightedIndex: import_prop_types.default.number,\n  defaultHighlightedIndex: import_prop_types.default.number,\n  initialHighlightedIndex: import_prop_types.default.number,\n  isOpen: import_prop_types.default.bool,\n  defaultIsOpen: import_prop_types.default.bool,\n  initialIsOpen: import_prop_types.default.bool,\n  selectedItem: import_prop_types.default.any,\n  initialSelectedItem: import_prop_types.default.any,\n  defaultSelectedItem: import_prop_types.default.any,\n  inputValue: import_prop_types.default.string,\n  defaultInputValue: import_prop_types.default.string,\n  initialInputValue: import_prop_types.default.string,\n  id: import_prop_types.default.string,\n  labelId: import_prop_types.default.string,\n  menuId: import_prop_types.default.string,\n  getItemId: import_prop_types.default.func,\n  inputId: import_prop_types.default.string,\n  toggleButtonId: import_prop_types.default.string,\n  stateReducer: import_prop_types.default.func,\n  onSelectedItemChange: import_prop_types.default.func,\n  onHighlightedIndexChange: import_prop_types.default.func,\n  onStateChange: import_prop_types.default.func,\n  onIsOpenChange: import_prop_types.default.func,\n  onInputValueChange: import_prop_types.default.func,\n  environment: import_prop_types.default.shape({\n    addEventListener: import_prop_types.default.func,\n    removeEventListener: import_prop_types.default.func,\n    document: import_prop_types.default.shape({\n      getElementById: import_prop_types.default.func,\n      activeElement: import_prop_types.default.any,\n      body: import_prop_types.default.any\n    })\n  })\n};\nfunction useControlledReducer(reducer, initialState3, props) {\n  const previousSelectedItemRef = (0, import_react40.useRef)();\n  const [state, dispatch2] = useEnhancedReducer(reducer, initialState3, props);\n  (0, import_react40.useEffect)(() => {\n    if (isControlledProp(props, \"selectedItem\")) {\n      if (previousSelectedItemRef.current !== props.selectedItem) {\n        dispatch2({\n          type: ControlledPropUpdatedSelectedItem,\n          inputValue: props.itemToString(props.selectedItem)\n        });\n      }\n      previousSelectedItemRef.current = state.selectedItem === previousSelectedItemRef.current ? props.selectedItem : state.selectedItem;\n    }\n  });\n  return [getState(state, props), dispatch2];\n}\nvar validatePropTypes$1 = noop2;\nif (true) {\n  validatePropTypes$1 = (options, caller) => {\n    import_prop_types.default.checkPropTypes(propTypes$1, options, \"prop\", caller.name);\n  };\n}\nvar defaultProps$1 = {\n  ...defaultProps$3,\n  getA11yStatusMessage: getA11yStatusMessage$1,\n  circularNavigation: true\n};\nfunction downshiftUseComboboxReducer(state, action) {\n  const {\n    type,\n    props,\n    shiftKey\n  } = action;\n  let changes;\n  switch (type) {\n    case ItemClick:\n      changes = {\n        isOpen: getDefaultValue$1(props, \"isOpen\"),\n        highlightedIndex: getDefaultValue$1(props, \"highlightedIndex\"),\n        selectedItem: props.items[action.index],\n        inputValue: props.itemToString(props.items[action.index])\n      };\n      break;\n    case InputKeyDownArrowDown:\n      if (state.isOpen) {\n        changes = {\n          highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n        };\n      } else {\n        changes = {\n          highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),\n          isOpen: props.items.length >= 0\n        };\n      }\n      break;\n    case InputKeyDownArrowUp:\n      if (state.isOpen) {\n        changes = {\n          highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n        };\n      } else {\n        changes = {\n          highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),\n          isOpen: props.items.length >= 0\n        };\n      }\n      break;\n    case InputKeyDownEnter:\n      changes = {\n        ...state.isOpen && state.highlightedIndex >= 0 && {\n          selectedItem: props.items[state.highlightedIndex],\n          isOpen: getDefaultValue$1(props, \"isOpen\"),\n          highlightedIndex: getDefaultValue$1(props, \"highlightedIndex\"),\n          inputValue: props.itemToString(props.items[state.highlightedIndex])\n        }\n      };\n      break;\n    case InputKeyDownEscape:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1,\n        ...!state.isOpen && {\n          selectedItem: null,\n          inputValue: \"\"\n        }\n      };\n      break;\n    case InputKeyDownHome:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n    case InputKeyDownEnd:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n    case InputBlur:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1,\n        ...state.highlightedIndex >= 0 && action.selectItem && {\n          selectedItem: props.items[state.highlightedIndex],\n          inputValue: props.itemToString(props.items[state.highlightedIndex])\n        }\n      };\n      break;\n    case InputChange:\n      changes = {\n        isOpen: true,\n        highlightedIndex: getDefaultValue$1(props, \"highlightedIndex\"),\n        inputValue: action.inputValue\n      };\n      break;\n    case FunctionSelectItem:\n      changes = {\n        selectedItem: action.selectedItem,\n        inputValue: props.itemToString(action.selectedItem)\n      };\n      break;\n    case ControlledPropUpdatedSelectedItem:\n      changes = {\n        inputValue: action.inputValue\n      };\n      break;\n    default:\n      return downshiftCommonReducer(state, action, stateChangeTypes$1);\n  }\n  return {\n    ...state,\n    ...changes\n  };\n}\nuseCombobox.stateChangeTypes = stateChangeTypes$1;\nfunction useCombobox(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n  validatePropTypes$1(userProps, useCombobox);\n  const props = {\n    ...defaultProps$1,\n    ...userProps\n  };\n  const {\n    initialIsOpen,\n    defaultIsOpen,\n    items,\n    scrollIntoView: scrollIntoView3,\n    environment,\n    getA11yStatusMessage: getA11yStatusMessage2,\n    getA11ySelectionMessage: getA11ySelectionMessage2,\n    itemToString: itemToString2\n  } = props;\n  const initialState3 = getInitialState$1(props);\n  const [state, dispatch2] = useControlledReducer(downshiftUseComboboxReducer, initialState3, props);\n  const {\n    isOpen,\n    highlightedIndex,\n    selectedItem,\n    inputValue\n  } = state;\n  const menuRef = (0, import_react40.useRef)(null);\n  const itemRefs = (0, import_react40.useRef)({});\n  const inputRef = (0, import_react40.useRef)(null);\n  const toggleButtonRef = (0, import_react40.useRef)(null);\n  const comboboxRef = (0, import_react40.useRef)(null);\n  const isInitialMountRef = (0, import_react40.useRef)(true);\n  const elementIds = useElementIds(props);\n  const previousResultCountRef = (0, import_react40.useRef)();\n  const latest = useLatestRef2({\n    state,\n    props\n  });\n  const getItemNodeFromIndex = (0, import_react40.useCallback)((index5) => itemRefs.current[elementIds.getItemId(index5)], [elementIds]);\n  useA11yMessageSetter(getA11yStatusMessage2, [isOpen, highlightedIndex, inputValue, items], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString: itemToString2,\n    ...state\n  });\n  useA11yMessageSetter(getA11ySelectionMessage2, [selectedItem], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString: itemToString2,\n    ...state\n  });\n  const shouldScrollRef = useScrollIntoView({\n    menuElement: menuRef.current,\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    scrollIntoView: scrollIntoView3,\n    getItemNodeFromIndex\n  });\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  });\n  (0, import_react40.useEffect)(() => {\n    const focusOnOpen = initialIsOpen || defaultIsOpen || isOpen;\n    if (focusOnOpen && inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []);\n  (0, import_react40.useEffect)(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n    previousResultCountRef.current = items.length;\n  });\n  const mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [comboboxRef, menuRef, toggleButtonRef], environment, () => {\n    dispatch2({\n      type: InputBlur,\n      selectItem: false\n    });\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker(\"getInputProps\", \"getComboboxProps\", \"getMenuProps\");\n  (0, import_react40.useEffect)(() => {\n    isInitialMountRef.current = false;\n  }, []);\n  (0, import_react40.useEffect)(() => {\n    if (!isOpen) {\n      itemRefs.current = {};\n    }\n  }, [isOpen]);\n  const inputKeyDownHandlers = (0, import_react40.useMemo)(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch2({\n        type: InputKeyDownArrowDown,\n        shiftKey: event.shiftKey,\n        getItemNodeFromIndex\n      });\n    },\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch2({\n        type: InputKeyDownArrowUp,\n        shiftKey: event.shiftKey,\n        getItemNodeFromIndex\n      });\n    },\n    Home(event) {\n      if (!latest.current.state.isOpen) {\n        return;\n      }\n      event.preventDefault();\n      dispatch2({\n        type: InputKeyDownHome,\n        getItemNodeFromIndex\n      });\n    },\n    End(event) {\n      if (!latest.current.state.isOpen) {\n        return;\n      }\n      event.preventDefault();\n      dispatch2({\n        type: InputKeyDownEnd,\n        getItemNodeFromIndex\n      });\n    },\n    Escape() {\n      const latestState = latest.current.state;\n      if (latestState.isOpen || latestState.inputValue || latestState.selectedItem || latestState.highlightedIndex > -1) {\n        dispatch2({\n          type: InputKeyDownEscape\n        });\n      }\n    },\n    Enter(event) {\n      const latestState = latest.current.state;\n      if (!latestState.isOpen || latestState.highlightedIndex < 0 || event.which === 229) {\n        return;\n      }\n      event.preventDefault();\n      dispatch2({\n        type: InputKeyDownEnter,\n        getItemNodeFromIndex\n      });\n    }\n  }), [dispatch2, latest, getItemNodeFromIndex]);\n  const getLabelProps = (0, import_react40.useCallback)((labelProps) => ({\n    id: elementIds.labelId,\n    htmlFor: elementIds.inputId,\n    ...labelProps\n  }), [elementIds]);\n  const getMenuProps = (0, import_react40.useCallback)(function(_temp, _temp2) {\n    let {\n      onMouseLeave,\n      refKey = \"ref\",\n      ref,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    let {\n      suppressRefError = false\n    } = _temp2 === void 0 ? {} : _temp2;\n    setGetterPropCallInfo(\"getMenuProps\", suppressRefError, refKey, menuRef);\n    return {\n      [refKey]: handleRefs(ref, (menuNode) => {\n        menuRef.current = menuNode;\n      }),\n      id: elementIds.menuId,\n      role: \"listbox\",\n      \"aria-labelledby\": elementIds.labelId,\n      onMouseLeave: callAllEventHandlers(onMouseLeave, () => {\n        dispatch2({\n          type: MenuMouseLeave\n        });\n      }),\n      ...rest\n    };\n  }, [dispatch2, setGetterPropCallInfo, elementIds]);\n  const getItemProps = (0, import_react40.useCallback)(function(_temp3) {\n    let {\n      item,\n      index: index5,\n      refKey = \"ref\",\n      ref,\n      onMouseMove,\n      onClick,\n      onPress,\n      ...rest\n    } = _temp3 === void 0 ? {} : _temp3;\n    const {\n      props: latestProps,\n      state: latestState\n    } = latest.current;\n    const itemIndex = getItemIndex(index5, item, latestProps.items);\n    if (itemIndex < 0) {\n      throw new Error(\"Pass either item or item index in getItemProps!\");\n    }\n    const onSelectKey = \"onClick\";\n    const customClickHandler = onClick;\n    const itemHandleMouseMove = () => {\n      if (index5 === latestState.highlightedIndex) {\n        return;\n      }\n      shouldScrollRef.current = false;\n      dispatch2({\n        type: ItemMouseMove,\n        index: index5\n      });\n    };\n    const itemHandleClick = () => {\n      dispatch2({\n        type: ItemClick,\n        index: index5\n      });\n      if (inputRef.current) {\n        inputRef.current.focus();\n      }\n    };\n    return {\n      [refKey]: handleRefs(ref, (itemNode) => {\n        if (itemNode) {\n          itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;\n        }\n      }),\n      role: \"option\",\n      \"aria-selected\": \"\" + (itemIndex === latestState.highlightedIndex),\n      id: elementIds.getItemId(itemIndex),\n      ...!rest.disabled && {\n        onMouseMove: callAllEventHandlers(onMouseMove, itemHandleMouseMove),\n        [onSelectKey]: callAllEventHandlers(customClickHandler, itemHandleClick)\n      },\n      ...rest\n    };\n  }, [dispatch2, latest, shouldScrollRef, elementIds]);\n  const getToggleButtonProps = (0, import_react40.useCallback)(function(_temp4) {\n    let {\n      onClick,\n      onPress,\n      refKey = \"ref\",\n      ref,\n      ...rest\n    } = _temp4 === void 0 ? {} : _temp4;\n    const toggleButtonHandleClick = () => {\n      dispatch2({\n        type: ToggleButtonClick\n      });\n      if (!latest.current.state.isOpen && inputRef.current) {\n        inputRef.current.focus();\n      }\n    };\n    return {\n      [refKey]: handleRefs(ref, (toggleButtonNode) => {\n        toggleButtonRef.current = toggleButtonNode;\n      }),\n      id: elementIds.toggleButtonId,\n      tabIndex: -1,\n      ...!rest.disabled && {\n        ...{\n          onClick: callAllEventHandlers(onClick, toggleButtonHandleClick)\n        }\n      },\n      ...rest\n    };\n  }, [dispatch2, latest, elementIds]);\n  const getInputProps = (0, import_react40.useCallback)(function(_temp5, _temp6) {\n    let {\n      onKeyDown,\n      onChange,\n      onInput,\n      onBlur,\n      onChangeText,\n      refKey = \"ref\",\n      ref,\n      ...rest\n    } = _temp5 === void 0 ? {} : _temp5;\n    let {\n      suppressRefError = false\n    } = _temp6 === void 0 ? {} : _temp6;\n    setGetterPropCallInfo(\"getInputProps\", suppressRefError, refKey, inputRef);\n    const latestState = latest.current.state;\n    const inputHandleKeyDown = (event) => {\n      const key = normalizeArrowKey(event);\n      if (key && inputKeyDownHandlers[key]) {\n        inputKeyDownHandlers[key](event);\n      }\n    };\n    const inputHandleChange = (event) => {\n      dispatch2({\n        type: InputChange,\n        inputValue: event.target.value\n      });\n    };\n    const inputHandleBlur = () => {\n      if (latestState.isOpen && !mouseAndTouchTrackersRef.current.isMouseDown) {\n        dispatch2({\n          type: InputBlur,\n          selectItem: true\n        });\n      }\n    };\n    const onChangeKey = \"onChange\";\n    let eventHandlers = {};\n    if (!rest.disabled) {\n      eventHandlers = {\n        [onChangeKey]: callAllEventHandlers(onChange, onInput, inputHandleChange),\n        onKeyDown: callAllEventHandlers(onKeyDown, inputHandleKeyDown),\n        onBlur: callAllEventHandlers(onBlur, inputHandleBlur)\n      };\n    }\n    return {\n      [refKey]: handleRefs(ref, (inputNode) => {\n        inputRef.current = inputNode;\n      }),\n      id: elementIds.inputId,\n      \"aria-autocomplete\": \"list\",\n      \"aria-controls\": elementIds.menuId,\n      ...latestState.isOpen && latestState.highlightedIndex > -1 && {\n        \"aria-activedescendant\": elementIds.getItemId(latestState.highlightedIndex)\n      },\n      \"aria-labelledby\": elementIds.labelId,\n      // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion\n      // revert back since autocomplete=\"nope\" is ignored on latest Chrome and Opera\n      autoComplete: \"off\",\n      value: latestState.inputValue,\n      ...eventHandlers,\n      ...rest\n    };\n  }, [dispatch2, inputKeyDownHandlers, latest, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds]);\n  const getComboboxProps = (0, import_react40.useCallback)(function(_temp7, _temp8) {\n    let {\n      refKey = \"ref\",\n      ref,\n      ...rest\n    } = _temp7 === void 0 ? {} : _temp7;\n    let {\n      suppressRefError = false\n    } = _temp8 === void 0 ? {} : _temp8;\n    setGetterPropCallInfo(\"getComboboxProps\", suppressRefError, refKey, comboboxRef);\n    return {\n      [refKey]: handleRefs(ref, (comboboxNode) => {\n        comboboxRef.current = comboboxNode;\n      }),\n      role: \"combobox\",\n      \"aria-haspopup\": \"listbox\",\n      \"aria-owns\": elementIds.menuId,\n      \"aria-expanded\": latest.current.state.isOpen,\n      ...rest\n    };\n  }, [latest, setGetterPropCallInfo, elementIds]);\n  const toggleMenu = (0, import_react40.useCallback)(() => {\n    dispatch2({\n      type: FunctionToggleMenu\n    });\n  }, [dispatch2]);\n  const closeMenu = (0, import_react40.useCallback)(() => {\n    dispatch2({\n      type: FunctionCloseMenu\n    });\n  }, [dispatch2]);\n  const openMenu = (0, import_react40.useCallback)(() => {\n    dispatch2({\n      type: FunctionOpenMenu\n    });\n  }, [dispatch2]);\n  const setHighlightedIndex = (0, import_react40.useCallback)((newHighlightedIndex) => {\n    dispatch2({\n      type: FunctionSetHighlightedIndex,\n      highlightedIndex: newHighlightedIndex\n    });\n  }, [dispatch2]);\n  const selectItem = (0, import_react40.useCallback)((newSelectedItem) => {\n    dispatch2({\n      type: FunctionSelectItem,\n      selectedItem: newSelectedItem\n    });\n  }, [dispatch2]);\n  const setInputValue = (0, import_react40.useCallback)((newInputValue) => {\n    dispatch2({\n      type: FunctionSetInputValue,\n      inputValue: newInputValue\n    });\n  }, [dispatch2]);\n  const reset = (0, import_react40.useCallback)(() => {\n    dispatch2({\n      type: FunctionReset$1\n    });\n  }, [dispatch2]);\n  return {\n    // prop getters.\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    getInputProps,\n    getComboboxProps,\n    getToggleButtonProps,\n    // actions.\n    toggleMenu,\n    openMenu,\n    closeMenu,\n    setHighlightedIndex,\n    setInputValue,\n    selectItem,\n    reset,\n    // state.\n    highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\nvar defaultStateValues = {\n  activeIndex: -1,\n  selectedItems: []\n};\nfunction getInitialValue(props, propKey) {\n  return getInitialValue$1(props, propKey, defaultStateValues);\n}\nfunction getDefaultValue(props, propKey) {\n  return getDefaultValue$1(props, propKey, defaultStateValues);\n}\nfunction getInitialState(props) {\n  const activeIndex = getInitialValue(props, \"activeIndex\");\n  const selectedItems = getInitialValue(props, \"selectedItems\");\n  return {\n    activeIndex,\n    selectedItems\n  };\n}\nfunction isKeyDownOperationPermitted(event) {\n  if (event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {\n    return false;\n  }\n  const element4 = event.target;\n  if (element4 instanceof HTMLInputElement && // if element is a text input\n  element4.value !== \"\" && // and we have text in it\n  // and cursor is either not at the start or is currently highlighting text.\n  (element4.selectionStart !== 0 || element4.selectionEnd !== 0)) {\n    return false;\n  }\n  return true;\n}\nfunction getA11yRemovalMessage(selectionParameters) {\n  const {\n    removedSelectedItem,\n    itemToString: itemToStringLocal\n  } = selectionParameters;\n  return itemToStringLocal(removedSelectedItem) + \" has been removed.\";\n}\nvar propTypes = {\n  selectedItems: import_prop_types.default.array,\n  initialSelectedItems: import_prop_types.default.array,\n  defaultSelectedItems: import_prop_types.default.array,\n  itemToString: import_prop_types.default.func,\n  getA11yRemovalMessage: import_prop_types.default.func,\n  stateReducer: import_prop_types.default.func,\n  activeIndex: import_prop_types.default.number,\n  initialActiveIndex: import_prop_types.default.number,\n  defaultActiveIndex: import_prop_types.default.number,\n  onActiveIndexChange: import_prop_types.default.func,\n  onSelectedItemsChange: import_prop_types.default.func,\n  keyNavigationNext: import_prop_types.default.string,\n  keyNavigationPrevious: import_prop_types.default.string,\n  environment: import_prop_types.default.shape({\n    addEventListener: import_prop_types.default.func,\n    removeEventListener: import_prop_types.default.func,\n    document: import_prop_types.default.shape({\n      getElementById: import_prop_types.default.func,\n      activeElement: import_prop_types.default.any,\n      body: import_prop_types.default.any\n    })\n  })\n};\nvar defaultProps2 = {\n  itemToString: defaultProps$3.itemToString,\n  stateReducer: defaultProps$3.stateReducer,\n  environment: defaultProps$3.environment,\n  getA11yRemovalMessage,\n  keyNavigationNext: \"ArrowRight\",\n  keyNavigationPrevious: \"ArrowLeft\"\n};\nvar validatePropTypes = noop2;\nif (true) {\n  validatePropTypes = (options, caller) => {\n    import_prop_types.default.checkPropTypes(propTypes, options, \"prop\", caller.name);\n  };\n}\nvar SelectedItemClick = true ? \"__selected_item_click__\" : 0;\nvar SelectedItemKeyDownDelete = true ? \"__selected_item_keydown_delete__\" : 1;\nvar SelectedItemKeyDownBackspace = true ? \"__selected_item_keydown_backspace__\" : 2;\nvar SelectedItemKeyDownNavigationNext = true ? \"__selected_item_keydown_navigation_next__\" : 3;\nvar SelectedItemKeyDownNavigationPrevious = true ? \"__selected_item_keydown_navigation_previous__\" : 4;\nvar DropdownKeyDownNavigationPrevious = true ? \"__dropdown_keydown_navigation_previous__\" : 5;\nvar DropdownKeyDownBackspace = true ? \"__dropdown_keydown_backspace__\" : 6;\nvar DropdownClick = true ? \"__dropdown_click__\" : 7;\nvar FunctionAddSelectedItem = true ? \"__function_add_selected_item__\" : 8;\nvar FunctionRemoveSelectedItem = true ? \"__function_remove_selected_item__\" : 9;\nvar FunctionSetSelectedItems = true ? \"__function_set_selected_items__\" : 10;\nvar FunctionSetActiveIndex = true ? \"__function_set_active_index__\" : 11;\nvar FunctionReset = true ? \"__function_reset__\" : 12;\nvar stateChangeTypes = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  SelectedItemClick,\n  SelectedItemKeyDownDelete,\n  SelectedItemKeyDownBackspace,\n  SelectedItemKeyDownNavigationNext,\n  SelectedItemKeyDownNavigationPrevious,\n  DropdownKeyDownNavigationPrevious,\n  DropdownKeyDownBackspace,\n  DropdownClick,\n  FunctionAddSelectedItem,\n  FunctionRemoveSelectedItem,\n  FunctionSetSelectedItems,\n  FunctionSetActiveIndex,\n  FunctionReset\n});\nfunction downshiftMultipleSelectionReducer(state, action) {\n  const {\n    type,\n    index: index5,\n    props,\n    selectedItem\n  } = action;\n  const {\n    activeIndex,\n    selectedItems\n  } = state;\n  let changes;\n  switch (type) {\n    case SelectedItemClick:\n      changes = {\n        activeIndex: index5\n      };\n      break;\n    case SelectedItemKeyDownNavigationPrevious:\n      changes = {\n        activeIndex: activeIndex - 1 < 0 ? 0 : activeIndex - 1\n      };\n      break;\n    case SelectedItemKeyDownNavigationNext:\n      changes = {\n        activeIndex: activeIndex + 1 >= selectedItems.length ? -1 : activeIndex + 1\n      };\n      break;\n    case SelectedItemKeyDownBackspace:\n    case SelectedItemKeyDownDelete: {\n      let newActiveIndex = activeIndex;\n      if (selectedItems.length === 1) {\n        newActiveIndex = -1;\n      } else if (activeIndex === selectedItems.length - 1) {\n        newActiveIndex = selectedItems.length - 2;\n      }\n      changes = {\n        selectedItems: [...selectedItems.slice(0, activeIndex), ...selectedItems.slice(activeIndex + 1)],\n        ...{\n          activeIndex: newActiveIndex\n        }\n      };\n      break;\n    }\n    case DropdownKeyDownNavigationPrevious:\n      changes = {\n        activeIndex: selectedItems.length - 1\n      };\n      break;\n    case DropdownKeyDownBackspace:\n      changes = {\n        selectedItems: selectedItems.slice(0, selectedItems.length - 1)\n      };\n      break;\n    case FunctionAddSelectedItem:\n      changes = {\n        selectedItems: [...selectedItems, selectedItem]\n      };\n      break;\n    case DropdownClick:\n      changes = {\n        activeIndex: -1\n      };\n      break;\n    case FunctionRemoveSelectedItem: {\n      let newActiveIndex = activeIndex;\n      const selectedItemIndex = selectedItems.indexOf(selectedItem);\n      if (selectedItemIndex >= 0) {\n        if (selectedItems.length === 1) {\n          newActiveIndex = -1;\n        } else if (selectedItemIndex === selectedItems.length - 1) {\n          newActiveIndex = selectedItems.length - 2;\n        }\n        changes = {\n          selectedItems: [...selectedItems.slice(0, selectedItemIndex), ...selectedItems.slice(selectedItemIndex + 1)],\n          activeIndex: newActiveIndex\n        };\n      }\n      break;\n    }\n    case FunctionSetSelectedItems: {\n      const {\n        selectedItems: newSelectedItems\n      } = action;\n      changes = {\n        selectedItems: newSelectedItems\n      };\n      break;\n    }\n    case FunctionSetActiveIndex: {\n      const {\n        activeIndex: newActiveIndex\n      } = action;\n      changes = {\n        activeIndex: newActiveIndex\n      };\n      break;\n    }\n    case FunctionReset:\n      changes = {\n        activeIndex: getDefaultValue(props, \"activeIndex\"),\n        selectedItems: getDefaultValue(props, \"selectedItems\")\n      };\n      break;\n    default:\n      throw new Error(\"Reducer called without proper action type.\");\n  }\n  return {\n    ...state,\n    ...changes\n  };\n}\nuseMultipleSelection.stateChangeTypes = stateChangeTypes;\nfunction useMultipleSelection(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n  validatePropTypes(userProps, useMultipleSelection);\n  const props = {\n    ...defaultProps2,\n    ...userProps\n  };\n  const {\n    getA11yRemovalMessage: getA11yRemovalMessage2,\n    itemToString: itemToString2,\n    environment,\n    keyNavigationNext,\n    keyNavigationPrevious\n  } = props;\n  const [state, dispatch2] = useControlledReducer$1(downshiftMultipleSelectionReducer, getInitialState(props), props);\n  const {\n    activeIndex,\n    selectedItems\n  } = state;\n  const isInitialMountRef = (0, import_react40.useRef)(true);\n  const dropdownRef = (0, import_react40.useRef)(null);\n  const previousSelectedItemsRef = (0, import_react40.useRef)(selectedItems);\n  const selectedItemRefs = (0, import_react40.useRef)();\n  selectedItemRefs.current = [];\n  const latest = useLatestRef2({\n    state,\n    props\n  });\n  (0, import_react40.useEffect)(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n    if (selectedItems.length < previousSelectedItemsRef.current.length) {\n      const removedSelectedItem = previousSelectedItemsRef.current.find((item) => selectedItems.indexOf(item) < 0);\n      setStatus(getA11yRemovalMessage2({\n        itemToString: itemToString2,\n        resultCount: selectedItems.length,\n        removedSelectedItem,\n        activeIndex,\n        activeSelectedItem: selectedItems[activeIndex]\n      }), environment.document);\n    }\n    previousSelectedItemsRef.current = selectedItems;\n  }, [selectedItems.length]);\n  (0, import_react40.useEffect)(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n    if (activeIndex === -1 && dropdownRef.current) {\n      dropdownRef.current.focus();\n    } else if (selectedItemRefs.current[activeIndex]) {\n      selectedItemRefs.current[activeIndex].focus();\n    }\n  }, [activeIndex]);\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker(\"getDropdownProps\");\n  (0, import_react40.useEffect)(() => {\n    isInitialMountRef.current = false;\n  }, []);\n  const selectedItemKeyDownHandlers = (0, import_react40.useMemo)(() => ({\n    [keyNavigationPrevious]() {\n      dispatch2({\n        type: SelectedItemKeyDownNavigationPrevious\n      });\n    },\n    [keyNavigationNext]() {\n      dispatch2({\n        type: SelectedItemKeyDownNavigationNext\n      });\n    },\n    Delete() {\n      dispatch2({\n        type: SelectedItemKeyDownDelete\n      });\n    },\n    Backspace() {\n      dispatch2({\n        type: SelectedItemKeyDownBackspace\n      });\n    }\n  }), [dispatch2, keyNavigationNext, keyNavigationPrevious]);\n  const dropdownKeyDownHandlers = (0, import_react40.useMemo)(() => ({\n    [keyNavigationPrevious](event) {\n      if (isKeyDownOperationPermitted(event)) {\n        dispatch2({\n          type: DropdownKeyDownNavigationPrevious\n        });\n      }\n    },\n    Backspace(event) {\n      if (isKeyDownOperationPermitted(event)) {\n        dispatch2({\n          type: DropdownKeyDownBackspace\n        });\n      }\n    }\n  }), [dispatch2, keyNavigationPrevious]);\n  const getSelectedItemProps = (0, import_react40.useCallback)(function(_temp) {\n    let {\n      refKey = \"ref\",\n      ref,\n      onClick,\n      onKeyDown,\n      selectedItem,\n      index: index5,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    const {\n      state: latestState\n    } = latest.current;\n    const itemIndex = getItemIndex(index5, selectedItem, latestState.selectedItems);\n    if (itemIndex < 0) {\n      throw new Error(\"Pass either selectedItem or index in getSelectedItemProps!\");\n    }\n    const selectedItemHandleClick = () => {\n      dispatch2({\n        type: SelectedItemClick,\n        index: index5\n      });\n    };\n    const selectedItemHandleKeyDown = (event) => {\n      const key = normalizeArrowKey(event);\n      if (key && selectedItemKeyDownHandlers[key]) {\n        selectedItemKeyDownHandlers[key](event);\n      }\n    };\n    return {\n      [refKey]: handleRefs(ref, (selectedItemNode) => {\n        if (selectedItemNode) {\n          selectedItemRefs.current.push(selectedItemNode);\n        }\n      }),\n      tabIndex: index5 === latestState.activeIndex ? 0 : -1,\n      onClick: callAllEventHandlers(onClick, selectedItemHandleClick),\n      onKeyDown: callAllEventHandlers(onKeyDown, selectedItemHandleKeyDown),\n      ...rest\n    };\n  }, [dispatch2, latest, selectedItemKeyDownHandlers]);\n  const getDropdownProps = (0, import_react40.useCallback)(function(_temp2, _temp3) {\n    let {\n      refKey = \"ref\",\n      ref,\n      onKeyDown,\n      onClick,\n      preventKeyAction = false,\n      ...rest\n    } = _temp2 === void 0 ? {} : _temp2;\n    let {\n      suppressRefError = false\n    } = _temp3 === void 0 ? {} : _temp3;\n    setGetterPropCallInfo(\"getDropdownProps\", suppressRefError, refKey, dropdownRef);\n    const dropdownHandleKeyDown = (event) => {\n      const key = normalizeArrowKey(event);\n      if (key && dropdownKeyDownHandlers[key]) {\n        dropdownKeyDownHandlers[key](event);\n      }\n    };\n    const dropdownHandleClick = () => {\n      dispatch2({\n        type: DropdownClick\n      });\n    };\n    return {\n      [refKey]: handleRefs(ref, (dropdownNode) => {\n        if (dropdownNode) {\n          dropdownRef.current = dropdownNode;\n        }\n      }),\n      ...!preventKeyAction && {\n        onKeyDown: callAllEventHandlers(onKeyDown, dropdownHandleKeyDown),\n        onClick: callAllEventHandlers(onClick, dropdownHandleClick)\n      },\n      ...rest\n    };\n  }, [dispatch2, dropdownKeyDownHandlers, setGetterPropCallInfo]);\n  const addSelectedItem = (0, import_react40.useCallback)((selectedItem) => {\n    dispatch2({\n      type: FunctionAddSelectedItem,\n      selectedItem\n    });\n  }, [dispatch2]);\n  const removeSelectedItem = (0, import_react40.useCallback)((selectedItem) => {\n    dispatch2({\n      type: FunctionRemoveSelectedItem,\n      selectedItem\n    });\n  }, [dispatch2]);\n  const setSelectedItems = (0, import_react40.useCallback)((newSelectedItems) => {\n    dispatch2({\n      type: FunctionSetSelectedItems,\n      selectedItems: newSelectedItems\n    });\n  }, [dispatch2]);\n  const setActiveIndex = (0, import_react40.useCallback)((newActiveIndex) => {\n    dispatch2({\n      type: FunctionSetActiveIndex,\n      activeIndex: newActiveIndex\n    });\n  }, [dispatch2]);\n  const reset = (0, import_react40.useCallback)(() => {\n    dispatch2({\n      type: FunctionReset\n    });\n  }, [dispatch2]);\n  return {\n    getSelectedItemProps,\n    getDropdownProps,\n    addSelectedItem,\n    removeSelectedItem,\n    setSelectedItems,\n    setActiveIndex,\n    reset,\n    selectedItems,\n    activeIndex\n  };\n}\n\n// node_modules/@udecode/plate-combobox/dist/index.es.js\nvar createComboboxStore = (state) => createStore3(`combobox-${state.id}`)(state);\nvar comboboxStore = createStore3(\"combobox\")({\n  activeId: null,\n  byId: {},\n  floatingOptions: {},\n  highlightedIndex: 0,\n  items: [],\n  filteredItems: [],\n  targetRange: null,\n  text: null\n}).extendActions((set4, get3) => ({\n  setComboboxById: (state) => {\n    if (get3.byId()[state.id])\n      return;\n    set4.state((draft) => {\n      draft.byId[state.id] = createComboboxStore(state);\n    });\n  },\n  open: (state) => {\n    set4.mergeState(state);\n  },\n  reset: () => {\n    set4.state((draft) => {\n      draft.activeId = null;\n      draft.highlightedIndex = 0;\n      draft.items = [];\n      draft.text = null;\n      draft.targetRange = null;\n    });\n  }\n})).extendSelectors((state) => ({\n  isOpen: () => !!state.activeId\n}));\nvar useComboboxSelectors = comboboxStore.use;\nvar comboboxSelectors = comboboxStore.get;\nvar comboboxActions = comboboxStore.set;\nvar getComboboxStoreById = (id) => id ? comboboxSelectors.byId()[id] : null;\nvar getTextFromTrigger = (editor, {\n  at,\n  trigger: trigger2,\n  searchPattern = `\\\\S+`\n}) => {\n  const escapedTrigger = escapeRegExp(trigger2);\n  const triggerRegex = new RegExp(`(?:^|\\\\s)${escapedTrigger}`);\n  let start2 = at;\n  let end2;\n  while (true) {\n    end2 = start2;\n    if (!start2)\n      break;\n    start2 = getPointBefore(editor, start2);\n    const charRange = start2 && getRange(editor, start2, end2);\n    const charText = getEditorString(editor, charRange);\n    if (!charText.match(searchPattern)) {\n      start2 = end2;\n      break;\n    }\n  }\n  const range = start2 && getRange(editor, start2, at);\n  const text4 = getEditorString(editor, range);\n  if (!range || !text4.match(triggerRegex))\n    return;\n  return {\n    range,\n    textAfterTrigger: text4.substring(trigger2.length)\n  };\n};\nvar onChangeCombobox = (editor) => () => {\n  const byId = comboboxSelectors.byId();\n  const activeId = comboboxSelectors.activeId();\n  let shouldClose = true;\n  for (const store of Object.values(byId)) {\n    var _store$get$controlled, _store$get, _store$get$searchPatt, _store$get2;\n    const id = store.get.id();\n    const controlled = (_store$get$controlled = (_store$get = store.get).controlled) === null || _store$get$controlled === void 0 ? void 0 : _store$get$controlled.call(_store$get);\n    if (controlled) {\n      if (activeId === id) {\n        shouldClose = false;\n        break;\n      } else {\n        continue;\n      }\n    }\n    const {\n      selection\n    } = editor;\n    if (!selection || !isCollapsed(selection)) {\n      continue;\n    }\n    const trigger2 = store.get.trigger();\n    const searchPattern = (_store$get$searchPatt = (_store$get2 = store.get).searchPattern) === null || _store$get$searchPatt === void 0 ? void 0 : _store$get$searchPatt.call(_store$get2);\n    const isCursorAfterTrigger = getTextFromTrigger(editor, {\n      at: Range.start(selection),\n      trigger: trigger2,\n      searchPattern\n    });\n    if (!isCursorAfterTrigger) {\n      continue;\n    }\n    const {\n      range,\n      textAfterTrigger\n    } = isCursorAfterTrigger;\n    comboboxActions.open({\n      activeId: id,\n      text: textAfterTrigger,\n      targetRange: range\n    });\n    shouldClose = false;\n    break;\n  }\n  if (shouldClose && comboboxSelectors.isOpen()) {\n    comboboxActions.reset();\n  }\n};\nfunction unwrapExports7(x4) {\n  return x4 && x4.__esModule && Object.prototype.hasOwnProperty.call(x4, \"default\") ? x4[\"default\"] : x4;\n}\nfunction createCommonjsModule9(fn4, module2) {\n  return module2 = { exports: {} }, fn4(module2, module2.exports), module2.exports;\n}\nvar lib7 = createCommonjsModule9(function(module2, exports2) {\n  Object.defineProperty(exports2, \"__esModule\", {\n    value: true\n  });\n  var IS_MAC = () => typeof window != \"undefined\" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n  var MODIFIERS = {\n    alt: \"altKey\",\n    control: \"ctrlKey\",\n    meta: \"metaKey\",\n    shift: \"shiftKey\"\n  };\n  var ALIASES = () => ({\n    add: \"+\",\n    break: \"pause\",\n    cmd: \"meta\",\n    command: \"meta\",\n    ctl: \"control\",\n    ctrl: \"control\",\n    del: \"delete\",\n    down: \"arrowdown\",\n    esc: \"escape\",\n    ins: \"insert\",\n    left: \"arrowleft\",\n    mod: IS_MAC() ? \"meta\" : \"control\",\n    opt: \"alt\",\n    option: \"alt\",\n    return: \"enter\",\n    right: \"arrowright\",\n    space: \" \",\n    spacebar: \" \",\n    up: \"arrowup\",\n    win: \"meta\",\n    windows: \"meta\"\n  });\n  var CODES = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    shift: 16,\n    control: 17,\n    alt: 18,\n    pause: 19,\n    capslock: 20,\n    escape: 27,\n    \" \": 32,\n    pageup: 33,\n    pagedown: 34,\n    end: 35,\n    home: 36,\n    arrowleft: 37,\n    arrowup: 38,\n    arrowright: 39,\n    arrowdown: 40,\n    insert: 45,\n    delete: 46,\n    meta: 91,\n    numlock: 144,\n    scrolllock: 145,\n    \";\": 186,\n    \"=\": 187,\n    \",\": 188,\n    \"-\": 189,\n    \".\": 190,\n    \"/\": 191,\n    \"`\": 192,\n    \"[\": 219,\n    \"\\\\\": 220,\n    \"]\": 221,\n    \"'\": 222\n  };\n  for (var f5 = 1; f5 < 20; f5++) {\n    CODES[\"f\" + f5] = 111 + f5;\n  }\n  function isHotkey9(hotkey, options, event) {\n    if (options && !(\"byKey\" in options)) {\n      event = options;\n      options = null;\n    }\n    if (!Array.isArray(hotkey)) {\n      hotkey = [hotkey];\n    }\n    var array = hotkey.map(function(string2) {\n      return parseHotkey(string2, options);\n    });\n    var check = function check2(e4) {\n      return array.some(function(object) {\n        return compareHotkey(object, e4);\n      });\n    };\n    var ret = event == null ? check : check(event);\n    return ret;\n  }\n  function isCodeHotkey(hotkey, event) {\n    return isHotkey9(hotkey, event);\n  }\n  function isKeyHotkey2(hotkey, event) {\n    return isHotkey9(hotkey, { byKey: true }, event);\n  }\n  function parseHotkey(hotkey, options) {\n    var byKey = options && options.byKey;\n    var ret = {};\n    hotkey = hotkey.replace(\"++\", \"+add\");\n    var values2 = hotkey.split(\"+\");\n    var length = values2.length;\n    for (var k3 in MODIFIERS) {\n      ret[MODIFIERS[k3]] = false;\n    }\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = void 0;\n    try {\n      for (var _iterator = values2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var value = _step.value;\n        var optional = value.endsWith(\"?\") && value.length > 1;\n        if (optional) {\n          value = value.slice(0, -1);\n        }\n        var name = toKeyName(value);\n        var modifier = MODIFIERS[name];\n        if (length === 1 || !modifier) {\n          if (byKey) {\n            ret.key = name;\n          } else {\n            ret.which = toKeyCode(value);\n          }\n        }\n        if (modifier) {\n          ret[modifier] = optional ? null : true;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    return ret;\n  }\n  function compareHotkey(object, event) {\n    for (var key in object) {\n      var expected = object[key];\n      var actual = void 0;\n      if (expected == null) {\n        continue;\n      }\n      if (key === \"key\" && event.key != null) {\n        actual = event.key.toLowerCase();\n      } else if (key === \"which\") {\n        actual = expected === 91 && event.which === 93 ? 91 : event.which;\n      } else {\n        actual = event[key];\n      }\n      if (actual == null && expected === false) {\n        continue;\n      }\n      if (actual !== expected) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function toKeyCode(name) {\n    name = toKeyName(name);\n    var code3 = CODES[name] || name.toUpperCase().charCodeAt(0);\n    return code3;\n  }\n  function toKeyName(name) {\n    name = name.toLowerCase();\n    name = ALIASES()[name] || name;\n    return name;\n  }\n  exports2.default = isHotkey9;\n  exports2.isHotkey = isHotkey9;\n  exports2.isCodeHotkey = isCodeHotkey;\n  exports2.isKeyHotkey = isKeyHotkey2;\n  exports2.parseHotkey = parseHotkey;\n  exports2.compareHotkey = compareHotkey;\n  exports2.toKeyCode = toKeyCode;\n  exports2.toKeyName = toKeyName;\n});\nvar isHotkey7 = unwrapExports7(lib7);\nlib7.isHotkey;\nlib7.isCodeHotkey;\nlib7.isKeyHotkey;\nlib7.parseHotkey;\nlib7.compareHotkey;\nlib7.toKeyCode;\nlib7.toKeyName;\nvar getNextNonDisabledIndex2 = (moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) => {\n  const currentElementNode = getItemNodeFromIndex(baseIndex);\n  if (!currentElementNode || !currentElementNode.hasAttribute(\"disabled\")) {\n    return baseIndex;\n  }\n  if (moveAmount > 0) {\n    for (let index5 = baseIndex + 1; index5 < itemCount; index5++) {\n      if (!getItemNodeFromIndex(index5).hasAttribute(\"disabled\")) {\n        return index5;\n      }\n    }\n  } else {\n    for (let index5 = baseIndex - 1; index5 >= 0; index5--) {\n      if (!getItemNodeFromIndex(index5).hasAttribute(\"disabled\")) {\n        return index5;\n      }\n    }\n  }\n  if (circular) {\n    return moveAmount > 0 ? getNextNonDisabledIndex2(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex2(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);\n  }\n  return -1;\n};\nvar getNextWrappingIndex2 = (moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular = true) => {\n  if (itemCount === 0) {\n    return -1;\n  }\n  const itemsLastIndex = itemCount - 1;\n  if (typeof baseIndex !== \"number\" || baseIndex < 0 || baseIndex >= itemCount) {\n    baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;\n  }\n  let newIndex = baseIndex + moveAmount;\n  if (newIndex < 0) {\n    newIndex = circular ? itemsLastIndex : 0;\n  } else if (newIndex > itemsLastIndex) {\n    newIndex = circular ? 0 : itemsLastIndex;\n  }\n  const nonDisabledNewIndex = getNextNonDisabledIndex2(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular);\n  if (nonDisabledNewIndex === -1) {\n    return baseIndex >= itemCount ? -1 : baseIndex;\n  }\n  return nonDisabledNewIndex;\n};\nvar onKeyDownCombobox = (editor) => (event) => {\n  const {\n    highlightedIndex,\n    filteredItems,\n    activeId\n  } = comboboxSelectors.state();\n  const isOpen = comboboxSelectors.isOpen();\n  if (!isOpen)\n    return;\n  const store = getComboboxStoreById(activeId);\n  if (!store)\n    return;\n  const onSelectItem = store.get.onSelectItem();\n  if (isHotkey7(\"down\", event)) {\n    event.preventDefault();\n    const newIndex = getNextWrappingIndex2(1, highlightedIndex, filteredItems.length, () => {\n    }, true);\n    comboboxActions.highlightedIndex(newIndex);\n    return;\n  }\n  if (isHotkey7(\"up\", event)) {\n    event.preventDefault();\n    const newIndex = getNextWrappingIndex2(-1, highlightedIndex, filteredItems.length, () => {\n    }, true);\n    comboboxActions.highlightedIndex(newIndex);\n    return;\n  }\n  if (isHotkey7(\"escape\", event)) {\n    event.preventDefault();\n    comboboxActions.reset();\n    return;\n  }\n  if (Hotkeys2.isTab(editor, event) || isHotkey7(\"enter\", event)) {\n    event.preventDefault();\n    event.stopPropagation();\n    if (filteredItems[highlightedIndex]) {\n      onSelectItem === null || onSelectItem === void 0 ? void 0 : onSelectItem(editor, filteredItems[highlightedIndex]);\n    }\n  }\n};\nvar KEY_COMBOBOX = \"combobox\";\nvar createComboboxPlugin = createPluginFactory({\n  key: KEY_COMBOBOX,\n  handlers: {\n    onChange: onChangeCombobox,\n    onKeyDown: onKeyDownCombobox\n  }\n});\n\n// node_modules/@udecode/plate-mention/dist/index.es.js\nfunction unwrapExports8(x4) {\n  return x4 && x4.__esModule && Object.prototype.hasOwnProperty.call(x4, \"default\") ? x4[\"default\"] : x4;\n}\nfunction createCommonjsModule10(fn4, module2) {\n  return module2 = { exports: {} }, fn4(module2, module2.exports), module2.exports;\n}\nvar lib8 = createCommonjsModule10(function(module2, exports2) {\n  Object.defineProperty(exports2, \"__esModule\", {\n    value: true\n  });\n  var IS_MAC = () => typeof window != \"undefined\" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n  var MODIFIERS = {\n    alt: \"altKey\",\n    control: \"ctrlKey\",\n    meta: \"metaKey\",\n    shift: \"shiftKey\"\n  };\n  var ALIASES = () => ({\n    add: \"+\",\n    break: \"pause\",\n    cmd: \"meta\",\n    command: \"meta\",\n    ctl: \"control\",\n    ctrl: \"control\",\n    del: \"delete\",\n    down: \"arrowdown\",\n    esc: \"escape\",\n    ins: \"insert\",\n    left: \"arrowleft\",\n    mod: IS_MAC() ? \"meta\" : \"control\",\n    opt: \"alt\",\n    option: \"alt\",\n    return: \"enter\",\n    right: \"arrowright\",\n    space: \" \",\n    spacebar: \" \",\n    up: \"arrowup\",\n    win: \"meta\",\n    windows: \"meta\"\n  });\n  var CODES = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    shift: 16,\n    control: 17,\n    alt: 18,\n    pause: 19,\n    capslock: 20,\n    escape: 27,\n    \" \": 32,\n    pageup: 33,\n    pagedown: 34,\n    end: 35,\n    home: 36,\n    arrowleft: 37,\n    arrowup: 38,\n    arrowright: 39,\n    arrowdown: 40,\n    insert: 45,\n    delete: 46,\n    meta: 91,\n    numlock: 144,\n    scrolllock: 145,\n    \";\": 186,\n    \"=\": 187,\n    \",\": 188,\n    \"-\": 189,\n    \".\": 190,\n    \"/\": 191,\n    \"`\": 192,\n    \"[\": 219,\n    \"\\\\\": 220,\n    \"]\": 221,\n    \"'\": 222\n  };\n  for (var f5 = 1; f5 < 20; f5++) {\n    CODES[\"f\" + f5] = 111 + f5;\n  }\n  function isHotkey9(hotkey, options, event) {\n    if (options && !(\"byKey\" in options)) {\n      event = options;\n      options = null;\n    }\n    if (!Array.isArray(hotkey)) {\n      hotkey = [hotkey];\n    }\n    var array = hotkey.map(function(string2) {\n      return parseHotkey(string2, options);\n    });\n    var check = function check2(e4) {\n      return array.some(function(object) {\n        return compareHotkey(object, e4);\n      });\n    };\n    var ret = event == null ? check : check(event);\n    return ret;\n  }\n  function isCodeHotkey(hotkey, event) {\n    return isHotkey9(hotkey, event);\n  }\n  function isKeyHotkey2(hotkey, event) {\n    return isHotkey9(hotkey, { byKey: true }, event);\n  }\n  function parseHotkey(hotkey, options) {\n    var byKey = options && options.byKey;\n    var ret = {};\n    hotkey = hotkey.replace(\"++\", \"+add\");\n    var values2 = hotkey.split(\"+\");\n    var length = values2.length;\n    for (var k3 in MODIFIERS) {\n      ret[MODIFIERS[k3]] = false;\n    }\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = void 0;\n    try {\n      for (var _iterator = values2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var value = _step.value;\n        var optional = value.endsWith(\"?\") && value.length > 1;\n        if (optional) {\n          value = value.slice(0, -1);\n        }\n        var name = toKeyName(value);\n        var modifier = MODIFIERS[name];\n        if (length === 1 || !modifier) {\n          if (byKey) {\n            ret.key = name;\n          } else {\n            ret.which = toKeyCode(value);\n          }\n        }\n        if (modifier) {\n          ret[modifier] = optional ? null : true;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    return ret;\n  }\n  function compareHotkey(object, event) {\n    for (var key in object) {\n      var expected = object[key];\n      var actual = void 0;\n      if (expected == null) {\n        continue;\n      }\n      if (key === \"key\" && event.key != null) {\n        actual = event.key.toLowerCase();\n      } else if (key === \"which\") {\n        actual = expected === 91 && event.which === 93 ? 91 : event.which;\n      } else {\n        actual = event[key];\n      }\n      if (actual == null && expected === false) {\n        continue;\n      }\n      if (actual !== expected) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function toKeyCode(name) {\n    name = toKeyName(name);\n    var code3 = CODES[name] || name.toUpperCase().charCodeAt(0);\n    return code3;\n  }\n  function toKeyName(name) {\n    name = name.toLowerCase();\n    name = ALIASES()[name] || name;\n    return name;\n  }\n  exports2.default = isHotkey9;\n  exports2.isHotkey = isHotkey9;\n  exports2.isCodeHotkey = isCodeHotkey;\n  exports2.isKeyHotkey = isKeyHotkey2;\n  exports2.parseHotkey = parseHotkey;\n  exports2.compareHotkey = compareHotkey;\n  exports2.toKeyCode = toKeyCode;\n  exports2.toKeyName = toKeyName;\n});\nvar isHotkey8 = unwrapExports8(lib8);\nlib8.isHotkey;\nlib8.isCodeHotkey;\nlib8.isKeyHotkey;\nlib8.parseHotkey;\nlib8.compareHotkey;\nlib8.toKeyCode;\nlib8.toKeyName;\nvar findMentionInput = (editor, options) => findNode(editor, {\n  ...options,\n  match: {\n    type: getPluginType(editor, ELEMENT_MENTION_INPUT)\n  }\n});\nvar isNodeMentionInput = (editor, node) => {\n  return node.type === getPluginType(editor, ELEMENT_MENTION_INPUT);\n};\nvar isSelectionInMentionInput = (editor) => findMentionInput(editor) !== void 0;\nvar removeMentionInput = (editor, path) => withoutNormalizing(editor, () => {\n  const node = getNode(editor, path);\n  if (!node)\n    return;\n  const {\n    trigger: trigger2\n  } = node;\n  insertText(editor, trigger2, {\n    at: {\n      path: [...path, 0],\n      offset: 0\n    }\n  });\n  unwrapNodes(editor, {\n    at: path\n  });\n});\nvar moveSelectionByOffset = (editor, {\n  query = () => true\n} = {}) => (event) => {\n  const {\n    selection\n  } = editor;\n  if (!selection || Range.isExpanded(selection) || !query(editor)) {\n    return false;\n  }\n  if (isHotkey8(\"left\", event)) {\n    event.preventDefault();\n    moveSelection(editor, {\n      unit: \"offset\",\n      reverse: true\n    });\n    return true;\n  }\n  if (isHotkey8(\"right\", event)) {\n    event.preventDefault();\n    moveSelection(editor, {\n      unit: \"offset\"\n    });\n    return true;\n  }\n};\nvar mentionOnKeyDownHandler = (options) => (editor) => (event) => {\n  if (isHotkey8(\"escape\", event)) {\n    event.preventDefault();\n    const currentMentionInput = findMentionInput(editor);\n    if (currentMentionInput) {\n      removeMentionInput(editor, currentMentionInput[1]);\n    }\n    return true;\n  }\n  return moveSelectionByOffset(editor, options)(event);\n};\nvar withMention = (editor, {\n  options: {\n    id,\n    trigger: trigger2,\n    inputCreation\n  }\n}) => {\n  const {\n    type\n  } = getPlugin(editor, ELEMENT_MENTION_INPUT);\n  const {\n    apply: apply2,\n    insertBreak,\n    insertText: _insertText,\n    deleteBackward: deleteBackward2,\n    insertFragment: _insertFragment,\n    insertTextData\n  } = editor;\n  const stripNewLineAndTrim = (text4) => {\n    return text4.split(/\\r\\n|\\r|\\n/).map((line) => line.trim()).join(\"\");\n  };\n  editor.insertFragment = (fragment) => {\n    const inMentionInput = findMentionInput(editor) !== void 0;\n    if (!inMentionInput) {\n      return _insertFragment(fragment);\n    }\n    return insertText(editor, fragment.map((node) => stripNewLineAndTrim(getNodeString(node))).join(\"\"));\n  };\n  editor.insertTextData = (data) => {\n    const inMentionInput = findMentionInput(editor) !== void 0;\n    if (!inMentionInput) {\n      return insertTextData(data);\n    }\n    const text4 = data.getData(\"text/plain\");\n    if (!text4) {\n      return false;\n    }\n    editor.insertText(stripNewLineAndTrim(text4));\n    return true;\n  };\n  editor.deleteBackward = (unit) => {\n    const currentMentionInput = findMentionInput(editor);\n    if (currentMentionInput && getNodeString(currentMentionInput[0]) === \"\") {\n      return removeMentionInput(editor, currentMentionInput[1]);\n    }\n    deleteBackward2(unit);\n  };\n  editor.insertBreak = () => {\n    if (isSelectionInMentionInput(editor)) {\n      return;\n    }\n    insertBreak();\n  };\n  editor.insertText = (text4) => {\n    if (!editor.selection || text4 !== trigger2 || isSelectionInMentionInput(editor)) {\n      return _insertText(text4);\n    }\n    const previousChar = getEditorString(editor, getRange(editor, editor.selection, getPointBefore(editor, editor.selection)));\n    const nextChar = getEditorString(editor, getRange(editor, editor.selection, getPointAfter(editor, editor.selection)));\n    const beginningOfLine = previousChar === \"\";\n    const endOfLine = nextChar === \"\";\n    const precededByWhitespace = previousChar === \" \";\n    const followedByWhitespace = nextChar === \" \";\n    if ((beginningOfLine || precededByWhitespace) && (endOfLine || followedByWhitespace)) {\n      const data = {\n        type,\n        children: [{\n          text: \"\"\n        }],\n        trigger: trigger2\n      };\n      if (inputCreation) {\n        data[inputCreation.key] = inputCreation.value;\n      }\n      return insertNodes(editor, data);\n    }\n    return _insertText(text4);\n  };\n  editor.apply = (operation) => {\n    apply2(operation);\n    if (operation.type === \"insert_text\" || operation.type === \"remove_text\") {\n      const currentMentionInput = findMentionInput(editor);\n      if (currentMentionInput) {\n        comboboxActions.text(getNodeString(currentMentionInput[0]));\n      }\n    } else if (operation.type === \"set_selection\") {\n      var _findMentionInput, _findMentionInput2;\n      const previousMentionInputPath = Range.isRange(operation.properties) ? (_findMentionInput = findMentionInput(editor, {\n        at: operation.properties\n      })) === null || _findMentionInput === void 0 ? void 0 : _findMentionInput[1] : void 0;\n      const currentMentionInputPath = Range.isRange(operation.newProperties) ? (_findMentionInput2 = findMentionInput(editor, {\n        at: operation.newProperties\n      })) === null || _findMentionInput2 === void 0 ? void 0 : _findMentionInput2[1] : void 0;\n      if (previousMentionInputPath && !currentMentionInputPath) {\n        removeMentionInput(editor, previousMentionInputPath);\n      }\n      if (currentMentionInputPath) {\n        comboboxActions.targetRange(editor.selection);\n      }\n    } else if (operation.type === \"insert_node\" && isNodeMentionInput(editor, operation.node)) {\n      var _$text, _2;\n      if (operation.node.trigger !== trigger2) {\n        return;\n      }\n      const text4 = (_$text = (_2 = operation.node.children[0]) === null || _2 === void 0 ? void 0 : _2.text) !== null && _$text !== void 0 ? _$text : \"\";\n      if (inputCreation === void 0 || operation.node[inputCreation.key] === inputCreation.value) {\n        setSelection(editor, {\n          anchor: {\n            path: operation.path.concat([0]),\n            offset: text4.length\n          },\n          focus: {\n            path: operation.path.concat([0]),\n            offset: text4.length\n          }\n        });\n        comboboxActions.open({\n          activeId: id,\n          text: text4,\n          targetRange: editor.selection\n        });\n      }\n    } else if (operation.type === \"remove_node\" && isNodeMentionInput(editor, operation.node)) {\n      if (operation.node.trigger !== trigger2) {\n        return;\n      }\n      comboboxActions.reset();\n    }\n  };\n  return editor;\n};\nvar ELEMENT_MENTION = \"mention\";\nvar ELEMENT_MENTION_INPUT = \"mention_input\";\nvar createMentionPlugin = createPluginFactory({\n  key: ELEMENT_MENTION,\n  isElement: true,\n  isInline: true,\n  isVoid: true,\n  handlers: {\n    onKeyDown: mentionOnKeyDownHandler({\n      query: isSelectionInMentionInput\n    })\n  },\n  withOverrides: withMention,\n  options: {\n    trigger: \"@\",\n    createMentionNode: (item) => ({\n      value: item.text\n    })\n  },\n  plugins: [{\n    key: ELEMENT_MENTION_INPUT,\n    isElement: true,\n    isInline: true\n  }],\n  then: (editor, {\n    key\n  }) => ({\n    options: {\n      id: key\n    }\n  })\n});\n\n// src/editor/plugins/autoComplete/queries/findAutoCompleteInput.ts\nvar findAutoCompleteInput = (editor, options) => findNode(editor, {\n  ...options,\n  match: { type: getPluginType(editor, ELEMENT_AUTO_COMPLETE_INPUT) }\n});\n\n// src/editor/plugins/autoComplete/queries/isNodeAutoCompleteInput.ts\nvar isNodeAutoCompleteInput = (editor, node) => {\n  return node.type === getPluginType(editor, ELEMENT_AUTO_COMPLETE_INPUT);\n};\n\n// src/editor/plugins/autoComplete/queries/isSelectionInAutoCompleteInput.ts\nvar isSelectionInAutoCompleteInput = (editor) => findAutoCompleteInput(editor) !== void 0;\n\n// src/editor/plugins/autoComplete/transforms/removeAutoCompleteInput.ts\nvar removeAutoCompleteInputAtPath = (editor, path) => withoutNormalizing(editor, () => {\n  const node = getNode(editor, path);\n  if (!node)\n    return;\n  const { trigger: trigger2 } = node;\n  insertText(editor, trigger2, {\n    at: { path: [...path, 0], offset: 0 }\n  });\n  unwrapNodes(editor, {\n    at: path\n  });\n});\nvar removeAutoCompleteInputFromCurrentSelection = (editor) => withoutMergingHistory(editor, () => {\n  removeNodes(editor, {\n    match: (node) => node.type === ELEMENT_AUTO_COMPLETE_INPUT\n  });\n});\n\n// src/editor/plugins/comboBox/store.ts\nvar useAutoCompletePluginStore = create2((set4) => ({\n  highlightedIndex: -1,\n  targetRange: null,\n  filteredItems: {},\n  setFilteredItems: (newState) => set4((state) => ({ ...state, filteredItems: { ...state.filteredItems, ...newState } })),\n  reset: () => set4({\n    activeId: void 0,\n    filteredItems: {},\n    highlightedIndex: -1,\n    popperContainer: void 0,\n    targetRange: null,\n    text: void 0\n  })\n}));\n\n// src/editor/plugins/autoComplete/withAutoComplete.ts\nvar withAutoComplete = (editor, { options: { id, trigger: trigger2, inputCreation, keepTrigger, needSpaceBeforeTrigger } }) => {\n  const { type } = getPlugin(editor, ELEMENT_AUTO_COMPLETE_INPUT);\n  const { apply: apply2, insertBreak, insertText: insertText2, deleteBackward: deleteBackward2 } = editor;\n  editor.deleteBackward = (unit) => {\n    const currentAutoCompleteInput = findAutoCompleteInput(editor);\n    if (currentAutoCompleteInput && getNodeString(currentAutoCompleteInput[0]) === \"\") {\n      return removeAutoCompleteInputAtPath(editor, currentAutoCompleteInput[1]);\n    }\n    deleteBackward2(unit);\n  };\n  editor.insertBreak = () => {\n    if (isSelectionInAutoCompleteInput(editor)) {\n      return;\n    }\n    insertBreak();\n  };\n  const textMatchTrigger = (text4, currentTrigger, currentSelection) => {\n    if (!currentTrigger)\n      return false;\n    if (currentTrigger.length === 1 && text4 === currentTrigger)\n      return true;\n    if (currentTrigger.length > 1) {\n      const previousChars = getEditorString(\n        editor,\n        getRange(editor, currentSelection, getPointBefore(editor, currentSelection, { distance: currentTrigger.length - 1 }))\n      );\n      if (`${previousChars}${text4}` === currentTrigger) {\n        return true;\n      }\n    }\n    return false;\n  };\n  editor.insertText = (text4) => {\n    const { selection } = editor;\n    if (!selection || isSelectionInAutoCompleteInput(editor)) {\n      return insertText2(text4);\n    }\n    if (!textMatchTrigger(text4, trigger2, selection)) {\n      return insertText2(text4);\n    }\n    const previousChar = getEditorString(editor, getRange(editor, selection, getPointBefore(editor, selection, { distance: trigger2.length + 1 })));\n    const previousCharPlus1 = getEditorString(editor, getRange(editor, selection, getPointBefore(editor, selection, { distance: trigger2.length + 2 })));\n    const nextChar = getEditorString(editor, getRange(editor, selection, getPointAfter(editor, selection)));\n    const beginningOfLine = previousChar === \"\" || previousChar.length === previousCharPlus1.length;\n    const endOfLine = nextChar === \"\";\n    const precededByWhitespace = !needSpaceBeforeTrigger || needSpaceBeforeTrigger && previousChar.startsWith(\" \");\n    const followedByWhitespace = nextChar === \" \";\n    if ((beginningOfLine || precededByWhitespace) && (endOfLine || followedByWhitespace)) {\n      const data = {\n        type,\n        children: [{ text: \"\" }],\n        trigger: trigger2\n      };\n      if (inputCreation) {\n        data[inputCreation.key] = inputCreation.value;\n      }\n      if (keepTrigger) {\n        insertText2(text4);\n      } else if (trigger2.length > 1) {\n        deleteBackward2(\"character\");\n      }\n      return insertNodes(editor, data);\n    }\n    return insertText2(text4);\n  };\n  editor.apply = (operation) => {\n    apply2(operation);\n    const { selection } = editor;\n    if (operation.type === \"insert_text\" || operation.type === \"remove_text\") {\n      const currentAutoCompleteInput = findAutoCompleteInput(editor);\n      if (currentAutoCompleteInput) {\n        useAutoCompletePluginStore.setState({ text: getNodeString(currentAutoCompleteInput[0]) });\n      }\n    } else if (operation.type === \"set_selection\") {\n      const previousAutoCompleteInputPath = Range.isRange(operation.properties) ? findAutoCompleteInput(editor, { at: operation.properties })?.[1] : void 0;\n      const currentAutoCompleteInputPath = Range.isRange(operation.newProperties) ? findAutoCompleteInput(editor, { at: operation.newProperties })?.[1] : void 0;\n      if (previousAutoCompleteInputPath && !currentAutoCompleteInputPath) {\n        removeAutoCompleteInputAtPath(editor, previousAutoCompleteInputPath);\n      }\n      if (currentAutoCompleteInputPath) {\n        useAutoCompletePluginStore.setState({ targetRange: selection });\n      }\n    } else if (operation.type === \"insert_node\" && isNodeAutoCompleteInput(editor, operation.node)) {\n      if (operation.node.trigger !== trigger2) {\n        return;\n      }\n      const text4 = operation.node.children[0]?.text ?? \"\";\n      if (inputCreation === void 0 || operation.node[inputCreation.key] === inputCreation.value) {\n        setSelection(editor, {\n          anchor: { path: [...operation.path, 0], offset: text4.length },\n          focus: { path: [...operation.path, 0], offset: text4.length }\n        });\n        useAutoCompletePluginStore.setState({\n          activeId: id,\n          text: text4,\n          targetRange: selection\n        });\n      }\n    } else if (operation.type === \"remove_node\" && isNodeAutoCompleteInput(editor, operation.node)) {\n      if (operation.node.trigger !== trigger2) {\n        return;\n      }\n      useAutoCompletePluginStore.getState().reset();\n    }\n  };\n  return editor;\n};\n\n// src/editor/plugins/autoComplete/createAutoCompletePlugin.ts\nvar ELEMENT_AUTO_COMPLETE = \"auto_complete\";\nvar ELEMENT_AUTO_COMPLETE_INPUT = \"auto_complete_input\";\nvar createAutoCompletePlugin = createPluginFactory({\n  key: ELEMENT_AUTO_COMPLETE,\n  isElement: true,\n  isInline: true,\n  isVoid: true,\n  handlers: {\n    onKeyDown: mentionOnKeyDownHandler({ query: isSelectionInMentionInput })\n  },\n  withOverrides: withAutoComplete,\n  options: {\n    needSpaceBeforeTrigger: true,\n    createAutoCompleteNode: (item) => {\n      return {\n        type: ELEMENT_PARAGRAPH,\n        children: [{ text: item.text }]\n      };\n    }\n  },\n  plugins: [\n    {\n      key: ELEMENT_AUTO_COMPLETE_INPUT,\n      isElement: true,\n      isInline: true\n    }\n  ],\n  then: (editor, { key, options: { trigger: trigger2 } }) => ({\n    options: {\n      id: key,\n      trigger: trigger2 ?? key\n    }\n  })\n});\n\n// node_modules/zustand/esm/shallow.mjs\nfunction shallow(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  if (objA instanceof Map && objB instanceof Map) {\n    if (objA.size !== objB.size)\n      return false;\n    for (const [key, value] of objA) {\n      if (!Object.is(value, objB.get(key))) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (objA instanceof Set && objB instanceof Set) {\n    if (objA.size !== objB.size)\n      return false;\n    for (const value of objA) {\n      if (!objB.has(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (let i5 = 0; i5 < keysA.length; i5++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i5]) || !Object.is(objA[keysA[i5]], objB[keysA[i5]])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// src/editor/plugins/comboBox/Combobox.tsx\nvar import_react46 = __toESM(require(\"react\"));\n\n// node_modules/@floating-ui/core/dist/floating-ui.core.browser.min.mjs\nfunction t5(t6) {\n  return t6.split(\"-\")[0];\n}\nfunction e3(t6) {\n  return t6.split(\"-\")[1];\n}\nfunction n6(e4) {\n  return [\"top\", \"bottom\"].includes(t5(e4)) ? \"x\" : \"y\";\n}\nfunction r5(t6) {\n  return \"y\" === t6 ? \"height\" : \"width\";\n}\nfunction i3(i5, o7, a7) {\n  let { reference: l6, floating: s5 } = i5;\n  const c5 = l6.x + l6.width / 2 - s5.width / 2, f5 = l6.y + l6.height / 2 - s5.height / 2, u5 = n6(o7), m4 = r5(u5), g4 = l6[m4] / 2 - s5[m4] / 2, d4 = \"x\" === u5;\n  let p6;\n  switch (t5(o7)) {\n    case \"top\":\n      p6 = { x: c5, y: l6.y - s5.height };\n      break;\n    case \"bottom\":\n      p6 = { x: c5, y: l6.y + l6.height };\n      break;\n    case \"right\":\n      p6 = { x: l6.x + l6.width, y: f5 };\n      break;\n    case \"left\":\n      p6 = { x: l6.x - s5.width, y: f5 };\n      break;\n    default:\n      p6 = { x: l6.x, y: l6.y };\n  }\n  switch (e3(o7)) {\n    case \"start\":\n      p6[u5] -= g4 * (a7 && d4 ? -1 : 1);\n      break;\n    case \"end\":\n      p6[u5] += g4 * (a7 && d4 ? -1 : 1);\n  }\n  return p6;\n}\nvar o5 = async (t6, e4, n8) => {\n  const { placement: r7 = \"bottom\", strategy: o7 = \"absolute\", middleware: a7 = [], platform: l6 } = n8, s5 = await (null == l6.isRTL ? void 0 : l6.isRTL(e4));\n  let c5 = await l6.getElementRects({ reference: t6, floating: e4, strategy: o7 }), { x: f5, y: u5 } = i3(c5, r7, s5), m4 = r7, g4 = {}, d4 = 0;\n  for (let n9 = 0; n9 < a7.length; n9++) {\n    const { name: p6, fn: h4 } = a7[n9], { x: y5, y: x4, data: w4, reset: v4 } = await h4({ x: f5, y: u5, initialPlacement: r7, placement: m4, strategy: o7, middlewareData: g4, rects: c5, platform: l6, elements: { reference: t6, floating: e4 } });\n    f5 = null != y5 ? y5 : f5, u5 = null != x4 ? x4 : u5, g4 = { ...g4, [p6]: { ...g4[p6], ...w4 } }, v4 && d4 <= 50 && (d4++, \"object\" == typeof v4 && (v4.placement && (m4 = v4.placement), v4.rects && (c5 = true === v4.rects ? await l6.getElementRects({ reference: t6, floating: e4, strategy: o7 }) : v4.rects), { x: f5, y: u5 } = i3(c5, m4, s5)), n9 = -1);\n  }\n  return { x: f5, y: u5, placement: m4, strategy: o7, middlewareData: g4 };\n};\nfunction a5(t6) {\n  return \"number\" != typeof t6 ? function(t7) {\n    return { top: 0, right: 0, bottom: 0, left: 0, ...t7 };\n  }(t6) : { top: t6, right: t6, bottom: t6, left: t6 };\n}\nfunction l4(t6) {\n  return { ...t6, top: t6.y, left: t6.x, right: t6.x + t6.width, bottom: t6.y + t6.height };\n}\nasync function s3(t6, e4) {\n  var n8;\n  void 0 === e4 && (e4 = {});\n  const { x: r7, y: i5, platform: o7, rects: s5, elements: c5, strategy: f5 } = t6, { boundary: u5 = \"clippingAncestors\", rootBoundary: m4 = \"viewport\", elementContext: g4 = \"floating\", altBoundary: d4 = false, padding: p6 = 0 } = e4, h4 = a5(p6), y5 = c5[d4 ? \"floating\" === g4 ? \"reference\" : \"floating\" : g4], x4 = l4(await o7.getClippingRect({ element: null == (n8 = await (null == o7.isElement ? void 0 : o7.isElement(y5))) || n8 ? y5 : y5.contextElement || await (null == o7.getDocumentElement ? void 0 : o7.getDocumentElement(c5.floating)), boundary: u5, rootBoundary: m4, strategy: f5 })), w4 = l4(o7.convertOffsetParentRelativeRectToViewportRelativeRect ? await o7.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: \"floating\" === g4 ? { ...s5.floating, x: r7, y: i5 } : s5.reference, offsetParent: await (null == o7.getOffsetParent ? void 0 : o7.getOffsetParent(c5.floating)), strategy: f5 }) : s5[g4]);\n  return { top: x4.top - w4.top + h4.top, bottom: w4.bottom - x4.bottom + h4.bottom, left: x4.left - w4.left + h4.left, right: w4.right - x4.right + h4.right };\n}\nvar c3 = Math.min;\nvar f3 = Math.max;\nfunction u3(t6, e4, n8) {\n  return f3(t6, c3(e4, n8));\n}\nvar g2 = { left: \"right\", right: \"left\", bottom: \"top\", top: \"bottom\" };\nfunction d2(t6) {\n  return t6.replace(/left|right|bottom|top/g, (t7) => g2[t7]);\n}\nfunction p4(t6, i5, o7) {\n  void 0 === o7 && (o7 = false);\n  const a7 = e3(t6), l6 = n6(t6), s5 = r5(l6);\n  let c5 = \"x\" === l6 ? a7 === (o7 ? \"end\" : \"start\") ? \"right\" : \"left\" : \"start\" === a7 ? \"bottom\" : \"top\";\n  return i5.reference[s5] > i5.floating[s5] && (c5 = d2(c5)), { main: c5, cross: d2(c5) };\n}\nvar h2 = { start: \"end\", end: \"start\" };\nfunction y3(t6) {\n  return t6.replace(/start|end/g, (t7) => h2[t7]);\n}\nvar x2 = [\"top\", \"right\", \"bottom\", \"left\"];\nvar w2 = x2.reduce((t6, e4) => t6.concat(e4, e4 + \"-start\", e4 + \"-end\"), []);\nvar b2 = function(e4) {\n  return void 0 === e4 && (e4 = {}), { name: \"flip\", options: e4, async fn(n8) {\n    var r7;\n    const { placement: i5, middlewareData: o7, rects: a7, initialPlacement: l6, platform: c5, elements: f5 } = n8, { mainAxis: u5 = true, crossAxis: m4 = true, fallbackPlacements: g4, fallbackStrategy: h4 = \"bestFit\", flipAlignment: x4 = true, ...w4 } = e4, v4 = t5(i5), b4 = g4 || (v4 === l6 || !x4 ? [d2(l6)] : function(t6) {\n      const e5 = d2(t6);\n      return [y3(t6), e5, y3(e5)];\n    }(l6)), R3 = [l6, ...b4], A2 = await s3(n8, w4), P3 = [];\n    let T3 = (null == (r7 = o7.flip) ? void 0 : r7.overflows) || [];\n    if (u5 && P3.push(A2[v4]), m4) {\n      const { main: t6, cross: e5 } = p4(i5, a7, await (null == c5.isRTL ? void 0 : c5.isRTL(f5.floating)));\n      P3.push(A2[t6], A2[e5]);\n    }\n    if (T3 = [...T3, { placement: i5, overflows: P3 }], !P3.every((t6) => t6 <= 0)) {\n      var O4, D4;\n      const t6 = (null != (O4 = null == (D4 = o7.flip) ? void 0 : D4.index) ? O4 : 0) + 1, e5 = R3[t6];\n      if (e5)\n        return { data: { index: t6, overflows: T3 }, reset: { placement: e5 } };\n      let n9 = \"bottom\";\n      switch (h4) {\n        case \"bestFit\": {\n          var L4;\n          const t7 = null == (L4 = T3.map((t8) => [t8, t8.overflows.filter((t9) => t9 > 0).reduce((t9, e6) => t9 + e6, 0)]).sort((t8, e6) => t8[1] - e6[1])[0]) ? void 0 : L4[0].placement;\n          t7 && (n9 = t7);\n          break;\n        }\n        case \"initialPlacement\":\n          n9 = l6;\n      }\n      if (i5 !== n9)\n        return { reset: { placement: n9 } };\n    }\n    return {};\n  } };\n};\nvar T = function(r7) {\n  return void 0 === r7 && (r7 = 0), { name: \"offset\", options: r7, async fn(i5) {\n    const { x: o7, y: a7 } = i5, l6 = await async function(r8, i6) {\n      const { placement: o8, platform: a8, elements: l7 } = r8, s5 = await (null == a8.isRTL ? void 0 : a8.isRTL(l7.floating)), c5 = t5(o8), f5 = e3(o8), u5 = \"x\" === n6(o8), m4 = [\"left\", \"top\"].includes(c5) ? -1 : 1, g4 = s5 && u5 ? -1 : 1, d4 = \"function\" == typeof i6 ? i6(r8) : i6;\n      let { mainAxis: p6, crossAxis: h4, alignmentAxis: y5 } = \"number\" == typeof d4 ? { mainAxis: d4, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...d4 };\n      return f5 && \"number\" == typeof y5 && (h4 = \"end\" === f5 ? -1 * y5 : y5), u5 ? { x: h4 * g4, y: p6 * m4 } : { x: p6 * m4, y: h4 * g4 };\n    }(i5, r7);\n    return { x: o7 + l6.x, y: a7 + l6.y, data: l6 };\n  } };\n};\nfunction O3(t6) {\n  return \"x\" === t6 ? \"y\" : \"x\";\n}\nvar D2 = function(e4) {\n  return void 0 === e4 && (e4 = {}), { name: \"shift\", options: e4, async fn(r7) {\n    const { x: i5, y: o7, placement: a7 } = r7, { mainAxis: l6 = true, crossAxis: c5 = false, limiter: f5 = { fn: (t6) => {\n      let { x: e5, y: n8 } = t6;\n      return { x: e5, y: n8 };\n    } }, ...m4 } = e4, g4 = { x: i5, y: o7 }, d4 = await s3(r7, m4), p6 = n6(t5(a7)), h4 = O3(p6);\n    let y5 = g4[p6], x4 = g4[h4];\n    if (l6) {\n      const t6 = \"y\" === p6 ? \"bottom\" : \"right\";\n      y5 = u3(y5 + d4[\"y\" === p6 ? \"top\" : \"left\"], y5, y5 - d4[t6]);\n    }\n    if (c5) {\n      const t6 = \"y\" === h4 ? \"bottom\" : \"right\";\n      x4 = u3(x4 + d4[\"y\" === h4 ? \"top\" : \"left\"], x4, x4 - d4[t6]);\n    }\n    const w4 = f5.fn({ ...r7, [p6]: y5, [h4]: x4 });\n    return { ...w4, data: { x: w4.x - i5, y: w4.y - o7 } };\n  } };\n};\n\n// node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.min.mjs\nfunction n7(t6) {\n  return t6 && t6.document && t6.location && t6.alert && t6.setInterval;\n}\nfunction o6(t6) {\n  if (null == t6)\n    return window;\n  if (!n7(t6)) {\n    const e4 = t6.ownerDocument;\n    return e4 && e4.defaultView || window;\n  }\n  return t6;\n}\nfunction i4(t6) {\n  return o6(t6).getComputedStyle(t6);\n}\nfunction r6(t6) {\n  return n7(t6) ? \"\" : t6 ? (t6.nodeName || \"\").toLowerCase() : \"\";\n}\nfunction l5() {\n  const t6 = navigator.userAgentData;\n  return null != t6 && t6.brands ? t6.brands.map((t7) => t7.brand + \"/\" + t7.version).join(\" \") : navigator.userAgent;\n}\nfunction c4(t6) {\n  return t6 instanceof o6(t6).HTMLElement;\n}\nfunction f4(t6) {\n  return t6 instanceof o6(t6).Element;\n}\nfunction s4(t6) {\n  if (\"undefined\" == typeof ShadowRoot)\n    return false;\n  return t6 instanceof o6(t6).ShadowRoot || t6 instanceof ShadowRoot;\n}\nfunction u4(t6) {\n  const { overflow: e4, overflowX: n8, overflowY: o7 } = i4(t6);\n  return /auto|scroll|overlay|hidden/.test(e4 + o7 + n8);\n}\nfunction d3(t6) {\n  return [\"table\", \"td\", \"th\"].includes(r6(t6));\n}\nfunction h3(t6) {\n  const e4 = /firefox/i.test(l5()), n8 = i4(t6);\n  return \"none\" !== n8.transform || \"none\" !== n8.perspective || \"paint\" === n8.contain || [\"transform\", \"perspective\"].includes(n8.willChange) || e4 && \"filter\" === n8.willChange || e4 && !!n8.filter && \"none\" !== n8.filter;\n}\nfunction a6() {\n  return !/^((?!chrome|android).)*safari/i.test(l5());\n}\nvar g3 = Math.min;\nvar p5 = Math.max;\nvar m3 = Math.round;\nfunction w3(t6, e4, n8) {\n  var i5, r7, l6, s5;\n  void 0 === e4 && (e4 = false), void 0 === n8 && (n8 = false);\n  const u5 = t6.getBoundingClientRect();\n  let d4 = 1, h4 = 1;\n  e4 && c4(t6) && (d4 = t6.offsetWidth > 0 && m3(u5.width) / t6.offsetWidth || 1, h4 = t6.offsetHeight > 0 && m3(u5.height) / t6.offsetHeight || 1);\n  const g4 = f4(t6) ? o6(t6) : window, p6 = !a6() && n8, w4 = (u5.left + (p6 && null != (i5 = null == (r7 = g4.visualViewport) ? void 0 : r7.offsetLeft) ? i5 : 0)) / d4, v4 = (u5.top + (p6 && null != (l6 = null == (s5 = g4.visualViewport) ? void 0 : s5.offsetTop) ? l6 : 0)) / h4, y5 = u5.width / d4, x4 = u5.height / h4;\n  return { width: y5, height: x4, top: v4, right: w4 + y5, bottom: v4 + x4, left: w4, x: w4, y: v4 };\n}\nfunction v3(t6) {\n  return (e4 = t6, (e4 instanceof o6(e4).Node ? t6.ownerDocument : t6.document) || window.document).documentElement;\n  var e4;\n}\nfunction y4(t6) {\n  return f4(t6) ? { scrollLeft: t6.scrollLeft, scrollTop: t6.scrollTop } : { scrollLeft: t6.pageXOffset, scrollTop: t6.pageYOffset };\n}\nfunction x3(t6) {\n  return w3(v3(t6)).left + y4(t6).scrollLeft;\n}\nfunction b3(t6, e4, n8) {\n  const o7 = c4(e4), i5 = v3(e4), l6 = w3(t6, o7 && function(t7) {\n    const e5 = w3(t7);\n    return m3(e5.width) !== t7.offsetWidth || m3(e5.height) !== t7.offsetHeight;\n  }(e4), \"fixed\" === n8);\n  let f5 = { scrollLeft: 0, scrollTop: 0 };\n  const s5 = { x: 0, y: 0 };\n  if (o7 || !o7 && \"fixed\" !== n8)\n    if ((\"body\" !== r6(e4) || u4(i5)) && (f5 = y4(e4)), c4(e4)) {\n      const t7 = w3(e4, true);\n      s5.x = t7.x + e4.clientLeft, s5.y = t7.y + e4.clientTop;\n    } else\n      i5 && (s5.x = x3(i5));\n  return { x: l6.left + f5.scrollLeft - s5.x, y: l6.top + f5.scrollTop - s5.y, width: l6.width, height: l6.height };\n}\nfunction L3(t6) {\n  return \"html\" === r6(t6) ? t6 : t6.assignedSlot || t6.parentNode || (s4(t6) ? t6.host : null) || v3(t6);\n}\nfunction R2(t6) {\n  return c4(t6) && \"fixed\" !== getComputedStyle(t6).position ? t6.offsetParent : null;\n}\nfunction T2(t6) {\n  const e4 = o6(t6);\n  let n8 = R2(t6);\n  for (; n8 && d3(n8) && \"static\" === getComputedStyle(n8).position; )\n    n8 = R2(n8);\n  return n8 && (\"html\" === r6(n8) || \"body\" === r6(n8) && \"static\" === getComputedStyle(n8).position && !h3(n8)) ? e4 : n8 || function(t7) {\n    let e5 = L3(t7);\n    for (s4(e5) && (e5 = e5.host); c4(e5) && ![\"html\", \"body\"].includes(r6(e5)); ) {\n      if (h3(e5))\n        return e5;\n      e5 = e5.parentNode;\n    }\n    return null;\n  }(t6) || e4;\n}\nfunction W2(t6) {\n  if (c4(t6))\n    return { width: t6.offsetWidth, height: t6.offsetHeight };\n  const e4 = w3(t6);\n  return { width: e4.width, height: e4.height };\n}\nfunction E3(t6) {\n  const e4 = L3(t6);\n  return [\"html\", \"body\", \"#document\"].includes(r6(e4)) ? t6.ownerDocument.body : c4(e4) && u4(e4) ? e4 : E3(e4);\n}\nfunction H2(t6, e4) {\n  var n8;\n  void 0 === e4 && (e4 = []);\n  const i5 = E3(t6), r7 = i5 === (null == (n8 = t6.ownerDocument) ? void 0 : n8.body), l6 = o6(i5), c5 = r7 ? [l6].concat(l6.visualViewport || [], u4(i5) ? i5 : []) : i5, f5 = e4.concat(c5);\n  return r7 ? f5 : f5.concat(H2(c5));\n}\nfunction C2(e4, n8, r7) {\n  return \"viewport\" === n8 ? l4(function(t6, e5) {\n    const n9 = o6(t6), i5 = v3(t6), r8 = n9.visualViewport;\n    let l6 = i5.clientWidth, c5 = i5.clientHeight, f5 = 0, s5 = 0;\n    if (r8) {\n      l6 = r8.width, c5 = r8.height;\n      const t7 = a6();\n      (t7 || !t7 && \"fixed\" === e5) && (f5 = r8.offsetLeft, s5 = r8.offsetTop);\n    }\n    return { width: l6, height: c5, x: f5, y: s5 };\n  }(e4, r7)) : f4(n8) ? function(t6, e5) {\n    const n9 = w3(t6, false, \"fixed\" === e5), o7 = n9.top + t6.clientTop, i5 = n9.left + t6.clientLeft;\n    return { top: o7, left: i5, x: i5, y: o7, right: i5 + t6.clientWidth, bottom: o7 + t6.clientHeight, width: t6.clientWidth, height: t6.clientHeight };\n  }(n8, r7) : l4(function(t6) {\n    var e5;\n    const n9 = v3(t6), o7 = y4(t6), r8 = null == (e5 = t6.ownerDocument) ? void 0 : e5.body, l6 = p5(n9.scrollWidth, n9.clientWidth, r8 ? r8.scrollWidth : 0, r8 ? r8.clientWidth : 0), c5 = p5(n9.scrollHeight, n9.clientHeight, r8 ? r8.scrollHeight : 0, r8 ? r8.clientHeight : 0);\n    let f5 = -o7.scrollLeft + x3(t6);\n    const s5 = -o7.scrollTop;\n    return \"rtl\" === i4(r8 || n9).direction && (f5 += p5(n9.clientWidth, r8 ? r8.clientWidth : 0) - l6), { width: l6, height: c5, x: f5, y: s5 };\n  }(v3(e4)));\n}\nfunction S2(t6) {\n  const e4 = H2(t6), n8 = [\"absolute\", \"fixed\"].includes(i4(t6).position) && c4(t6) ? T2(t6) : t6;\n  return f4(n8) ? e4.filter((t7) => f4(t7) && function(t8, e5) {\n    const n9 = null == e5.getRootNode ? void 0 : e5.getRootNode();\n    if (t8.contains(e5))\n      return true;\n    if (n9 && s4(n9)) {\n      let n10 = e5;\n      do {\n        if (n10 && t8 === n10)\n          return true;\n        n10 = n10.parentNode || n10.host;\n      } while (n10);\n    }\n    return false;\n  }(t7, n8) && \"body\" !== r6(t7)) : [];\n}\nvar D3 = { getClippingRect: function(t6) {\n  let { element: e4, boundary: n8, rootBoundary: o7, strategy: i5 } = t6;\n  const r7 = [...\"clippingAncestors\" === n8 ? S2(e4) : [].concat(n8), o7], l6 = r7[0], c5 = r7.reduce((t7, n9) => {\n    const o8 = C2(e4, n9, i5);\n    return t7.top = p5(o8.top, t7.top), t7.right = g3(o8.right, t7.right), t7.bottom = g3(o8.bottom, t7.bottom), t7.left = p5(o8.left, t7.left), t7;\n  }, C2(e4, l6, i5));\n  return { width: c5.right - c5.left, height: c5.bottom - c5.top, x: c5.left, y: c5.top };\n}, convertOffsetParentRelativeRectToViewportRelativeRect: function(t6) {\n  let { rect: e4, offsetParent: n8, strategy: o7 } = t6;\n  const i5 = c4(n8), l6 = v3(n8);\n  if (n8 === l6)\n    return e4;\n  let f5 = { scrollLeft: 0, scrollTop: 0 };\n  const s5 = { x: 0, y: 0 };\n  if ((i5 || !i5 && \"fixed\" !== o7) && ((\"body\" !== r6(n8) || u4(l6)) && (f5 = y4(n8)), c4(n8))) {\n    const t7 = w3(n8, true);\n    s5.x = t7.x + n8.clientLeft, s5.y = t7.y + n8.clientTop;\n  }\n  return { ...e4, x: e4.x - f5.scrollLeft + s5.x, y: e4.y - f5.scrollTop + s5.y };\n}, isElement: f4, getDimensions: W2, getOffsetParent: T2, getDocumentElement: v3, getElementRects: (t6) => {\n  let { reference: e4, floating: n8, strategy: o7 } = t6;\n  return { reference: b3(e4, T2(n8), o7), floating: { ...W2(n8), x: 0, y: 0 } };\n}, getClientRects: (t6) => Array.from(t6.getClientRects()), isRTL: (t6) => \"rtl\" === i4(t6).direction };\nfunction N(t6, e4, n8, o7) {\n  void 0 === o7 && (o7 = {});\n  const { ancestorScroll: i5 = true, ancestorResize: r7 = true, elementResize: l6 = true, animationFrame: c5 = false } = o7, s5 = i5 && !c5, u5 = r7 && !c5, d4 = s5 || u5 ? [...f4(t6) ? H2(t6) : [], ...H2(e4)] : [];\n  d4.forEach((t7) => {\n    s5 && t7.addEventListener(\"scroll\", n8, { passive: true }), u5 && t7.addEventListener(\"resize\", n8);\n  });\n  let h4, a7 = null;\n  if (l6) {\n    let o8 = true;\n    a7 = new ResizeObserver(() => {\n      o8 || n8(), o8 = false;\n    }), f4(t6) && !c5 && a7.observe(t6), a7.observe(e4);\n  }\n  let g4 = c5 ? w3(t6) : null;\n  return c5 && function e5() {\n    const o8 = w3(t6);\n    !g4 || o8.x === g4.x && o8.y === g4.y && o8.width === g4.width && o8.height === g4.height || n8();\n    g4 = o8, h4 = requestAnimationFrame(e5);\n  }(), n8(), () => {\n    var t7;\n    d4.forEach((t8) => {\n      s5 && t8.removeEventListener(\"scroll\", n8), u5 && t8.removeEventListener(\"resize\", n8);\n    }), null == (t7 = a7) || t7.disconnect(), a7 = null, c5 && cancelAnimationFrame(h4);\n  };\n}\nvar z2 = (t6, n8, o7) => o5(t6, n8, { platform: D3, ...o7 });\n\n// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js\nvar React17 = __toESM(require(\"react\"));\nvar import_react42 = require(\"react\");\nvar ReactDOM4 = __toESM(require(\"react-dom\"));\nvar index3 = typeof document !== \"undefined\" ? import_react42.useLayoutEffect : import_react42.useEffect;\nfunction deepEqual3(a7, b4) {\n  if (a7 === b4) {\n    return true;\n  }\n  if (typeof a7 !== typeof b4) {\n    return false;\n  }\n  if (typeof a7 === \"function\" && a7.toString() === b4.toString()) {\n    return true;\n  }\n  let length, i5, keys4;\n  if (a7 && b4 && typeof a7 == \"object\") {\n    if (Array.isArray(a7)) {\n      length = a7.length;\n      if (length != b4.length)\n        return false;\n      for (i5 = length; i5-- !== 0; ) {\n        if (!deepEqual3(a7[i5], b4[i5])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys4 = Object.keys(a7);\n    length = keys4.length;\n    if (length !== Object.keys(b4).length) {\n      return false;\n    }\n    for (i5 = length; i5-- !== 0; ) {\n      if (!Object.prototype.hasOwnProperty.call(b4, keys4[i5])) {\n        return false;\n      }\n    }\n    for (i5 = length; i5-- !== 0; ) {\n      const key = keys4[i5];\n      if (key === \"_owner\" && a7.$$typeof) {\n        continue;\n      }\n      if (!deepEqual3(a7[key], b4[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a7 !== a7 && b4 !== b4;\n}\nfunction useLatestRef3(value) {\n  const ref = React17.useRef(value);\n  index3(() => {\n    ref.current = value;\n  });\n  return ref;\n}\nfunction useFloating2(_temp) {\n  let {\n    middleware,\n    placement = \"bottom\",\n    strategy = \"absolute\",\n    whileElementsMounted\n  } = _temp === void 0 ? {} : _temp;\n  const reference2 = React17.useRef(null);\n  const floating = React17.useRef(null);\n  const whileElementsMountedRef = useLatestRef3(whileElementsMounted);\n  const cleanupRef = React17.useRef(null);\n  const [data, setData] = React17.useState({\n    // Setting these to `null` will allow the consumer to determine if\n    // `computePosition()` has run yet\n    x: null,\n    y: null,\n    strategy,\n    placement,\n    middlewareData: {}\n  });\n  const [latestMiddleware, setLatestMiddleware] = React17.useState(middleware);\n  if (!deepEqual3(latestMiddleware == null ? void 0 : latestMiddleware.map((_ref) => {\n    let {\n      options\n    } = _ref;\n    return options;\n  }), middleware == null ? void 0 : middleware.map((_ref2) => {\n    let {\n      options\n    } = _ref2;\n    return options;\n  }))) {\n    setLatestMiddleware(middleware);\n  }\n  const update = React17.useCallback(() => {\n    if (!reference2.current || !floating.current) {\n      return;\n    }\n    z2(reference2.current, floating.current, {\n      middleware: latestMiddleware,\n      placement,\n      strategy\n    }).then((data2) => {\n      if (isMountedRef.current) {\n        ReactDOM4.flushSync(() => {\n          setData(data2);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy]);\n  index3(() => {\n    if (isMountedRef.current) {\n      update();\n    }\n  }, [update]);\n  const isMountedRef = React17.useRef(false);\n  index3(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  const runElementMountCallback = React17.useCallback(() => {\n    if (typeof cleanupRef.current === \"function\") {\n      cleanupRef.current();\n      cleanupRef.current = null;\n    }\n    if (reference2.current && floating.current) {\n      if (whileElementsMountedRef.current) {\n        const cleanupFn = whileElementsMountedRef.current(reference2.current, floating.current, update);\n        cleanupRef.current = cleanupFn;\n      } else {\n        update();\n      }\n    }\n  }, [update, whileElementsMountedRef]);\n  const setReference = React17.useCallback((node) => {\n    reference2.current = node;\n    runElementMountCallback();\n  }, [runElementMountCallback]);\n  const setFloating = React17.useCallback((node) => {\n    floating.current = node;\n    runElementMountCallback();\n  }, [runElementMountCallback]);\n  const refs = React17.useMemo(() => ({\n    reference: reference2,\n    floating\n  }), []);\n  return React17.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    reference: setReference,\n    floating: setFloating\n  }), [data, update, refs, setReference, setFloating]);\n}\n\n// node_modules/@floating-ui/react-dom-interactions/dist/floating-ui.react-dom-interactions.esm.js\nvar React18 = __toESM(require(\"react\"));\nvar import_react43 = require(\"react\");\nvar import_react_dom5 = require(\"react-dom\");\nvar index4 = typeof document !== \"undefined\" ? import_react43.useLayoutEffect : import_react43.useEffect;\nfunction createPubSub2() {\n  const map2 = /* @__PURE__ */ new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n      (_map$get = map2.get(event)) == null ? void 0 : _map$get.forEach((handler) => handler(data));\n    },\n    on(event, listener) {\n      map2.set(event, [...map2.get(event) || [], listener]);\n    },\n    off(event, listener) {\n      map2.set(event, (map2.get(event) || []).filter((l6) => l6 !== listener));\n    }\n  };\n}\nvar serverHandoffComplete = false;\nvar count = 0;\nvar genId = () => \"floating-ui-\" + count++;\nfunction useFloatingId() {\n  const [id, setId] = React18.useState(() => serverHandoffComplete ? genId() : void 0);\n  index4(() => {\n    if (id == null) {\n      setId(genId());\n    }\n  }, []);\n  React18.useEffect(() => {\n    if (!serverHandoffComplete) {\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return id;\n}\nvar useReactId = React18[/* @__PURE__ */ \"useId\".toString()];\nvar useId = useReactId != null ? useReactId : useFloatingId;\nvar FloatingTreeContext2 = /* @__PURE__ */ React18.createContext(null);\nvar useFloatingTree2 = () => React18.useContext(FloatingTreeContext2);\nfunction getDocument2(floating) {\n  var _floating$ownerDocume;\n  return (_floating$ownerDocume = floating == null ? void 0 : floating.ownerDocument) != null ? _floating$ownerDocume : document;\n}\nfunction getWindow3(value) {\n  var _getDocument$defaultV;\n  return (_getDocument$defaultV = getDocument2(value).defaultView) != null ? _getDocument$defaultV : window;\n}\nfunction isElement6(value) {\n  return value ? value instanceof getWindow3(value).Element : false;\n}\nfunction useFloating3(_temp) {\n  let {\n    open = false,\n    onOpenChange = () => {\n    },\n    whileElementsMounted,\n    placement,\n    middleware,\n    strategy,\n    nodeId\n  } = _temp === void 0 ? {} : _temp;\n  const tree = useFloatingTree2();\n  const domReferenceRef = React18.useRef(null);\n  const dataRef = React18.useRef({});\n  const events = React18.useState(() => createPubSub2())[0];\n  const floating = useFloating2({\n    placement,\n    middleware,\n    strategy,\n    whileElementsMounted\n  });\n  const refs = React18.useMemo(() => ({\n    ...floating.refs,\n    domReference: domReferenceRef\n  }), [floating.refs]);\n  const context = React18.useMemo(() => ({\n    ...floating,\n    refs,\n    dataRef,\n    nodeId,\n    events,\n    open,\n    onOpenChange\n  }), [floating, nodeId, events, open, onOpenChange, refs]);\n  index4(() => {\n    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);\n    if (node) {\n      node.context = context;\n    }\n  });\n  const {\n    reference: reference2\n  } = floating;\n  const setReference = React18.useCallback((node) => {\n    if (isElement6(node) || node === null) {\n      context.refs.domReference.current = node;\n    }\n    reference2(node);\n  }, [reference2, context.refs]);\n  return React18.useMemo(() => ({\n    ...floating,\n    context,\n    refs,\n    reference: setReference\n  }), [floating, refs, context, setReference]);\n}\nfunction mergeProps2(userProps, propsList, elementKey) {\n  const map2 = /* @__PURE__ */ new Map();\n  return {\n    ...elementKey === \"floating\" && {\n      tabIndex: -1\n    },\n    ...userProps,\n    ...propsList.map((value) => value ? value[elementKey] : null).concat(userProps).reduce((acc, props) => {\n      if (!props) {\n        return acc;\n      }\n      Object.entries(props).forEach((_ref) => {\n        let [key, value] = _ref;\n        if (key.indexOf(\"on\") === 0) {\n          if (!map2.has(key)) {\n            map2.set(key, []);\n          }\n          if (typeof value === \"function\") {\n            var _map$get;\n            (_map$get = map2.get(key)) == null ? void 0 : _map$get.push(value);\n          }\n          acc[key] = function() {\n            var _map$get2;\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n            (_map$get2 = map2.get(key)) == null ? void 0 : _map$get2.forEach((fn4) => fn4(...args));\n          };\n        } else {\n          acc[key] = value;\n        }\n      });\n      return acc;\n    }, {})\n  };\n}\nvar useInteractions = function(propsList) {\n  if (propsList === void 0) {\n    propsList = [];\n  }\n  return {\n    getReferenceProps: (userProps) => mergeProps2(userProps, propsList, \"reference\"),\n    getFloatingProps: (userProps) => mergeProps2(userProps, propsList, \"floating\"),\n    getItemProps: (userProps) => mergeProps2(userProps, propsList, \"item\")\n  };\n};\nvar TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nvar SELECTOR = \"select:not([disabled]),a[href],button:not([disabled]),[tabindex],iframe,object,embed,area[href],audio[controls],video[controls],\" + TYPEABLE_SELECTOR;\n\n// node_modules/@udecode/plate-floating/dist/index.es.js\nvar import_react44 = __toESM(require(\"react\"));\nvar getDefaultBoundingClientRect2 = () => ({\n  width: 0,\n  height: 0,\n  x: 0,\n  y: 0,\n  top: -9999,\n  left: -9999,\n  right: 9999,\n  bottom: 9999\n});\nvar createVirtualElement2 = () => ({\n  getBoundingClientRect: getDefaultBoundingClientRect2\n});\nfunction _extends5() {\n  _extends5 = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i5 = 1; i5 < arguments.length; i5++) {\n      var source = arguments[i5];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends5.apply(this, arguments);\n}\nvar Popover = ({\n  floatingOptions,\n  children,\n  content,\n  ...props\n}) => {\n  const {\n    x: x4,\n    y: y5,\n    reference: reference2,\n    floating,\n    strategy\n  } = useFloating3({\n    middleware: [T(12), b2({\n      padding: 96\n    }), D2()],\n    whileElementsMounted: N,\n    ...floatingOptions\n  });\n  const {\n    getReferenceProps\n  } = useInteractions();\n  return /* @__PURE__ */ import_react44.default.createElement(import_react44.default.Fragment, null, /* @__PURE__ */ (0, import_react44.cloneElement)(children, getReferenceProps({\n    ref: reference2,\n    ...children.props\n  })), (floatingOptions === null || floatingOptions === void 0 ? void 0 : floatingOptions.open) && createElementAs(\"div\", {\n    ref: floating,\n    style: {\n      position: strategy,\n      top: y5 !== null && y5 !== void 0 ? y5 : 0,\n      left: x4 !== null && x4 !== void 0 ? x4 : 0,\n      zIndex: 1\n    },\n    contentEditable: false,\n    children: content,\n    ...props\n  }));\n};\nvar ElementPopover = ({\n  floatingOptions = {},\n  ...props\n}) => {\n  const readOnly = useReadOnly();\n  const selected = useSelected();\n  const editor = useEditorState();\n  return /* @__PURE__ */ import_react44.default.createElement(Popover, _extends5({\n    floatingOptions: {\n      open: !readOnly && selected && isCollapsed(editor.selection),\n      ...floatingOptions\n    }\n  }, props));\n};\nvar getRangeBoundingClientRect2 = (editor, at) => {\n  if (!at)\n    return getDefaultBoundingClientRect2();\n  const domRange = toDOMRange(editor, at);\n  if (!domRange)\n    return getDefaultBoundingClientRect2();\n  return domRange.getBoundingClientRect();\n};\nvar getSelectionBoundingClientRect2 = () => {\n  const domSelection = window.getSelection();\n  if (!domSelection || domSelection.rangeCount < 1) {\n    return getDefaultBoundingClientRect2();\n  }\n  const domRange = domSelection.getRangeAt(0);\n  return domRange.getBoundingClientRect();\n};\nvar useVirtualFloating2 = ({\n  getBoundingClientRect: getBoundingClientRect3 = getSelectionBoundingClientRect2,\n  ...floatingOptions\n}) => {\n  const virtualElementRef = (0, import_react44.useRef)(createVirtualElement2());\n  const [visible, setVisible] = (0, import_react44.useState)(true);\n  const floatingResult = useFloating3({\n    // update on scroll and resize\n    whileElementsMounted: N,\n    ...floatingOptions\n  });\n  const {\n    reference: reference2,\n    middlewareData,\n    strategy,\n    x: x4,\n    y: y5,\n    update\n  } = floatingResult;\n  (0, import_react44.useLayoutEffect)(() => {\n    virtualElementRef.current.getBoundingClientRect = getBoundingClientRect3;\n  }, [getBoundingClientRect3, update]);\n  (0, import_react44.useLayoutEffect)(() => {\n    reference2(virtualElementRef.current);\n  }, [reference2]);\n  (0, import_react44.useLayoutEffect)(() => {\n    if (!(middlewareData !== null && middlewareData !== void 0 && middlewareData.hide))\n      return;\n    const {\n      referenceHidden\n    } = middlewareData.hide;\n    setVisible(!referenceHidden);\n  }, [middlewareData.hide]);\n  return {\n    ...floatingResult,\n    virtualElementRef,\n    style: {\n      position: strategy,\n      top: y5 !== null && y5 !== void 0 ? y5 : 0,\n      left: x4 !== null && x4 !== void 0 ? x4 : 0,\n      display: floatingOptions.open === false ? \"none\" : void 0,\n      visibility: !visible ? \"hidden\" : void 0\n    }\n  };\n};\n\n// src/editor/plugins/comboBox/Combobox.tsx\nvar import_styled_components7 = __toESM(require_styled_components_browser_cjs());\nvar import_typescript_styled_is2 = __toESM(require_dist());\n\n// src/editor/plugins/comboBox/useComboBox.ts\nvar import_react45 = require(\"react\");\nfunction useComboBox(filteredItems) {\n  const { highlightedIndex, isOpen } = useAutoCompletePluginStore(\n    ({ highlightedIndex: highlightedIndex2, activeId }) => ({\n      highlightedIndex: highlightedIndex2,\n      isOpen: activeId !== void 0\n    }),\n    shallow\n  );\n  const { closeMenu, getMenuProps, getComboboxProps, getInputProps, getItemProps } = useCombobox({\n    isOpen,\n    highlightedIndex,\n    items: filteredItems,\n    circularNavigation: true\n  });\n  getMenuProps({}, { suppressRefError: true });\n  getComboboxProps({}, { suppressRefError: true });\n  getInputProps({}, { suppressRefError: true });\n  return (0, import_react45.useMemo)(\n    () => ({\n      closeMenu,\n      getMenuProps,\n      getItemProps\n    }),\n    [closeMenu, getItemProps, getMenuProps]\n  );\n}\n\n// src/editor/plugins/comboBox/Combobox.tsx\nvar Container = import_styled_components7.default.ul`\n  width: 300px;\n  max-height: 288px;\n  border-radius: 0 0 2px 2px;\n  box-shadow: rgba(0, 0, 0, 0.133) 0 3.2px 7.2px 0, rgba(0, 0, 0, 0.11) 0 0.6px 1.8px 0;\n  background-color: white;\n  margin: 0;\n  padding: 0;\n  overflow: scroll;\n  overflow: overlay;\n\n  z-index: 500;\n`;\nvar Item2 = import_styled_components7.default.div`\n  display: flex;\n  align-items: center;\n  curser: pointer;\n\n  padding: 0 2px;\n\n  font-size: 14px;\n  border-radius: 0;\n  min-height: 36px;\n  user-select: none;\n  color: rgb(32, 31, 30);\n  background: transparent;\n\n  &:hover {\n    background: rgb(243, 242, 241);\n  }\n\n  ${(0, import_typescript_styled_is2.default)(\"highlighted\")`\n    background: rgb(237, 235, 233);\n\n    &:hover {\n      background: rgb(237, 235, 233);\n    }\n  `}\n`;\nfunction Combobox({\n  id,\n  onSelectItem,\n  onRenderItem,\n  items,\n  maxSuggestions = items?.length ?? 0,\n  filter: filter3,\n  getRenderTextTemplate,\n  getNameTemplate\n}) {\n  const { activeId, highlightedIndex, popperContainer, targetRange: targetRange2, text: text4, filteredItems } = useAutoCompletePluginStore(\n    ({ activeId: activeId2, highlightedIndex: highlightedIndex2, popperContainer: popperContainer2, targetRange: targetRange3, text: text5, filteredItems: filteredItems2 }) => ({\n      activeId: activeId2,\n      highlightedIndex: highlightedIndex2,\n      popperContainer: popperContainer2,\n      targetRange: targetRange3,\n      text: text5,\n      filteredItems: filteredItems2[id ?? \"\"] ?? []\n    }),\n    shallow\n  );\n  const editor = useEditorState();\n  const focusedEditorId = useEventEditorSelectors.focus?.();\n  (0, import_react46.useEffect)(() => {\n    let result = [];\n    if (!items) {\n      result = [];\n    } else if (!isDefined(text4) || text4.length === 0) {\n      result = items.slice(0, maxSuggestions);\n    } else {\n      result = items.filter(\n        (element4) => (filter3 !== void 0 ? filter3(text4) : (value) => value.text.toLowerCase().startsWith(text4.toLowerCase()))(element4)\n      ).slice(0, maxSuggestions);\n    }\n    if (activeId) {\n      useAutoCompletePluginStore.getState().setFilteredItems({ [id]: result });\n    }\n  }, [filter3, items, maxSuggestions, text4]);\n  const getBoundingClientRect3 = (0, import_react46.useCallback)(() => getRangeBoundingClientRect2(editor, targetRange2), [editor, targetRange2]);\n  const isHidden = editor.selection == null || focusedEditorId !== editor.id || activeId !== id;\n  const { style: containerStyles, floating: floatingReference } = useVirtualFloating2({\n    placement: \"bottom-start\",\n    getBoundingClientRect: getBoundingClientRect3,\n    middleware: [T(4), D2(), b2()],\n    open: !isHidden\n  });\n  const comboBox = useComboBox(filteredItems);\n  const menuProps = comboBox ? comboBox.getMenuProps({}, { suppressRefError: true }) : { ref: null };\n  return /* @__PURE__ */ import_react46.default.createElement(PortalBody, null, /* @__PURE__ */ import_react46.default.createElement(Container, { ...menuProps, ref: floatingReference, style: containerStyles }, filteredItems.map((item, index5) => {\n    const renderedItem = onRenderItem != null ? onRenderItem({ item, getRenderTextTemplate, getNameTemplate }) : item.text;\n    const highlighted = index5 === highlightedIndex;\n    return /* @__PURE__ */ import_react46.default.createElement(\n      Item2,\n      {\n        key: item.key,\n        highlighted,\n        ...comboBox.getItemProps({\n          item,\n          index: index5\n        }),\n        onMouseDown: (event) => {\n          event.preventDefault();\n          onSelectItem?.(editor, item);\n        }\n      },\n      renderedItem\n    );\n  })));\n}\n\n// src/editor/plugins/advancedBlock/replaceCurrentBlockWithParseResult.ts\nfunction replaceCurrentBlockWithParseResult(editor) {\n  const blockRange = getRangeFromBlockStart(editor);\n  if (blockRange === void 0)\n    return;\n  const currentBlockNode = getNode(editor, blockRange.anchor.path.slice(void 0, -1));\n  if (!currentBlockNode)\n    return;\n  const currentNodeText = serialize(currentBlockNode);\n  if (currentNodeText) {\n    const newSlateNode = deserialize(currentNodeText);\n    insertNodes(editor, newSlateNode, { at: blockRange.anchor.path });\n  }\n}\n\n// src/editor/plugins/comboBox/getAutoCompleteOnSelectItem.ts\nvar getAutoCompleteOnSelectItem = ({ key = ELEMENT_AUTO_COMPLETE } = {}) => (editor, item) => {\n  const { targetRange: targetRange2, reset } = useAutoCompletePluginStore.getState();\n  if (!targetRange2)\n    return;\n  const {\n    type,\n    options: { createAutoCompleteNode, textToInsertAfter }\n  } = getPlugin(editor, key);\n  const pathAbove = getBlockAbove(editor)?.[1];\n  const isBlockEnd = editor.selection && pathAbove && isEndPoint(editor, editor.selection.anchor, pathAbove);\n  withoutNormalizing(editor, () => {\n    if (isBlockEnd) {\n      insertText(editor, \" \");\n    }\n    removeAutoCompleteInputFromCurrentSelection(editor);\n    const props = createAutoCompleteNode?.(item);\n    if (props?.text) {\n      insertText(editor, props.text);\n    } else {\n      insertNodes(editor, {\n        type,\n        children: [{ text: \"\" }],\n        ...props\n      });\n    }\n    if (textToInsertAfter) {\n      insertText(editor, textToInsertAfter);\n    }\n    if (isBlockEnd) {\n      deleteText(editor);\n    }\n    replaceCurrentBlockWithParseResult(editor);\n  });\n  return reset();\n};\n\n// src/editor/plugins/comboBox/onKeyDownCombobox.ts\nvar onKeyDownCombobox2 = (editor) => (event) => {\n  const { highlightedIndex, filteredItems, activeId, reset } = useAutoCompletePluginStore.getState();\n  const currentFilteredItems = filteredItems[activeId ?? \"\"] ?? [];\n  const isOpen = activeId !== void 0;\n  if (!isOpen)\n    return;\n  const onSelectItem = getAutoCompleteOnSelectItem({\n    key: activeId\n  });\n  const {\n    options: { keepTrigger, trigger: trigger2 }\n  } = getPlugin(editor, activeId);\n  if (event.key === \"ArrowDown\") {\n    event.preventDefault();\n    const newIndex = getNextWrappingIndex2(1, highlightedIndex, currentFilteredItems.length, () => {\n    }, true);\n    useAutoCompletePluginStore.setState({ highlightedIndex: newIndex });\n    return;\n  }\n  if (event.key === \"ArrowUp\") {\n    event.preventDefault();\n    const newIndex = getNextWrappingIndex2(-1, highlightedIndex, currentFilteredItems.length, () => {\n    }, true);\n    useAutoCompletePluginStore.setState({ highlightedIndex: newIndex });\n    return;\n  }\n  if (event.key === \"Escape\") {\n    event.preventDefault();\n    removeAutoCompleteInputFromCurrentSelection(editor);\n    if (keepTrigger !== true) {\n      insertText(editor, trigger2 ?? \"\");\n    }\n    reset();\n    return;\n  }\n  if ([\"Tab\", \"Enter\"].includes(event.key)) {\n    event.preventDefault();\n    event.stopPropagation();\n    const selectedItem = currentFilteredItems[highlightedIndex];\n    if (selectedItem !== void 0) {\n      onSelectItem?.(editor, selectedItem);\n    }\n  }\n};\n\n// src/editor/plugins/comboBox/createComboBoxPlugin.ts\nvar KEY_COMBOBOX2 = \"combobox\";\nvar createComboBoxPlugin = createPluginFactory({\n  key: KEY_COMBOBOX2,\n  handlers: {\n    onKeyDown: onKeyDownCombobox2\n  }\n});\n\n// src/editor/config/plugins.ts\nvar basicElements = createPlugins([\n  createBlockquotePlugin(),\n  createCodeBlockPlugin(),\n  createHeadingPlugin2(),\n  createParagraphPlugin(),\n  createHorizontalRulePlugin(),\n  createListPlugin(),\n  createLinkPlugin(),\n  createTablePlugin()\n]);\nvar basicMarks = createPlugins([\n  createBoldPlugin(),\n  createCodePlugin(),\n  createItalicPlugin(),\n  createStrikethroughPlugin(),\n  createSubscriptPlugin(),\n  createSuperscriptPlugin(),\n  createUnderlinePlugin()\n]);\nvar utils = createPlugins([\n  createComboBoxPlugin(),\n  createAutoCompletePlugin(CONFIG.snippetComboBox),\n  createAutoCompletePlugin(CONFIG.wikiLinkComboBox),\n  createAutoCompletePlugin(CONFIG.wikiTransclusionComboBox),\n  createAutoCompletePlugin(CONFIG.macrosComboBox),\n  createAutoCompletePlugin(CONFIG.widgetComboBox),\n  createSelectOnBackspacePlugin(CONFIG.selectOnBackspace),\n  createSoftBreakPlugin(CONFIG.softBreak),\n  createExitBreakPlugin(CONFIG.exitBreak),\n  createAutoformatPlugin(CONFIG.autoformat),\n  createDndPlugin(),\n  createIndentListPlugin(),\n  createIndentPlugin(),\n  createKbdPlugin(),\n  createInlineVoidPlugin(),\n  /**\n   * Add a trailing block when the last node type is not `type` and when the editor has .\n   */\n  createTrailingBlockPlugin()\n]);\nvar twAdvancedElements = createPlugins([createWidgetPlugin(), createMacroPlugin(), createSetVariablePlugin()]);\n\n// src/editor/components/Toolbars.tsx\nvar import_react53 = __toESM(require(\"react\"));\n\n// node_modules/@styled-icons/boxicons-regular/CodeAlt/CodeAlt.esm.js\nvar React21 = __toESM(require(\"react\"));\nvar CodeAlt = /* @__PURE__ */ React21.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React21.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React21.createElement(\"path\", {\n    d: \"m7.375 16.781 1.25-1.562L4.601 12l4.024-3.219-1.25-1.562-5 4a1 1 0 0 0 0 1.562l5 4zm9.25-9.562-1.25 1.562L19.399 12l-4.024 3.219 1.25 1.562 5-4a1 1 0 0 0 0-1.562l-5-4zm-1.649-4.003-4 18-1.953-.434 4-18z\"\n  }));\n});\nCodeAlt.displayName = \"CodeAlt\";\n\n// node_modules/@styled-icons/boxicons-regular/CodeBlock/CodeBlock.esm.js\nvar React22 = __toESM(require(\"react\"));\nvar CodeBlock = /* @__PURE__ */ React22.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React22.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React22.createElement(\"path\", {\n    d: \"M20 3H4c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h16c1.103 0 2-.897 2-2V5c0-1.103-.897-2-2-2zM4 19V7h16l.002 12H4z\"\n  }), /* @__PURE__ */ React22.createElement(\"path\", {\n    d: \"M9.293 9.293 5.586 13l3.707 3.707 1.414-1.414L8.414 13l2.293-2.293zm5.414 0-1.414 1.414L15.586 13l-2.293 2.293 1.414 1.414L18.414 13z\"\n  }));\n});\nCodeBlock.displayName = \"CodeBlock\";\n\n// node_modules/@styled-icons/foundation/Subscript/Subscript.esm.js\nvar React23 = __toESM(require(\"react\"));\nvar Subscript = /* @__PURE__ */ React23.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React23.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 100 100\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React23.createElement(\"path\", {\n    d: \"M90.694 76.981a.99.99 0 0 0-.703-.291v-.012h-5.208c3.816-2.52 5.064-4.32 5.064-6.504 0-3.216-2.712-5.521-6.865-5.521-2.138 0-4.685.695-6.521 2.481-.043.031-.092.048-.13.087-.027.027-.038.063-.062.093-.018.018-.038.033-.055.052l.012.014a.967.967 0 0 0 .005 1.096l-.016.01 1.367 1.995h.001a.98.98 0 0 0 1.265.092l.007.009c.036-.03.072-.056.108-.085.007-.007.017-.009.025-.016l.005-.007c1.184-.965 2.446-1.548 4.088-1.548 1.032 0 1.848.48 1.848 1.248 0 1.2-.696 1.8-8.017 6.96v.022c-.067.041-.139.073-.197.131a.97.97 0 0 0-.267.578h-.024v2.609c0 .241.195.437.437.437.018 0 .034-.008.052-.01v.004h13.082a.992.992 0 0 0 .994-.994v-2.225a1.013 1.013 0 0 0-.295-.705zM70.495 33.34l-3.389-3.39a2.604 2.604 0 0 0-3.683 0l-.016-.016-13.033 13.034L37.34 29.934a2.604 2.604 0 0 0-3.683 0l-3.389 3.389a2.604 2.604 0 0 0 0 3.683l-.016.016 13.033 13.033L30.252 63.09l.016.016a2.604 2.604 0 0 0 0 3.683l3.389 3.389a2.604 2.604 0 0 0 3.683 0l13.033-13.033 13.033 13.033.016-.016a2.604 2.604 0 0 0 3.683 0l3.389-3.389a2.604 2.604 0 0 0 0-3.683L57.462 50.056l13.033-13.033a2.603 2.603 0 0 0 0-3.683z\"\n  }));\n});\nSubscript.displayName = \"Subscript\";\n\n// node_modules/@styled-icons/foundation/Superscript/Superscript.esm.js\nvar React24 = __toESM(require(\"react\"));\nvar Superscript = /* @__PURE__ */ React24.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React24.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 100 100\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React24.createElement(\"path\", {\n    d: \"M90.478 31.418a.99.99 0 0 0-.703-.291v-.011h-5.208c3.816-2.52 5.064-4.32 5.064-6.504 0-3.216-2.712-5.521-6.865-5.521-2.138 0-4.685.695-6.521 2.481-.043.031-.092.048-.13.087-.027.027-.038.063-.062.093-.018.018-.038.033-.055.052l.012.014a.965.965 0 0 0 .005 1.095l-.016.01 1.367 1.995h.001a.982.982 0 0 0 1.265.093l.007.009c.036-.03.072-.056.108-.085.007-.007.017-.009.025-.016l.005-.007c1.184-.965 2.446-1.548 4.088-1.548 1.032 0 1.848.48 1.848 1.248 0 1.2-.696 1.8-8.017 6.96v.022c-.067.041-.139.073-.197.131a.97.97 0 0 0-.267.578h-.024v2.609c0 .241.195.437.437.437.018 0 .034-.008.052-.01v.004h13.082a.992.992 0 0 0 .994-.994v-2.225a1.013 1.013 0 0 0-.295-.706zm-20.199 2.049-3.389-3.39a2.604 2.604 0 0 0-3.683 0l-.016-.016-13.034 13.034-13.033-13.034a2.604 2.604 0 0 0-3.683 0l-3.389 3.389a2.604 2.604 0 0 0 0 3.683l-.016.016 13.033 13.033-13.034 13.035.016.016a2.604 2.604 0 0 0 0 3.683l3.389 3.389a2.604 2.604 0 0 0 3.683 0l13.033-13.033 13.033 13.033.016-.016a2.604 2.604 0 0 0 3.683 0l3.389-3.389a2.604 2.604 0 0 0 0-3.683L57.246 50.183 70.279 37.15a2.604 2.604 0 0 0 0-3.683z\"\n  }));\n});\nSuperscript.displayName = \"Superscript\";\n\n// node_modules/@styled-icons/material/FormatBold/FormatBold.esm.js\nvar React25 = __toESM(require(\"react\"));\nvar FormatBold = /* @__PURE__ */ React25.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React25.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React25.createElement(\"path\", {\n    d: \"M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z\"\n  }));\n});\nFormatBold.displayName = \"FormatBold\";\n\n// node_modules/@styled-icons/material/FormatItalic/FormatItalic.esm.js\nvar React26 = __toESM(require(\"react\"));\nvar FormatItalic = /* @__PURE__ */ React26.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React26.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React26.createElement(\"path\", {\n    d: \"M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z\"\n  }));\n});\nFormatItalic.displayName = \"FormatItalic\";\n\n// node_modules/@styled-icons/material/FormatListBulleted/FormatListBulleted.esm.js\nvar React27 = __toESM(require(\"react\"));\nvar FormatListBulleted = /* @__PURE__ */ React27.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React27.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React27.createElement(\"path\", {\n    d: \"M4 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-6c-.83 0-1.5.67-1.5 1.5S3.17 7.5 4 7.5 5.5 6.83 5.5 6 4.83 4.5 4 4.5zm0 12c-.83 0-1.5.68-1.5 1.5s.68 1.5 1.5 1.5 1.5-.68 1.5-1.5-.67-1.5-1.5-1.5zM7 19h14v-2H7v2zm0-6h14v-2H7v2zm0-8v2h14V5H7z\"\n  }));\n});\nFormatListBulleted.displayName = \"FormatListBulleted\";\n\n// node_modules/@styled-icons/material/FormatListNumbered/FormatListNumbered.esm.js\nvar React28 = __toESM(require(\"react\"));\nvar FormatListNumbered = /* @__PURE__ */ React28.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React28.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React28.createElement(\"path\", {\n    d: \"M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z\"\n  }));\n});\nFormatListNumbered.displayName = \"FormatListNumbered\";\n\n// node_modules/@styled-icons/material/FormatQuote/FormatQuote.esm.js\nvar React29 = __toESM(require(\"react\"));\nvar FormatQuote = /* @__PURE__ */ React29.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React29.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React29.createElement(\"path\", {\n    d: \"M6 17h3l2-4V7H5v6h3zm8 0h3l2-4V7h-6v6h3z\"\n  }));\n});\nFormatQuote.displayName = \"FormatQuote\";\n\n// node_modules/@styled-icons/material/FormatStrikethrough/FormatStrikethrough.esm.js\nvar React30 = __toESM(require(\"react\"));\nvar FormatStrikethrough = /* @__PURE__ */ React30.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React30.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React30.createElement(\"path\", {\n    d: \"M10 19h4v-3h-4v3zM5 4v3h5v3h4V7h5V4H5zM3 14h18v-2H3v2z\"\n  }));\n});\nFormatStrikethrough.displayName = \"FormatStrikethrough\";\n\n// node_modules/@styled-icons/material/FormatUnderlined/FormatUnderlined.esm.js\nvar React31 = __toESM(require(\"react\"));\nvar FormatUnderlined = /* @__PURE__ */ React31.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React31.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React31.createElement(\"path\", {\n    d: \"M12 17c3.31 0 6-2.69 6-6V3h-2.5v8c0 1.93-1.57 3.5-3.5 3.5S8.5 12.93 8.5 11V3H6v8c0 3.31 2.69 6 6 6zm-7 2v2h14v-2H5z\"\n  }));\n});\nFormatUnderlined.displayName = \"FormatUnderlined\";\n\n// node_modules/@styled-icons/material/Looks3/Looks3.esm.js\nvar React32 = __toESM(require(\"react\"));\nvar Looks3 = /* @__PURE__ */ React32.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React32.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React32.createElement(\"path\", {\n    d: \"M19.01 3h-14c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4 7.5c0 .83-.67 1.5-1.5 1.5.83 0 1.5.67 1.5 1.5V15a2 2 0 0 1-2 2h-4v-2h4v-2h-2v-2h2V9h-4V7h4a2 2 0 0 1 2 2v1.5z\"\n  }));\n});\nLooks3.displayName = \"Looks3\";\n\n// node_modules/@styled-icons/material/Looks4/Looks4.esm.js\nvar React33 = __toESM(require(\"react\"));\nvar Looks4 = /* @__PURE__ */ React33.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React33.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React33.createElement(\"path\", {\n    d: \"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4 14h-2v-4H9V7h2v4h2V7h2v10z\"\n  }));\n});\nLooks4.displayName = \"Looks4\";\n\n// node_modules/@styled-icons/material/Looks5/Looks5.esm.js\nvar React34 = __toESM(require(\"react\"));\nvar Looks5 = /* @__PURE__ */ React34.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React34.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React34.createElement(\"path\", {\n    d: \"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4 6h-4v2h2a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H9v-2h4v-2H9V7h6v2z\"\n  }));\n});\nLooks5.displayName = \"Looks5\";\n\n// node_modules/@styled-icons/material/Looks6/Looks6.esm.js\nvar React35 = __toESM(require(\"react\"));\nvar Looks6 = /* @__PURE__ */ React35.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React35.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React35.createElement(\"path\", {\n    d: \"M11 15h2v-2h-2v2zm8-12H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4 6h-4v2h2a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2h-2a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h4v2z\"\n  }));\n});\nLooks6.displayName = \"Looks6\";\n\n// node_modules/@styled-icons/material/LooksOne/LooksOne.esm.js\nvar React36 = __toESM(require(\"react\"));\nvar LooksOne = /* @__PURE__ */ React36.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React36.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React36.createElement(\"path\", {\n    d: \"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14h-2V9h-2V7h4v10z\"\n  }));\n});\nLooksOne.displayName = \"LooksOne\";\n\n// node_modules/@styled-icons/material/LooksTwo/LooksTwo.esm.js\nvar React37 = __toESM(require(\"react\"));\nvar LooksTwo = /* @__PURE__ */ React37.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React37.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React37.createElement(\"path\", {\n    d: \"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4 8a2 2 0 0 1-2 2h-2v2h4v2H9v-4a2 2 0 0 1 2-2h2V9H9V7h4a2 2 0 0 1 2 2v2z\"\n  }));\n});\nLooksTwo.displayName = \"LooksTwo\";\n\n// node_modules/@styled-icons/material/Link/Link.esm.js\nvar React38 = __toESM(require(\"react\"));\nvar Link2 = /* @__PURE__ */ React38.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React38.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React38.createElement(\"path\", {\n    d: \"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z\"\n  }));\n});\nLink2.displayName = \"Link\";\n\n// node_modules/@styled-icons/boxicons-regular/Bracket/Bracket.esm.js\nvar React39 = __toESM(require(\"react\"));\nvar Bracket = /* @__PURE__ */ React39.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React39.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React39.createElement(\"path\", {\n    d: \"M10 4V2H4v20h6v-2H6V4zm4 16v2h6V2h-6v2h4v16z\"\n  }));\n});\nBracket.displayName = \"Bracket\";\n\n// node_modules/@udecode/plate-ui-toolbar/dist/index.es.js\nvar import_styled_components9 = __toESM(require_styled_components_browser_cjs());\nvar import_react48 = __toESM(require(\"react\"));\n\n// node_modules/@udecode/plate-ui-button/dist/index.es.js\nvar import_styled_components8 = __toESM(require_styled_components_browser_cjs());\nvar import_react47 = __toESM(require(\"react\"));\nvar plateButtonCss = [{\n  \"position\": \"relative\",\n  \"display\": \"inline-flex\",\n  \"justifyContent\": \"center\",\n  \"alignItems\": \"center\",\n  \"textAlign\": \"center\",\n  \"maxWidth\": \"100%\",\n  \"padding\": \"0px\"\n}, {\n  \"borderWidth\": \"0px\",\n  \"fontWeight\": \"500\",\n  \"cursor\": \"pointer\"\n}, {\n  \"--tw-bg-opacity\": \"1\",\n  \"backgroundColor\": \"rgba(255, 255, 255, var(--tw-bg-opacity))\",\n  \":hover\": {\n    \"--tw-bg-opacity\": \"1\",\n    \"backgroundColor\": \"rgba(243, 244, 246, var(--tw-bg-opacity))\"\n  },\n  \":active\": {\n    \"--tw-bg-opacity\": \"1\",\n    \"backgroundColor\": \"rgba(229, 231, 235, var(--tw-bg-opacity))\"\n  }\n}, {\n  \"paddingLeft\": \"0.625rem\",\n  \"paddingRight\": \"0.625rem\",\n  \"paddingTop\": \"0.25rem\",\n  \"paddingBottom\": \"0.25rem\"\n}, (0, import_styled_components8.css)([\"font-family:inherit;font-size:14px;border-radius:3px;color:inherit;:active{color:inherit;}:visited{color:inherit;}\"])];\nvar PlateButton = ({\n  size,\n  px,\n  py,\n  css: _css,\n  ...props\n}) => /* @__PURE__ */ import_react47.default.createElement(_StyledButton2, props);\nvar _StyledButton2 = (0, import_styled_components8.default)(Button).withConfig({\n  displayName: \"PlateButton___StyledButton\",\n  componentId: \"sc-wfqywr-0\"\n})([\"\", \"\"], plateButtonCss);\nfunction _extends6() {\n  _extends6 = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i5 = 1; i5 < arguments.length; i5++) {\n      var source = arguments[i5];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends6.apply(this, arguments);\n}\nvar Icon = /* @__PURE__ */ (0, import_react47.forwardRef)((props, ref) => {\n  const {\n    children,\n    iconVerticalAlign,\n    size,\n    title: title2,\n    ...otherProps\n  } = props;\n  const iconProps = {\n    height: props.height !== void 0 ? props.height : size,\n    width: props.width !== void 0 ? props.width : size,\n    \"aria-hidden\": title2 == null ? \"true\" : void 0,\n    focusable: \"false\",\n    role: title2 != null ? \"img\" : void 0,\n    ...otherProps\n  };\n  return /* @__PURE__ */ import_react47.default.createElement(\"svg\", _extends6({}, iconProps, {\n    ref\n  }), title2 && /* @__PURE__ */ import_react47.default.createElement(\"title\", {\n    key: \"icon-title\"\n  }, title2), children);\n});\nvar StyledIcon = (0, import_styled_components8.default)(Icon).withConfig({\n  displayName: \"StyledIcon\",\n  componentId: \"sc-1lmwuuu-0\"\n})([\"display:inline-block;vertical-align:\", \";overflow:hidden;height:100%;\"], (props) => props.iconVerticalAlign);\nvar DeleteIcon = (props) => /* @__PURE__ */ import_react47.default.createElement(StyledIcon, _extends6({\n  viewBox: \"0 0 24 24\",\n  fill: \"currentColor\"\n}, props), /* @__PURE__ */ import_react47.default.createElement(\"path\", {\n  fill: \"none\",\n  d: \"M0 0h24v24H0z\"\n}), /* @__PURE__ */ import_react47.default.createElement(\"path\", {\n  d: \"M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z\"\n}));\nvar RemoveNodeButton = ({\n  element: element4,\n  ...props\n}) => {\n  const editor = useEditorRef();\n  return /* @__PURE__ */ import_react47.default.createElement(_StyledPlateButton, _extends6({\n    onClick: () => {\n      const path = findNodePath(editor, element4);\n      removeNodes(editor, {\n        at: path\n      });\n      focusEditor(editor, editor.selection);\n    }\n  }, props, {\n    $_css: [{\n      \"paddingTop\": \"0.25rem\",\n      \"paddingBottom\": \"0.25rem\",\n      \"paddingLeft\": \"0px\",\n      \"paddingRight\": \"0px\"\n    }, `\n        width: 24px;\n        height: 24px;\n      `]\n  }), /* @__PURE__ */ import_react47.default.createElement(DeleteIcon, null));\n};\nvar _StyledPlateButton = (0, import_styled_components8.default)(PlateButton).withConfig({\n  displayName: \"RemoveNodeButton___StyledPlateButton\",\n  componentId: \"sc-nzabn0-0\"\n})([\"\", \"\"], (p6) => p6.$_css);\nvar _StyledStyledIcon = (0, import_styled_components8.default)(StyledIcon).withConfig({\n  displayName: \"ChevronDownIcon___StyledStyledIcon\",\n  componentId: \"sc-1mognml-0\"\n})({\n  \"display\": \"inline\",\n  \"textAlign\": \"center\",\n  \"userSelect\": \"none\",\n  \"overflow\": \"hidden\",\n  \"pointerEvents\": \"none\",\n  \"maxWidth\": \"100%\",\n  \"maxHeight\": \"100%\",\n  \"height\": \"100%\",\n  \"verticalAlign\": \"middle\"\n});\n\n// node_modules/@udecode/plate-ui-toolbar/dist/index.es.js\nvar _StyledDiv$12 = (0, import_styled_components9.default)(\"div\").withConfig({\n  displayName: \"FloatingVerticalDivider___StyledDiv\",\n  componentId: \"sc-17bdbkd-0\"\n})({\n  \"width\": \"1px\",\n  \"height\": \"1.25rem\",\n  \"--tw-bg-opacity\": \"1\",\n  \"backgroundColor\": \"rgba(229, 231, 235, var(--tw-bg-opacity))\",\n  \"marginLeft\": \"0.5rem\",\n  \"marginRight\": \"0.5rem\"\n});\nvar floatingRootCss = (0, import_styled_components9.css)([\"\", \";border-radius:4px;box-shadow:rgb(15 15 15 / 5%) 0 0 0 1px,rgb(15 15 15 / 10%) 0 3px 6px,rgb(15 15 15 / 20%) 0 9px 24px;\"], {\n  \"--tw-bg-opacity\": \"1\",\n  \"backgroundColor\": \"rgba(255, 255, 255, var(--tw-bg-opacity))\",\n  \"zIndex\": \"20 !important\",\n  \"width\": \"auto\"\n});\nvar floatingRowCss = (0, import_styled_components9.css)([\"\", \";\"], {\n  \"paddingLeft\": \"0.5rem\",\n  \"paddingRight\": \"0.5rem\",\n  \"paddingTop\": \"0.25rem\",\n  \"paddingBottom\": \"0.25rem\",\n  \"display\": \"flex\",\n  \"flexDirection\": \"row\",\n  \"alignItems\": \"center\"\n});\nvar floatingButtonCss = [...plateButtonCss, {\n  \"paddingLeft\": \"0.25rem\",\n  \"paddingRight\": \"0.25rem\"\n}];\nvar FloatingIconWrapper = import_styled_components9.default.div.withConfig({\n  displayName: \"styles__FloatingIconWrapper\",\n  componentId: \"sc-zqwbtz-0\"\n})([\"\", \";\"], {\n  \"display\": \"flex\",\n  \"alignItems\": \"center\",\n  \"paddingLeft\": \"0.5rem\",\n  \"paddingRight\": \"0.5rem\",\n  \"--tw-text-opacity\": \"1\",\n  \"color\": \"rgba(156, 163, 175, var(--tw-text-opacity))\"\n});\nvar FloatingInputWrapper = import_styled_components9.default.div.withConfig({\n  displayName: \"styles__FloatingInputWrapper\",\n  componentId: \"sc-zqwbtz-1\"\n})([\"\", \";\"], {\n  \"display\": \"flex\",\n  \"alignItems\": \"center\",\n  \"paddingTop\": \"0.25rem\",\n  \"paddingBottom\": \"0.25rem\",\n  \"paddingRight\": \"0.5rem\"\n});\nvar floatingInputCss = [{\n  \"borderStyle\": \"none\",\n  \"backgroundColor\": \"rgba(0, 0, 0, 0)\",\n  \"height\": \"2rem\",\n  \"flexGrow\": \"1\",\n  \"padding\": \"0px\"\n}, {\n  \":focus\": {\n    \"outline\": \"2px solid transparent\",\n    \"outlineOffset\": \"2px\"\n  }\n}, (0, import_styled_components9.css)([\"line-height:20px;\"])];\nvar getToolbarStyles = (props) => createStyles({\n  prefixClassNames: \"Toolbar\",\n  ...props\n}, {\n  root: [{\n    \"display\": \"flex\",\n    \"alignItems\": \"center\",\n    \"userSelect\": \"none\",\n    \"boxSizing\": \"content-box\"\n  }, {\n    \"color\": \"rgb(68, 68, 68)\",\n    \"minHeight\": \"40px\"\n  }]\n});\nvar getBalloonToolbarStyles = (props) => {\n  let color = \"rgb(157, 170, 182)\";\n  let colorActive = \"white\";\n  let background = \"rgb(36, 42, 49)\";\n  let borderColor = \"transparent\";\n  if (props.theme === \"light\") {\n    color = \"rgba(0, 0, 0, 0.50)\";\n    colorActive = \"black\";\n    background = \"rgb(250, 250, 250)\";\n    borderColor = \"rgb(196, 196, 196)\";\n  }\n  const {\n    placement = \"top\"\n  } = props;\n  const arrowStyle = [props.arrow && (0, import_styled_components9.css)([\"::after{left:50%;content:' ';position:absolute;margin-top:-1px;transform:translateX(-50%);border-color:\", \" transparent;border-style:solid;}\"], background), props.arrow && placement.includes(\"top\") && (0, import_styled_components9.css)([\"::after{top:100%;bottom:auto;border-width:8px 8px 0;}\"]), props.arrow && !placement.includes(\"top\") && (0, import_styled_components9.css)([\"::after{top:auto;bottom:100%;border-width:0 8px 8px;}\"])];\n  const arrowBorderStyle = [props.arrow && placement.includes(\"top\") && props.theme === \"light\" && (0, import_styled_components9.css)([\"::before{margin-top:0;border-width:9px 9px 0;border-color:\", \" transparent;}\"], borderColor), props.arrow && !placement.includes(\"top\") && props.theme === \"light\" && (0, import_styled_components9.css)([\"::before{margin-top:0;border-width:0 9px 9px;border-color:\", \" transparent;}\"], borderColor)];\n  return createStyles({\n    prefixClassNames: \"BalloonToolbar\",\n    ...props\n  }, {\n    root: [...getToolbarStyles(props).root.css, {\n      \"position\": \"absolute\",\n      \"whiteSpace\": \"nowrap\",\n      \"opacity\": \"1\",\n      \"transition\": \"opacity .2s ease-in-out\"\n    }, (0, import_styled_components9.css)([\"color:\", \";background:\", \";z-index:500;border:1px solid \", \";border-radius:4px;.slate-ToolbarButton-active,.slate-ToolbarButton:hover{color:\", \";}::before{\", \"}\"], color, background, borderColor, colorActive, arrowBorderStyle), ...arrowStyle, ...arrowBorderStyle]\n  });\n};\nfunction _extends7() {\n  _extends7 = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i5 = 1; i5 < arguments.length; i5++) {\n      var source = arguments[i5];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends7.apply(this, arguments);\n}\nvar ToolbarBase = /* @__PURE__ */ import_react48.default.forwardRef((props, ref) => {\n  return /* @__PURE__ */ import_react48.default.createElement(\"div\", _extends7({\n    \"data-testid\": \"Toolbar\",\n    ref\n  }, props));\n});\nvar _StyledToolbarBase$2 = (0, import_styled_components9.default)(ToolbarBase).withConfig({\n  displayName: \"Toolbar___StyledToolbarBase\",\n  componentId: \"sc-1srlh8g-0\"\n})([\"\", \"\"], (p6) => p6.$_css);\nvar useFloatingToolbar = ({\n  floatingOptions\n} = {}) => {\n  var _selectionText$length;\n  const focusedEditorId = useEventEditorSelectors.focus();\n  const editor = useEditorState();\n  const focused = useFocused();\n  const [waitForCollapsedSelection, setWaitForCollapsedSelection] = (0, import_react48.useState)(false);\n  const [open, setOpen] = (0, import_react48.useState)(false);\n  const selectionExpanded = editor && isSelectionExpanded(editor);\n  const selectionText = editor && getSelectionText(editor);\n  (0, import_react48.useEffect)(() => {\n    if (!focused) {\n      setWaitForCollapsedSelection(true);\n    }\n    if (!selectionExpanded) {\n      setWaitForCollapsedSelection(false);\n    }\n  }, [focused, selectionExpanded]);\n  (0, import_react48.useEffect)(() => {\n    if (!selectionExpanded || !selectionText || editor.id !== focusedEditorId) {\n      setOpen(false);\n    } else if (selectionText && selectionExpanded && !waitForCollapsedSelection) {\n      setOpen(true);\n    }\n  }, [editor.id, editor.selection, focusedEditorId, selectionExpanded, selectionText, waitForCollapsedSelection]);\n  const floatingResult = useVirtualFloating2(mergeProps({\n    middleware: [T(12), b2({\n      padding: 96\n    })],\n    placement: \"top\",\n    getBoundingClientRect: getSelectionBoundingClientRect2,\n    open,\n    onOpenChange: setOpen\n  }, floatingOptions));\n  const {\n    update\n  } = floatingResult;\n  const selectionTextLength = (_selectionText$length = selectionText === null || selectionText === void 0 ? void 0 : selectionText.length) !== null && _selectionText$length !== void 0 ? _selectionText$length : 0;\n  (0, import_react48.useEffect)(() => {\n    if (selectionTextLength > 0) {\n      update === null || update === void 0 ? void 0 : update();\n    }\n  }, [selectionTextLength, update]);\n  return {\n    ...floatingResult,\n    open\n  };\n};\nvar BalloonToolbar = withPlateEventProvider((props) => {\n  const {\n    children,\n    theme = \"dark\",\n    arrow: arrow3 = false,\n    portalElement,\n    floatingOptions\n  } = props;\n  const {\n    floating,\n    style,\n    placement,\n    open\n  } = useFloatingToolbar({\n    floatingOptions\n  });\n  const styles2 = getBalloonToolbarStyles({\n    placement,\n    theme,\n    arrow: arrow3,\n    ...props\n  });\n  if (!open)\n    return null;\n  return /* @__PURE__ */ import_react48.default.createElement(PortalBody, {\n    element: portalElement\n  }, /* @__PURE__ */ import_react48.default.createElement(_StyledToolbarBase$1, {\n    className: styles2.root.className,\n    ref: floating,\n    style,\n    $_css: styles2.root.css\n  }, children));\n});\nvar _StyledToolbarBase$1 = (0, import_styled_components9.default)(ToolbarBase).withConfig({\n  displayName: \"BalloonToolbar___StyledToolbarBase\",\n  componentId: \"sc-s0c2tw-0\"\n})([\"\", \"\"], (p6) => p6.$_css);\nvar getToolbarButtonStyles = (props) => createStyles({\n  prefixClassNames: \"ToolbarButton\",\n  ...props\n}, {\n  root: [{\n    \"display\": \"flex\",\n    \"justifyContent\": \"center\",\n    \"alignItems\": \"center\",\n    \"userSelect\": \"none\",\n    \"cursor\": \"pointer\",\n    \"verticalAlign\": \"middle\"\n  }, {\n    \"width\": \"28px\",\n    \"height\": \"24px\"\n  }, (0, import_styled_components9.css)([\"> svg{\", \"}\"], {\n    \"display\": \"block\",\n    \"width\": \"1.25rem\",\n    \"height\": \"1.25rem\"\n  })],\n  ...props.active && {\n    active: {}\n  }\n});\nfunction toVal2(mix) {\n  var k3, y5, str = \"\";\n  if (typeof mix === \"string\" || typeof mix === \"number\") {\n    str += mix;\n  } else if (typeof mix === \"object\") {\n    if (Array.isArray(mix)) {\n      for (k3 = 0; k3 < mix.length; k3++) {\n        if (mix[k3]) {\n          if (y5 = toVal2(mix[k3])) {\n            str && (str += \" \");\n            str += y5;\n          }\n        }\n      }\n    } else {\n      for (k3 in mix) {\n        if (mix[k3]) {\n          str && (str += \" \");\n          str += k3;\n        }\n      }\n    }\n  }\n  return str;\n}\nfunction clsx3() {\n  var i5 = 0, tmp, x4, str = \"\";\n  while (i5 < arguments.length) {\n    if (tmp = arguments[i5++]) {\n      if (x4 = toVal2(tmp)) {\n        str && (str += \" \");\n        str += x4;\n      }\n    }\n  }\n  return str;\n}\nvar ToolbarButton = (props) => {\n  const {\n    icon,\n    tooltip,\n    onMouseDown\n  } = props;\n  const spanProps = {\n    onMouseDown\n  };\n  const tooltipProps = {\n    content: \"\",\n    arrow: true,\n    offset: [0, 17],\n    delay: 0,\n    duration: [200, 0],\n    hideOnClick: false,\n    ...tooltip\n  };\n  const {\n    root: root5,\n    active\n  } = getToolbarButtonStyles(props);\n  const button = /* @__PURE__ */ import_react48.default.createElement(_StyledSpan2, _extends7({\n    \"data-testid\": \"ToolbarButton\",\n    className: clsx3(root5.className, active === null || active === void 0 ? void 0 : active.className)\n  }, spanProps, {\n    $_css: root5.css\n  }), icon);\n  return tooltip ? /* @__PURE__ */ import_react48.default.createElement(tippy_react_esm_default, tooltipProps, button) : button;\n};\nvar _StyledSpan2 = (0, import_styled_components9.default)(\"span\").withConfig({\n  displayName: \"ToolbarButton___StyledSpan\",\n  componentId: \"sc-1rn3zj7-0\"\n})([\"\", \"\"], (p6) => p6.$_css);\nvar BlockToolbarButton = withPlateEventProvider(({\n  id,\n  type,\n  inactiveType,\n  active,\n  ...props\n}) => {\n  id = useEventPlateId(id);\n  const editor = usePlateEditorState(id);\n  return /* @__PURE__ */ import_react48.default.createElement(ToolbarButton, _extends7({\n    active: active !== null && active !== void 0 ? active : !!(editor !== null && editor !== void 0 && editor.selection) && someNode(editor, {\n      match: {\n        type\n      }\n    }),\n    onMouseDown: editor && getPreventDefaultHandler(toggleNodeType, editor, {\n      activeType: type,\n      inactiveType\n    })\n  }, props));\n});\nvar _StyledToolbarBase = (0, import_styled_components9.default)(ToolbarBase).withConfig({\n  displayName: \"HeadingToolbar___StyledToolbarBase\",\n  componentId: \"sc-1gnw7ox-0\"\n})([\"\", \"\"], (p6) => p6.$_css);\nvar MarkToolbarButton = withPlateEventProvider(({\n  id,\n  type,\n  clear,\n  ...props\n}) => {\n  id = useEventPlateId(id);\n  const editor = usePlateEditorState(id);\n  return /* @__PURE__ */ import_react48.default.createElement(ToolbarButton, _extends7({\n    active: !!(editor !== null && editor !== void 0 && editor.selection) && isMarkActive(editor, type),\n    onMouseDown: editor ? getPreventDefaultHandler(toggleMark, editor, {\n      key: type,\n      clear\n    }) : void 0\n  }, props));\n});\nvar _StyledDiv7 = (0, import_styled_components9.default)(\"div\").withConfig({\n  displayName: \"ToolbarDropdown___StyledDiv\",\n  componentId: \"sc-1w3yept-0\"\n})([\"\", \"\"], (p6) => p6.$_css);\n\n// node_modules/@udecode/plate-ui-list/dist/index.es.js\nvar import_react50 = __toESM(require(\"react\"));\nvar import_styled_components10 = __toESM(require_styled_components_browser_cjs());\nfunction _extends8() {\n  _extends8 = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i5 = 1; i5 < arguments.length; i5++) {\n      var source = arguments[i5];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends8.apply(this, arguments);\n}\nvar ListToolbarButton = withPlateEventProvider(({\n  id,\n  type = ELEMENT_UL,\n  ...props\n}) => {\n  id = useEventPlateId(id);\n  const editor = usePlateEditorState(id);\n  const res = !!(editor !== null && editor !== void 0 && editor.selection) && getListItemEntry(editor);\n  return /* @__PURE__ */ import_react50.default.createElement(BlockToolbarButton, _extends8({\n    active: !!res && res.list[0].type === type,\n    type,\n    onMouseDown: editor && getPreventDefaultHandler(toggleList, editor, {\n      type\n    })\n  }, props));\n});\nvar _StyledDiv8 = (0, import_styled_components10.default)(\"div\").withConfig({\n  displayName: \"TodoListElement___StyledDiv\",\n  componentId: \"sc-1k5d4zs-0\"\n})([\"\", \"\"], (p6) => p6.$_css);\nvar _StyledDiv23 = (0, import_styled_components10.default)(\"div\").withConfig({\n  displayName: \"TodoListElement___StyledDiv2\",\n  componentId: \"sc-1k5d4zs-1\"\n})([\"\", \"\"], (p6) => p6.$_css2);\nvar _StyledInput = (0, import_styled_components10.default)(\"input\").withConfig({\n  displayName: \"TodoListElement___StyledInput\",\n  componentId: \"sc-1k5d4zs-2\"\n})([\"\", \"\"], (p6) => p6.$_css3);\nvar _StyledSpan3 = (0, import_styled_components10.default)(\"span\").withConfig({\n  displayName: \"TodoListElement___StyledSpan\",\n  componentId: \"sc-1k5d4zs-3\"\n})([\"\", \"\"], (p6) => p6.$_css4);\n\n// node_modules/@udecode/plate-ui-table/dist/index.es.js\nvar import_styled_components11 = __toESM(require_styled_components_browser_cjs());\nvar import_react51 = __toESM(require(\"react\"));\n\n// node_modules/re-resizable/lib/index.js\nvar React44 = __toESM(require(\"react\"));\nvar import_react_dom6 = require(\"react-dom\");\n\n// node_modules/re-resizable/lib/resizer.js\nvar React43 = __toESM(require(\"react\"));\nvar __extends = function() {\n  var extendStatics = function(d4, b4) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b5) {\n      d5.__proto__ = b5;\n    } || function(d5, b5) {\n      for (var p6 in b5)\n        if (Object.prototype.hasOwnProperty.call(b5, p6))\n          d5[p6] = b5[p6];\n    };\n    return extendStatics(d4, b4);\n  };\n  return function(d4, b4) {\n    extendStatics(d4, b4);\n    function __() {\n      this.constructor = d4;\n    }\n    d4.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());\n  };\n}();\nvar __assign2 = function() {\n  __assign2 = Object.assign || function(t6) {\n    for (var s5, i5 = 1, n8 = arguments.length; i5 < n8; i5++) {\n      s5 = arguments[i5];\n      for (var p6 in s5)\n        if (Object.prototype.hasOwnProperty.call(s5, p6))\n          t6[p6] = s5[p6];\n    }\n    return t6;\n  };\n  return __assign2.apply(this, arguments);\n};\nvar rowSizeBase = {\n  width: \"100%\",\n  height: \"10px\",\n  top: \"0px\",\n  left: \"0px\",\n  cursor: \"row-resize\"\n};\nvar colSizeBase = {\n  width: \"10px\",\n  height: \"100%\",\n  top: \"0px\",\n  left: \"0px\",\n  cursor: \"col-resize\"\n};\nvar edgeBase = {\n  width: \"20px\",\n  height: \"20px\",\n  position: \"absolute\"\n};\nvar styles = {\n  top: __assign2(__assign2({}, rowSizeBase), { top: \"-5px\" }),\n  right: __assign2(__assign2({}, colSizeBase), { left: void 0, right: \"-5px\" }),\n  bottom: __assign2(__assign2({}, rowSizeBase), { top: void 0, bottom: \"-5px\" }),\n  left: __assign2(__assign2({}, colSizeBase), { left: \"-5px\" }),\n  topRight: __assign2(__assign2({}, edgeBase), { right: \"-10px\", top: \"-10px\", cursor: \"ne-resize\" }),\n  bottomRight: __assign2(__assign2({}, edgeBase), { right: \"-10px\", bottom: \"-10px\", cursor: \"se-resize\" }),\n  bottomLeft: __assign2(__assign2({}, edgeBase), { left: \"-10px\", bottom: \"-10px\", cursor: \"sw-resize\" }),\n  topLeft: __assign2(__assign2({}, edgeBase), { left: \"-10px\", top: \"-10px\", cursor: \"nw-resize\" })\n};\nvar Resizer = function(_super) {\n  __extends(Resizer2, _super);\n  function Resizer2() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.onMouseDown = function(e4) {\n      _this.props.onResizeStart(e4, _this.props.direction);\n    };\n    _this.onTouchStart = function(e4) {\n      _this.props.onResizeStart(e4, _this.props.direction);\n    };\n    return _this;\n  }\n  Resizer2.prototype.render = function() {\n    return React43.createElement(\"div\", { className: this.props.className || \"\", style: __assign2(__assign2({ position: \"absolute\", userSelect: \"none\" }, styles[this.props.direction]), this.props.replaceStyles || {}), onMouseDown: this.onMouseDown, onTouchStart: this.onTouchStart }, this.props.children);\n  };\n  return Resizer2;\n}(React43.PureComponent);\n\n// node_modules/re-resizable/lib/index.js\nvar __extends2 = function() {\n  var extendStatics = function(d4, b4) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b5) {\n      d5.__proto__ = b5;\n    } || function(d5, b5) {\n      for (var p6 in b5)\n        if (Object.prototype.hasOwnProperty.call(b5, p6))\n          d5[p6] = b5[p6];\n    };\n    return extendStatics(d4, b4);\n  };\n  return function(d4, b4) {\n    extendStatics(d4, b4);\n    function __() {\n      this.constructor = d4;\n    }\n    d4.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());\n  };\n}();\nvar __assign3 = function() {\n  __assign3 = Object.assign || function(t6) {\n    for (var s5, i5 = 1, n8 = arguments.length; i5 < n8; i5++) {\n      s5 = arguments[i5];\n      for (var p6 in s5)\n        if (Object.prototype.hasOwnProperty.call(s5, p6))\n          t6[p6] = s5[p6];\n    }\n    return t6;\n  };\n  return __assign3.apply(this, arguments);\n};\nvar DEFAULT_SIZE = {\n  width: \"auto\",\n  height: \"auto\"\n};\nvar clamp = function(n8, min3, max3) {\n  return Math.max(Math.min(n8, max3), min3);\n};\nvar snap = function(n8, size) {\n  return Math.round(n8 / size) * size;\n};\nvar hasDirection = function(dir, target) {\n  return new RegExp(dir, \"i\").test(target);\n};\nvar isTouchEvent = function(event) {\n  return Boolean(event.touches && event.touches.length);\n};\nvar isMouseEvent2 = function(event) {\n  return Boolean((event.clientX || event.clientX === 0) && (event.clientY || event.clientY === 0));\n};\nvar findClosestSnap = function(n8, snapArray, snapGap) {\n  if (snapGap === void 0) {\n    snapGap = 0;\n  }\n  var closestGapIndex = snapArray.reduce(function(prev, curr, index5) {\n    return Math.abs(curr - n8) < Math.abs(snapArray[prev] - n8) ? index5 : prev;\n  }, 0);\n  var gap = Math.abs(snapArray[closestGapIndex] - n8);\n  return snapGap === 0 || gap < snapGap ? snapArray[closestGapIndex] : n8;\n};\nvar getStringSize = function(n8) {\n  n8 = n8.toString();\n  if (n8 === \"auto\") {\n    return n8;\n  }\n  if (n8.endsWith(\"px\")) {\n    return n8;\n  }\n  if (n8.endsWith(\"%\")) {\n    return n8;\n  }\n  if (n8.endsWith(\"vh\")) {\n    return n8;\n  }\n  if (n8.endsWith(\"vw\")) {\n    return n8;\n  }\n  if (n8.endsWith(\"vmax\")) {\n    return n8;\n  }\n  if (n8.endsWith(\"vmin\")) {\n    return n8;\n  }\n  return n8 + \"px\";\n};\nvar getPixelSize = function(size, parentSize, innerWidth2, innerHeight2) {\n  if (size && typeof size === \"string\") {\n    if (size.endsWith(\"px\")) {\n      return Number(size.replace(\"px\", \"\"));\n    }\n    if (size.endsWith(\"%\")) {\n      var ratio = Number(size.replace(\"%\", \"\")) / 100;\n      return parentSize * ratio;\n    }\n    if (size.endsWith(\"vw\")) {\n      var ratio = Number(size.replace(\"vw\", \"\")) / 100;\n      return innerWidth2 * ratio;\n    }\n    if (size.endsWith(\"vh\")) {\n      var ratio = Number(size.replace(\"vh\", \"\")) / 100;\n      return innerHeight2 * ratio;\n    }\n  }\n  return size;\n};\nvar calculateNewMax = function(parentSize, innerWidth2, innerHeight2, maxWidth, maxHeight, minWidth, minHeight) {\n  maxWidth = getPixelSize(maxWidth, parentSize.width, innerWidth2, innerHeight2);\n  maxHeight = getPixelSize(maxHeight, parentSize.height, innerWidth2, innerHeight2);\n  minWidth = getPixelSize(minWidth, parentSize.width, innerWidth2, innerHeight2);\n  minHeight = getPixelSize(minHeight, parentSize.height, innerWidth2, innerHeight2);\n  return {\n    maxWidth: typeof maxWidth === \"undefined\" ? void 0 : Number(maxWidth),\n    maxHeight: typeof maxHeight === \"undefined\" ? void 0 : Number(maxHeight),\n    minWidth: typeof minWidth === \"undefined\" ? void 0 : Number(minWidth),\n    minHeight: typeof minHeight === \"undefined\" ? void 0 : Number(minHeight)\n  };\n};\nvar definedProps = [\n  \"as\",\n  \"style\",\n  \"className\",\n  \"grid\",\n  \"snap\",\n  \"bounds\",\n  \"boundsByDirection\",\n  \"size\",\n  \"defaultSize\",\n  \"minWidth\",\n  \"minHeight\",\n  \"maxWidth\",\n  \"maxHeight\",\n  \"lockAspectRatio\",\n  \"lockAspectRatioExtraWidth\",\n  \"lockAspectRatioExtraHeight\",\n  \"enable\",\n  \"handleStyles\",\n  \"handleClasses\",\n  \"handleWrapperStyle\",\n  \"handleWrapperClass\",\n  \"children\",\n  \"onResizeStart\",\n  \"onResize\",\n  \"onResizeStop\",\n  \"handleComponent\",\n  \"scale\",\n  \"resizeRatio\",\n  \"snapGap\"\n];\nvar baseClassName = \"__resizable_base__\";\nvar Resizable = function(_super) {\n  __extends2(Resizable2, _super);\n  function Resizable2(props) {\n    var _this = _super.call(this, props) || this;\n    _this.ratio = 1;\n    _this.resizable = null;\n    _this.parentLeft = 0;\n    _this.parentTop = 0;\n    _this.resizableLeft = 0;\n    _this.resizableRight = 0;\n    _this.resizableTop = 0;\n    _this.resizableBottom = 0;\n    _this.targetLeft = 0;\n    _this.targetTop = 0;\n    _this.appendBase = function() {\n      if (!_this.resizable || !_this.window) {\n        return null;\n      }\n      var parent2 = _this.parentNode;\n      if (!parent2) {\n        return null;\n      }\n      var element4 = _this.window.document.createElement(\"div\");\n      element4.style.width = \"100%\";\n      element4.style.height = \"100%\";\n      element4.style.position = \"absolute\";\n      element4.style.transform = \"scale(0, 0)\";\n      element4.style.left = \"0\";\n      element4.style.flex = \"0 0 100%\";\n      if (element4.classList) {\n        element4.classList.add(baseClassName);\n      } else {\n        element4.className += baseClassName;\n      }\n      parent2.appendChild(element4);\n      return element4;\n    };\n    _this.removeBase = function(base) {\n      var parent2 = _this.parentNode;\n      if (!parent2) {\n        return;\n      }\n      parent2.removeChild(base);\n    };\n    _this.ref = function(c5) {\n      if (c5) {\n        _this.resizable = c5;\n      }\n    };\n    _this.state = {\n      isResizing: false,\n      width: typeof (_this.propsSize && _this.propsSize.width) === \"undefined\" ? \"auto\" : _this.propsSize && _this.propsSize.width,\n      height: typeof (_this.propsSize && _this.propsSize.height) === \"undefined\" ? \"auto\" : _this.propsSize && _this.propsSize.height,\n      direction: \"right\",\n      original: {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      },\n      backgroundStyle: {\n        height: \"100%\",\n        width: \"100%\",\n        backgroundColor: \"rgba(0,0,0,0)\",\n        cursor: \"auto\",\n        opacity: 0,\n        position: \"fixed\",\n        zIndex: 9999,\n        top: \"0\",\n        left: \"0\",\n        bottom: \"0\",\n        right: \"0\"\n      },\n      flexBasis: void 0\n    };\n    _this.onResizeStart = _this.onResizeStart.bind(_this);\n    _this.onMouseMove = _this.onMouseMove.bind(_this);\n    _this.onMouseUp = _this.onMouseUp.bind(_this);\n    return _this;\n  }\n  Object.defineProperty(Resizable2.prototype, \"parentNode\", {\n    get: function() {\n      if (!this.resizable) {\n        return null;\n      }\n      return this.resizable.parentNode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Resizable2.prototype, \"window\", {\n    get: function() {\n      if (!this.resizable) {\n        return null;\n      }\n      if (!this.resizable.ownerDocument) {\n        return null;\n      }\n      return this.resizable.ownerDocument.defaultView;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Resizable2.prototype, \"propsSize\", {\n    get: function() {\n      return this.props.size || this.props.defaultSize || DEFAULT_SIZE;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Resizable2.prototype, \"size\", {\n    get: function() {\n      var width = 0;\n      var height = 0;\n      if (this.resizable && this.window) {\n        var orgWidth = this.resizable.offsetWidth;\n        var orgHeight = this.resizable.offsetHeight;\n        var orgPosition = this.resizable.style.position;\n        if (orgPosition !== \"relative\") {\n          this.resizable.style.position = \"relative\";\n        }\n        width = this.resizable.style.width !== \"auto\" ? this.resizable.offsetWidth : orgWidth;\n        height = this.resizable.style.height !== \"auto\" ? this.resizable.offsetHeight : orgHeight;\n        this.resizable.style.position = orgPosition;\n      }\n      return { width, height };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Resizable2.prototype, \"sizeStyle\", {\n    get: function() {\n      var _this = this;\n      var size = this.props.size;\n      var getSize = function(key) {\n        if (typeof _this.state[key] === \"undefined\" || _this.state[key] === \"auto\") {\n          return \"auto\";\n        }\n        if (_this.propsSize && _this.propsSize[key] && _this.propsSize[key].toString().endsWith(\"%\")) {\n          if (_this.state[key].toString().endsWith(\"%\")) {\n            return _this.state[key].toString();\n          }\n          var parentSize = _this.getParentSize();\n          var value = Number(_this.state[key].toString().replace(\"px\", \"\"));\n          var percent = value / parentSize[key] * 100;\n          return percent + \"%\";\n        }\n        return getStringSize(_this.state[key]);\n      };\n      var width = size && typeof size.width !== \"undefined\" && !this.state.isResizing ? getStringSize(size.width) : getSize(\"width\");\n      var height = size && typeof size.height !== \"undefined\" && !this.state.isResizing ? getStringSize(size.height) : getSize(\"height\");\n      return { width, height };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Resizable2.prototype.getParentSize = function() {\n    if (!this.parentNode) {\n      if (!this.window) {\n        return { width: 0, height: 0 };\n      }\n      return { width: this.window.innerWidth, height: this.window.innerHeight };\n    }\n    var base = this.appendBase();\n    if (!base) {\n      return { width: 0, height: 0 };\n    }\n    var wrapChanged = false;\n    var wrap = this.parentNode.style.flexWrap;\n    if (wrap !== \"wrap\") {\n      wrapChanged = true;\n      this.parentNode.style.flexWrap = \"wrap\";\n    }\n    base.style.position = \"relative\";\n    base.style.minWidth = \"100%\";\n    base.style.minHeight = \"100%\";\n    var size = {\n      width: base.offsetWidth,\n      height: base.offsetHeight\n    };\n    if (wrapChanged) {\n      this.parentNode.style.flexWrap = wrap;\n    }\n    this.removeBase(base);\n    return size;\n  };\n  Resizable2.prototype.bindEvents = function() {\n    if (this.window) {\n      this.window.addEventListener(\"mouseup\", this.onMouseUp);\n      this.window.addEventListener(\"mousemove\", this.onMouseMove);\n      this.window.addEventListener(\"mouseleave\", this.onMouseUp);\n      this.window.addEventListener(\"touchmove\", this.onMouseMove, {\n        capture: true,\n        passive: false\n      });\n      this.window.addEventListener(\"touchend\", this.onMouseUp);\n    }\n  };\n  Resizable2.prototype.unbindEvents = function() {\n    if (this.window) {\n      this.window.removeEventListener(\"mouseup\", this.onMouseUp);\n      this.window.removeEventListener(\"mousemove\", this.onMouseMove);\n      this.window.removeEventListener(\"mouseleave\", this.onMouseUp);\n      this.window.removeEventListener(\"touchmove\", this.onMouseMove, true);\n      this.window.removeEventListener(\"touchend\", this.onMouseUp);\n    }\n  };\n  Resizable2.prototype.componentDidMount = function() {\n    if (!this.resizable || !this.window) {\n      return;\n    }\n    var computedStyle = this.window.getComputedStyle(this.resizable);\n    this.setState({\n      width: this.state.width || this.size.width,\n      height: this.state.height || this.size.height,\n      flexBasis: computedStyle.flexBasis !== \"auto\" ? computedStyle.flexBasis : void 0\n    });\n  };\n  Resizable2.prototype.componentWillUnmount = function() {\n    if (this.window) {\n      this.unbindEvents();\n    }\n  };\n  Resizable2.prototype.createSizeForCssProperty = function(newSize, kind) {\n    var propsSize = this.propsSize && this.propsSize[kind];\n    return this.state[kind] === \"auto\" && this.state.original[kind] === newSize && (typeof propsSize === \"undefined\" || propsSize === \"auto\") ? \"auto\" : newSize;\n  };\n  Resizable2.prototype.calculateNewMaxFromBoundary = function(maxWidth, maxHeight) {\n    var boundsByDirection = this.props.boundsByDirection;\n    var direction = this.state.direction;\n    var widthByDirection = boundsByDirection && hasDirection(\"left\", direction);\n    var heightByDirection = boundsByDirection && hasDirection(\"top\", direction);\n    var boundWidth;\n    var boundHeight;\n    if (this.props.bounds === \"parent\") {\n      var parent_1 = this.parentNode;\n      if (parent_1) {\n        boundWidth = widthByDirection ? this.resizableRight - this.parentLeft : parent_1.offsetWidth + (this.parentLeft - this.resizableLeft);\n        boundHeight = heightByDirection ? this.resizableBottom - this.parentTop : parent_1.offsetHeight + (this.parentTop - this.resizableTop);\n      }\n    } else if (this.props.bounds === \"window\") {\n      if (this.window) {\n        boundWidth = widthByDirection ? this.resizableRight : this.window.innerWidth - this.resizableLeft;\n        boundHeight = heightByDirection ? this.resizableBottom : this.window.innerHeight - this.resizableTop;\n      }\n    } else if (this.props.bounds) {\n      boundWidth = widthByDirection ? this.resizableRight - this.targetLeft : this.props.bounds.offsetWidth + (this.targetLeft - this.resizableLeft);\n      boundHeight = heightByDirection ? this.resizableBottom - this.targetTop : this.props.bounds.offsetHeight + (this.targetTop - this.resizableTop);\n    }\n    if (boundWidth && Number.isFinite(boundWidth)) {\n      maxWidth = maxWidth && maxWidth < boundWidth ? maxWidth : boundWidth;\n    }\n    if (boundHeight && Number.isFinite(boundHeight)) {\n      maxHeight = maxHeight && maxHeight < boundHeight ? maxHeight : boundHeight;\n    }\n    return { maxWidth, maxHeight };\n  };\n  Resizable2.prototype.calculateNewSizeFromDirection = function(clientX, clientY) {\n    var scale = this.props.scale || 1;\n    var resizeRatio = this.props.resizeRatio || 1;\n    var _a = this.state, direction = _a.direction, original = _a.original;\n    var _b = this.props, lockAspectRatio = _b.lockAspectRatio, lockAspectRatioExtraHeight = _b.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _b.lockAspectRatioExtraWidth;\n    var newWidth = original.width;\n    var newHeight = original.height;\n    var extraHeight = lockAspectRatioExtraHeight || 0;\n    var extraWidth = lockAspectRatioExtraWidth || 0;\n    if (hasDirection(\"right\", direction)) {\n      newWidth = original.width + (clientX - original.x) * resizeRatio / scale;\n      if (lockAspectRatio) {\n        newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;\n      }\n    }\n    if (hasDirection(\"left\", direction)) {\n      newWidth = original.width - (clientX - original.x) * resizeRatio / scale;\n      if (lockAspectRatio) {\n        newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;\n      }\n    }\n    if (hasDirection(\"bottom\", direction)) {\n      newHeight = original.height + (clientY - original.y) * resizeRatio / scale;\n      if (lockAspectRatio) {\n        newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;\n      }\n    }\n    if (hasDirection(\"top\", direction)) {\n      newHeight = original.height - (clientY - original.y) * resizeRatio / scale;\n      if (lockAspectRatio) {\n        newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;\n      }\n    }\n    return { newWidth, newHeight };\n  };\n  Resizable2.prototype.calculateNewSizeFromAspectRatio = function(newWidth, newHeight, max3, min3) {\n    var _a = this.props, lockAspectRatio = _a.lockAspectRatio, lockAspectRatioExtraHeight = _a.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _a.lockAspectRatioExtraWidth;\n    var computedMinWidth = typeof min3.width === \"undefined\" ? 10 : min3.width;\n    var computedMaxWidth = typeof max3.width === \"undefined\" || max3.width < 0 ? newWidth : max3.width;\n    var computedMinHeight = typeof min3.height === \"undefined\" ? 10 : min3.height;\n    var computedMaxHeight = typeof max3.height === \"undefined\" || max3.height < 0 ? newHeight : max3.height;\n    var extraHeight = lockAspectRatioExtraHeight || 0;\n    var extraWidth = lockAspectRatioExtraWidth || 0;\n    if (lockAspectRatio) {\n      var extraMinWidth = (computedMinHeight - extraHeight) * this.ratio + extraWidth;\n      var extraMaxWidth = (computedMaxHeight - extraHeight) * this.ratio + extraWidth;\n      var extraMinHeight = (computedMinWidth - extraWidth) / this.ratio + extraHeight;\n      var extraMaxHeight = (computedMaxWidth - extraWidth) / this.ratio + extraHeight;\n      var lockedMinWidth = Math.max(computedMinWidth, extraMinWidth);\n      var lockedMaxWidth = Math.min(computedMaxWidth, extraMaxWidth);\n      var lockedMinHeight = Math.max(computedMinHeight, extraMinHeight);\n      var lockedMaxHeight = Math.min(computedMaxHeight, extraMaxHeight);\n      newWidth = clamp(newWidth, lockedMinWidth, lockedMaxWidth);\n      newHeight = clamp(newHeight, lockedMinHeight, lockedMaxHeight);\n    } else {\n      newWidth = clamp(newWidth, computedMinWidth, computedMaxWidth);\n      newHeight = clamp(newHeight, computedMinHeight, computedMaxHeight);\n    }\n    return { newWidth, newHeight };\n  };\n  Resizable2.prototype.setBoundingClientRect = function() {\n    if (this.props.bounds === \"parent\") {\n      var parent_2 = this.parentNode;\n      if (parent_2) {\n        var parentRect = parent_2.getBoundingClientRect();\n        this.parentLeft = parentRect.left;\n        this.parentTop = parentRect.top;\n      }\n    }\n    if (this.props.bounds && typeof this.props.bounds !== \"string\") {\n      var targetRect = this.props.bounds.getBoundingClientRect();\n      this.targetLeft = targetRect.left;\n      this.targetTop = targetRect.top;\n    }\n    if (this.resizable) {\n      var _a = this.resizable.getBoundingClientRect(), left2 = _a.left, top_1 = _a.top, right2 = _a.right, bottom2 = _a.bottom;\n      this.resizableLeft = left2;\n      this.resizableRight = right2;\n      this.resizableTop = top_1;\n      this.resizableBottom = bottom2;\n    }\n  };\n  Resizable2.prototype.onResizeStart = function(event, direction) {\n    if (!this.resizable || !this.window) {\n      return;\n    }\n    var clientX = 0;\n    var clientY = 0;\n    if (event.nativeEvent && isMouseEvent2(event.nativeEvent)) {\n      clientX = event.nativeEvent.clientX;\n      clientY = event.nativeEvent.clientY;\n    } else if (event.nativeEvent && isTouchEvent(event.nativeEvent)) {\n      clientX = event.nativeEvent.touches[0].clientX;\n      clientY = event.nativeEvent.touches[0].clientY;\n    }\n    if (this.props.onResizeStart) {\n      if (this.resizable) {\n        var startResize = this.props.onResizeStart(event, direction, this.resizable);\n        if (startResize === false) {\n          return;\n        }\n      }\n    }\n    if (this.props.size) {\n      if (typeof this.props.size.height !== \"undefined\" && this.props.size.height !== this.state.height) {\n        this.setState({ height: this.props.size.height });\n      }\n      if (typeof this.props.size.width !== \"undefined\" && this.props.size.width !== this.state.width) {\n        this.setState({ width: this.props.size.width });\n      }\n    }\n    this.ratio = typeof this.props.lockAspectRatio === \"number\" ? this.props.lockAspectRatio : this.size.width / this.size.height;\n    var flexBasis;\n    var computedStyle = this.window.getComputedStyle(this.resizable);\n    if (computedStyle.flexBasis !== \"auto\") {\n      var parent_3 = this.parentNode;\n      if (parent_3) {\n        var dir = this.window.getComputedStyle(parent_3).flexDirection;\n        this.flexDir = dir.startsWith(\"row\") ? \"row\" : \"column\";\n        flexBasis = computedStyle.flexBasis;\n      }\n    }\n    this.setBoundingClientRect();\n    this.bindEvents();\n    var state = {\n      original: {\n        x: clientX,\n        y: clientY,\n        width: this.size.width,\n        height: this.size.height\n      },\n      isResizing: true,\n      backgroundStyle: __assign3(__assign3({}, this.state.backgroundStyle), { cursor: this.window.getComputedStyle(event.target).cursor || \"auto\" }),\n      direction,\n      flexBasis\n    };\n    this.setState(state);\n  };\n  Resizable2.prototype.onMouseMove = function(event) {\n    var _this = this;\n    if (!this.state.isResizing || !this.resizable || !this.window) {\n      return;\n    }\n    if (this.window.TouchEvent && isTouchEvent(event)) {\n      try {\n        event.preventDefault();\n        event.stopPropagation();\n      } catch (e4) {\n      }\n    }\n    var _a = this.props, maxWidth = _a.maxWidth, maxHeight = _a.maxHeight, minWidth = _a.minWidth, minHeight = _a.minHeight;\n    var clientX = isTouchEvent(event) ? event.touches[0].clientX : event.clientX;\n    var clientY = isTouchEvent(event) ? event.touches[0].clientY : event.clientY;\n    var _b = this.state, direction = _b.direction, original = _b.original, width = _b.width, height = _b.height;\n    var parentSize = this.getParentSize();\n    var max3 = calculateNewMax(parentSize, this.window.innerWidth, this.window.innerHeight, maxWidth, maxHeight, minWidth, minHeight);\n    maxWidth = max3.maxWidth;\n    maxHeight = max3.maxHeight;\n    minWidth = max3.minWidth;\n    minHeight = max3.minHeight;\n    var _c = this.calculateNewSizeFromDirection(clientX, clientY), newHeight = _c.newHeight, newWidth = _c.newWidth;\n    var boundaryMax = this.calculateNewMaxFromBoundary(maxWidth, maxHeight);\n    if (this.props.snap && this.props.snap.x) {\n      newWidth = findClosestSnap(newWidth, this.props.snap.x, this.props.snapGap);\n    }\n    if (this.props.snap && this.props.snap.y) {\n      newHeight = findClosestSnap(newHeight, this.props.snap.y, this.props.snapGap);\n    }\n    var newSize = this.calculateNewSizeFromAspectRatio(newWidth, newHeight, { width: boundaryMax.maxWidth, height: boundaryMax.maxHeight }, { width: minWidth, height: minHeight });\n    newWidth = newSize.newWidth;\n    newHeight = newSize.newHeight;\n    if (this.props.grid) {\n      var newGridWidth = snap(newWidth, this.props.grid[0]);\n      var newGridHeight = snap(newHeight, this.props.grid[1]);\n      var gap = this.props.snapGap || 0;\n      newWidth = gap === 0 || Math.abs(newGridWidth - newWidth) <= gap ? newGridWidth : newWidth;\n      newHeight = gap === 0 || Math.abs(newGridHeight - newHeight) <= gap ? newGridHeight : newHeight;\n    }\n    var delta = {\n      width: newWidth - original.width,\n      height: newHeight - original.height\n    };\n    if (width && typeof width === \"string\") {\n      if (width.endsWith(\"%\")) {\n        var percent = newWidth / parentSize.width * 100;\n        newWidth = percent + \"%\";\n      } else if (width.endsWith(\"vw\")) {\n        var vw = newWidth / this.window.innerWidth * 100;\n        newWidth = vw + \"vw\";\n      } else if (width.endsWith(\"vh\")) {\n        var vh = newWidth / this.window.innerHeight * 100;\n        newWidth = vh + \"vh\";\n      }\n    }\n    if (height && typeof height === \"string\") {\n      if (height.endsWith(\"%\")) {\n        var percent = newHeight / parentSize.height * 100;\n        newHeight = percent + \"%\";\n      } else if (height.endsWith(\"vw\")) {\n        var vw = newHeight / this.window.innerWidth * 100;\n        newHeight = vw + \"vw\";\n      } else if (height.endsWith(\"vh\")) {\n        var vh = newHeight / this.window.innerHeight * 100;\n        newHeight = vh + \"vh\";\n      }\n    }\n    var newState = {\n      width: this.createSizeForCssProperty(newWidth, \"width\"),\n      height: this.createSizeForCssProperty(newHeight, \"height\")\n    };\n    if (this.flexDir === \"row\") {\n      newState.flexBasis = newState.width;\n    } else if (this.flexDir === \"column\") {\n      newState.flexBasis = newState.height;\n    }\n    (0, import_react_dom6.flushSync)(function() {\n      _this.setState(newState);\n    });\n    if (this.props.onResize) {\n      this.props.onResize(event, direction, this.resizable, delta);\n    }\n  };\n  Resizable2.prototype.onMouseUp = function(event) {\n    var _a = this.state, isResizing = _a.isResizing, direction = _a.direction, original = _a.original;\n    if (!isResizing || !this.resizable) {\n      return;\n    }\n    var delta = {\n      width: this.size.width - original.width,\n      height: this.size.height - original.height\n    };\n    if (this.props.onResizeStop) {\n      this.props.onResizeStop(event, direction, this.resizable, delta);\n    }\n    if (this.props.size) {\n      this.setState(this.props.size);\n    }\n    this.unbindEvents();\n    this.setState({\n      isResizing: false,\n      backgroundStyle: __assign3(__assign3({}, this.state.backgroundStyle), { cursor: \"auto\" })\n    });\n  };\n  Resizable2.prototype.updateSize = function(size) {\n    this.setState({ width: size.width, height: size.height });\n  };\n  Resizable2.prototype.renderResizer = function() {\n    var _this = this;\n    var _a = this.props, enable = _a.enable, handleStyles = _a.handleStyles, handleClasses = _a.handleClasses, handleWrapperStyle = _a.handleWrapperStyle, handleWrapperClass = _a.handleWrapperClass, handleComponent = _a.handleComponent;\n    if (!enable) {\n      return null;\n    }\n    var resizers = Object.keys(enable).map(function(dir) {\n      if (enable[dir] !== false) {\n        return React44.createElement(Resizer, { key: dir, direction: dir, onResizeStart: _this.onResizeStart, replaceStyles: handleStyles && handleStyles[dir], className: handleClasses && handleClasses[dir] }, handleComponent && handleComponent[dir] ? handleComponent[dir] : null);\n      }\n      return null;\n    });\n    return React44.createElement(\"div\", { className: handleWrapperClass, style: handleWrapperStyle }, resizers);\n  };\n  Resizable2.prototype.render = function() {\n    var _this = this;\n    var extendsProps = Object.keys(this.props).reduce(function(acc, key) {\n      if (definedProps.indexOf(key) !== -1) {\n        return acc;\n      }\n      acc[key] = _this.props[key];\n      return acc;\n    }, {});\n    var style = __assign3(__assign3(__assign3({ position: \"relative\", userSelect: this.state.isResizing ? \"none\" : \"auto\" }, this.props.style), this.sizeStyle), { maxWidth: this.props.maxWidth, maxHeight: this.props.maxHeight, minWidth: this.props.minWidth, minHeight: this.props.minHeight, boxSizing: \"border-box\", flexShrink: 0 });\n    if (this.state.flexBasis) {\n      style.flexBasis = this.state.flexBasis;\n    }\n    var Wrapper = this.props.as || \"div\";\n    return React44.createElement(\n      Wrapper,\n      __assign3({ ref: this.ref, style, className: this.props.className }, extendsProps),\n      this.state.isResizing && React44.createElement(\"div\", { style: this.state.backgroundStyle }),\n      this.props.children,\n      this.renderResizer()\n    );\n  };\n  Resizable2.defaultProps = {\n    as: \"div\",\n    onResizeStart: function() {\n    },\n    onResize: function() {\n    },\n    onResizeStop: function() {\n    },\n    enable: {\n      top: true,\n      right: true,\n      bottom: true,\n      left: true,\n      topRight: true,\n      bottomRight: true,\n      bottomLeft: true,\n      topLeft: true\n    },\n    style: {},\n    grid: [1, 1],\n    lockAspectRatio: false,\n    lockAspectRatioExtraWidth: 0,\n    lockAspectRatioExtraHeight: 0,\n    scale: 1,\n    resizeRatio: 1,\n    snapGap: 0\n  };\n  return Resizable2;\n}(React44.PureComponent);\n\n// node_modules/@udecode/plate-ui-table/dist/index.es.js\nvar {\n  tableStore,\n  useTableStore\n} = createAtomStore({\n  hoveredColIndex: null,\n  resizingCol: null,\n  selectedCells: null\n}, {\n  name: \"table\",\n  scope: ELEMENT_TABLE\n});\nvar getTableCellElementStyles = (props) => {\n  const {\n    hovered,\n    selected,\n    hideBorder,\n    readOnly\n  } = props;\n  return createStyles({\n    prefixClassNames: \"TableCellElement\",\n    ...props\n  }, {\n    root: [{\n      \"position\": \"relative\",\n      \"padding\": \"0px\",\n      \"overflow\": \"visible\",\n      \"--tw-bg-opacity\": \"1\",\n      \"backgroundColor\": \"rgba(255, 255, 255, var(--tw-bg-opacity))\"\n    }, hideBorder ? {\n      \"borderStyle\": \"none\"\n    } : {\n      \"borderTopWidth\": \"1px\",\n      \"borderLeftWidth\": \"1px\",\n      \"borderBottomWidth\": \"0px\",\n      \"borderRightWidth\": \"0px\",\n      \"--tw-border-opacity\": \"1\",\n      \"borderColor\": \"rgba(209, 213, 219, var(--tw-border-opacity))\"\n    }, selected && {\n      \"borderWidth\": \"1px\",\n      \"--tw-border-opacity\": \"1\",\n      \"borderColor\": \"rgba(59, 130, 246, var(--tw-border-opacity))\"\n    }, (0, import_styled_components11.css)([\"min-width:48px;\"])],\n    content: {\n      \"position\": \"relative\",\n      \"paddingLeft\": \"0.75rem\",\n      \"paddingRight\": \"0.75rem\",\n      \"paddingTop\": \"0.5rem\",\n      \"paddingBottom\": \"0.5rem\",\n      \"zIndex\": \"10\",\n      \"height\": \"100%\",\n      \"boxSizing\": \"border-box\"\n    },\n    resizableWrapper: [{\n      \"position\": \"absolute\",\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"top\": \"0px\"\n    }, selected && {\n      \"display\": \"none\"\n    }],\n    selectedCell: [!selected && {\n      \"display\": \"none\"\n    }, {\n      \"position\": \"absolute\",\n      \"top\": \"0px\",\n      \"left\": \"0px\",\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"pointerEvents\": \"none\"\n    }, selected && (0, import_styled_components11.css)([\"z-index:12;background-color:rgb(179,212,255);opacity:0.3;\"])],\n    handle: [{\n      \"position\": \"absolute\"\n    }, !readOnly && hovered && {\n      \"--tw-bg-opacity\": \"1\",\n      \"backgroundColor\": \"rgba(59, 130, 246, var(--tw-bg-opacity))\"\n    }, (0, import_styled_components11.css)([\"top:-12px;right:-2px;width:4px;height:calc(100% + 12px);z-index:10;\"])]\n  });\n};\nfunction _extends9() {\n  _extends9 = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i5 = 1; i5 < arguments.length; i5++) {\n      var source = arguments[i5];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends9.apply(this, arguments);\n}\nfunction toVal3(mix) {\n  var k3, y5, str = \"\";\n  if (typeof mix === \"string\" || typeof mix === \"number\") {\n    str += mix;\n  } else if (typeof mix === \"object\") {\n    if (Array.isArray(mix)) {\n      for (k3 = 0; k3 < mix.length; k3++) {\n        if (mix[k3]) {\n          if (y5 = toVal3(mix[k3])) {\n            str && (str += \" \");\n            str += y5;\n          }\n        }\n      }\n    } else {\n      for (k3 in mix) {\n        if (mix[k3]) {\n          str && (str += \" \");\n          str += k3;\n        }\n      }\n    }\n  }\n  return str;\n}\nfunction clsx4() {\n  var i5 = 0, tmp, x4, str = \"\";\n  while (i5 < arguments.length) {\n    if (tmp = arguments[i5++]) {\n      if (x4 = toVal3(tmp)) {\n        str && (str += \" \");\n        str += x4;\n      }\n    }\n  }\n  return str;\n}\nvar useIsCellSelected = (element4) => {\n  const selectedCells = useTableStore().get.selectedCells();\n  return (0, import_react51.useMemo)(() => selectedCells === null || selectedCells === void 0 ? void 0 : selectedCells.includes(element4), [element4, selectedCells]);\n};\nvar TableCellElement = (props) => {\n  const {\n    attributes,\n    children,\n    nodeProps,\n    element: element4,\n    resizableProps,\n    editor,\n    ignoreReadOnly = false\n  } = props;\n  const rootProps = getRootProps(props);\n  const readOnly = useReadOnly();\n  const [hoveredColIndex, setHoveredColIndex] = useTableStore().use.hoveredColIndex();\n  const setResizingCol = useTableStore().set.resizingCol();\n  const isCellSelected = useIsCellSelected(element4);\n  const handleResize = ignoreReadOnly || !readOnly ? {\n    right: {\n      top: -12,\n      height: \"calc(100% + 12px)\",\n      zIndex: 20\n    }\n  } : void 0;\n  const colIndex = (0, import_react51.useMemo)(() => getTableColumnIndex(editor, {\n    node: element4\n  }), [editor, element4]);\n  const {\n    root: root5,\n    content,\n    resizableWrapper,\n    resizable,\n    selectedCell,\n    handle\n  } = getTableCellElementStyles({\n    ...props,\n    selected: isCellSelected,\n    hovered: hoveredColIndex === colIndex,\n    readOnly: !ignoreReadOnly && readOnly\n  });\n  const onResize = (e4, direction, ref) => {\n    setResizingCol({\n      index: colIndex,\n      width: ref.offsetWidth\n    });\n  };\n  const onResizeStop = (e4, direction, ref) => {\n    setTableColSize(editor, {\n      colIndex,\n      width: ref.offsetWidth\n    }, {\n      at: findNodePath(editor, element4)\n    });\n    setResizingCol(null);\n  };\n  return /* @__PURE__ */ import_react51.default.createElement(_StyledTd, _extends9({}, attributes, {\n    className: root5.className\n  }, rootProps, nodeProps, {\n    $_css: root5.css\n  }), /* @__PURE__ */ import_react51.default.createElement(_StyledDiv9, {\n    className: content === null || content === void 0 ? void 0 : content.className,\n    $_css2: content === null || content === void 0 ? void 0 : content.css\n  }, children), /* @__PURE__ */ import_react51.default.createElement(_StyledDiv24, {\n    className: clsx4(resizableWrapper === null || resizableWrapper === void 0 ? void 0 : resizableWrapper.className, \"group\"),\n    contentEditable: false,\n    onMouseOver: () => setHoveredColIndex(colIndex),\n    onFocus: () => setHoveredColIndex(colIndex),\n    onMouseOut: () => setHoveredColIndex(null),\n    onBlur: () => setHoveredColIndex(null),\n    $_css3: resizableWrapper === null || resizableWrapper === void 0 ? void 0 : resizableWrapper.css\n  }, /* @__PURE__ */ import_react51.default.createElement(_StyledResizable, _extends9({\n    className: resizable === null || resizable === void 0 ? void 0 : resizable.className,\n    size: {\n      width: \"100%\",\n      height: \"100%\"\n    },\n    enable: {\n      right: ignoreReadOnly || !readOnly\n    },\n    handleStyles: handleResize,\n    onResize,\n    onResizeStop\n  }, resizableProps, {\n    $_css4: resizable === null || resizable === void 0 ? void 0 : resizable.css\n  })), /* @__PURE__ */ import_react51.default.createElement(_StyledDiv32, {\n    className: handle === null || handle === void 0 ? void 0 : handle.className,\n    $_css5: handle === null || handle === void 0 ? void 0 : handle.css\n  })), /* @__PURE__ */ import_react51.default.createElement(_StyledDiv42, {\n    className: selectedCell === null || selectedCell === void 0 ? void 0 : selectedCell.className,\n    contentEditable: false,\n    $_css6: selectedCell === null || selectedCell === void 0 ? void 0 : selectedCell.css\n  }));\n};\nvar _StyledTd = (0, import_styled_components11.default)(\"td\").withConfig({\n  displayName: \"TableCellElement___StyledTd\",\n  componentId: \"sc-r69en2-0\"\n})([\"\", \"\"], (p6) => p6.$_css);\nvar _StyledDiv9 = (0, import_styled_components11.default)(\"div\").withConfig({\n  displayName: \"TableCellElement___StyledDiv\",\n  componentId: \"sc-r69en2-1\"\n})([\"\", \"\"], (p6) => p6.$_css2);\nvar _StyledDiv24 = (0, import_styled_components11.default)(\"div\").withConfig({\n  displayName: \"TableCellElement___StyledDiv2\",\n  componentId: \"sc-r69en2-2\"\n})([\"\", \"\"], (p6) => p6.$_css3);\nvar _StyledResizable = (0, import_styled_components11.default)(Resizable).withConfig({\n  displayName: \"TableCellElement___StyledResizable\",\n  componentId: \"sc-r69en2-3\"\n})([\"\", \"\"], (p6) => p6.$_css4);\nvar _StyledDiv32 = (0, import_styled_components11.default)(\"div\").withConfig({\n  displayName: \"TableCellElement___StyledDiv3\",\n  componentId: \"sc-r69en2-4\"\n})([\"\", \"\"], (p6) => p6.$_css5);\nvar _StyledDiv42 = (0, import_styled_components11.default)(\"div\").withConfig({\n  displayName: \"TableCellElement___StyledDiv4\",\n  componentId: \"sc-r69en2-5\"\n})([\"\", \"\"], (p6) => p6.$_css6);\nvar getTableElementStyles = (props) => createStyles({\n  prefixClassNames: \"TableElement\",\n  ...props\n}, {\n  root: [{\n    \"display\": \"table\",\n    \"tableLayout\": \"fixed\",\n    \"height\": \"1px\",\n    \"width\": \"100%\",\n    \"marginTop\": \"1rem\",\n    \"marginBottom\": \"1rem\",\n    \"marginLeft\": \"0px\",\n    \"marginRight\": \"0px\",\n    \"borderCollapse\": \"collapse\",\n    \"borderWidth\": \"1px\",\n    \"borderStyle\": \"solid\",\n    \"--tw-border-opacity\": \"1\",\n    \"borderColor\": \"rgba(209, 213, 219, var(--tw-border-opacity))\"\n  }, props.isSelectingCell && (0, import_styled_components11.css)([\"*::selection{background:none;}\"])],\n  tbody: {\n    \"minWidth\": \"100%\"\n  }\n});\nvar useSelectedCells = () => {\n  const readOnly = useReadOnly();\n  const selected = useSelected();\n  const editor = useEditorRef();\n  const [selectedCells, setSelectedCells] = useTableStore().use.selectedCells();\n  (0, import_react51.useEffect)(() => {\n    if (!selected || readOnly)\n      setSelectedCells(null);\n  }, [selected, editor, setSelectedCells, readOnly]);\n  (0, import_react51.useEffect)(() => {\n    if (readOnly)\n      return;\n    const cellEntries = getTableGridAbove(editor, {\n      format: \"cell\"\n    });\n    if (cellEntries.length > 1) {\n      const cells = cellEntries.map((entry) => entry[0]);\n      if (JSON.stringify(cells) !== JSON.stringify(selectedCells)) {\n        setSelectedCells(cells);\n      }\n    } else if (selectedCells) {\n      setSelectedCells(null);\n    }\n  }, [editor, editor.selection, readOnly, selectedCells, setSelectedCells]);\n};\nvar useTableColSizes = (tableNode) => {\n  const resizingCol = useTableStore().get.resizingCol();\n  const colCount = getTableColumnCount(tableNode);\n  const colSizes = tableNode.colSizes ? [...tableNode.colSizes] : Array(colCount);\n  if (resizingCol) {\n    var _resizingCol$index;\n    colSizes[(_resizingCol$index = resizingCol.index) !== null && _resizingCol$index !== void 0 ? _resizingCol$index : 0] = resizingCol.width;\n  }\n  return colSizes;\n};\nvar TablePopover = ({\n  children,\n  ...props\n}) => {\n  const element4 = useElement();\n  return /* @__PURE__ */ import_react51.default.createElement(_StyledElementPopover, _extends9({\n    content: /* @__PURE__ */ import_react51.default.createElement(_StyledRemoveNodeButton, {\n      element: element4,\n      contentEditable: false\n    })\n  }, props), children);\n};\nvar _StyledRemoveNodeButton = (0, import_styled_components11.default)(RemoveNodeButton).withConfig({\n  displayName: \"TablePopover___StyledRemoveNodeButton\",\n  componentId: \"sc-egd6av-0\"\n})([\"\", \"\"], floatingButtonCss);\nvar _StyledElementPopover = (0, import_styled_components11.default)(ElementPopover).withConfig({\n  displayName: \"TablePopover___StyledElementPopover\",\n  componentId: \"sc-egd6av-1\"\n})([\"\", \"\"], floatingRootCss);\nvar TableElement = ({\n  transformColSizes,\n  popoverProps,\n  ...props\n}) => {\n  const {\n    attributes,\n    children,\n    nodeProps,\n    element: element4\n  } = props;\n  const rootProps = getRootProps(props);\n  const selectedCells = useTableStore().get.selectedCells();\n  const {\n    root: root5,\n    tbody: tbody3\n  } = getTableElementStyles({\n    ...props,\n    isSelectingCell: !!selectedCells\n  });\n  let colSizes = useTableColSizes(element4);\n  if (transformColSizes) {\n    colSizes = transformColSizes(colSizes);\n  }\n  useSelectedCells();\n  return /* @__PURE__ */ import_react51.default.createElement(_StyledTable, _extends9({}, attributes, {\n    className: root5.className\n  }, rootProps, nodeProps, {\n    $_css: root5.css\n  }), /* @__PURE__ */ import_react51.default.createElement(\"colgroup\", {\n    contentEditable: false\n  }, colSizes.map((width, index5) => /* @__PURE__ */ import_react51.default.createElement(\"col\", {\n    key: index5,\n    style: width ? {\n      width\n    } : void 0\n  }))), /* @__PURE__ */ import_react51.default.createElement(TablePopover, popoverProps, /* @__PURE__ */ import_react51.default.createElement(_StyledTbody, {\n    className: tbody3 === null || tbody3 === void 0 ? void 0 : tbody3.className,\n    $_css2: tbody3 === null || tbody3 === void 0 ? void 0 : tbody3.css\n  }, children)));\n};\nvar _StyledTable = (0, import_styled_components11.default)(\"table\").withConfig({\n  displayName: \"TableElement___StyledTable\",\n  componentId: \"sc-1jga5yk-0\"\n})([\"\", \"\"], (p6) => p6.$_css);\nvar _StyledTbody = (0, import_styled_components11.default)(\"tbody\").withConfig({\n  displayName: \"TableElement___StyledTbody\",\n  componentId: \"sc-1jga5yk-1\"\n})([\"\", \"\"], (p6) => p6.$_css2);\nvar getTableRowElementStyles = (props) => createStyles({\n  prefixClassNames: \"TableRowElement\",\n  ...props\n}, {\n  root: [props.hideBorder && {\n    \"borderStyle\": \"none\"\n  }]\n});\nvar TableRowElement = (props) => {\n  const {\n    attributes,\n    children,\n    nodeProps\n  } = props;\n  const rootProps = getRootProps(props);\n  const {\n    root: root5\n  } = getTableRowElementStyles(props);\n  return /* @__PURE__ */ import_react51.default.createElement(_StyledTr, _extends9({}, attributes, {\n    className: root5.className\n  }, rootProps, nodeProps, {\n    $_css: root5.css\n  }), children);\n};\nvar _StyledTr = (0, import_styled_components11.default)(\"tr\").withConfig({\n  displayName: \"TableRowElement___StyledTr\",\n  componentId: \"sc-718caz-0\"\n})([\"\", \"\"], (p6) => p6.$_css);\nvar TableToolbarButton = withPlateEventProvider(({\n  id,\n  transform,\n  header,\n  ...props\n}) => {\n  id = useEventPlateId(id);\n  const editor = usePlateEditorState(id);\n  const type = getPluginType(editor, ELEMENT_TABLE);\n  return /* @__PURE__ */ import_react51.default.createElement(ToolbarButton, _extends9({\n    active: !!(editor !== null && editor !== void 0 && editor.selection) && someNode(editor, {\n      match: {\n        type\n      }\n    }),\n    onMouseDown: !!type && editor ? getPreventDefaultHandler(transform, editor, {\n      header\n    }) : void 0\n  }, props));\n});\n\n// src/editor/plugins/link/LinkToolbarButton.tsx\nvar import_react52 = __toESM(require(\"react\"));\n\n// src/editor/plugins/link/transforms/wrapLink.ts\nvar wrapLink2 = (editor, { at, url }) => {\n  wrapNodes(\n    editor,\n    {\n      type: getPluginType(editor, ELEMENT_LINK),\n      url,\n      children: [],\n      \"tw-type\": \"link\"\n    },\n    { at, split: true }\n  );\n};\n\n// src/editor/plugins/link/transforms/upsertLinkAtSelection.ts\nvar upsertLinkAtSelection = (editor, {\n  url,\n  wrap\n}) => {\n  if (!editor.selection)\n    return;\n  const type = getPluginType(editor, ELEMENT_LINK);\n  if (!wrap && isCollapsed(editor.selection)) {\n    return insertNodes(editor, {\n      type,\n      url,\n      children: [{ text: url }],\n      // we need to change this, so fork the code\n      \"tw-type\": \"link\"\n    });\n  }\n  if (wrap && isCollapsed(editor.selection)) {\n    const linkLeaf = getLeafNode(editor, editor.selection);\n    const [, inlinePath] = linkLeaf;\n    select(editor, inlinePath);\n  }\n  unwrapNodes(editor, { at: editor.selection, match: { type } });\n  wrapLink2(editor, { at: editor.selection, url });\n  collapseSelection(editor, { edge: \"end\" });\n};\n\n// src/editor/plugins/link/transforms/getAndUpsertLink.ts\nvar getAndUpsertLink = async (editor, getLinkUrl) => {\n  const type = getPluginType(editor, ELEMENT_LINK);\n  let previousUrl = \"\";\n  const selectedText = editor.selection === null ? \"\" : Editor.string(editor, editor.selection);\n  const linkNode = getAboveNode(editor, {\n    match: { type }\n  });\n  if (linkNode !== void 0) {\n    previousUrl = linkNode[0].url;\n  }\n  let url = null;\n  if (getLinkUrl !== void 0) {\n    url = await getLinkUrl(previousUrl);\n  } else {\n    url = window.prompt(`Enter the URL of the link:`, previousUrl || selectedText);\n  }\n  if (url === null)\n    return;\n  if (url === \"\" && editor.selection !== void 0 && editor.selection !== null) {\n    return unwrapNodes(editor, {\n      at: editor.selection,\n      match: { type: getPluginType(editor, ELEMENT_LINK) }\n    });\n  }\n  const shouldWrap = linkNode !== void 0 && isCollapsed(editor.selection);\n  upsertLinkAtSelection(editor, { url, wrap: shouldWrap });\n};\n\n// src/editor/plugins/link/LinkToolbarButton.tsx\nvar LinkToolbarButton = withPlateEventProvider(({ id, getLinkUrl, ...props }) => {\n  id = useEventPlateId(id);\n  const editor = usePlateEditorState(id);\n  const type = getPluginType(editor, ELEMENT_LINK);\n  const isLink = !(editor?.selection === void 0) && someNode(editor, { match: { type } });\n  return /* @__PURE__ */ import_react52.default.createElement(\n    ToolbarButton,\n    {\n      active: isLink,\n      onMouseDown: (event) => {\n        if (!editor)\n          return;\n        event.preventDefault();\n        void getAndUpsertLink(editor, getLinkUrl);\n      },\n      ...props\n    }\n  );\n});\n\n// node_modules/@styled-icons/material/BorderAll/BorderAll.esm.js\nvar React47 = __toESM(require(\"react\"));\nvar BorderAll = /* @__PURE__ */ React47.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React47.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React47.createElement(\"path\", {\n    d: \"M3 3v18h18V3H3zm8 16H5v-6h6v6zm0-8H5V5h6v6zm8 8h-6v-6h6v6zm0-8h-6V5h6v6z\"\n  }));\n});\nBorderAll.displayName = \"BorderAll\";\n\n// node_modules/@styled-icons/material/BorderClear/BorderClear.esm.js\nvar React48 = __toESM(require(\"react\"));\nvar BorderClear = /* @__PURE__ */ React48.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React48.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React48.createElement(\"path\", {\n    d: \"M7 5h2V3H7v2zm0 8h2v-2H7v2zm0 8h2v-2H7v2zm4-4h2v-2h-2v2zm0 4h2v-2h-2v2zm-8 0h2v-2H3v2zm0-4h2v-2H3v2zm0-4h2v-2H3v2zm0-4h2V7H3v2zm0-4h2V3H3v2zm8 8h2v-2h-2v2zm8 4h2v-2h-2v2zm0-4h2v-2h-2v2zm0 8h2v-2h-2v2zm0-12h2V7h-2v2zm-8 0h2V7h-2v2zm8-6v2h2V3h-2zm-8 2h2V3h-2v2zm4 16h2v-2h-2v2zm0-8h2v-2h-2v2zm0-8h2V3h-2v2z\"\n  }));\n});\nBorderClear.displayName = \"BorderClear\";\n\n// node_modules/@styled-icons/material/BorderBottom/BorderBottom.esm.js\nvar React49 = __toESM(require(\"react\"));\nvar BorderBottom = /* @__PURE__ */ React49.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React49.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React49.createElement(\"path\", {\n    d: \"M9 11H7v2h2v-2zm4 4h-2v2h2v-2zM9 3H7v2h2V3zm4 8h-2v2h2v-2zM5 3H3v2h2V3zm8 4h-2v2h2V7zm4 4h-2v2h2v-2zm-4-8h-2v2h2V3zm4 0h-2v2h2V3zm2 10h2v-2h-2v2zm0 4h2v-2h-2v2zM5 7H3v2h2V7zm14-4v2h2V3h-2zm0 6h2V7h-2v2zM5 11H3v2h2v-2zM3 21h18v-2H3v2zm2-6H3v2h2v-2z\"\n  }));\n});\nBorderBottom.displayName = \"BorderBottom\";\n\n// node_modules/@styled-icons/material/BorderTop/BorderTop.esm.js\nvar React50 = __toESM(require(\"react\"));\nvar BorderTop = /* @__PURE__ */ React50.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React50.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React50.createElement(\"path\", {\n    d: \"M7 21h2v-2H7v2zm0-8h2v-2H7v2zm4 0h2v-2h-2v2zm0 8h2v-2h-2v2zm-8-4h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2v-2H3v2zm0-4h2V7H3v2zm8 8h2v-2h-2v2zm8-8h2V7h-2v2zm0 4h2v-2h-2v2zM3 3v2h18V3H3zm16 14h2v-2h-2v2zm-4 4h2v-2h-2v2zM11 9h2V7h-2v2zm8 12h2v-2h-2v2zm-4-8h2v-2h-2v2z\"\n  }));\n});\nBorderTop.displayName = \"BorderTop\";\n\n// node_modules/@styled-icons/material/BorderLeft/BorderLeft.esm.js\nvar React51 = __toESM(require(\"react\"));\nvar BorderLeft = /* @__PURE__ */ React51.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React51.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React51.createElement(\"path\", {\n    d: \"M11 21h2v-2h-2v2zm0-4h2v-2h-2v2zm0-12h2V3h-2v2zm0 4h2V7h-2v2zm0 4h2v-2h-2v2zm-4 8h2v-2H7v2zM7 5h2V3H7v2zm0 8h2v-2H7v2zm-4 8h2V3H3v18zM19 9h2V7h-2v2zm-4 12h2v-2h-2v2zm4-4h2v-2h-2v2zm0-14v2h2V3h-2zm0 10h2v-2h-2v2zm0 8h2v-2h-2v2zm-4-8h2v-2h-2v2zm0-8h2V3h-2v2z\"\n  }));\n});\nBorderLeft.displayName = \"BorderLeft\";\n\n// node_modules/@styled-icons/material/BorderRight/BorderRight.esm.js\nvar React52 = __toESM(require(\"react\"));\nvar BorderRight = /* @__PURE__ */ React52.forwardRef(function(props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /* @__PURE__ */ React52.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 24 24\"\n  }, props, {\n    ref\n  }), /* @__PURE__ */ React52.createElement(\"path\", {\n    d: \"M7 21h2v-2H7v2zM3 5h2V3H3v2zm4 0h2V3H7v2zm0 8h2v-2H7v2zm-4 8h2v-2H3v2zm8 0h2v-2h-2v2zm-8-8h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm8 8h2v-2h-2v2zm4-4h2v-2h-2v2zm4-10v18h2V3h-2zm-4 18h2v-2h-2v2zm0-16h2V3h-2v2zm-4 8h2v-2h-2v2zm0-8h2V3h-2v2zm0 4h2V7h-2v2z\"\n  }));\n});\nBorderRight.displayName = \"BorderRight\";\n\n// src/editor/components/Toolbars.tsx\nvar tooltipStyle = {\n  arrow: true,\n  delay: 0,\n  duration: [200, 0],\n  hideOnClick: false,\n  offset: [0, 17],\n  placement: \"top\"\n};\nvar BasicElementToolbarButtons = () => {\n  const editor = usePlateEditorRef();\n  return /* @__PURE__ */ import_react53.default.createElement(import_react53.default.Fragment, null, /* @__PURE__ */ import_react53.default.createElement(BlockToolbarButton, { type: getPluginType(editor, ELEMENT_H1), icon: /* @__PURE__ */ import_react53.default.createElement(LooksOne, null), tooltip: { content: \"H1 (Ctrl+1) (! )\", ...tooltipStyle } }), /* @__PURE__ */ import_react53.default.createElement(BlockToolbarButton, { type: getPluginType(editor, ELEMENT_H2), icon: /* @__PURE__ */ import_react53.default.createElement(LooksTwo, null), tooltip: { content: \"H2 (Ctrl+2) (!! )\", ...tooltipStyle } }), /* @__PURE__ */ import_react53.default.createElement(BlockToolbarButton, { type: getPluginType(editor, ELEMENT_H3), icon: /* @__PURE__ */ import_react53.default.createElement(Looks3, null), tooltip: { content: \"H3 (Ctrl+3) (!!! )\", ...tooltipStyle } }), /* @__PURE__ */ import_react53.default.createElement(BlockToolbarButton, { type: getPluginType(editor, ELEMENT_H4), icon: /* @__PURE__ */ import_react53.default.createElement(Looks4, null), tooltip: { content: \"H4 (Ctrl+4) (!!!! )\", ...tooltipStyle } }), /* @__PURE__ */ import_react53.default.createElement(BlockToolbarButton, { type: getPluginType(editor, ELEMENT_H5), icon: /* @__PURE__ */ import_react53.default.createElement(Looks5, null), tooltip: { content: \"H5 (Ctrl+5) (!!!!! )\", ...tooltipStyle } }), /* @__PURE__ */ import_react53.default.createElement(BlockToolbarButton, { type: getPluginType(editor, ELEMENT_H6), icon: /* @__PURE__ */ import_react53.default.createElement(Looks6, null), tooltip: { content: \"H6 (Ctrl+6) (!!!!!! )\", ...tooltipStyle } }), /* @__PURE__ */ import_react53.default.createElement(\n    BlockToolbarButton,\n    {\n      type: getPluginType(editor, ELEMENT_BLOCKQUOTE),\n      icon: /* @__PURE__ */ import_react53.default.createElement(FormatQuote, null),\n      tooltip: { content: \"Quote (Ctrl+E) (> )\", ...tooltipStyle }\n    }\n  ), /* @__PURE__ */ import_react53.default.createElement(BlockToolbarButton, { type: getPluginType(editor, ELEMENT_CODE_BLOCK), icon: /* @__PURE__ */ import_react53.default.createElement(CodeBlock, null), tooltip: { content: \"Code (Ctrl+K) (```)\", ...tooltipStyle } }), /* @__PURE__ */ import_react53.default.createElement(LinkToolbarButton, { icon: /* @__PURE__ */ import_react53.default.createElement(Link2, null), tooltip: { content: \"Link to (Ctrl+L) ([[)\", ...tooltipStyle } }), /* @__PURE__ */ import_react53.default.createElement(\n    LinkToolbarButton,\n    {\n      icon: /* @__PURE__ */ import_react53.default.createElement(Bracket, null),\n      getLinkUrl: (previousUrl) => editor.selection === null ? previousUrl ?? \"\" : Editor.string(editor, editor.selection),\n      tooltip: { content: \"WikiLink ([[)\", ...tooltipStyle }\n    }\n  ), /* @__PURE__ */ import_react53.default.createElement(TableToolbarButtons, null));\n};\nvar TableToolbarButtons = () => /* @__PURE__ */ import_react53.default.createElement(import_react53.default.Fragment, null, /* @__PURE__ */ import_react53.default.createElement(TableToolbarButton, { icon: /* @__PURE__ */ import_react53.default.createElement(BorderAll, null), transform: insertTable }), /* @__PURE__ */ import_react53.default.createElement(TableToolbarButton, { icon: /* @__PURE__ */ import_react53.default.createElement(BorderClear, null), transform: deleteTable }), /* @__PURE__ */ import_react53.default.createElement(TableToolbarButton, { icon: /* @__PURE__ */ import_react53.default.createElement(BorderBottom, null), transform: insertTableRow }), /* @__PURE__ */ import_react53.default.createElement(TableToolbarButton, { icon: /* @__PURE__ */ import_react53.default.createElement(BorderTop, null), transform: deleteRow }), /* @__PURE__ */ import_react53.default.createElement(TableToolbarButton, { icon: /* @__PURE__ */ import_react53.default.createElement(BorderLeft, null), transform: insertTableColumn }), /* @__PURE__ */ import_react53.default.createElement(TableToolbarButton, { icon: /* @__PURE__ */ import_react53.default.createElement(BorderRight, null), transform: deleteColumn }));\nvar ListToolbarButtons = () => {\n  const editor = usePlateEditorRef();\n  return /* @__PURE__ */ import_react53.default.createElement(import_react53.default.Fragment, null, /* @__PURE__ */ import_react53.default.createElement(\n    ListToolbarButton,\n    {\n      type: getPluginType(editor, ELEMENT_UL),\n      icon: /* @__PURE__ */ import_react53.default.createElement(FormatListBulleted, null),\n      tooltip: { content: `UnorderedList (-) (*)`, ...tooltipStyle }\n    }\n  ), /* @__PURE__ */ import_react53.default.createElement(\n    ListToolbarButton,\n    {\n      type: getPluginType(editor, ELEMENT_OL),\n      icon: /* @__PURE__ */ import_react53.default.createElement(FormatListNumbered, null),\n      tooltip: { content: `OrderedList (#) (1.)`, ...tooltipStyle }\n    }\n  ));\n};\nvar BasicMarkToolbarButtons = () => {\n  const editor = usePlateEditorRef();\n  return /* @__PURE__ */ import_react53.default.createElement(import_react53.default.Fragment, null, /* @__PURE__ */ import_react53.default.createElement(MarkToolbarButton, { type: getPluginType(editor, MARK_BOLD), icon: /* @__PURE__ */ import_react53.default.createElement(FormatBold, null), tooltip: { content: `Bold (\\u2318B) ('')`, ...tooltipStyle } }), /* @__PURE__ */ import_react53.default.createElement(MarkToolbarButton, { type: getPluginType(editor, MARK_ITALIC), icon: /* @__PURE__ */ import_react53.default.createElement(FormatItalic, null), tooltip: { content: \"Italic (\\u2318I) (//)\", ...tooltipStyle } }), /* @__PURE__ */ import_react53.default.createElement(\n    MarkToolbarButton,\n    {\n      type: getPluginType(editor, MARK_UNDERLINE),\n      icon: /* @__PURE__ */ import_react53.default.createElement(FormatUnderlined, null),\n      tooltip: { content: \"Underline (\\u2318U) (__)\", ...tooltipStyle }\n    }\n  ), /* @__PURE__ */ import_react53.default.createElement(\n    MarkToolbarButton,\n    {\n      type: getPluginType(editor, MARK_STRIKETHROUGH),\n      icon: /* @__PURE__ */ import_react53.default.createElement(FormatStrikethrough, null),\n      tooltip: { content: `Delete (~~)`, ...tooltipStyle }\n    }\n  ), /* @__PURE__ */ import_react53.default.createElement(MarkToolbarButton, { type: getPluginType(editor, MARK_CODE), icon: /* @__PURE__ */ import_react53.default.createElement(CodeAlt, null), tooltip: { content: \"Code (`)\", ...tooltipStyle } }), /* @__PURE__ */ import_react53.default.createElement(\n    MarkToolbarButton,\n    {\n      type: getPluginType(editor, MARK_SUPERSCRIPT),\n      clear: getPluginType(editor, MARK_SUBSCRIPT$1),\n      icon: /* @__PURE__ */ import_react53.default.createElement(Superscript, null),\n      tooltip: { content: \"SuperScript (^^)\", ...tooltipStyle }\n    }\n  ), /* @__PURE__ */ import_react53.default.createElement(\n    MarkToolbarButton,\n    {\n      type: getPluginType(editor, MARK_SUBSCRIPT$1),\n      clear: getPluginType(editor, MARK_SUPERSCRIPT),\n      icon: /* @__PURE__ */ import_react53.default.createElement(Subscript, null),\n      tooltip: { content: \"SubScript (,,)\", ...tooltipStyle }\n    }\n  ));\n};\nvar BallonToolbar = () => {\n  const theme = \"light\";\n  return /* @__PURE__ */ import_react53.default.createElement(\n    BalloonToolbar,\n    {\n      floatingOptions: {\n        placement: \"top\"\n      },\n      theme\n    },\n    /* @__PURE__ */ import_react53.default.createElement(BasicMarkToolbarButtons, null),\n    /* @__PURE__ */ import_react53.default.createElement(BasicElementToolbarButtons, null),\n    /* @__PURE__ */ import_react53.default.createElement(ListToolbarButtons, null)\n  );\n};\n\n// src/editor/config/globalStyle.ts\nvar import_styled_components12 = __toESM(require_styled_components_browser_cjs());\nvar bodyStyles = import_styled_components12.css`\n  .tippy-box[data-theme~='tomato'] {\n    background-color: tomato;\n    color: yellow;\n  }\n`;\nvar GlobalStyle = import_styled_components12.createGlobalStyle`\n  ${bodyStyles}\n`;\n\n// src/editor/editor.tsx\nvar import_tw_react3 = __toESM(require_tw_react());\n\n// src/editor/components/combobox/SnippetCombobox.tsx\nvar import_react58 = __toESM(require(\"react\"));\n\n// src/editor/components/combobox/snippets.ts\nvar snippets = [];\nfunction getSnippetName(tiddler2) {\n  const name = tiddler2.fields[\"snippet-name\"];\n  if (typeof name !== \"string\" || name) {\n    const splits = tiddler2.fields.title.split(\"/\");\n    return splits[splits.length - 1];\n  }\n  return name;\n}\n$tw.utils.each($tw.wiki.filterTiddlers(\"[all[tiddlers+shadows]tag[$:/tags/TextEditor/Snippet]]\"), (snippetTiddlerTitle) => {\n  if (!snippetTiddlerTitle)\n    return;\n  const snippet = $tw.wiki.getTiddler(snippetTiddlerTitle);\n  if (snippet === void 0)\n    return;\n  snippets.push({\n    key: snippetTiddlerTitle,\n    data: {\n      name: getSnippetName(snippet),\n      preview: `!! ${snippet.fields.caption}${snippet.fields[\"snippet-description\"] ? `\n\n${snippet.fields[\"snippet-description\"]}` : \"\"}\n\n${snippet.fields.text}`\n    },\n    text: snippet.fields.text\n  });\n});\n$tw.utils.each($tw.wiki.filterTiddlers(\"[all[tiddlers+shadows]tag[$:/tags/KaTeX/Snippet]]\"), (snippetTiddlerTitle) => {\n  if (!snippetTiddlerTitle)\n    return;\n  const snippet = $tw.wiki.getTiddler(snippetTiddlerTitle);\n  if (snippet === void 0)\n    return;\n  const name = getSnippetName(snippet);\n  snippets.push({\n    key: snippetTiddlerTitle,\n    data: {\n      name,\n      preview: snippet.fields.text\n    },\n    text: snippet.fields.text\n  });\n});\n\n// src/editor/plugins/comboBox/AutoCompleteCombobox.tsx\nvar import_react54 = __toESM(require(\"react\"));\nfunction AutoCompleteCombobox({\n  pluginKey = ELEMENT_AUTO_COMPLETE,\n  id = pluginKey,\n  ...props\n}) {\n  const editor = usePlateEditorRef();\n  const { trigger: trigger2 } = getPluginOptions(editor, pluginKey);\n  const onSelectItem = (0, import_react54.useMemo)(\n    () => getAutoCompleteOnSelectItem({\n      key: pluginKey\n    }),\n    [pluginKey]\n  );\n  return /* @__PURE__ */ import_react54.default.createElement(Combobox, { id, trigger: trigger2, controlled: true, onSelectItem, ...props });\n}\n\n// src/editor/components/combobox/ListItem.tsx\nvar import_react57 = __toESM(require(\"react\"));\nvar import_styled_components13 = __toESM(require_styled_components_browser_cjs());\nvar import_memoize = __toESM(require_memoize());\n\n// src/editor/components/combobox/PreviewTooltip.tsx\nvar import_react55 = __toESM(require(\"react\"));\nvar LazyTippy = (props) => {\n  const [mounted, setMounted] = import_react55.default.useState(false);\n  const lazyPlugin = {\n    fn: () => ({\n      onMount: () => setMounted(true),\n      onHidden: () => setMounted(false)\n    })\n  };\n  const computedProps = { ...props };\n  computedProps.plugins = [lazyPlugin, ...props.plugins ?? []];\n  if (props.render !== void 0) {\n    const render2 = props.render;\n    computedProps.render = (...arguments_) => mounted ? render2(...arguments_) : \"\";\n  } else {\n    computedProps.content = mounted ? props.content : \"\";\n  }\n  return /* @__PURE__ */ import_react55.default.createElement(tippy_react_esm_default, { ...computedProps });\n};\n\n// src/editor/components/combobox/ListItem.tsx\nvar ListItemContentContainer = import_styled_components13.default.div`\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n`;\nvar Preview = import_styled_components13.default.div``;\nvar Name = import_styled_components13.default.div``;\nvar memorizedRenderText = (0, import_memoize.default)((text4) => $tw.wiki.renderText(\"text/html\", \"text/vnd.tiddlywiki\", text4));\nvar memorizedRenderTiddler = (0, import_memoize.default)((title2) => $tw.wiki.renderTiddler(\"text/html\", title2));\nvar filterKey = (text4) => (value) => value.key.toLowerCase().startsWith(text4.toLowerCase());\nfunction PreviewWithWikiText(props) {\n  const renderResult = props.getRenderTextTemplate(props.item);\n  return /* @__PURE__ */ import_react57.default.createElement(Preview, { dangerouslySetInnerHTML: { __html: renderResult } });\n}\nfunction ComboBoxDorpDownListItem(props) {\n  return /* @__PURE__ */ import_react57.default.createElement(\n    LazyTippy,\n    {\n      content: /* @__PURE__ */ import_react57.default.createElement(PreviewWithWikiText, { getRenderTextTemplate: props.getRenderTextTemplate, item: props.item }),\n      showOnCreate: false,\n      placement: \"right\",\n      hideOnClick: true\n    },\n    /* @__PURE__ */ import_react57.default.createElement(ListItemContentContainer, null, /* @__PURE__ */ import_react57.default.createElement(Name, null, props.getNameTemplate?.(props.item) ?? props.item.text))\n  );\n}\n\n// src/editor/components/combobox/SnippetCombobox.tsx\nvar filter2 = (text4) => (value) => value.data.name.toLowerCase().startsWith(text4.toLowerCase());\nfunction SnippetCombobox(props) {\n  const { id, pluginKey } = props;\n  return /* @__PURE__ */ import_react58.default.createElement(\n    AutoCompleteCombobox,\n    {\n      id: pluginKey,\n      items: snippets,\n      pluginKey,\n      filter: filter2,\n      onRenderItem: ComboBoxDorpDownListItem,\n      getRenderTextTemplate: (item) => memorizedRenderText(item.data.preview),\n      getNameTemplate: (item) => item.data.name\n    }\n  );\n}\n\n// src/editor/components/combobox/WikiLinkCombobox.tsx\nvar import_react59 = __toESM(require(\"react\"));\nfunction WikiLinkCombobox(props) {\n  const { id, pluginKey } = props;\n  const tiddlers = (0, import_react59.useMemo)(() => $tw.wiki.getTiddlers().map((title2) => ({ key: title2, text: title2 })), []);\n  return /* @__PURE__ */ import_react59.default.createElement(\n    AutoCompleteCombobox,\n    {\n      id: pluginKey,\n      items: tiddlers,\n      pluginKey,\n      filter: filterKey,\n      onRenderItem: ComboBoxDorpDownListItem,\n      getRenderTextTemplate: (item) => memorizedRenderTiddler(item.key)\n    }\n  );\n}\n\n// src/editor/components/combobox/MacrosCombobox.tsx\nvar import_react60 = __toESM(require(\"react\"));\nvar import_tw_react = __toESM(require_tw_react());\nfunction MacrosCombobox(props) {\n  const { id, pluginKey } = props;\n  const parentWidget = (0, import_react60.useContext)(import_tw_react.ParentWidgetContext);\n  const macros = (0, import_tw_react.useFilter)(\"[variables[]]\", parentWidget, [parentWidget]);\n  const macrosItems = (0, import_react60.useMemo)(() => macros.map((macro3) => ({ key: macro3, text: `<<${macro3}>>` })), [macros]);\n  return /* @__PURE__ */ import_react60.default.createElement(\n    AutoCompleteCombobox,\n    {\n      id: pluginKey,\n      items: macrosItems,\n      pluginKey,\n      filter: filterKey,\n      onRenderItem: ComboBoxDorpDownListItem,\n      getRenderTextTemplate: (item) => memorizedRenderText(`!! ${item.key}\n\n${item.text}`)\n    }\n  );\n}\n\n// src/editor/components/combobox/WidgetCombobox.tsx\nvar import_react61 = __toESM(require(\"react\"));\nfunction WidgetCombobox(props) {\n  const { id, pluginKey } = props;\n  const widgetItems = (0, import_react61.useMemo)(\n    () => Object.entries($tw.rootWidget.widgetClasses).map(([key, widgetClass]) => ({ key, text: `<$${key} />`, data: { widgetClass } })),\n    []\n  );\n  return /* @__PURE__ */ import_react61.default.createElement(\n    AutoCompleteCombobox,\n    {\n      id: pluginKey,\n      items: widgetItems,\n      pluginKey,\n      filter: filterKey,\n      onRenderItem: ComboBoxDorpDownListItem,\n      getRenderTextTemplate: (item) => memorizedRenderText(`!! ${item.key}\n\n${item.text}`),\n      getNameTemplate: (item) => item.data.widgetClass.name\n    }\n  );\n}\n\n// src/editor/components/index.ts\nvar import_styled_components22 = __toESM(require_styled_components_browser_cjs());\n\n// node_modules/@udecode/plate-ui-link/dist/index.es.js\nvar import_styled_components14 = __toESM(require_styled_components_browser_cjs());\nvar import_react62 = __toESM(require(\"react\"));\nvar _StyledDiv10 = (0, import_styled_components14.default)(\"div\").withConfig({\n  displayName: \"PlateFloatingLink___StyledDiv\",\n  componentId: \"sc-1bralnd-0\"\n})({\n  \"display\": \"flex\",\n  \"flexDirection\": \"column\",\n  \"width\": \"330px\"\n});\nvar _StyledFloatingLinkUrlInput = (0, import_styled_components14.default)(FloatingLink.UrlInput).withConfig({\n  displayName: \"PlateFloatingLink___StyledFloatingLinkUrlInput\",\n  componentId: \"sc-1bralnd-1\"\n})([\"\", \"\"], floatingInputCss);\nvar _StyledDiv25 = (0, import_styled_components14.default)(\"div\").withConfig({\n  displayName: \"PlateFloatingLink___StyledDiv2\",\n  componentId: \"sc-1bralnd-2\"\n})({\n  \"height\": \"1px\",\n  \"--tw-bg-opacity\": \"1\",\n  \"backgroundColor\": \"rgba(229, 231, 235, var(--tw-bg-opacity))\"\n});\nvar _StyledFloatingLinkTextInput = (0, import_styled_components14.default)(FloatingLink.TextInput).withConfig({\n  displayName: \"PlateFloatingLink___StyledFloatingLinkTextInput\",\n  componentId: \"sc-1bralnd-3\"\n})([\"\", \"\"], floatingInputCss);\nvar _StyledDiv33 = (0, import_styled_components14.default)(\"div\").withConfig({\n  displayName: \"PlateFloatingLink___StyledDiv3\",\n  componentId: \"sc-1bralnd-4\"\n})([\"\", \"\"], floatingRowCss);\nvar _StyledFloatingLinkEditButton = (0, import_styled_components14.default)(FloatingLink.EditButton).withConfig({\n  displayName: \"PlateFloatingLink___StyledFloatingLinkEditButton\",\n  componentId: \"sc-1bralnd-5\"\n})([\"\", \"\"], plateButtonCss);\nvar _StyledFloatingLinkOpenLinkButton = (0, import_styled_components14.default)(FloatingLink.OpenLinkButton).withConfig({\n  displayName: \"PlateFloatingLink___StyledFloatingLinkOpenLinkButton\",\n  componentId: \"sc-1bralnd-6\"\n})([\"\", \"\"], floatingButtonCss);\nvar _StyledFloatingLinkUnlinkButton = (0, import_styled_components14.default)(FloatingLink.UnlinkButton).withConfig({\n  displayName: \"PlateFloatingLink___StyledFloatingLinkUnlinkButton\",\n  componentId: \"sc-1bralnd-7\"\n})([\"\", \"\"], floatingButtonCss);\nvar _StyledFloatingLinkInsertRoot = (0, import_styled_components14.default)(FloatingLink.InsertRoot).withConfig({\n  displayName: \"PlateFloatingLink___StyledFloatingLinkInsertRoot\",\n  componentId: \"sc-1bralnd-8\"\n})([\"\", \"\"], floatingRootCss);\nvar _StyledFloatingLinkEditRoot = (0, import_styled_components14.default)(FloatingLink.EditRoot).withConfig({\n  displayName: \"PlateFloatingLink___StyledFloatingLinkEditRoot\",\n  componentId: \"sc-1bralnd-9\"\n})([\"\", \"\"], floatingRootCss);\nvar getLinkElementStyles = (props) => createStyles({\n  prefixClassNames: \"LinkElement\",\n  ...props\n}, {\n  root: (0, import_styled_components14.css)([\"color:#0078d4;text-decoration:initial;:hover,:visited:hover{color:#004578;text-decoration:underline;}:visited{color:#0078d4;}\"])\n});\nfunction _extends10() {\n  _extends10 = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i5 = 1; i5 < arguments.length; i5++) {\n      var source = arguments[i5];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends10.apply(this, arguments);\n}\nvar LinkElement = (props) => {\n  const {\n    as,\n    ...rootProps\n  } = props;\n  const {\n    root: root5\n  } = getLinkElementStyles(props);\n  return /* @__PURE__ */ import_react62.default.createElement(_StyledLinkRoot, _extends10({}, rootProps, {\n    $_css: root5.css\n  }));\n};\nvar _StyledLinkRoot = (0, import_styled_components14.default)(Link.Root).withConfig({\n  displayName: \"LinkElement___StyledLinkRoot\",\n  componentId: \"sc-1wp6xlj-0\"\n})([\"\", \"\"], (p6) => p6.$_css);\nvar LinkToolbarButton2 = withPlateEventProvider(({\n  id,\n  getLinkUrl,\n  ...props\n}) => {\n  id = useEventPlateId(id);\n  const editor = usePlateEditorState(id);\n  const type = getPluginType(editor, ELEMENT_LINK);\n  const isLink = !!(editor !== null && editor !== void 0 && editor.selection) && someNode(editor, {\n    match: {\n      type\n    }\n  });\n  return /* @__PURE__ */ import_react62.default.createElement(ToolbarButton, _extends10({\n    active: isLink,\n    onMouseDown: async (event) => {\n      var _editor$selection;\n      if (!editor)\n        return;\n      event.preventDefault();\n      event.stopPropagation();\n      focusEditor(editor, (_editor$selection = editor.selection) !== null && _editor$selection !== void 0 ? _editor$selection : editor.prevSelection);\n      setTimeout(() => {\n        triggerFloatingLink(editor, {\n          focused: true\n        });\n      }, 0);\n    }\n  }, props));\n});\n\n// node_modules/@udecode/plate-ui-mention/dist/index.es.js\nvar import_react64 = __toESM(require(\"react\"));\n\n// node_modules/@udecode/plate-ui-combobox/dist/index.es.js\nvar import_styled_components15 = __toESM(require_styled_components_browser_cjs());\nvar import_react63 = __toESM(require(\"react\"));\nvar _StyledUl = (0, import_styled_components15.default)(\"ul\").withConfig({\n  displayName: \"Combobox___StyledUl\",\n  componentId: \"sc-1chhjwl-0\"\n})([\"\", \"\"], (p6) => p6.$_css);\nvar _StyledDiv11 = (0, import_styled_components15.default)(\"div\").withConfig({\n  displayName: \"Combobox___StyledDiv\",\n  componentId: \"sc-1chhjwl-1\"\n})([\"\", \"\"], (p6) => p6.$_css2);\n\n// node_modules/@udecode/plate-ui-mention/dist/index.es.js\nvar import_styled_components16 = __toESM(require_styled_components_browser_cjs());\nfunction _extends11() {\n  _extends11 = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i5 = 1; i5 < arguments.length; i5++) {\n      var source = arguments[i5];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends11.apply(this, arguments);\n}\nvar getMentionElementStyles = (props) => createStyles({\n  prefixClassNames: \"MentionElement\",\n  ...props\n}, {\n  root: [{\n    \"marginTop\": \"0px\",\n    \"marginBottom\": \"0px\",\n    \"marginLeft\": \"1px\",\n    \"marginRight\": \"1px\",\n    \"verticalAlign\": \"baseline\",\n    \"display\": \"inline-block\"\n  }, props.selected && props.focused && {\n    \"boxShadow\": \"0 0 0 2px #B4D5FF\"\n  }, (0, import_styled_components16.css)([\"padding:3px 3px 2px;border-radius:4px;background-color:#eee;font-size:0.9em;\"])]\n});\nvar MentionElement = (props) => {\n  const {\n    attributes,\n    children,\n    nodeProps,\n    element: element4,\n    prefix,\n    onClick,\n    renderLabel\n  } = props;\n  const rootProps = getRootProps(props);\n  const selected = useSelected();\n  const focused = useFocused();\n  const styles2 = getMentionElementStyles({\n    ...props,\n    selected,\n    focused\n  });\n  return /* @__PURE__ */ import_react64.default.createElement(_StyledSpan$1, _extends11({}, attributes, {\n    \"data-slate-value\": element4.value,\n    className: styles2.root.className,\n    contentEditable: false,\n    onClick: getHandler(onClick, element4)\n  }, rootProps, nodeProps, {\n    $_css: styles2.root.css\n  }), prefix, renderLabel ? renderLabel(element4) : element4.value, children);\n};\nvar _StyledSpan$1 = (0, import_styled_components16.default)(\"span\").withConfig({\n  displayName: \"MentionElement___StyledSpan\",\n  componentId: \"sc-1oqi1vc-0\"\n})([\"\", \"\"], (p6) => p6.$_css);\nvar getMentionInputElementStyles = (props) => createStyles({\n  prefixClassNames: \"MentionInputElement\",\n  ...props\n}, {\n  root: [{\n    \"marginTop\": \"0px\",\n    \"marginBottom\": \"0px\",\n    \"marginLeft\": \"1px\",\n    \"marginRight\": \"1px\",\n    \"verticalAlign\": \"baseline\",\n    \"display\": \"inline-block\"\n  }, props.selected && props.focused && {\n    \"boxShadow\": \"0 0 0 2px #B4D5FF\"\n  }, (0, import_styled_components16.css)([\"padding:3px 3px 2px;border-radius:4px;background-color:#eee;font-size:0.9em;\"])]\n});\nvar MentionInputElement = (props) => {\n  const {\n    attributes,\n    children,\n    nodeProps,\n    element: element4,\n    as,\n    onClick\n  } = props;\n  const rootProps = getRootProps(props);\n  const selected = useSelected();\n  const focused = useFocused();\n  const styles2 = getMentionInputElementStyles({\n    ...props,\n    selected,\n    focused\n  });\n  return /* @__PURE__ */ import_react64.default.createElement(_StyledSpan4, _extends11({}, attributes, {\n    as,\n    \"data-slate-value\": element4.value,\n    className: styles2.root.className,\n    onClick: getHandler(onClick, element4)\n  }, rootProps, nodeProps, {\n    $_css: styles2.root.css\n  }), children);\n};\nvar _StyledSpan4 = (0, import_styled_components16.default)(\"span\").withConfig({\n  displayName: \"MentionInputElement___StyledSpan\",\n  componentId: \"sc-7amwcf-0\"\n})([\"\", \"\"], (p6) => p6.$_css);\n\n// node_modules/@udecode/plate-highlight/dist/index.es.js\nvar MARK_HIGHLIGHT = \"highlight\";\nvar createHighlightPlugin = createPluginFactory({\n  key: MARK_HIGHLIGHT,\n  isLeaf: true,\n  handlers: {\n    onKeyDown: onKeyDownToggleMark\n  },\n  deserializeHtml: {\n    rules: [{\n      validNodeName: [\"MARK\"]\n    }]\n  },\n  options: {\n    hotkey: \"mod+shift+h\"\n  }\n});\n\n// node_modules/@udecode/plate-ui-block-quote/dist/index.es.js\nvar import_styled_components17 = __toESM(require_styled_components_browser_cjs());\nvar import_react65 = __toESM(require(\"react\"));\nvar getBlockquoteElementStyles = (props) => createStyles({\n  prefixClassNames: \"BlockquoteElement\",\n  ...props\n}, {\n  root: [{\n    \"marginTop\": \"0.5rem\",\n    \"marginBottom\": \"0.5rem\",\n    \"marginLeft\": \"0px\",\n    \"marginRight\": \"0px\"\n  }, (0, import_styled_components17.css)([\"border-left:2px solid #ddd;padding:10px 20px 10px 16px;color:#aaa;\"])]\n});\nfunction _extends12() {\n  _extends12 = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i5 = 1; i5 < arguments.length; i5++) {\n      var source = arguments[i5];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends12.apply(this, arguments);\n}\nvar BlockquoteElement = (props) => {\n  const {\n    attributes,\n    children,\n    nodeProps\n  } = props;\n  const rootProps = getRootProps(props);\n  const {\n    root: root5\n  } = getBlockquoteElementStyles(props);\n  return /* @__PURE__ */ import_react65.default.createElement(_StyledBlockquote, _extends12({}, attributes, {\n    className: root5.className\n  }, rootProps, nodeProps, {\n    $_css: root5.css\n  }), children);\n};\nvar _StyledBlockquote = (0, import_styled_components17.default)(\"blockquote\").withConfig({\n  displayName: \"BlockquoteElement___StyledBlockquote\",\n  componentId: \"sc-qjadfw-0\"\n})([\"\", \"\"], (p6) => p6.$_css);\n\n// src/editor/config/withStyledDraggables.tsx\nvar import_styled_components18 = __toESM(require_styled_components_browser_cjs());\nvar withStyledDraggables = (components2) => {\n  return withDraggables2(components2, [\n    // only element that registered keys here will have dnd grabber\n    {\n      key: ELEMENT_LI,\n      styles: {\n        gutterLeft: import_styled_components18.css`\n          transform: translateX(-6em);\n        `\n      }\n    },\n    {\n      key: ELEMENT_H1,\n      styles: {\n        gutterLeft: import_styled_components18.css`\n          padding: 0 0 4px;\n          font-size: 1.875em;\n        `,\n        blockToolbarWrapper: import_styled_components18.css`\n          height: 1.3em;\n        `\n      }\n    },\n    {\n      key: ELEMENT_H2,\n      styles: {\n        gutterLeft: import_styled_components18.css`\n          padding: 0 0 1px;\n          font-size: 1.5em;\n        `,\n        blockToolbarWrapper: import_styled_components18.css`\n          height: 1.3em;\n        `\n      }\n    },\n    {\n      key: ELEMENT_H3,\n      styles: {\n        gutterLeft: import_styled_components18.css`\n          padding: 0 0 1px;\n          font-size: 1.25em;\n        `,\n        blockToolbarWrapper: import_styled_components18.css`\n          height: 1.3em;\n        `\n      }\n    },\n    {\n      key: ELEMENT_H4,\n      styles: {\n        gutterLeft: import_styled_components18.css`\n          padding: 0 0 0;\n          font-size: 0.9em;\n        `,\n        blockToolbarWrapper: import_styled_components18.css`\n          height: 1.3em;\n        `\n      }\n    },\n    {\n      keys: [ELEMENT_H5, ELEMENT_H6],\n      styles: {\n        gutterLeft: import_styled_components18.css`\n          padding: 0;\n          margin-top: -0.4em;\n        `\n      }\n    },\n    {\n      key: ELEMENT_PARAGRAPH\n    },\n    {\n      key: ELEMENT_BLOCKQUOTE\n    },\n    {\n      key: ELEMENT_CODE_BLOCK,\n      styles: {\n        gutterLeft: import_styled_components18.css`\n          padding-top: 0.2em;\n        `\n      }\n    },\n    {\n      keys: [ELEMENT_WIDGET, ELEMENT_MACRO],\n      level: 0\n    }\n  ]);\n};\n\n// node_modules/@udecode/plate-ui-placeholder/dist/index.es.js\nvar import_styled_components19 = __toESM(require_styled_components_browser_cjs());\nvar import_react66 = __toESM(require(\"react\"));\nvar getPlaceholderStyles = (props) => createStyles({\n  prefixClassNames: \"Placeholder\",\n  ...props\n}, {\n  root: props.enabled ? (0, import_styled_components19.css)([\"::before{content:attr(placeholder);opacity:0.3;\", \"}\"], {\n    \"display\": \"block\",\n    \"position\": \"absolute\",\n    \"cursor\": \"text\"\n  }) : void 0\n});\nvar Placeholder = (props) => {\n  const {\n    children,\n    element: element4,\n    placeholder,\n    hideOnBlur = true,\n    nodeProps\n  } = props;\n  const focused = useFocused();\n  const selected = useSelected();\n  const editor = useEditorState();\n  const isEmptyBlock = isElementEmpty(editor, element4);\n  const enabled = isEmptyBlock && (!hideOnBlur || isCollapsed(editor.selection) && hideOnBlur && focused && selected);\n  return import_react66.default.Children.map(children, (child) => {\n    return /* @__PURE__ */ import_react66.default.cloneElement(child, {\n      className: child.props.className,\n      nodeProps: {\n        ...nodeProps,\n        styles: getPlaceholderStyles({\n          enabled,\n          ...props\n        }),\n        placeholder\n      }\n    });\n  });\n};\nvar withPlaceholder = createNodeHOC(Placeholder);\nvar withPlaceholders = createNodesHOC(Placeholder);\n\n// src/editor/config/withStyledPlaceHolders.ts\nvar withStyledPlaceHolders = (components2) => withPlaceholders(components2, [\n  {\n    key: ELEMENT_PARAGRAPH,\n    placeholder: \"Type / for commands\",\n    hideOnBlur: true\n  }\n]);\n\n// src/editor/plugins/widget/WidgetBlock.tsx\nvar import_react69 = __toESM(require(\"react\"));\nvar import_tw_react2 = __toESM(require_tw_react());\nvar import_styled_components21 = __toESM(require_styled_components_browser_cjs());\n\n// src/editor/plugins/widget/WidgetCodeEditor.tsx\nvar import_react67 = __toESM(require(\"react\"));\nvar import_styled_components20 = __toESM(require_styled_components_browser_cjs());\n\n// src/editor/plugins/widget/store.ts\nvar useWidgetCodeBlockStore = create2((_set) => ({\n  previousActiveId: void 0,\n  previousCodeMirrorSelection: void 0\n}));\n\n// src/editor/plugins/widget/WidgetCodeEditor.tsx\nvar CodeBlockWrapper = import_styled_components20.default.div`\n  position: absolute;\n  z-index: 1;\n  /** placed on the bottom of widget by default */\n  /* top: calc(100% + ${({ top: top2 }) => top2}px);\n  left: ${({ left: left2 }) => left2}px;\n  opacity: ${({ opacity }) => opacity}; */\n`;\nvar CodeBlockContainer = import_styled_components20.default.div`\n  user-select: none;\n  display: flex;\n  flex-direction: row;\n`;\nvar CodeTextArea2 = import_styled_components20.default.textarea`\n  width: 100%;\n  height: max-content;\n`;\nvar SaveButton = import_styled_components20.default.button``;\nvar SaveButtonText = $tw.wiki.getTiddlerText(\"$:/language/Buttons/SaveWiki/Hint\");\nfunction useCodeMirrorOnCmdEnter(onSave, codeMirror) {\n  const hasCodeMirrorEventListenerSettled = (0, import_react67.useRef)(false);\n  (0, import_react67.useEffect)(() => {\n    if (codeMirror?.current !== null && !hasCodeMirrorEventListenerSettled.current) {\n      const saveKeyMap = { \"Ctrl-Enter\": onSave, \"Cmd-Enter\": onSave };\n      codeMirror.current.addKeyMap(saveKeyMap);\n      hasCodeMirrorEventListenerSettled.current = true;\n    }\n  }, [codeMirror, onSave]);\n}\nfunction WidgetCodeEditor(props) {\n  const { element: element4, children, editor } = props;\n  const store = useWidgetCodeBlockStore();\n  const textAreaReference = (0, import_react67.useRef)(null);\n  const code3 = (0, import_react67.useMemo)(() => wikiAstToWikiText(element4.node), [element4.node]);\n  const cmOptions = (0, import_react67.useMemo)(() => ({ mode: CODE_BLOCK_LANGUAGES.TiddlyWiki[0], value: code3 }), [code3]);\n  const codeMirror = useCodeMirror(textAreaReference, cmOptions);\n  const path = (0, import_react67.useMemo)(() => findNodePath(editor, element4), [editor, element4]);\n  const latestCodeReference = (0, import_react67.useRef)(code3);\n  const onCodeChange = (0, import_react67.useCallback)((eventOrString) => {\n    const latestCode = typeof eventOrString === \"string\" ? eventOrString : eventOrString.target.value;\n    latestCodeReference.current = latestCode;\n  }, []);\n  const onSave = useDebouncedCallback_default(() => {\n    if (path !== void 0) {\n      const slateNode2 = deserialize(latestCodeReference.current);\n      const previousSlateSelection = editor.selection;\n      useWidgetCodeBlockStore.setState({\n        previousActiveId: element4.id,\n        previousCodeMirrorSelection: codeMirror.current?.getCursor?.(\"from\") ?? void 0\n      });\n      withoutNormalizing(editor, () => {\n        removeNodes(editor, { at: path });\n        insertNodes(editor, slateNode2, { at: path });\n        setNodes(editor, { id: element4.id }, { at: path });\n        editor.selection = previousSlateSelection;\n      });\n    }\n  }, [editor, path, codeMirror]);\n  useCodeMirrorEventListenerSettled(onCodeChange, codeMirror);\n  useCodeMirrorOnCmdEnter(onSave, codeMirror);\n  (0, import_react67.useEffect)(() => {\n    codeMirror.current?.focus?.();\n    if (store.previousActiveId === element4.id && store.previousCodeMirrorSelection !== void 0) {\n      codeMirror.current?.setSelection?.(store.previousCodeMirrorSelection);\n    }\n  }, [codeMirror, element4.id, store.previousActiveId, store.previousCodeMirrorSelection]);\n  return /* @__PURE__ */ import_react67.default.createElement(CodeBlockWrapper, null, /* @__PURE__ */ import_react67.default.createElement(CodeBlockContainer, { contentEditable: false }, /* @__PURE__ */ import_react67.default.createElement(\"div\", { className: \"tw-widget-code-editor-container\" }, /* @__PURE__ */ import_react67.default.createElement(CodeTextArea2, { ref: textAreaReference, onChange: onCodeChange, defaultValue: code3, className: \"CodeMirror\" })), /* @__PURE__ */ import_react67.default.createElement(tippy_react_esm_default, { content: \"(\\u2303/\\u2318 + \\u23CE)\" }, /* @__PURE__ */ import_react67.default.createElement(SaveButton, { onClick: onSave }, SaveButtonText))), children);\n}\n\n// src/editor/plugins/widget/WidgetBlock.tsx\nvar import_typescript_styled_is3 = __toESM(require_dist());\nvar TwWidgetContainerOuter = import_styled_components21.default.div``;\nvar TwWidgetContainerInner = import_styled_components21.default.div`\n  user-select: normal;\n  white-space: normal;\n`;\nvar TwWidgetCodeContainer = import_styled_components21.default.div`\n  opacity: 0;\n  ${(0, import_typescript_styled_is3.default)(\"selected\")`\n    opacity: 1;\n  `}\n  transition: opacity 0.1s;\n`;\nfunction WidgetBlock(props) {\n  const { attributes, element: element4, children, editor } = props;\n  const widgetContainerReference = (0, import_react69.useRef)(null);\n  (0, import_tw_react2.useWidget)(element4.node, widgetContainerReference);\n  const rootProps = getRootProps(props);\n  const selected = useSelected();\n  return /* @__PURE__ */ import_react69.default.createElement(TwWidgetContainerOuter, { \"data-role\": \"tw-widget-container\", ...attributes, ...rootProps, as: rootProps.as }, /* @__PURE__ */ import_react69.default.createElement(TwWidgetContainerInner, { contentEditable: false }, /* @__PURE__ */ import_react69.default.createElement(\"div\", { ref: widgetContainerReference })), children, /* @__PURE__ */ import_react69.default.createElement(TwWidgetCodeContainer, { selected }, selected && /* @__PURE__ */ import_react69.default.createElement(WidgetCodeEditor, { ...props })));\n}\n\n// src/editor/components/index.ts\nvar createPlateUI = (overrideByKey) => {\n  const components2 = {};\n  if (overrideByKey !== void 0) {\n    Object.keys(overrideByKey).forEach((key) => {\n      const newOne = overrideByKey[key];\n      if (newOne !== void 0) {\n        components2[key] = newOne;\n      }\n    });\n  }\n  return components2;\n};\nvar rawComponents = createPlateUI({\n  [ELEMENT_AUTO_COMPLETE]: MentionElement,\n  [ELEMENT_AUTO_COMPLETE_INPUT]: MentionInputElement,\n  [ELEMENT_WIDGET]: WidgetBlock,\n  [ELEMENT_MACRO]: WidgetBlock,\n  [ELEMENT_LINK]: LinkElement,\n  [ELEMENT_CODE_BLOCK]: CodeBlockElement,\n  [ELEMENT_OL]: withProps(StyledElement, {\n    as: \"ol\"\n  }),\n  [ELEMENT_UL]: withProps(StyledElement, {\n    as: \"ul\"\n  }),\n  [ELEMENT_PARAGRAPH]: withProps(StyledElement, {\n    as: \"p\",\n    styles: {\n      root: import_styled_components22.css`\n        padding: 0;\n      `\n    }\n  }),\n  [ELEMENT_BLOCKQUOTE]: BlockquoteElement,\n  [ELEMENT_CODE_BLOCK]: CodeBlockElement,\n  // [ELEMENT_CODE_LINE]: CodeLineElement,\n  // [ELEMENT_CODE_SYNTAX]: CodeSyntaxLeaf,\n  // TODO: use basic hr element, plate's is wiredly huge\n  // [ELEMENT_HR]: HrElement,\n  [ELEMENT_H1]: withProps(StyledElement, {\n    as: \"h1\",\n    styles: {\n      root: import_styled_components22.css`\n        margin: 2em 0 4px;\n        font-size: 1.875em;\n        font-weight: 500;\n        line-height: 1.3;\n      `\n    }\n  }),\n  [ELEMENT_H2]: withProps(StyledElement, {\n    as: \"h2\",\n    styles: {\n      root: import_styled_components22.css`\n        margin: 1.4em 0 1px;\n        font-size: 1.5em;\n        font-weight: 500;\n        line-height: 1.3;\n      `\n    }\n  }),\n  [ELEMENT_H3]: withProps(StyledElement, {\n    as: \"h3\",\n    styles: {\n      root: import_styled_components22.css`\n        margin: 1em 0 1px;\n        font-size: 1.25em;\n        font-weight: 500;\n        line-height: 1.3;\n        color: #434343;\n      `\n    }\n  }),\n  [ELEMENT_H4]: withProps(StyledElement, {\n    as: \"h4\",\n    styles: {\n      root: import_styled_components22.css`\n        margin: 0.75em 0 0;\n        font-size: 1.1em;\n        font-weight: 500;\n        line-height: 1.3;\n        color: #666666;\n      `\n    }\n  }),\n  [ELEMENT_H5]: withProps(StyledElement, {\n    as: \"h5\",\n    styles: {\n      root: import_styled_components22.css`\n        margin: 0.75em 0 0;\n        font-size: 1.1em;\n        font-weight: 500;\n        line-height: 1.3;\n        color: #666666;\n      `\n    }\n  }),\n  [ELEMENT_H6]: withProps(StyledElement, {\n    as: \"h6\",\n    styles: {\n      root: import_styled_components22.css`\n        margin: 0.75em 0 0;\n        font-size: 1.1em;\n        font-weight: 500;\n        line-height: 1.3;\n        color: #666666;\n      `\n    }\n  }),\n  // TODO: use tw image widget\n  // [ELEMENT_IMAGE]: ImageElement,\n  [ELEMENT_LI]: withProps(StyledElement, { as: \"li\" }),\n  [ELEMENT_LINK]: LinkElement,\n  // [ELEMENT_MEDIA_EMBED]: MediaEmbedElement,\n  // [ELEMENT_MENTION]: MentionElement,\n  // [ELEMENT_MENTION_INPUT]: MentionInputElement,\n  [ELEMENT_UL]: withProps(StyledElement, {\n    as: \"ul\",\n    styles: {\n      root: import_styled_components22.css`\n        margin: 0;\n        padding-inline-start: 24px;\n      `\n    }\n  }),\n  [ELEMENT_OL]: withProps(StyledElement, {\n    as: \"ol\",\n    styles: {\n      root: import_styled_components22.css`\n        margin: 0;\n        padding-inline-start: 24px;\n      `\n    }\n  }),\n  [ELEMENT_TABLE]: TableElement,\n  [ELEMENT_TD]: TableCellElement,\n  [ELEMENT_TH]: withProps(StyledElement, {\n    as: \"th\",\n    styles: {\n      root: [\n        import_styled_components22.css`\n          padding: 2px;\n          text-align: left;\n          background-color: rgb(244, 245, 247);\n          border: 1px solid rgb(193, 199, 208);\n          min-width: 48px;\n\n          > * {\n            margin: 0;\n          }\n        `\n      ]\n    }\n  }),\n  [ELEMENT_TR]: TableRowElement,\n  // [ELEMENT_TODO_LI]: TodoListElement,\n  [MARK_BOLD]: withProps(StyledLeaf, { as: \"strong\" }),\n  [MARK_CODE]: withProps(StyledLeaf, {\n    as: \"code\",\n    styles: {\n      root: [\n        import_styled_components22.css`\n          white-space: pre-wrap;\n          font-size: 85%;\n          font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;\n          background-color: rgba(135, 131, 120, 0.15);\n          border-radius: 3px;\n          padding: 0.2em 0.4em;\n          line-height: normal;\n        `\n      ]\n    }\n  }),\n  [MARK_HIGHLIGHT]: withProps(StyledLeaf, {\n    as: \"mark\",\n    styles: {\n      root: import_styled_components22.css`\n        background-color: #fef3b7;\n      `\n    }\n  }),\n  [MARK_ITALIC]: withProps(StyledLeaf, { as: \"em\" }),\n  [MARK_KBD]: withProps(StyledLeaf, {\n    as: \"kbd\",\n    styles: {\n      root: [\n        import_styled_components22.css`\n          white-space: pre-wrap;\n          font-size: 75%;\n          font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;\n          background-color: white;\n          border: 1px solid black;\n          border-radius: 3px;\n          padding: 0.2em 0.4em;\n          line-height: normal;\n          margin-right: 0.2em;\n          box-shadow: 2px 2px 3px 0 rgba(0, 0, 0, 0.75);\n        `\n      ]\n    }\n  }),\n  [MARK_STRIKETHROUGH]: withProps(StyledLeaf, { as: \"s\" }),\n  [MARK_SUBSCRIPT$1]: withProps(StyledLeaf, { as: \"sub\" }),\n  [MARK_SUPERSCRIPT]: withProps(StyledLeaf, { as: \"sup\" }),\n  [MARK_UNDERLINE]: withProps(StyledLeaf, { as: \"u\" })\n});\nvar components = withStyledDraggables(withStyledPlaceHolders(rawComponents));\n\n// src/editor/plugins/id/getId.ts\nvar getIdFactory = (tiddlerTitle) => {\n  let id = 1;\n  return () => `${tiddlerTitle}-${id++}`;\n};\n\n// src/editor/editor.tsx\nvar defaultPlugins = createPlugins([...basicElements, ...basicMarks, ...utils, ...twAdvancedElements], {\n  // Plate components\n  components\n});\nfunction Editor2(props) {\n  const editorID = props.currentTiddler;\n  const { resetEditor, value: updateEditorValue } = getPlateActions(editorID);\n  const idCreator = (0, import_react70.useMemo)(() => {\n    return getIdFactory(props.currentTiddler);\n  }, [props.currentTiddler]);\n  const editorReference = usePlateEditorRef(editorID);\n  const currentAstReference = (0, import_react70.useRef)(deserialize(props.initialTiddlerText, { idCreator }));\n  const currentTextReference = (0, import_react70.useRef)(props.initialTiddlerText);\n  const idPlugin = (0, import_react70.useMemo)(\n    () => createNodeIdPlugin({\n      options: {\n        idCreator\n      }\n    }),\n    [idCreator]\n  );\n  const plugins = (0, import_react70.useMemo)(() => createPlugins([...defaultPlugins, idPlugin]), [idPlugin]);\n  (0, import_react70.useEffect)(() => {\n    if (currentTextReference.current !== props.initialTiddlerText) {\n      const newValue = deserialize(props.initialTiddlerText, { idCreator });\n      currentAstReference.current = newValue;\n      resetEditor();\n      updateEditorValue(newValue);\n    }\n  }, [props.initialTiddlerText, currentTextReference, updateEditorValue, resetEditor, idCreator]);\n  const saver = (0, import_react70.useCallback)(\n    (newValue) => {\n      console.log(`newValue`, newValue);\n      const newText = serialize(newValue);\n      props.saver.onSave(newText);\n      currentTextReference.current = newText;\n    },\n    [props.saver.onSave]\n  );\n  const debouncedSaver = useDebouncedCallback_default(saver, [saver], props.saver.interval);\n  const onChange = (0, import_react70.useCallback)(\n    (newValue) => {\n      if (currentAstReference.current === newValue)\n        return;\n      console.log(`currentAstReference.current = newValue`, newValue);\n      currentAstReference.current = newValue;\n      if (editorReference === null || ReactEditor.isComposing(editorReference)) {\n        return;\n      }\n      if (editorReference.operations.every((op) => op.type === \"set_selection\")) {\n        return;\n      }\n      props.saver.lock();\n      debouncedSaver(newValue);\n    },\n    [debouncedSaver, editorReference, props.saver]\n  );\n  (0, import_react70.useEffect)(() => {\n    return () => {\n      saver(currentAstReference.current);\n    };\n  }, []);\n  if (typeof document === \"undefined\") {\n    return /* @__PURE__ */ import_react70.default.createElement(\"div\", null, \"Loading...\");\n  }\n  console.log(`currentAstRef.current`, currentAstReference.current);\n  return /* @__PURE__ */ import_react70.default.createElement(Plate, { id: editorID, initialValue: currentAstReference.current, plugins, onChange, editableProps: { ...CONFIG.editableProps } }, /* @__PURE__ */ import_react70.default.createElement(BallonToolbar, null), /* @__PURE__ */ import_react70.default.createElement(SnippetCombobox, { id: editorID, pluginKey: \"/\" }), /* @__PURE__ */ import_react70.default.createElement(WikiLinkCombobox, { id: editorID, pluginKey: \"[[\" }), /* @__PURE__ */ import_react70.default.createElement(WikiLinkCombobox, { id: editorID, pluginKey: \"{{\" }), /* @__PURE__ */ import_react70.default.createElement(MacrosCombobox, { id: editorID, pluginKey: \"<<\" }), /* @__PURE__ */ import_react70.default.createElement(WidgetCombobox, { id: editorID, pluginKey: \"<$\" }));\n}\nfunction App(props) {\n  return /* @__PURE__ */ import_react70.default.createElement(PlateProvider, { id: props.currentTiddler }, /* @__PURE__ */ import_react70.default.createElement(import_tw_react3.ParentWidgetContext.Provider, { value: props.parentWidget }, /* @__PURE__ */ import_react70.default.createElement(GlobalStyle, null), /* @__PURE__ */ import_react70.default.createElement(DndProvider, { backend: HTML5Backend }, /* @__PURE__ */ import_react70.default.createElement(Editor2, { ...props }))));\n}\n\n// src/editor/index.ts\nvar Widget = require(\"$:/plugins/linonetwo/tw-react/widget.js\").widget;\nvar DEFAULT_MIN_TEXT_AREA_HEIGHT = \"100px\";\nvar HEIGHT_MODE_TITLE = \"$:/config/TextEditor/EditorHeight/Mode\";\nvar ENABLE_TOOLBAR_TITLE = \"$:/config/TextEditor/EnableToolbar\";\nvar SlateWriteWidget = class extends Widget {\n  currentTiddler;\n  editorOperations = {};\n  editTitle;\n  editField;\n  editIndex;\n  editDefault;\n  editClass;\n  editPlaceholder;\n  editSize;\n  editRows;\n  editAutoHeight;\n  editMinHeight;\n  editFocusPopup;\n  editFocus;\n  editTabIndex;\n  editCancelPopups;\n  editInputActions;\n  editRefreshTitle;\n  editAutoComplete;\n  isDisabled;\n  isFileDropEnabled;\n  editShowToolbar;\n  constructor(parseTreeNode, options) {\n    super(parseTreeNode, options);\n    $tw.modules.applyMethods(\"texteditoroperation\", this.editorOperations);\n  }\n  reactComponent = App;\n  getProps = () => {\n    const onSave = (newText) => {\n      if (!this.editTitle) {\n        return;\n      }\n      const previousText = $tw.wiki.getTiddlerText(this.editTitle) ?? \"\";\n      if (previousText === newText) {\n        return;\n      }\n      $tw.wiki.setText(this.editTitle, void 0, void 0, newText);\n      notifyNavigatorSaveTiddler(this.editTitle, this.parentWidget);\n      this.unlock();\n    };\n    return {\n      currentTiddler: this.editTitle ?? this.getVariable(\"currentTiddler\"),\n      initialTiddlerText: (this.editTitle && $tw.wiki.getTiddlerText(this.editTitle)) ?? \"\",\n      saver: {\n        lock: this.lock,\n        onSave,\n        interval: SAVE_DEBOUNCE_INTERVAL\n      }\n    };\n  };\n  /** a lock to prevent update from tiddler to slate, when update of tiddler is trigger by slate. */\n  isUpdatingByUserInput = false;\n  updatingLockTimeoutHandle;\n  get editIconElement() {\n    const element4 = this.parentDomNode.closest(\".tc-tiddler-exists\")?.querySelector(\".tc-image-wysiwyg-edit-button\");\n    return element4;\n  }\n  lock = () => {\n    this.isUpdatingByUserInput = true;\n    const iconText = this.editIconElement?.querySelector(\"text\");\n    if (iconText) {\n      iconText.innerHTML = \".....\";\n    }\n    if (this.updatingLockTimeoutHandle !== void 0) {\n      clearTimeout(this.updatingLockTimeoutHandle);\n    }\n  };\n  unlock = () => {\n    this.updatingLockTimeoutHandle = setTimeout(() => {\n      this.isUpdatingByUserInput = false;\n      const iconText = this.editIconElement?.querySelector(\"text\");\n      if (iconText) {\n        iconText.innerHTML = \"T\";\n      }\n    });\n  };\n  execute() {\n    this.editTitle = this.getAttribute(\"tiddler\", this.getVariable(\"currentTiddler\"));\n    this.editField = this.getAttribute(\"field\", \"text\");\n    this.editIndex = this.getAttribute(\"index\");\n    this.editDefault = this.getAttribute(\"default\");\n    this.editClass = this.getAttribute(\"class\");\n    this.editPlaceholder = this.getAttribute(\"placeholder\");\n    this.editSize = this.getAttribute(\"size\");\n    this.editRows = this.getAttribute(\"rows\");\n    const editAutoHeight = $tw.wiki.getTiddlerText(HEIGHT_MODE_TITLE, \"auto\");\n    this.editAutoHeight = this.getAttribute(\"autoHeight\", editAutoHeight === \"auto\" ? \"yes\" : \"no\") === \"yes\";\n    this.editMinHeight = this.getAttribute(\"minHeight\", DEFAULT_MIN_TEXT_AREA_HEIGHT);\n    this.editFocusPopup = this.getAttribute(\"focusPopup\");\n    this.editFocus = this.getAttribute(\"focus\");\n    this.editTabIndex = this.getAttribute(\"tabindex\");\n    this.editCancelPopups = this.getAttribute(\"cancelPopups\", \"\") === \"yes\";\n    this.editInputActions = this.getAttribute(\"inputActions\");\n    this.editRefreshTitle = this.getAttribute(\"refreshTitle\");\n    this.editAutoComplete = this.getAttribute(\"autocomplete\");\n    this.isDisabled = this.getAttribute(\"disabled\", \"no\");\n    this.isFileDropEnabled = this.getAttribute(\"fileDrop\", \"no\") === \"yes\";\n    this.makeChildWidgets();\n    const editShowToolbar = $tw.wiki.getTiddlerText(ENABLE_TOOLBAR_TITLE, \"yes\");\n    this.editShowToolbar = editShowToolbar === \"yes\" && !!(this.children && this.children.length > 0);\n  }\n  refresh(changedTiddlers) {\n    const changedAttributes = this.computeAttributes();\n    if (this.isUpdatingByUserInput) {\n      return false;\n    }\n    if (changedAttributes.tiddler || changedAttributes.field || changedAttributes.index || changedAttributes.default || changedAttributes.class || changedAttributes.placeholder || changedAttributes.size > 0 || changedAttributes.autoHeight || changedAttributes.minHeight || changedAttributes.focusPopup || changedAttributes.rows || changedAttributes.tabindex || changedAttributes.cancelPopups || changedAttributes.inputActions || changedAttributes.refreshTitle || changedAttributes.autocomplete || changedTiddlers[HEIGHT_MODE_TITLE] || changedTiddlers[ENABLE_TOOLBAR_TITLE] || changedAttributes.disabled || changedAttributes.fileDrop || this.editRefreshTitle !== void 0 && changedTiddlers[this.editRefreshTitle] || this.editTitle && changedTiddlers[this.editTitle]?.modified) {\n      this.refreshSelf();\n      return this.refreshChildren(changedTiddlers);\n    }\n    return false;\n  }\n};\nfunction notifyNavigatorSaveTiddler(title2, parentWidget) {\n  parentWidget?.dispatchEvent({\n    type: \"tm-save-tiddler\",\n    // param: param,\n    paramObject: { suppressNavigation: \"yes\" },\n    tiddlerTitle: title2\n  });\n  parentWidget?.dispatchEvent({ type: \"tm-auto-save-wiki\" });\n}\nexports.widget = SlateWriteWidget;\n/*! Bundled license information:\n\nuse-sync-external-store/cjs/use-sync-external-store-shim.development.js:\n  (**\n   * @license React\n   * use-sync-external-store-shim.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n\nuse-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:\n  (**\n   * @license React\n   * use-sync-external-store-shim/with-selector.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n\nunist-util-find/index.js:\n  (**\n   * @author Richard Smith-Unna\n   * @copyright 2016 Richard Smith-Unnar\n   * @license MIT\n   * @module unist:find\n   * @fileoverview Unist node finder\n   *)\n\nreact-is/cjs/react-is.development.js:\n  (** @license React v16.13.1\n   * react-is.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n\nobject-assign/index.js:\n  (*\n  object-assign\n  (c) Sindre Sorhus\n  @license MIT\n  *)\n\nreact-is/cjs/react-is.development.js:\n  (** @license React v17.0.2\n   * react-is.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n\nis-plain-object/dist/is-plain-object.mjs:\n  (*!\n   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n   *\n   * Copyright (c) 2014-2017, Jon Schlinkert.\n   * Released under the MIT License.\n   *)\n\n@udecode/plate-core/dist/index.es.js:\n  (*!\n   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n   *\n   * Copyright (c) 2014-2017, Jon Schlinkert.\n   * Released under the MIT License.\n   *)\n*/\n","type":"application/javascript","module-type":"library"},"$:/plugins/linonetwo/slate-write/modify-navigator.js":{"title":"$:/plugins/linonetwo/slate-write/modify-navigator.js","text":"\"use strict\";\n\n// src/event-listeners/modify-navigator.ts\nvar NavigatorWidget = require(\"$:/core/modules/widgets/navigator.js\").navigator;\nNavigatorWidget.prototype.handleEditWYSIWYGTiddlerEvent = function(event) {\n  const editTiddler = $tw.hooks.invokeHook(\"th-editing-wysiwyg-tiddler\", event);\n  if (editTiddler === void 0) {\n    return false;\n  }\n  const isUnmodifiedShadow = (title2) => {\n    return this.wiki.isShadowTiddler(title2) && !this.wiki.tiddlerExists(title2);\n  };\n  const confirmEditShadow = (title2) => {\n    const win = event.event && \"view\" in event.event && event.event.view !== void 0 ? event.event.view : window;\n    return win.confirm($tw.language.getString(\"ConfirmEditShadowTiddler\", { variables: { title: title2 } }));\n  };\n  const title = event.param || event.tiddlerTitle;\n  if (!title || isUnmodifiedShadow(title) && !confirmEditShadow(title)) {\n    return false;\n  }\n  if (event.paramObject === void 0 || event.paramObject.suppressNavigation !== \"yes\") {\n    const tiddler = $tw.wiki.getTiddler(title);\n    $tw.wiki.addTiddler({ ...tiddler?.fields, wysiwyg: tiddler?.fields?.wysiwyg === \"yes\" ? void 0 : \"yes\" });\n    return false;\n  }\n};\nvar coreRender = NavigatorWidget.prototype.render;\nNavigatorWidget.prototype.render = function(parent, nextSibling) {\n  this.addEventListeners([{ type: \"tm-edit-wysiwyg-tiddler\", handler: \"handleEditWYSIWYGTiddlerEvent\" }]);\n  Reflect.apply(coreRender, this, [parent, nextSibling]);\n};\n","creator":"LinOnetwo","type":"application/javascript","module-type":"startup"},"$:/plugins/linonetwo/slate-write/readme":{"title":"$:/plugins/linonetwo/slate-write/readme","type":"text/vnd.tiddlywiki","text":"!! Usage 用法\n\n点击条目查看工具栏上的 {{$:/plugins/linonetwo/slate-write/ui/ViewToolbar/images/edit-wysiwyg-button}} 按钮即可在只读模式和编所见即所得辑模式之间切换。\n\nYou can click on {{$:/plugins/linonetwo/slate-write/ui/ViewToolbar/images/edit-wysiwyg-button}} on view toolbar on your tiddler to switch between read-only mode and wysiwyg-edit mode.\n\n!!! Advanced Usage 高级用法\n\n如果你在开发自己的插件，那么你可以用这个微件来在任意地方显示一个编辑器，通过 `tiddler` 字段可以指定要编辑的条目，不填 `tiddler` 就会编辑 `currentTiddler` 环境变量指向的条目。\n\nIf you are developing your own plugin, then you can use this widget to display an editor anywhere. The `tiddler` field allows you to specify the tiddler to edit, and leaving the `tiddler` field unfilled will edit the tiddler that `currentTiddler` environment variable pointed to.\n\n`<$edit-slateWrite tiddler=\"AAA\" />`\n\n!! Install 安装\n\n[[Install from CPL|https://tw-cpl.netlify.app/]]\n\n[[使用社区插件源（CPL）安装|https://tw-cpl.netlify.app/]]\n\n!! Development 开发\n\n欢迎了解实现细节并参与开发，详见[[开发手册|$:/plugins/linonetwo/slate-write/develop]]。\n\n该项目在 [[GitHub tiddly-gittly/slate-write|https://github.com/tiddly-gittly/slate-write]] 仓库里开发，如果你喜欢，请点亮它的星，谢谢。\n\n如果你发现有什么太微语法未得到支持，或者编辑后文本发生了不符合预期的变化，也请到这个仓库里提出你的建议，并附带上完整的复现方式和条目内容。\n\nYou are welcome to learn the implementation details and join the development, read the [[develop manual|$:/plugins/linonetwo/slate-write/develop]] for more information.\n\nThe project is under development in [[GitHub tiddly-gittly/slate-write|https://github.com/tiddly-gittly/slate-write]], give it a star if you like it, thanks.\n\nIf you find some TiddlyWiki wikitext syntax is not supported yet, or if the text changes in a way that is not expected after editing, please also go to this repository and rise an issue, with a complete reproduction example text.\n\n!! FAQ 答疑\n\n!!! How to make this the default editor 如何设为默认编辑器？\n\n* If you want it in edit mode (not recommended, because you may still want to see and edit the source text to use some advanced TW5 feature):\n** By setting tiddler `$:/config/EditorTypeMappings/text/vnd.tiddlywiki` to `slateWrite`, then tiddlywiki will try to use widget `<$edit-slateWrite />` as the editor.\n** Then you will have normal view mode and a WYSIWYG edit draft edit mode\n* If you want it replace the default view mode:\n** Not recommended, because Its macro and widget support is not completed. After its complete, I will make an config to allow set it to default."},"$:/plugins/linonetwo/slate-write/style.css":{"title":"$:/plugins/linonetwo/slate-write/style.css","text":".tw-codeblock-container,\n.tw-widget-code-editor-container {\n\tdisplay: block;\n\tword-break: normal;\n\tword-wrap: break-word;\n\twhite-space: {{$:/themes/tiddlywiki/vanilla/options/codewrapping}};\n\tbackground-color: <<colour pre-background>>;\n\tborder: 1px solid <<colour pre-border>>;\n\tpadding: 0 3px 2px;\n\tborder-radius: 3px;\n\tfont-family: {{$:/themes/tiddlywiki/vanilla/settings/codefontfamily}};\n}\n","creator":"LinOnetwo","tags":"$:/tags/Stylesheet","type":"text/vnd.tiddlywiki"},"$:/plugins/linonetwo/slate-write/ui/ViewTemplate/body/edit-slate-write-cascade-filter":{"title":"$:/plugins/linonetwo/slate-write/ui/ViewTemplate/body/edit-slate-write-cascade-filter","tags":"$:/tags/ViewTemplateBodyFilter","list-before":"$:/config/ViewTemplateBodyFilters/system","text":"[has:field[wysiwyg]then[$:/plugins/linonetwo/slate-write/ui/ViewTemplate/body/edit-slate-write]]"},"$:/plugins/linonetwo/slate-write/ui/ViewTemplate/body/edit-slate-write":{"title":"$:/plugins/linonetwo/slate-write/ui/ViewTemplate/body/edit-slate-write","text":"\\define lingo-base() $:/language/EditTemplate/Body/\n\n<$edit-slateWrite />\n"},"$:/plugins/linonetwo/slate-write/ui/ViewToolbar/images/edit-wysiwyg-button":{"title":"$:/plugins/linonetwo/slate-write/ui/ViewToolbar/images/edit-wysiwyg-button","tags":"$:/tags/Image","text":"<svg width=\"22pt\" height=\"22pt\" class=\"tc-image-edit-button tc-image-wysiwyg-edit-button tc-image-button\" viewBox=\"0 0 128 128\">\n  <g fill-rule=\"evenodd\">\n    <g id=\"svg_1\" fill-rule=\"evenodd\">\n      <path id=\"svg_2\"\n        d=\"m95.627,10.059l-5.656,5.657l11.313,11.313l5.657,-5.656l-11.314,-11.314zm5.657,-5.657l1.966,-1.966c3.123,-3.122 8.194,-3.129 11.319,-0.005c3.117,3.118 3.122,8.192 -0.005,11.32l-1.966,1.965l-11.314,-11.314zm-16.97,16.97l-60.25,60.25a8.12,8.12 0 0 0 -0.322,0.342c-0.1,0.087 -0.198,0.179 -0.295,0.275c-5.735,5.735 -10.702,22.016 -10.702,22.016s16.405,-5.09 22.016,-10.702c0.095,-0.096 0.186,-0.193 0.272,-0.292a8.12,8.12 0 0 0 0.345,-0.325l60.25,-60.25l-11.314,-11.313l0,-0.001zm-49.143,102.818c6.788,-0.577 13.898,-2.272 23.689,-5.348c1.825,-0.573 3.57,-1.136 6.336,-2.04c16,-5.226 21.877,-6.807 28.745,-7.146c8.358,-0.413 13.854,2.13 17.58,8.699a4,4 0 0 0 6.959,-3.946c-5.334,-9.406 -13.745,-13.296 -24.933,-12.744c-7.875,0.39 -14.057,2.052 -30.835,7.533c-2.739,0.894 -4.46,1.45 -6.25,2.012c-19.46,6.112 -30.77,7.072 -39.597,1.747a4,4 0 1 0 -4.132,6.85c6.333,3.82 13.754,5.12 22.438,4.383z\" />\n    </g>\n    <text xml:space=\"preserve\" text-anchor=\"start\" font-family=\"Noto Sans JP\" font-size=\"108\" id=\"svg_11\" y=\"89\" x=\"2\"\n      stroke-width=\"0\">T</text>\n  </g>\n</svg>"},"$:/plugins/linonetwo/slate-write/ui/ViewToolbar/Buttons/edit-wysiwyg":{"title":"$:/plugins/linonetwo/slate-write/ui/ViewToolbar/Buttons/edit-wysiwyg","tags":"$:/tags/ViewToolbar","caption":"{{$:/plugins/linonetwo/slate-write/ui/ViewToolbar/images/edit-wysiwyg-button}} {{$:/language/Buttons/Edit/Caption}}","description":"{{$:/language/Buttons/Edit/Hint}}","text":"\\whitespace trim\n<$list filter=\"[<currentTiddler>field:type[text/vnd.tiddlywiki]]:or[<currentTiddler>field:type[]]\">\n  <$button message=\"tm-edit-wysiwyg-tiddler\" param=<<currentTiddler>> tooltip={{$:/language/Buttons/Edit/Hint}} aria-label={{$:/language/Buttons/Edit/Caption}} class=<<tv-config-toolbar-class>>>\n    <$list filter=\"[<tv-config-toolbar-icons>match[yes]]\">\n      {{$:/plugins/linonetwo/slate-write/ui/ViewToolbar/images/edit-wysiwyg-button}}\n    </$list>\n    <$list filter=\"[<tv-config-toolbar-text>match[yes]]\">\n      <span class=\"tc-btn-text\">\n        <$text text={{$:/language/Buttons/Edit/Caption}}/>\n      </span>\n    </$list>\n  </$button>\n</$list>"},"$:/plugins/linonetwo/slate-write/widget.js":{"title":"$:/plugins/linonetwo/slate-write/widget.js","text":"!function(){if(!$tw.browser)return;const e=require(\"$:/plugins/linonetwo/slate-write/components/index.js\"),{widget:t}=e;exports.slateWrite=t,exports[\"edit-slateWrite\"]=t}();","type":"application/javascript","module-type":"widget"}}}