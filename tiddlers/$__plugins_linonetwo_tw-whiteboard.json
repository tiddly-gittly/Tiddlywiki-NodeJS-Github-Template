{"tiddlers":{"$:/language/Docs/Types/application/tldr":{"title":"$:/language/Docs/Types/application/tldr","description":"Tldraw白板","name":"application/tldr","group":"图像"},"$:/plugins/linonetwo/itonnote/Startup/registerFileType.js":{"title":"$:/plugins/linonetwo/itonnote/Startup/registerFileType.js","text":"$tw.utils.registerFileType(\"application/tldr\",\"utf8\",\".tldr\");","module-type":"startup","type":"application/javascript"},"dist/plugins/linonetwo/tw-whiteboard/components/App.css":{"title":"dist/plugins/linonetwo/tw-whiteboard/components/App.css","text":".tw-whiteboard-tldraw-container {\n  width: 100%;\n  height: 500px;\n  position: relative;\n  /** don't overlap with other dropdown */\n  z-index: 0;\n}\n\n.tw-whiteboard-tldraw-container button:not(.tc-btn-invisible) {\n  padding: unset;\n  margin: unset;\n  border-radius: unset;\n  background-color: unset;\n}"},"$:/plugins/linonetwo/tw-whiteboard/useStyleVariables.css":{"title":"$:/plugins/linonetwo/tw-whiteboard/useStyleVariables.css","text":".tl-container{--tl-zoom:1;--tl-scale:calc(1 / var(--tl-zoom));--tl-padding:calc(64px * max(1, var(--tl-scale)));--tl-performance-all:auto;--tl-performance-selected:auto;position:relative;top:0;left:0;width:100%;height:100%;max-width:100%;max-height:100%;box-sizing:border-box;padding:0;margin:0;z-index:100;overflow:hidden;touch-action:none;overscroll-behavior:none;background-color:var(--tl-background)}.tl-container *{box-sizing:border-box}.tl-overlay{position:absolute;width:100%;height:100%;touch-action:none;pointer-events:none}.tl-grid{position:absolute;width:100%;height:100%;touch-action:none;pointer-events:none;user-select:none}.tl-snap-line,.tl-snap-point{stroke:var(--tl-accent);stroke-width:calc(1px * var(--tl-scale))}.tl-canvas{position:absolute;width:100%;height:100%;touch-action:none;pointer-events:all;overflow:clip}.tl-layer{position:absolute;top:0;left:0;height:0;width:0;contain:layout style size}.tl-absolute{position:absolute;top:0;left:0;transform-origin:center center;contain:layout style size}.tl-positioned{position:absolute;top:0;left:0;transform-origin:center center;pointer-events:none;display:flex;align-items:center;justify-content:center;contain:layout style size;will-change:var(--tl-performance-all)}.tl-positioned-svg{width:100%;height:100%;overflow:hidden;contain:layout style size}.tl-positioned-div{position:relative;width:100%;height:100%;padding:var(--tl-padding);overflow:hidden;contain:layout style size}.tl-positioned-selected{will-change:var(--tl-performance-selected)}.tl-inner-div{position:relative;width:100%;height:100%}.tl-stroke-hitarea{fill:none;stroke:transparent;stroke-width:calc(24px * var(--tl-scale));pointer-events:stroke;stroke-linecap:round;stroke-linejoin:round}.tl-fill-hitarea{fill:transparent;stroke:transparent;stroke-width:calc(24px * var(--tl-scale));pointer-events:all;stroke-linecap:round;stroke-linejoin:round}.tl-counter-scaled{transform:scale(var(--tl-scale))}.tl-dashed{stroke-dasharray:calc(2px * var(--tl-scale)),calc(2px * var(--tl-scale))}.tl-transparent{fill:transparent;stroke:transparent}.tl-cursor-ns{cursor:ns-resize}.tl-cursor-ew{cursor:ew-resize}.tl-cursor-nesw{cursor:nesw-resize}.tl-cursor-nwse{cursor:nwse-resize}.tl-corner-handle{stroke:var(--tl-selectStroke);fill:var(--tl-background);stroke-width:calc(1.5px * var(--tl-scale))}.tl-rotate-handle{stroke:var(--tl-selectStroke);fill:var(--tl-background);stroke-width:calc(1.5px * var(--tl-scale));cursor:grab}.tl-binding{fill:var(--tl-selectFill);stroke:var(--tl-selectStroke);stroke-width:calc(1px * var(--tl-scale));pointer-events:none}.tl-user{left:calc(-15px * var(--tl-scale));top:calc(-15px * var(--tl-scale));height:calc(35px * var(--tl-scale));width:calc(35px * var(--tl-scale));transform:scale(var(--tl-scale));pointer-events:none;will-change:transform}.tl-animated{transition:transform .2s linear}.tl-indicator{fill:transparent;stroke-width:calc(1.5px * var(--tl-scale));pointer-events:none}.tl-user-indicator-bounds{border-style:solid;border-width:calc(1px * var(--tl-scale))}.tl-hovered,.tl-selected{stroke:var(--tl-selectStroke)}.tl-locked{stroke-dasharray:calc(3px * var(--tl-scale)) calc(3px * var(--tl-scale))}.tl-editing{stroke-width:calc(2.5px * min(5,var(--tl-scale)))}.tl-performance{will-change:transform,contents}.tl-clone-target{pointer-events:all}.tl-clone-target:hover .tl-clone-button{opacity:1}.tl-clone-button-target{cursor:pointer;pointer-events:all}.tl-clone-button-target:hover .tl-clone-button{fill:var(--tl-selectStroke)}.tl-clone-button{opacity:0;r:calc(8px * var(--tl-scale));stroke-width:calc(1.5px * var(--tl-scale));stroke:var(--tl-selectStroke);fill:var(--tl-background)}.tl-bounds{pointer-events:none;contain:layout style size}.tl-bounds-bg{stroke:none;fill:var(--tl-selectFill);pointer-events:all;contain:layout style size}.tl-bounds-center{fill:transparent;stroke:var(--tl-selectStroke);stroke-width:calc(1.5px * var(--tl-scale))}.tl-brush{fill:var(--tl-brushFill);stroke:var(--tl-brushStroke);stroke-width:calc(1px * var(--tl-scale));pointer-events:none;contain:layout style size}.tl-dashed-brush-line{fill:none;stroke:var(--tl-brushDashStroke);stroke-width:calc(1px * var(--tl-scale));pointer-events:none}.tl-brush.dashed{stroke:none}.tl-handle{pointer-events:all;cursor:grab;fill:var(--tl-background);stroke:var(--tl-selectStroke);stroke-width:1.5px}.tl-handle:hover .tl-handle-bg{fill:var(--tl-selectFill)}.tl-handle:hover .tl-handle-bg>*{stroke:var(--tl-selectFill)}.tl-handle:active .tl-handle-bg{cursor:grabbing;fill:var(--tl-selectFill)}.tl-handle:active .tl-handle-bg>*{stroke:var(--tl-selectFill)}.tl-handle-bg{fill:transparent;stroke:none;pointer-events:all;r:calc(16px / max(1,var(--tl-zoom)))}.tl-binding-indicator{fill:transparent;stroke:var(--tl-binding)}.tl-centered-g{transform:translate(var(--tl-padding),var(--tl-padding))}.tl-current-parent>[data-shy=true]{opacity:1}.tl-binding{fill:none;stroke:var(--tl-selectStroke);stroke-width:calc(2px * var(--tl-scale))}.tl-grid-dot{fill:var(--tl-grid)}.tl-erase-line{stroke-linejoin:round;stroke-linecap:round;pointer-events:none;fill:var(--tl-grid);opacity:.32}","tags":"$:/tags/Stylesheet","type":"text/css"},"$:/plugins/linonetwo/tw-whiteboard/readme":{"title":"$:/plugins/linonetwo/tw-whiteboard/readme","creator":"LinOnetwo","type":"text/vnd.tiddlywiki","text":"Tiny little drawing app in TW, using tldraw. Providing diagram widget and whiteboard view. \n"},"$:/plugins/linonetwo/tw-whiteboard/Snippets/whiteBoardLoadTiddler":{"title":"$:/plugins/linonetwo/tw-whiteboard/Snippets/whiteBoardLoadTiddler","tags":"$:/tags/TextEditor/Snippet","caption":"WhiteBoard Load Tiddler readonly","text":"<$whiteboard tiddler=\"tldrTiddler\" readonly=\"yes\" zoomToFit=\"yes\" width=\"30%\" height=\"300px\" />"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/EditTemplate/body/EditTemplateBody.css":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/EditTemplate/body/EditTemplateBody.css","text":".tw-whiteboard-edit-body-container {\n  width: 100%;\n  height: 100%;\n  margin-bottom: 20px;\n}","type":"text/vnd.tiddlywiki","tags":"$:/tags/Stylesheet"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/EditTemplate/body/edit-whiteboard-cascade-filter":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/EditTemplate/body/edit-whiteboard-cascade-filter","tags":"$:/tags/EditTemplateBodyFilter","list-before":"$:/config/EditTemplateBodyFilters/default","text":"[field:type[application/tldr]then[$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/EditTemplate/body/edit-whiteboard]]"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/EditTemplate/body/edit-whiteboard":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/EditTemplate/body/edit-whiteboard","text":"\\define lingo-base() $:/language/EditTemplate/Body/\n\n<div class=\"tw-whiteboard-edit-body-container\">\n<!-- always get real tiddler title, prevent getting `\"Draft of 'AAA'\"` from <<currentTiddler>> when in draft mode. -->\n<$set name=\"tiddler\" value={{!!draft.title}} emptyValue=<<currentTiddler>>>\n<$edit-whiteboard tiddler=<<tiddler>> draftTitle={{!!draft.title}} height=\"500px\" />\n</$set>\n</div>"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/PageLayout/CreateNewTiddlerPopup":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/PageLayout/CreateNewTiddlerPopup","text":"<div class=\"tw-whiteboard-layout-create-new-tiddler-popup\">\n  <$edit-text focus=\"yes\" tiddler=\"$:/state/Whiteboard/PageLayout/create-tiddler\" default=\"\" rows=1 />\n  <$button>\n    Create\n    <$action-createtiddler $basetitle={{$:/state/Whiteboard/PageLayout/create-tiddler}} type=\"application/tldr\" />\n    <$action-setfield $tiddler=\"$:/state/Whiteboard/PageLayout/create-tiddler\" text=\"\"/>\n  </$button>\n</div>"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/PageLayout/WhiteBoardLayout.css":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/PageLayout/WhiteBoardLayout.css","text":".tw-whiteboard-layout-top-bar {\n  position: absolute;\n  z-index: 1;\n  top: 0;\n\n  width: 400px;\n  left: calc(50% - 400px / 2);\n  padding: 5px;\n\n  background-color: rgba(255, 255, 255, 0.5);\n  backdrop-filter: blur(5px);\n\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.tw-whiteboard-layout-top-bar > select {\n  max-width: 200px;\n}\n\n.tw-whiteboard-layout-main-area {\n}\n\ndiv.tw-whiteboard-layout-container {\n  margin-top: 0px;\n}\n.tw-whiteboard-layout-container p {\n  margin: 0;\n}\n\n.tw-whiteboard-layout-create-new-tiddler-popup {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  width: 200px;\n}\n.tw-whiteboard-layout-create-new-tiddler-popup button {\n  width: 100%;\n}\n.tw-whiteboard-layout-create-new-tiddler-popup textarea {\n  width: 100%;\n}\n","type":"text/vnd.tiddlywiki","tags":"$:/tags/Stylesheet"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/PageLayout/WhiteBoard":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/PageLayout/WhiteBoard","name":"White Board","description":"show `application/tldr` type tiddlers in full screen whiteboard","tags":"$:/tags/Layout","text":"\\whitespace trim\n\\define containerClasses()\ntc-page-container tc-page-view-$(storyviewTitle)$ tc-language-$(languageTitle)$ tw-whiteboard-layout-container\n\\end\n\\import [[$:/core/ui/PageMacros]] [all[shadows+tiddlers]tag[$:/tags/Macro]!has[draft.of]]\n\n<$vars\n\ttv-config-toolbar-icons={{$:/config/Toolbar/Icons}}\n\ttv-config-toolbar-text={{$:/config/Toolbar/Text}}\n\ttv-config-toolbar-class={{$:/config/Toolbar/ButtonClass}}\n\ttv-show-missing-links={{$:/config/MissingLinks}}\n\tstoryviewTitle={{$:/view}}\n\tlanguageTitle={{{ [{$:/language}get[name]] }}}>\n\n<div class=<<containerClasses>>>\n\n<$navigator story=\"$:/StoryList\" history=\"$:/HistoryList\" openLinkFromInsideRiver={{$:/config/Navigation/openLinkFromInsideRiver}} openLinkFromOutsideRiver={{$:/config/Navigation/openLinkFromOutsideRiver}} relinkOnRename={{$:/config/RelinkOnRename}}>\n\n<main class=\"tw-whiteboard-layout-main-area\">\n\t<$reveal state=\"$:/state/Whiteboard/PageLayout/tiddler\" type=\"nomatch\" text=\"\">\n\t\t<$whiteboard tiddler={{$:/state/Whiteboard/PageLayout/tiddler}} height=\"calc(100vh - 35px)\" />\n\t</$reveal>\n\t<!-- default value, when first opened, select widget's state tiddler is empty, but default value filter gives a value, we show that tiddler -->\n\t<$reveal state=\"$:/state/Whiteboard/PageLayout/tiddler\" type=\"match\" text=\"\">\n\t\t<$list filter='[all[shadows+tiddlers]field:type[application/tldr]sort[modified]first[]]'>\n\t\t\t<$whiteboard tiddler={{{[all[shadows+tiddlers]field:type[application/tldr]sort[modified]first[]]}}} height=\"calc(100vh - 35px)\" />\n\t\t</$list>\n\t</$reveal>\n</main>\n\n<!-- put this below main, so nav bar is layered on top of the main. In UI, this nav in on the top of the page. -->\n<nav class=\"tw-whiteboard-layout-top-bar\">\n\tSelect board: \n\t<!-- default to recently used whiteboard tiddler -->\n\t<$select tiddler=\"$:/state/Whiteboard/PageLayout/tiddler\" default={{{[all[shadows+tiddlers]field:type[application/tldr]sort[modified]first[]]}}}>\n\t\t<$list filter='[all[shadows+tiddlers]field:type[application/tldr]sort[modified]]'>\n\t\t\t<option value=<<currentTiddler>>><$view field='title'/></option>\n\t\t</$list>\n\t</$select>\n\n\t<$button tooltip=\"New\" popup=\"$:/state/Whiteboard/PageLayout/CreateNewTiddlerPopup\">{{$:/core/images/new-button}}</$button>\n\t<$reveal type=\"popup\" state=\"$:/state/Whiteboard/PageLayout/CreateNewTiddlerPopup\">\n\t\t{{$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/PageLayout/CreateNewTiddlerPopup}}\n\t</$reveal>\n\n\t<$reveal state=\"$:/state/Whiteboard/PageLayout/tiddler\" type=\"nomatch\" text=\"\">\n\t\t<$button tooltip=\"Open In StoryView\">\n\t\t\t{{$:/core/images/home-button}}\n\t\t\t<$action-setfield $tiddler=\"$:/layout\" text=\"$:/core/ui/PageTemplate\"/>\n\t\t\t<$action-navigate $to={{$:/state/Whiteboard/PageLayout/tiddler}}/>\n\t\t</$button>\n\t</$reveal>\n\t<!-- default value, when first opened, select widget's state tiddler is empty, but default value filter gives a value, we show that tiddler -->\n\t<$reveal state=\"$:/state/Whiteboard/PageLayout/tiddler\" type=\"match\" text=\"\">\n\t\t<$list filter='[all[shadows+tiddlers]field:type[application/tldr]sort[modified]first[]]'>\n\t\t\t<$button tooltip=\"Open In StoryView\">\n\t\t\t\t{{$:/core/images/home-button}}\n\t\t\t\t<$action-setfield $tiddler=\"$:/layout\" text=\"$:/core/ui/PageTemplate\"/>\n\t\t\t\t<$action-navigate $to={{{[all[shadows+tiddlers]field:type[application/tldr]sort[modified]first[]]}}} />\n\t\t\t</$button>\n\t\t</$list>\n\t</$reveal>\n</nav>\n\n</$navigator>\n\n</div>\n\n</$vars>"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewTemplate/body/view-whiteboard-cascade-filter":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewTemplate/body/view-whiteboard-cascade-filter","tags":"$:/tags/ViewTemplateBodyFilter","list-before":"$:/config/ViewTemplateBodyFilters/system","text":"[field:type[application/tldr]then[$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewTemplate/body/view-whiteboard]]"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewTemplate/body/view-whiteboard":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewTemplate/body/view-whiteboard","text":"\\define lingo-base() $:/language/ViewTemplate/Body/\n\n<$whiteboard tiddler=<<currentTiddler>> readonly=\"yes\" height=\"500px\" />\n"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewToolbar/Buttons/OpenInFullScreenWhiteBoardButton":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewToolbar/Buttons/OpenInFullScreenWhiteBoardButton","tags":"$:/tags/ViewToolbar","caption":"{{$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewToolbar/images/OpenInFullScreenWhiteBoardButtonImage}} {{$:/language/Buttons/Edit/Caption}}","description":"{{$:/language/Buttons/Edit/Hint}}","text":"\\whitespace trim\n<$list filter=\"[<currentTiddler>field:type[application/tldr]]\" variable=\"ignore\">\n  <$button tooltip={{$:/language/Buttons/Edit/Hint}} aria-label={{$:/language/Buttons/Edit/Caption}} class=<<tv-config-toolbar-class>> >\n    <$action-setfield $tiddler=\"$:/layout\" text=\"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/PageLayout/WhiteBoard\"/>\n    <$action-setfield $tiddler=\"$:/state/Whiteboard/PageLayout/tiddler\" text=<<currentTiddler>> />\n\n    <$list filter=\"[<tv-config-toolbar-icons>match[yes]]\">\n      {{$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewToolbar/images/OpenInFullScreenWhiteBoardButtonImage}}\n    </$list>\n    <$list filter=\"[<tv-config-toolbar-text>match[yes]]\">\n      <span class=\"tc-btn-text\">\n        <$text text={{$:/language/Buttons/Edit/Caption}}/>\n      </span>\n    </$list>\n  </$button>\n</$list>"},"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewToolbar/images/OpenInFullScreenWhiteBoardButtonImage":{"title":"$:/plugins/linonetwo/tw-whiteboard/tiddlywiki-ui/ViewToolbar/images/OpenInFullScreenWhiteBoardButtonImage","tags":"$:/tags/Image","text":"<svg width=\"22pt\" height=\"22pt\" class=\"tc-image-edit-button tc-image-whiteboard-edit-button tc-image-button\" viewBox=\"0 0 128 128\">\n  <g fill-rule=\"evenodd\">\n    <g id=\"svg_1\" fill-rule=\"evenodd\">\n      <path id=\"svg_2\"\n        d=\"m95.627,10.059l-5.656,5.657l11.313,11.313l5.657,-5.656l-11.314,-11.314zm5.657,-5.657l1.966,-1.966c3.123,-3.122 8.194,-3.129 11.319,-0.005c3.117,3.118 3.122,8.192 -0.005,11.32l-1.966,1.965l-11.314,-11.314zm-16.97,16.97l-60.25,60.25a8.12,8.12 0 0 0 -0.322,0.342c-0.1,0.087 -0.198,0.179 -0.295,0.275c-5.735,5.735 -10.702,22.016 -10.702,22.016s16.405,-5.09 22.016,-10.702c0.095,-0.096 0.186,-0.193 0.272,-0.292a8.12,8.12 0 0 0 0.345,-0.325l60.25,-60.25l-11.314,-11.313l0,-0.001zm-49.143,102.818c6.788,-0.577 13.898,-2.272 23.689,-5.348c1.825,-0.573 3.57,-1.136 6.336,-2.04c16,-5.226 21.877,-6.807 28.745,-7.146c8.358,-0.413 13.854,2.13 17.58,8.699a4,4 0 0 0 6.959,-3.946c-5.334,-9.406 -13.745,-13.296 -24.933,-12.744c-7.875,0.39 -14.057,2.052 -30.835,7.533c-2.739,0.894 -4.46,1.45 -6.25,2.012c-19.46,6.112 -30.77,7.072 -39.597,1.747a4,4 0 1 0 -4.132,6.85c6.333,3.82 13.754,5.12 22.438,4.383z\" />\n    </g>\n    <text xml:space=\"preserve\" text-anchor=\"start\" font-family=\"Noto Sans JP\" font-size=\"108\" id=\"svg_11\" y=\"89\" x=\"2\"\n      stroke-width=\"0\">Bo</text>\n  </g>\n</svg>"},"$:/plugins/linonetwo/tw-whiteboard/widget-loader.js":{"title":"$:/plugins/linonetwo/tw-whiteboard/widget-loader.js","text":"!function(){if(!$tw.browser)return;const t=require(\"$:/plugins/linonetwo/tw-whiteboard/widget.js\"),{whiteboard:e}=t;exports.whiteboard=e,exports[\"edit-whiteboard\"]=e}();","type":"application/javascript","module-type":"widget"},"$:/plugins/linonetwo/tw-whiteboard/widget.css":{"title":"$:/plugins/linonetwo/tw-whiteboard/widget.css","text":"/* src/components/App.css */\n.tw-whiteboard-tldraw-container {\n  width: 100%;\n  height: 500px;\n  position: relative;\n  z-index: 0;\n}\n.tw-whiteboard-tldraw-container button:not(.tc-btn-invisible) {\n  padding: unset;\n  margin: unset;\n  border-radius: unset;\n  background-color: unset;\n}\n","type":"text/vnd.tiddlywiki","tags":"$:/tags/Stylesheet"},"$:/plugins/linonetwo/tw-whiteboard/widget.js":{"title":"$:/plugins/linonetwo/tw-whiteboard/widget.js","text":"\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// node_modules/.pnpm/lodash.debounce@4.0.8/node_modules/lodash.debounce/index.js\nvar require_lodash = __commonJS({\n  \"node_modules/.pnpm/lodash.debounce@4.0.8/node_modules/lodash.debounce/index.js\"(exports2, module2) {\n    var FUNC_ERROR_TEXT = \"Expected a function\";\n    var NAN = 0 / 0;\n    var symbolTag = \"[object Symbol]\";\n    var reTrim = /^\\s+|\\s+$/g;\n    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n    var reIsBinary = /^0b[01]+$/i;\n    var reIsOctal = /^0o[0-7]+$/i;\n    var freeParseInt = parseInt;\n    var freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\n    var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n    var root = freeGlobal || freeSelf || Function(\"return this\")();\n    var objectProto = Object.prototype;\n    var objectToString = objectProto.toString;\n    var nativeMax = Math.max;\n    var nativeMin = Math.min;\n    var now = function() {\n      return root.Date.now();\n    };\n    function debounce2(func, wait, options) {\n      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n      if (typeof func != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = \"maxWait\" in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n      }\n      function invokeFunc(time) {\n        var args = lastArgs, thisArg = lastThis;\n        lastArgs = lastThis = void 0;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n      function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = setTimeout(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n      }\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;\n        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;\n      }\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n      }\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n      function trailingEdge(time) {\n        timerId = void 0;\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = void 0;\n        return result;\n      }\n      function cancel() {\n        if (timerId !== void 0) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = void 0;\n      }\n      function flush() {\n        return timerId === void 0 ? result : trailingEdge(now());\n      }\n      function debounced() {\n        var time = now(), isInvoking = shouldInvoke(time);\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n          if (timerId === void 0) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === void 0) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n    function isObject(value) {\n      var type = typeof value;\n      return !!value && (type == \"object\" || type == \"function\");\n    }\n    function isObjectLike(value) {\n      return !!value && typeof value == \"object\";\n    }\n    function isSymbol(value) {\n      return typeof value == \"symbol\" || isObjectLike(value) && objectToString.call(value) == symbolTag;\n    }\n    function toNumber(value) {\n      if (typeof value == \"number\") {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n        value = isObject(other) ? other + \"\" : other;\n      }\n      if (typeof value != \"string\") {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, \"\");\n      var isBinary = reIsBinary.test(value);\n      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n    }\n    module2.exports = debounce2;\n  }\n});\n\n// node_modules/.pnpm/tw-react@0.4.6_react-dom@18.2.0_react@18.2.0/node_modules/tw-react/dist/plugins/linonetwo/tw-react/index.js\nvar require_tw_react = __commonJS({\n  \"node_modules/.pnpm/tw-react@0.4.6_react-dom@18.2.0_react@18.2.0/node_modules/tw-react/dist/plugins/linonetwo/tw-react/index.js\"(exports2, module2) {\n    \"use strict\";\n    var __defProp2 = Object.defineProperty;\n    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;\n    var __getOwnPropNames2 = Object.getOwnPropertyNames;\n    var __hasOwnProp2 = Object.prototype.hasOwnProperty;\n    var __export = (target, all) => {\n      for (var name in all)\n        __defProp2(target, name, { get: all[name], enumerable: true });\n    };\n    var __copyProps2 = (to, from, except, desc) => {\n      if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames2(from))\n          if (!__hasOwnProp2.call(to, key) && key !== except)\n            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });\n      }\n      return to;\n    };\n    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, \"__esModule\", { value: true }), mod);\n    var src_exports = {};\n    __export(src_exports, {\n      ParentWidgetContext: () => ParentWidgetContext2,\n      useFilter: () => useFilter,\n      useRenderTiddler: () => useRenderTiddler,\n      useWidget: () => useWidget2\n    });\n    module2.exports = __toCommonJS(src_exports);\n    var import_react43 = require(\"react\");\n    function useFilter(twFilter, widget = $tw.rootWidget, dependencies = []) {\n      const [filterResult, setFilterResult] = (0, import_react43.useState)([]);\n      const compiledFilter = (0, import_react43.useMemo)(() => $tw.wiki.compileFilter(twFilter), [twFilter]);\n      (0, import_react43.useEffect)(() => {\n        setFilterResult(compiledFilter(void 0, widget));\n      }, [compiledFilter, widget, ...dependencies]);\n      return filterResult;\n    }\n    var import_react310 = require(\"react\");\n    var import_react210 = require(\"react\");\n    var ParentWidgetContext2 = (0, import_react210.createContext)(void 0);\n    function useRenderTiddler(tiddlerTitle, containerReference, options) {\n      const parentWidget = (0, import_react310.useContext)(ParentWidgetContext2);\n      (0, import_react310.useEffect)(() => {\n        const domNode = containerReference.current;\n        if (domNode === null) {\n          return;\n        }\n        if (parentWidget === void 0) {\n          throw new Error(\n            \"Your plugin have a bug: `parentWidget` is undefined, you should use `<ParentWidgetContext.Provider value={props.parentWidget}>`, see tw-react for document.\"\n          );\n        }\n        if (options?.skip === true) {\n          return;\n        }\n        const id = String(Math.random());\n        const transcludeWidgetNode = $tw.wiki.makeTranscludeWidget(tiddlerTitle, {\n          document,\n          parentWidget,\n          recursionMarker: \"yes\",\n          mode: \"block\",\n          importPageMacros: true,\n          variables: { \"use-widget-id\": id }\n        });\n        const tiddlerContainer = document.createElement(\"div\");\n        domNode.append(tiddlerContainer);\n        transcludeWidgetNode.render(tiddlerContainer, null);\n        parentWidget.children.push(transcludeWidgetNode);\n        return () => {\n          parentWidget.children = parentWidget.children.filter((child) => child.getVariable(\"use-widget-id\") !== id);\n          if (domNode === null) {\n            return;\n          }\n          domNode.textContent = \"\";\n        };\n      }, [tiddlerTitle, containerReference]);\n    }\n    var import_react44 = require(\"react\");\n    function useWidget2(parseTreeNode, containerReference, options) {\n      const parentWidget = (0, import_react44.useContext)(ParentWidgetContext2);\n      (0, import_react44.useEffect)(() => {\n        const domNode = containerReference.current;\n        if (domNode === null) {\n          return;\n        }\n        if (parentWidget === void 0) {\n          throw new Error(\n            \"Your plugin have a bug: `parentWidget` is undefined, you should use `<ParentWidgetContext.Provider value={props.parentWidget}>`, see tw-react for document.\"\n          );\n        }\n        if (options?.skip === true) {\n          return;\n        }\n        const id = String(Math.random());\n        const newWidgetNode = parentWidget.makeChildWidget(parseTreeNode, { variables: { \"use-widget-id\": id } });\n        newWidgetNode.render(domNode, null);\n        parentWidget.children.push(newWidgetNode);\n        return () => {\n          parentWidget.children = parentWidget.children.filter((child) => child.getVariable(\"use-widget-id\") !== id);\n          if (domNode === null) {\n            return;\n          }\n          domNode.textContent = \"\";\n        };\n      }, [parseTreeNode, containerReference, parentWidget, options?.skip]);\n    }\n  }\n});\n\n// node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\nvar require_use_sync_external_store_shim_development = __commonJS({\n  \"node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\"(exports2) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var React50 = require(\"react\");\n        var ReactSharedInternals = React50.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n          {\n            {\n              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                args[_key2 - 1] = arguments[_key2];\n              }\n              printWarning(\"error\", format, args);\n            }\n          }\n        }\n        function printWarning(level, format, args) {\n          {\n            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n            var stack = ReactDebugCurrentFrame.getStackAddendum();\n            if (stack !== \"\") {\n              format += \"%s\";\n              args = args.concat([stack]);\n            }\n            var argsWithFormat = args.map(function(item) {\n              return String(item);\n            });\n            argsWithFormat.unshift(\"Warning: \" + format);\n            Function.prototype.apply.call(console[level], console, argsWithFormat);\n          }\n        }\n        function is(x5, y6) {\n          return x5 === y6 && (x5 !== 0 || 1 / x5 === 1 / y6) || x5 !== x5 && y6 !== y6;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        var useState16 = React50.useState, useEffect24 = React50.useEffect, useLayoutEffect12 = React50.useLayoutEffect, useDebugValue2 = React50.useDebugValue;\n        var didWarnOld18Alpha = false;\n        var didWarnUncachedGetSnapshot = false;\n        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n          {\n            if (!didWarnOld18Alpha) {\n              if (React50.startTransition !== void 0) {\n                didWarnOld18Alpha = true;\n                error(\"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\");\n              }\n            }\n          }\n          var value = getSnapshot();\n          {\n            if (!didWarnUncachedGetSnapshot) {\n              var cachedValue = getSnapshot();\n              if (!objectIs(value, cachedValue)) {\n                error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                didWarnUncachedGetSnapshot = true;\n              }\n            }\n          }\n          var _useState = useState16({\n            inst: {\n              value,\n              getSnapshot\n            }\n          }), inst = _useState[0].inst, forceUpdate = _useState[1];\n          useLayoutEffect12(function() {\n            inst.value = value;\n            inst.getSnapshot = getSnapshot;\n            if (checkIfSnapshotChanged(inst)) {\n              forceUpdate({\n                inst\n              });\n            }\n          }, [subscribe, value, getSnapshot]);\n          useEffect24(function() {\n            if (checkIfSnapshotChanged(inst)) {\n              forceUpdate({\n                inst\n              });\n            }\n            var handleStoreChange = function() {\n              if (checkIfSnapshotChanged(inst)) {\n                forceUpdate({\n                  inst\n                });\n              }\n            };\n            return subscribe(handleStoreChange);\n          }, [subscribe]);\n          useDebugValue2(value);\n          return value;\n        }\n        function checkIfSnapshotChanged(inst) {\n          var latestGetSnapshot = inst.getSnapshot;\n          var prevValue = inst.value;\n          try {\n            var nextValue = latestGetSnapshot();\n            return !objectIs(prevValue, nextValue);\n          } catch (error2) {\n            return true;\n          }\n        }\n        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n          return getSnapshot();\n        }\n        var canUseDOM = !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\n        var isServerEnvironment = !canUseDOM;\n        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\n        var useSyncExternalStore$2 = React50.useSyncExternalStore !== void 0 ? React50.useSyncExternalStore : shim;\n        exports2.useSyncExternalStore = useSyncExternalStore$2;\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n      })();\n    }\n  }\n});\n\n// node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/index.js\nvar require_shim = __commonJS({\n  \"node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/index.js\"(exports2, module2) {\n    \"use strict\";\n    if (false) {\n      module2.exports = null;\n    } else {\n      module2.exports = require_use_sync_external_store_shim_development();\n    }\n  }\n});\n\n// node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\nvar require_with_selector_development = __commonJS({\n  \"node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\"(exports2) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var React50 = require(\"react\");\n        var shim = require_shim();\n        function is(x5, y6) {\n          return x5 === y6 && (x5 !== 0 || 1 / x5 === 1 / y6) || x5 !== x5 && y6 !== y6;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        var useSyncExternalStore = shim.useSyncExternalStore;\n        var useRef26 = React50.useRef, useEffect24 = React50.useEffect, useMemo14 = React50.useMemo, useDebugValue2 = React50.useDebugValue;\n        function useSyncExternalStoreWithSelector2(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n          var instRef = useRef26(null);\n          var inst;\n          if (instRef.current === null) {\n            inst = {\n              hasValue: false,\n              value: null\n            };\n            instRef.current = inst;\n          } else {\n            inst = instRef.current;\n          }\n          var _useMemo = useMemo14(function() {\n            var hasMemo = false;\n            var memoizedSnapshot;\n            var memoizedSelection;\n            var memoizedSelector = function(nextSnapshot) {\n              if (!hasMemo) {\n                hasMemo = true;\n                memoizedSnapshot = nextSnapshot;\n                var _nextSelection = selector(nextSnapshot);\n                if (isEqual !== void 0) {\n                  if (inst.hasValue) {\n                    var currentSelection = inst.value;\n                    if (isEqual(currentSelection, _nextSelection)) {\n                      memoizedSelection = currentSelection;\n                      return currentSelection;\n                    }\n                  }\n                }\n                memoizedSelection = _nextSelection;\n                return _nextSelection;\n              }\n              var prevSnapshot = memoizedSnapshot;\n              var prevSelection = memoizedSelection;\n              if (objectIs(prevSnapshot, nextSnapshot)) {\n                return prevSelection;\n              }\n              var nextSelection = selector(nextSnapshot);\n              if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {\n                return prevSelection;\n              }\n              memoizedSnapshot = nextSnapshot;\n              memoizedSelection = nextSelection;\n              return nextSelection;\n            };\n            var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;\n            var getSnapshotWithSelector = function() {\n              return memoizedSelector(getSnapshot());\n            };\n            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {\n              return memoizedSelector(maybeGetServerSnapshot());\n            };\n            return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n          }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];\n          var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n          useEffect24(function() {\n            inst.hasValue = true;\n            inst.value = value;\n          }, [value]);\n          useDebugValue2(value);\n          return value;\n        }\n        exports2.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector2;\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n      })();\n    }\n  }\n});\n\n// node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/with-selector.js\nvar require_with_selector = __commonJS({\n  \"node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/with-selector.js\"(exports2, module2) {\n    \"use strict\";\n    if (false) {\n      module2.exports = null;\n    } else {\n      module2.exports = require_with_selector_development();\n    }\n  }\n});\n\n// node_modules/.pnpm/requestidlecallback-polyfill@1.0.2/node_modules/requestidlecallback-polyfill/index.js\nwindow.requestIdleCallback = window.requestIdleCallback || function(cb) {\n  var start = Date.now();\n  return setTimeout(function() {\n    cb({\n      didTimeout: false,\n      timeRemaining: function() {\n        return Math.max(0, 50 - (Date.now() - start));\n      }\n    });\n  }, 1);\n};\nwindow.cancelIdleCallback = window.cancelIdleCallback || function(id) {\n  clearTimeout(id);\n};\n\n// node_modules/.pnpm/beautiful-react-hooks@4.3.0_react-dom@18.2.0_react-router-dom@6.11.2_react@18.2.0_rxjs@7.8.1/node_modules/beautiful-react-hooks/esm/useDebouncedCallback.js\nvar import_react3 = require(\"react\");\nvar import_lodash = __toESM(require_lodash());\n\n// node_modules/.pnpm/beautiful-react-hooks@4.3.0_react-dom@18.2.0_react-router-dom@6.11.2_react@18.2.0_rxjs@7.8.1/node_modules/beautiful-react-hooks/esm/useWillUnmount.js\nvar import_react2 = require(\"react\");\n\n// node_modules/.pnpm/beautiful-react-hooks@4.3.0_react-dom@18.2.0_react-router-dom@6.11.2_react@18.2.0_rxjs@7.8.1/node_modules/beautiful-react-hooks/esm/shared/isFunction.js\nvar isFunction = (functionToCheck) => typeof functionToCheck === \"function\" && !!functionToCheck.constructor && !!functionToCheck.call && !!functionToCheck.apply;\nvar isFunction_default = isFunction;\n\n// node_modules/.pnpm/beautiful-react-hooks@4.3.0_react-dom@18.2.0_react-router-dom@6.11.2_react@18.2.0_rxjs@7.8.1/node_modules/beautiful-react-hooks/esm/factory/createHandlerSetter.js\nvar import_react = require(\"react\");\nvar createHandlerSetter = (callback) => {\n  const handlerRef = (0, import_react.useRef)(callback);\n  const setHandler = (0, import_react.useRef)((nextCallback) => {\n    if (typeof nextCallback !== \"function\") {\n      throw new Error(\"the argument supplied to the 'setHandler' function should be of type function\");\n    }\n    handlerRef.current = nextCallback;\n  });\n  return [handlerRef, setHandler.current];\n};\nvar createHandlerSetter_default = createHandlerSetter;\n\n// node_modules/.pnpm/beautiful-react-hooks@4.3.0_react-dom@18.2.0_react-router-dom@6.11.2_react@18.2.0_rxjs@7.8.1/node_modules/beautiful-react-hooks/esm/useWillUnmount.js\nvar useWillUnmount = (callback) => {\n  const mountRef = (0, import_react2.useRef)(false);\n  const [handler, setHandler] = createHandlerSetter_default(callback);\n  (0, import_react2.useEffect)(() => {\n    mountRef.current = true;\n    return () => {\n      if (isFunction_default(handler === null || handler === void 0 ? void 0 : handler.current) && mountRef.current) {\n        handler.current();\n      }\n    };\n  }, []);\n  return setHandler;\n};\nvar useWillUnmount_default = useWillUnmount;\n\n// node_modules/.pnpm/beautiful-react-hooks@4.3.0_react-dom@18.2.0_react-router-dom@6.11.2_react@18.2.0_rxjs@7.8.1/node_modules/beautiful-react-hooks/esm/useDebouncedCallback.js\nvar defaultOptions = {\n  leading: false,\n  trailing: true\n};\nvar useDebouncedCallback = (fn2, dependencies, wait = 600, options = defaultOptions) => {\n  const debounced = (0, import_react3.useRef)((0, import_lodash.default)(fn2, wait, options));\n  (0, import_react3.useEffect)(() => {\n    debounced.current = (0, import_lodash.default)(fn2, wait, options);\n  }, [fn2, wait, options]);\n  useWillUnmount_default(() => {\n    var _a;\n    (_a = debounced.current) === null || _a === void 0 ? void 0 : _a.cancel();\n  });\n  return (0, import_react3.useCallback)(debounced.current, dependencies !== null && dependencies !== void 0 ? dependencies : []);\n};\nvar useDebouncedCallback_default = useDebouncedCallback;\n\n// src/components/App.tsx\nvar import_react42 = require(\"react\");\nvar import_tw_react2 = __toESM(require_tw_react());\n\n// src/components/Tldraw/Tldraw.tsx\nvar React49 = __toESM(require(\"react\"));\n\n// node_modules/.pnpm/@tldraw+core@1.23.2_react-dom@18.2.0_react@18.2.0/node_modules/@tldraw/core/dist/index.mjs\nvar N2 = __toESM(require(\"react\"), 1);\nvar D2 = __toESM(require(\"react\"), 1);\nvar z2 = __toESM(require(\"react\"), 1);\nvar Ye = __toESM(require(\"react\"), 1);\nvar Se2 = __toESM(require(\"react\"), 1);\n\n// node_modules/.pnpm/@tldraw+vec@1.9.2/node_modules/@tldraw/vec/dist/index.mjs\nvar h = Object.defineProperty;\nvar d = (s5, n5, r5) => n5 in s5 ? h(s5, n5, { enumerable: true, configurable: true, writable: true, value: r5 }) : s5[n5] = r5;\nvar m = (s5, n5, r5) => (d(s5, typeof n5 != \"symbol\" ? n5 + \"\" : n5, r5), r5);\nvar t = class {\n  static clamp(n5, r5, u5) {\n    return Math.max(r5, typeof u5 != \"undefined\" ? Math.min(n5, u5) : n5);\n  }\n  static clampV(n5, r5, u5) {\n    return n5.map((b6) => u5 ? t.clamp(b6, r5, u5) : t.clamp(b6, r5));\n  }\n  static cross(n5, r5, u5) {\n    return (r5[0] - n5[0]) * (u5[1] - n5[1]) - (u5[0] - n5[0]) * (r5[1] - n5[1]);\n  }\n  static snap(n5, r5 = 1) {\n    return [Math.round(n5[0] / r5) * r5, Math.round(n5[1] / r5) * r5];\n  }\n};\nvar e = t;\nm(e, \"neg\", (n5) => [-n5[0], -n5[1]]), m(e, \"add\", (n5, r5) => [n5[0] + r5[0], n5[1] + r5[1]]), m(e, \"addScalar\", (n5, r5) => [n5[0] + r5, n5[1] + r5]), m(e, \"sub\", (n5, r5) => [n5[0] - r5[0], n5[1] - r5[1]]), m(e, \"subScalar\", (n5, r5) => [n5[0] - r5, n5[1] - r5]), m(e, \"vec\", (n5, r5) => [r5[0] - n5[0], r5[1] - n5[1]]), m(e, \"mul\", (n5, r5) => [n5[0] * r5, n5[1] * r5]), m(e, \"mulV\", (n5, r5) => [n5[0] * r5[0], n5[1] * r5[1]]), m(e, \"div\", (n5, r5) => [n5[0] / r5, n5[1] / r5]), m(e, \"divV\", (n5, r5) => [n5[0] / r5[0], n5[1] / r5[1]]), m(e, \"per\", (n5) => [n5[1], -n5[0]]), m(e, \"dpr\", (n5, r5) => n5[0] * r5[0] + n5[1] * r5[1]), m(e, \"cpr\", (n5, r5) => n5[0] * r5[1] - r5[0] * n5[1]), m(e, \"len2\", (n5) => n5[0] * n5[0] + n5[1] * n5[1]), m(e, \"len\", (n5) => Math.hypot(n5[0], n5[1])), m(e, \"pry\", (n5, r5) => t.dpr(n5, r5) / t.len(r5)), m(e, \"uni\", (n5) => t.div(n5, t.len(n5))), m(e, \"normalize\", (n5) => t.uni(n5)), m(e, \"tangent\", (n5, r5) => t.uni(t.sub(n5, r5))), m(e, \"dist2\", (n5, r5) => t.len2(t.sub(n5, r5))), m(e, \"dist\", (n5, r5) => Math.hypot(n5[1] - r5[1], n5[0] - r5[0])), m(e, \"fastDist\", (n5, r5) => {\n  let u5 = [r5[0] - n5[0], r5[1] - n5[1]], b6 = [Math.abs(u5[0]), Math.abs(u5[1])], a7 = 1 / Math.max(b6[0], b6[1]);\n  return a7 = a7 * (1.29289 - (b6[0] + b6[1]) * a7 * 0.29289), [u5[0] * a7, u5[1] * a7];\n}), m(e, \"ang\", (n5, r5) => Math.atan2(t.cpr(n5, r5), t.dpr(n5, r5))), m(e, \"angle\", (n5, r5) => Math.atan2(r5[1] - n5[1], r5[0] - n5[0])), m(e, \"med\", (n5, r5) => t.mul(t.add(n5, r5), 0.5)), m(e, \"rot\", (n5, r5 = 0) => [n5[0] * Math.cos(r5) - n5[1] * Math.sin(r5), n5[0] * Math.sin(r5) + n5[1] * Math.cos(r5)]), m(e, \"rotWith\", (n5, r5, u5 = 0) => {\n  if (u5 === 0)\n    return n5;\n  let b6 = Math.sin(u5), a7 = Math.cos(u5), i4 = n5[0] - r5[0], o5 = n5[1] - r5[1], c5 = i4 * a7 - o5 * b6, l7 = i4 * b6 + o5 * a7;\n  return [c5 + r5[0], l7 + r5[1]];\n}), m(e, \"isEqual\", (n5, r5) => n5[0] === r5[0] && n5[1] === r5[1]), m(e, \"lrp\", (n5, r5, u5) => t.add(n5, t.mul(t.sub(r5, n5), u5))), m(e, \"int\", (n5, r5, u5, b6, a7 = 1) => {\n  let i4 = (t.clamp(u5, b6) - u5) / (b6 - u5);\n  return t.add(t.mul(n5, 1 - i4), t.mul(r5, a7));\n}), m(e, \"ang3\", (n5, r5, u5) => {\n  let b6 = t.vec(r5, n5), a7 = t.vec(r5, u5);\n  return t.ang(b6, a7);\n}), m(e, \"abs\", (n5) => [Math.abs(n5[0]), Math.abs(n5[1])]), m(e, \"rescale\", (n5, r5) => {\n  let u5 = t.len(n5);\n  return [r5 * n5[0] / u5, r5 * n5[1] / u5];\n}), m(e, \"isLeft\", (n5, r5, u5) => (r5[0] - n5[0]) * (u5[1] - n5[1]) - (u5[0] - n5[0]) * (r5[1] - n5[1])), m(e, \"clockwise\", (n5, r5, u5) => t.isLeft(n5, r5, u5) > 0), m(e, \"toFixed\", (n5) => n5.map((r5) => Math.round(r5 * 100) / 100)), m(e, \"nearestPointOnLineThroughPoint\", (n5, r5, u5) => t.add(n5, t.mul(r5, t.pry(t.sub(u5, n5), r5)))), m(e, \"distanceToLineThroughPoint\", (n5, r5, u5) => t.dist(u5, t.nearestPointOnLineThroughPoint(n5, r5, u5))), m(e, \"nearestPointOnLineSegment\", (n5, r5, u5, b6 = true) => {\n  let a7 = t.uni(t.sub(r5, n5)), i4 = t.add(n5, t.mul(a7, t.pry(t.sub(u5, n5), a7)));\n  if (b6) {\n    if (i4[0] < Math.min(n5[0], r5[0]))\n      return n5[0] < r5[0] ? n5 : r5;\n    if (i4[0] > Math.max(n5[0], r5[0]))\n      return n5[0] > r5[0] ? n5 : r5;\n    if (i4[1] < Math.min(n5[1], r5[1]))\n      return n5[1] < r5[1] ? n5 : r5;\n    if (i4[1] > Math.max(n5[1], r5[1]))\n      return n5[1] > r5[1] ? n5 : r5;\n  }\n  return i4;\n}), m(e, \"distanceToLineSegment\", (n5, r5, u5, b6 = true) => t.dist(u5, t.nearestPointOnLineSegment(n5, r5, u5, b6))), m(e, \"nearestPointOnBounds\", (n5, r5) => [t.clamp(r5[0], n5.minX, n5.maxX), t.clamp(r5[1], n5.minY, n5.maxY)]), m(e, \"distanceToBounds\", (n5, r5) => t.dist(r5, t.nearestPointOnBounds(n5, r5))), m(e, \"nudge\", (n5, r5, u5) => t.isEqual(n5, r5) ? n5 : t.add(n5, t.mul(t.uni(t.sub(r5, n5)), u5))), m(e, \"nudgeAtAngle\", (n5, r5, u5) => [Math.cos(r5) * u5 + n5[0], Math.sin(r5) * u5 + n5[1]]), m(e, \"toPrecision\", (n5, r5 = 4) => [+n5[0].toPrecision(r5), +n5[1].toPrecision(r5)]), m(e, \"pointsBetween\", (n5, r5, u5 = 6) => Array.from(Array(u5)).map((b6, a7) => {\n  let i4 = a7 / (u5 - 1), o5 = Math.min(1, 0.5 + Math.abs(0.5 - i4));\n  return [...t.lrp(n5, r5, i4), o5];\n})), m(e, \"slope\", (n5, r5) => n5[0] === r5[0] ? NaN : (n5[1] - r5[1]) / (n5[0] - r5[0])), m(e, \"max\", (...n5) => [Math.max(...n5.map((r5) => r5[0])), Math.max(...n5.map((r5) => r5[1]))]), m(e, \"min\", (...n5) => [Math.min(...n5.map((r5) => r5[0])), Math.min(...n5.map((r5) => r5[1]))]);\nvar p = e;\n\n// node_modules/.pnpm/@use-gesture+core@10.2.23/node_modules/@use-gesture/core/dist/maths-b28d9b98.esm.js\nfunction clamp(v6, min, max) {\n  return Math.max(min, Math.min(v6, max));\n}\nvar V = {\n  toVector(v6, fallback) {\n    if (v6 === void 0)\n      v6 = fallback;\n    return Array.isArray(v6) ? v6 : [v6, v6];\n  },\n  add(v1, v22) {\n    return [v1[0] + v22[0], v1[1] + v22[1]];\n  },\n  sub(v1, v22) {\n    return [v1[0] - v22[0], v1[1] - v22[1]];\n  },\n  addTo(v1, v22) {\n    v1[0] += v22[0];\n    v1[1] += v22[1];\n  },\n  subTo(v1, v22) {\n    v1[0] -= v22[0];\n    v1[1] -= v22[1];\n  }\n};\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity)\n    return Math.pow(distance, constant * 5);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\nfunction rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {\n  if (constant === 0)\n    return clamp(position, min, max);\n  if (position < min)\n    return -rubberband(min - position, max - min, constant) + min;\n  if (position > max)\n    return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\nfunction computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {\n  const [[X0, X1], [Y0, Y1]] = bounds;\n  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];\n}\n\n// node_modules/.pnpm/@use-gesture+core@10.2.23/node_modules/@use-gesture/core/dist/actions-e3d93fde.esm.js\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function(sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i4 = 1; i4 < arguments.length; i4++) {\n    var source = null != arguments[i4] ? arguments[i4] : {};\n    i4 % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar EVENT_TYPE_MAP = {\n  pointer: {\n    start: \"down\",\n    change: \"move\",\n    end: \"up\"\n  },\n  mouse: {\n    start: \"down\",\n    change: \"move\",\n    end: \"up\"\n  },\n  touch: {\n    start: \"start\",\n    change: \"move\",\n    end: \"end\"\n  },\n  gesture: {\n    start: \"start\",\n    change: \"change\",\n    end: \"end\"\n  }\n};\nfunction capitalize(string) {\n  if (!string)\n    return \"\";\n  return string[0].toUpperCase() + string.slice(1);\n}\nvar actionsWithoutCaptureSupported = [\"enter\", \"leave\"];\nfunction hasCapture(capture = false, actionKey) {\n  return capture && !actionsWithoutCaptureSupported.includes(actionKey);\n}\nfunction toHandlerProp(device, action = \"\", capture = false) {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return \"on\" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? \"Capture\" : \"\");\n}\nvar pointerCaptureEvents = [\"gotpointercapture\", \"lostpointercapture\"];\nfunction parseProp(prop) {\n  let eventKey = prop.substring(2).toLowerCase();\n  const passive = !!~eventKey.indexOf(\"passive\");\n  if (passive)\n    eventKey = eventKey.replace(\"passive\", \"\");\n  const captureKey = pointerCaptureEvents.includes(eventKey) ? \"capturecapture\" : \"capture\";\n  const capture = !!~eventKey.indexOf(captureKey);\n  if (capture)\n    eventKey = eventKey.replace(\"capture\", \"\");\n  return {\n    device: eventKey,\n    capture,\n    passive\n  };\n}\nfunction toDomEventType(device, action = \"\") {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return device + actionKey;\n}\nfunction isTouch(event) {\n  return \"touches\" in event;\n}\nfunction getPointerType(event) {\n  if (isTouch(event))\n    return \"touch\";\n  if (\"pointerType\" in event)\n    return event.pointerType;\n  return \"mouse\";\n}\nfunction getCurrentTargetTouchList(event) {\n  return Array.from(event.touches).filter((e5) => {\n    var _event$currentTarget, _event$currentTarget$;\n    return e5.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e5.target));\n  });\n}\nfunction getTouchList(event) {\n  return event.type === \"touchend\" || event.type === \"touchcancel\" ? event.changedTouches : event.targetTouches;\n}\nfunction getValueEvent(event) {\n  return isTouch(event) ? getTouchList(event)[0] : event;\n}\nfunction distanceAngle(P1, P22) {\n  const dx = P22.clientX - P1.clientX;\n  const dy = P22.clientY - P1.clientY;\n  const cx = (P22.clientX + P1.clientX) / 2;\n  const cy = (P22.clientY + P1.clientY) / 2;\n  const distance = Math.hypot(dx, dy);\n  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;\n  const origin = [cx, cy];\n  return {\n    angle,\n    distance,\n    origin\n  };\n}\nfunction touchIds(event) {\n  return getCurrentTargetTouchList(event).map((touch) => touch.identifier);\n}\nfunction touchDistanceAngle(event, ids) {\n  const [P1, P22] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));\n  return distanceAngle(P1, P22);\n}\nfunction pointerId(event) {\n  const valueEvent = getValueEvent(event);\n  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;\n}\nfunction pointerValues(event) {\n  const valueEvent = getValueEvent(event);\n  return [valueEvent.clientX, valueEvent.clientY];\n}\nvar LINE_HEIGHT = 40;\nvar PAGE_HEIGHT = 800;\nfunction wheelValues(event) {\n  let {\n    deltaX,\n    deltaY,\n    deltaMode\n  } = event;\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT;\n    deltaY *= LINE_HEIGHT;\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT;\n    deltaY *= PAGE_HEIGHT;\n  }\n  return [deltaX, deltaY];\n}\nfunction scrollValues(event) {\n  var _ref, _ref2;\n  const {\n    scrollX,\n    scrollY,\n    scrollLeft,\n    scrollTop\n  } = event.currentTarget;\n  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];\n}\nfunction getEventDetails(event) {\n  const payload = {};\n  if (\"buttons\" in event)\n    payload.buttons = event.buttons;\n  if (\"shiftKey\" in event) {\n    const {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    } = event;\n    Object.assign(payload, {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    });\n  }\n  return payload;\n}\nfunction call(v6, ...args) {\n  if (typeof v6 === \"function\") {\n    return v6(...args);\n  } else {\n    return v6;\n  }\n}\nfunction noop() {\n}\nfunction chain(...fns) {\n  if (fns.length === 0)\n    return noop;\n  if (fns.length === 1)\n    return fns[0];\n  return function() {\n    let result;\n    for (const fn2 of fns) {\n      result = fn2.apply(this, arguments) || result;\n    }\n    return result;\n  };\n}\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\nvar BEFORE_LAST_KINEMATICS_DELAY = 32;\nvar Engine = class {\n  constructor(ctrl, args, key) {\n    this.ctrl = ctrl;\n    this.args = args;\n    this.key = key;\n    if (!this.state) {\n      this.state = {};\n      this.computeValues([0, 0]);\n      this.computeInitial();\n      if (this.init)\n        this.init();\n      this.reset();\n    }\n  }\n  get state() {\n    return this.ctrl.state[this.key];\n  }\n  set state(state) {\n    this.ctrl.state[this.key] = state;\n  }\n  get shared() {\n    return this.ctrl.state.shared;\n  }\n  get eventStore() {\n    return this.ctrl.gestureEventStores[this.key];\n  }\n  get timeoutStore() {\n    return this.ctrl.gestureTimeoutStores[this.key];\n  }\n  get config() {\n    return this.ctrl.config[this.key];\n  }\n  get sharedConfig() {\n    return this.ctrl.config.shared;\n  }\n  get handler() {\n    return this.ctrl.handlers[this.key];\n  }\n  reset() {\n    const {\n      state,\n      shared,\n      ingKey,\n      args\n    } = this;\n    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;\n    state._step = [false, false];\n    state.intentional = false;\n    state._movement = [0, 0];\n    state._distance = [0, 0];\n    state._direction = [0, 0];\n    state._delta = [0, 0];\n    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];\n    state.args = args;\n    state.axis = void 0;\n    state.memo = void 0;\n    state.elapsedTime = 0;\n    state.direction = [0, 0];\n    state.distance = [0, 0];\n    state.overflow = [0, 0];\n    state._movementBound = [false, false];\n    state.velocity = [0, 0];\n    state.movement = [0, 0];\n    state.delta = [0, 0];\n    state.timeStamp = 0;\n  }\n  start(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._active) {\n      this.reset();\n      this.computeInitial();\n      state._active = true;\n      state.target = event.target;\n      state.currentTarget = event.currentTarget;\n      state.lastOffset = config.from ? call(config.from, state) : state.offset;\n      state.offset = state.lastOffset;\n    }\n    state.startTime = state.timeStamp = event.timeStamp;\n  }\n  computeValues(values) {\n    const state = this.state;\n    state._values = values;\n    state.values = this.config.transform(values);\n  }\n  computeInitial() {\n    const state = this.state;\n    state._initial = state._values;\n    state.initial = state.values;\n  }\n  compute(event) {\n    const {\n      state,\n      config,\n      shared\n    } = this;\n    state.args = this.args;\n    let dt2 = 0;\n    if (event) {\n      state.event = event;\n      if (config.preventDefault && event.cancelable)\n        state.event.preventDefault();\n      state.type = event.type;\n      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;\n      shared.locked = !!document.pointerLockElement;\n      Object.assign(shared, getEventDetails(event));\n      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;\n      dt2 = event.timeStamp - state.timeStamp;\n      state.timeStamp = event.timeStamp;\n      state.elapsedTime = state.timeStamp - state.startTime;\n    }\n    if (state._active) {\n      const _absoluteDelta = state._delta.map(Math.abs);\n      V.addTo(state._distance, _absoluteDelta);\n    }\n    if (this.axisIntent)\n      this.axisIntent(event);\n    const [_m0, _m1] = state._movement;\n    const [t0, t1] = config.threshold;\n    const {\n      _step,\n      values\n    } = state;\n    if (config.hasCustomTransform) {\n      if (_step[0] === false)\n        _step[0] = Math.abs(_m0) >= t0 && values[0];\n      if (_step[1] === false)\n        _step[1] = Math.abs(_m1) >= t1 && values[1];\n    } else {\n      if (_step[0] === false)\n        _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;\n      if (_step[1] === false)\n        _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;\n    }\n    state.intentional = _step[0] !== false || _step[1] !== false;\n    if (!state.intentional)\n      return;\n    const movement = [0, 0];\n    if (config.hasCustomTransform) {\n      const [v0, v1] = values;\n      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;\n    } else {\n      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;\n    }\n    if (this.restrictToAxis && !state._blocked)\n      this.restrictToAxis(movement);\n    const previousOffset = state.offset;\n    const gestureIsActive = state._active && !state._blocked || state.active;\n    if (gestureIsActive) {\n      state.first = state._active && !state.active;\n      state.last = !state._active && state.active;\n      state.active = shared[this.ingKey] = state._active;\n      if (event) {\n        if (state.first) {\n          if (\"bounds\" in config)\n            state._bounds = call(config.bounds, state);\n          if (this.setup)\n            this.setup();\n        }\n        state.movement = movement;\n        this.computeOffset();\n      }\n    }\n    const [ox, oy] = state.offset;\n    const [[x0, x1], [y0, y1]] = state._bounds;\n    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];\n    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;\n    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;\n    const rubberband2 = state._active ? config.rubberband || [0, 0] : [0, 0];\n    state.offset = computeRubberband(state._bounds, state.offset, rubberband2);\n    state.delta = V.sub(state.offset, previousOffset);\n    this.computeMovement();\n    if (gestureIsActive && (!state.last || dt2 > BEFORE_LAST_KINEMATICS_DELAY)) {\n      state.delta = V.sub(state.offset, previousOffset);\n      const absoluteDelta = state.delta.map(Math.abs);\n      V.addTo(state.distance, absoluteDelta);\n      state.direction = state.delta.map(Math.sign);\n      state._direction = state._delta.map(Math.sign);\n      if (!state.first && dt2 > 0) {\n        state.velocity = [absoluteDelta[0] / dt2, absoluteDelta[1] / dt2];\n      }\n    }\n  }\n  emit() {\n    const state = this.state;\n    const shared = this.shared;\n    const config = this.config;\n    if (!state._active)\n      this.clean();\n    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents)\n      return;\n    const memo45 = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {\n      [this.aliasKey]: state.values\n    }));\n    if (memo45 !== void 0)\n      state.memo = memo45;\n  }\n  clean() {\n    this.eventStore.clean();\n    this.timeoutStore.clean();\n  }\n};\nfunction selectAxis([dx, dy], threshold) {\n  const absDx = Math.abs(dx);\n  const absDy = Math.abs(dy);\n  if (absDx > absDy && absDx > threshold) {\n    return \"x\";\n  }\n  if (absDy > absDx && absDy > threshold) {\n    return \"y\";\n  }\n  return void 0;\n}\nvar CoordinatesEngine = class extends Engine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"aliasKey\", \"xy\");\n  }\n  reset() {\n    super.reset();\n    this.state.axis = void 0;\n  }\n  init() {\n    this.state.offset = [0, 0];\n    this.state.lastOffset = [0, 0];\n  }\n  computeOffset() {\n    this.state.offset = V.add(this.state.lastOffset, this.state.movement);\n  }\n  computeMovement() {\n    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);\n  }\n  axisIntent(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state.axis && event) {\n      const threshold = typeof config.axisThreshold === \"object\" ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;\n      state.axis = selectAxis(state._movement, threshold);\n    }\n    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;\n  }\n  restrictToAxis(v6) {\n    if (this.config.axis || this.config.lockDirection) {\n      switch (this.state.axis) {\n        case \"x\":\n          v6[1] = 0;\n          break;\n        case \"y\":\n          v6[0] = 0;\n          break;\n      }\n    }\n  }\n};\nvar identity = (v6) => v6;\nvar DEFAULT_RUBBERBAND = 0.15;\nvar commonConfigResolver = {\n  enabled(value = true) {\n    return value;\n  },\n  eventOptions(value, _k, config) {\n    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);\n  },\n  preventDefault(value = false) {\n    return value;\n  },\n  triggerAllEvents(value = false) {\n    return value;\n  },\n  rubberband(value = 0) {\n    switch (value) {\n      case true:\n        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];\n      case false:\n        return [0, 0];\n      default:\n        return V.toVector(value);\n    }\n  },\n  from(value) {\n    if (typeof value === \"function\")\n      return value;\n    if (value != null)\n      return V.toVector(value);\n  },\n  transform(value, _k, config) {\n    const transform = value || config.shared.transform;\n    this.hasCustomTransform = !!transform;\n    if (true) {\n      const originalTransform = transform || identity;\n      return (v6) => {\n        const r5 = originalTransform(v6);\n        if (!isFinite(r5[0]) || !isFinite(r5[1])) {\n          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r5[0]},${[1]}]`);\n        }\n        return r5;\n      };\n    }\n    return transform || identity;\n  },\n  threshold(value) {\n    return V.toVector(value, 0);\n  }\n};\nif (true) {\n  Object.assign(commonConfigResolver, {\n    domTarget(value) {\n      if (value !== void 0) {\n        throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n      }\n      return NaN;\n    },\n    lockDirection(value) {\n      if (value !== void 0) {\n        throw Error(`[@use-gesture]: \\`lockDirection\\` option has been merged with \\`axis\\`. Use it as in \\`{ axis: 'lock' }\\``);\n      }\n      return NaN;\n    },\n    initial(value) {\n      if (value !== void 0) {\n        throw Error(`[@use-gesture]: \\`initial\\` option has been renamed to \\`from\\`.`);\n      }\n      return NaN;\n    }\n  });\n}\nvar DEFAULT_AXIS_THRESHOLD = 0;\nvar coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  axis(_v, _k, {\n    axis\n  }) {\n    this.lockDirection = axis === \"lock\";\n    if (!this.lockDirection)\n      return axis;\n  },\n  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {\n    return value;\n  },\n  bounds(value = {}) {\n    if (typeof value === \"function\") {\n      return (state) => coordinatesConfigResolver.bounds(value(state));\n    }\n    if (\"current\" in value) {\n      return () => value.current;\n    }\n    if (typeof HTMLElement === \"function\" && value instanceof HTMLElement) {\n      return value;\n    }\n    const {\n      left = -Infinity,\n      right = Infinity,\n      top: top2 = -Infinity,\n      bottom = Infinity\n    } = value;\n    return [[left, right], [top2, bottom]];\n  }\n});\nvar DISPLACEMENT = 10;\nvar KEYS_DELTA_MAP = {\n  ArrowRight: (factor = 1) => [DISPLACEMENT * factor, 0],\n  ArrowLeft: (factor = 1) => [-DISPLACEMENT * factor, 0],\n  ArrowUp: (factor = 1) => [0, -DISPLACEMENT * factor],\n  ArrowDown: (factor = 1) => [0, DISPLACEMENT * factor]\n};\nvar DragEngine = class extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", \"dragging\");\n  }\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._pointerId = void 0;\n    state._pointerActive = false;\n    state._keyboardActive = false;\n    state._preventScroll = false;\n    state._delayed = false;\n    state.swipe = [0, 0];\n    state.tap = false;\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n  }\n  setup() {\n    const state = this.state;\n    if (state._bounds instanceof HTMLElement) {\n      const boundRect = state._bounds.getBoundingClientRect();\n      const targetRect = state.currentTarget.getBoundingClientRect();\n      const _bounds = {\n        left: boundRect.left - targetRect.left + state.offset[0],\n        right: boundRect.right - targetRect.right + state.offset[0],\n        top: boundRect.top - targetRect.top + state.offset[1],\n        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]\n      };\n      state._bounds = coordinatesConfigResolver.bounds(_bounds);\n    }\n  }\n  cancel() {\n    const state = this.state;\n    if (state.canceled)\n      return;\n    state.canceled = true;\n    state._active = false;\n    setTimeout(() => {\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n  setActive() {\n    this.state._active = this.state._pointerActive || this.state._keyboardActive;\n  }\n  clean() {\n    this.pointerClean();\n    this.state._pointerActive = false;\n    this.state._keyboardActive = false;\n    super.clean();\n  }\n  pointerDown(event) {\n    const config = this.config;\n    const state = this.state;\n    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons))\n      return;\n    const ctrlIds = this.ctrl.setEventIds(event);\n    if (config.pointerCapture) {\n      event.target.setPointerCapture(event.pointerId);\n    }\n    if (ctrlIds && ctrlIds.size > 1 && state._pointerActive)\n      return;\n    this.start(event);\n    this.setupPointer(event);\n    state._pointerId = pointerId(event);\n    state._pointerActive = true;\n    this.computeValues(pointerValues(event));\n    this.computeInitial();\n    if (config.preventScrollAxis && getPointerType(event) !== \"mouse\") {\n      state._active = false;\n      this.setupScrollPrevention(event);\n    } else if (config.delay > 0) {\n      this.setupDelayTrigger(event);\n      if (config.triggerAllEvents) {\n        this.compute(event);\n        this.emit();\n      }\n    } else {\n      this.startPointerDrag(event);\n    }\n  }\n  startPointerDrag(event) {\n    const state = this.state;\n    state._active = true;\n    state._preventScroll = true;\n    state._delayed = false;\n    this.compute(event);\n    this.emit();\n  }\n  pointerMove(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._pointerActive)\n      return;\n    if (state.type === event.type && event.timeStamp === state.timeStamp)\n      return;\n    const id = pointerId(event);\n    if (state._pointerId !== void 0 && id !== state._pointerId)\n      return;\n    const _values = pointerValues(event);\n    if (document.pointerLockElement === event.target) {\n      state._delta = [event.movementX, event.movementY];\n    } else {\n      state._delta = V.sub(_values, state._values);\n      this.computeValues(_values);\n    }\n    V.addTo(state._movement, state._delta);\n    this.compute(event);\n    if (state._delayed && state.intentional) {\n      this.timeoutStore.remove(\"dragDelay\");\n      state.active = false;\n      this.startPointerDrag(event);\n      return;\n    }\n    if (config.preventScrollAxis && !state._preventScroll) {\n      if (state.axis) {\n        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === \"xy\") {\n          state._active = false;\n          this.clean();\n          return;\n        } else {\n          this.timeoutStore.remove(\"startPointerDrag\");\n          this.startPointerDrag(event);\n          return;\n        }\n      } else {\n        return;\n      }\n    }\n    this.emit();\n  }\n  pointerUp(event) {\n    this.ctrl.setEventIds(event);\n    try {\n      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {\n        ;\n        event.target.releasePointerCapture(event.pointerId);\n      }\n    } catch (_unused) {\n      if (true) {\n        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \\`@react-three/fiber\\`. \n\nPlease upgrade to the latest version.`);\n      }\n    }\n    const state = this.state;\n    const config = this.config;\n    if (!state._active || !state._pointerActive)\n      return;\n    const id = pointerId(event);\n    if (state._pointerId !== void 0 && id !== state._pointerId)\n      return;\n    this.state._pointerActive = false;\n    this.setActive();\n    this.compute(event);\n    const [dx, dy] = state._distance;\n    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;\n    if (state.tap && config.filterTaps) {\n      state._force = true;\n    } else {\n      const [dirx, diry] = state.direction;\n      const [vx, vy] = state.velocity;\n      const [mx, my] = state.movement;\n      const [svx, svy] = config.swipe.velocity;\n      const [sx, sy] = config.swipe.distance;\n      const sdt = config.swipe.duration;\n      if (state.elapsedTime < sdt) {\n        if (Math.abs(vx) > svx && Math.abs(mx) > sx)\n          state.swipe[0] = dirx;\n        if (Math.abs(vy) > svy && Math.abs(my) > sy)\n          state.swipe[1] = diry;\n      }\n    }\n    this.emit();\n  }\n  pointerClick(event) {\n    if (!this.state.tap && event.detail > 0) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n  setupPointer(event) {\n    const config = this.config;\n    const device = config.device;\n    if (true) {\n      try {\n        if (device === \"pointer\" && config.preventScrollDelay === void 0) {\n          const currentTarget = \"uv\" in event ? event.sourceEvent.currentTarget : event.currentTarget;\n          const style = window.getComputedStyle(currentTarget);\n          if (style.touchAction === \"auto\") {\n            console.warn(`[@use-gesture]: The drag target has its \\`touch-action\\` style property set to \\`auto\\`. It is recommended to add \\`touch-action: 'none'\\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\n\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);\n          }\n        }\n      } catch (_unused2) {\n      }\n    }\n    if (config.pointerLock) {\n      event.currentTarget.requestPointerLock();\n    }\n    if (!config.pointerCapture) {\n      this.eventStore.add(this.sharedConfig.window, device, \"change\", this.pointerMove.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, \"end\", this.pointerUp.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, \"cancel\", this.pointerUp.bind(this));\n    }\n  }\n  pointerClean() {\n    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {\n      document.exitPointerLock();\n    }\n  }\n  preventScroll(event) {\n    if (this.state._preventScroll && event.cancelable) {\n      event.preventDefault();\n    }\n  }\n  setupScrollPrevention(event) {\n    this.state._preventScroll = false;\n    persistEvent(event);\n    const remove = this.eventStore.add(this.sharedConfig.window, \"touch\", \"change\", this.preventScroll.bind(this), {\n      passive: false\n    });\n    this.eventStore.add(this.sharedConfig.window, \"touch\", \"end\", remove);\n    this.eventStore.add(this.sharedConfig.window, \"touch\", \"cancel\", remove);\n    this.timeoutStore.add(\"startPointerDrag\", this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);\n  }\n  setupDelayTrigger(event) {\n    this.state._delayed = true;\n    this.timeoutStore.add(\"dragDelay\", () => {\n      this.state._step = [0, 0];\n      this.startPointerDrag(event);\n    }, this.config.delay);\n  }\n  keyDown(event) {\n    const deltaFn = KEYS_DELTA_MAP[event.key];\n    if (deltaFn) {\n      const state = this.state;\n      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;\n      this.start(event);\n      state._delta = deltaFn(factor);\n      state._keyboardActive = true;\n      V.addTo(state._movement, state._delta);\n      this.compute(event);\n      this.emit();\n    }\n  }\n  keyUp(event) {\n    if (!(event.key in KEYS_DELTA_MAP))\n      return;\n    this.state._keyboardActive = false;\n    this.setActive();\n    this.compute(event);\n    this.emit();\n  }\n  bind(bindFunction) {\n    const device = this.config.device;\n    bindFunction(device, \"start\", this.pointerDown.bind(this));\n    if (this.config.pointerCapture) {\n      bindFunction(device, \"change\", this.pointerMove.bind(this));\n      bindFunction(device, \"end\", this.pointerUp.bind(this));\n      bindFunction(device, \"cancel\", this.pointerUp.bind(this));\n      bindFunction(\"lostPointerCapture\", \"\", this.pointerUp.bind(this));\n    }\n    if (this.config.keys) {\n      bindFunction(\"key\", \"down\", this.keyDown.bind(this));\n      bindFunction(\"key\", \"up\", this.keyUp.bind(this));\n    }\n    if (this.config.filterTaps) {\n      bindFunction(\"click\", \"\", this.pointerClick.bind(this), {\n        capture: true,\n        passive: false\n      });\n    }\n  }\n};\nfunction persistEvent(event) {\n  \"persist\" in event && typeof event.persist === \"function\" && event.persist();\n}\nvar isBrowser = typeof window !== \"undefined\" && window.document && window.document.createElement;\nfunction supportsTouchEvents() {\n  return isBrowser && \"ontouchstart\" in window;\n}\nfunction isTouchScreen() {\n  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;\n}\nfunction supportsPointerEvents() {\n  return isBrowser && \"onpointerdown\" in window;\n}\nfunction supportsPointerLock() {\n  return isBrowser && \"exitPointerLock\" in window.document;\n}\nfunction supportsGestureEvents() {\n  try {\n    return \"constructor\" in GestureEvent;\n  } catch (e5) {\n    return false;\n  }\n}\nvar SUPPORT = {\n  isBrowser,\n  gesture: supportsGestureEvents(),\n  touch: isTouchScreen(),\n  touchscreen: isTouchScreen(),\n  pointer: supportsPointerEvents(),\n  pointerLock: supportsPointerLock()\n};\nvar DEFAULT_PREVENT_SCROLL_DELAY = 250;\nvar DEFAULT_DRAG_DELAY = 180;\nvar DEFAULT_SWIPE_VELOCITY = 0.5;\nvar DEFAULT_SWIPE_DISTANCE = 50;\nvar DEFAULT_SWIPE_DURATION = 250;\nvar DEFAULT_DRAG_AXIS_THRESHOLD = {\n  mouse: 0,\n  touch: 0,\n  pen: 8\n};\nvar dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  device(_v, _k, {\n    pointer: {\n      touch = false,\n      lock = false,\n      mouse = false\n    } = {}\n  }) {\n    this.pointerLock = lock && SUPPORT.pointerLock;\n    if (SUPPORT.touch && touch)\n      return \"touch\";\n    if (this.pointerLock)\n      return \"mouse\";\n    if (SUPPORT.pointer && !mouse)\n      return \"pointer\";\n    if (SUPPORT.touch)\n      return \"touch\";\n    return \"mouse\";\n  },\n  preventScrollAxis(value, _k, {\n    preventScroll\n  }) {\n    this.preventScrollDelay = typeof preventScroll === \"number\" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;\n    if (!SUPPORT.touchscreen || preventScroll === false)\n      return void 0;\n    return value ? value : preventScroll !== void 0 ? \"y\" : void 0;\n  },\n  pointerCapture(_v, _k, {\n    pointer: {\n      capture = true,\n      buttons = 1,\n      keys = true\n    } = {}\n  }) {\n    this.pointerButtons = buttons;\n    this.keys = keys;\n    return !this.pointerLock && this.device === \"pointer\" && capture;\n  },\n  threshold(value, _k, {\n    filterTaps = false,\n    tapsThreshold = 3,\n    axis = void 0\n  }) {\n    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);\n    this.filterTaps = filterTaps;\n    this.tapsThreshold = tapsThreshold;\n    return threshold;\n  },\n  swipe({\n    velocity = DEFAULT_SWIPE_VELOCITY,\n    distance = DEFAULT_SWIPE_DISTANCE,\n    duration = DEFAULT_SWIPE_DURATION\n  } = {}) {\n    return {\n      velocity: this.transform(V.toVector(velocity)),\n      distance: this.transform(V.toVector(distance)),\n      duration\n    };\n  },\n  delay(value = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n      case false:\n        return 0;\n      default:\n        return value;\n    }\n  },\n  axisThreshold(value) {\n    if (!value)\n      return DEFAULT_DRAG_AXIS_THRESHOLD;\n    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);\n  }\n});\nif (true) {\n  Object.assign(dragConfigResolver, {\n    useTouch(value) {\n      if (value !== void 0) {\n        throw Error(`[@use-gesture]: \\`useTouch\\` option has been renamed to \\`pointer.touch\\`. Use it as in \\`{ pointer: { touch: true } }\\`.`);\n      }\n      return NaN;\n    },\n    experimental_preventWindowScrollY(value) {\n      if (value !== void 0) {\n        throw Error(`[@use-gesture]: \\`experimental_preventWindowScrollY\\` option has been renamed to \\`preventScroll\\`.`);\n      }\n      return NaN;\n    },\n    swipeVelocity(value) {\n      if (value !== void 0) {\n        throw Error(`[@use-gesture]: \\`swipeVelocity\\` option has been renamed to \\`swipe.velocity\\`. Use it as in \\`{ swipe: { velocity: 0.5 } }\\`.`);\n      }\n      return NaN;\n    },\n    swipeDistance(value) {\n      if (value !== void 0) {\n        throw Error(`[@use-gesture]: \\`swipeDistance\\` option has been renamed to \\`swipe.distance\\`. Use it as in \\`{ swipe: { distance: 50 } }\\`.`);\n      }\n      return NaN;\n    },\n    swipeDuration(value) {\n      if (value !== void 0) {\n        throw Error(`[@use-gesture]: \\`swipeDuration\\` option has been renamed to \\`swipe.duration\\`. Use it as in \\`{ swipe: { duration: 250 } }\\`.`);\n      }\n      return NaN;\n    }\n  });\n}\nfunction clampStateInternalMovementToBounds(state) {\n  const [ox, oy] = state.overflow;\n  const [dx, dy] = state._delta;\n  const [dirx, diry] = state._direction;\n  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {\n    state._movement[0] = state._movementBound[0];\n  }\n  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {\n    state._movement[1] = state._movementBound[1];\n  }\n}\nvar SCALE_ANGLE_RATIO_INTENT_DEG = 30;\nvar PINCH_WHEEL_RATIO = 100;\nvar PinchEngine = class extends Engine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", \"pinching\");\n    _defineProperty(this, \"aliasKey\", \"da\");\n  }\n  init() {\n    this.state.offset = [1, 0];\n    this.state.lastOffset = [1, 0];\n    this.state._pointerEvents = /* @__PURE__ */ new Map();\n  }\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._touchIds = [];\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n    state.turns = 0;\n  }\n  computeOffset() {\n    const {\n      type,\n      movement,\n      lastOffset\n    } = this.state;\n    if (type === \"wheel\") {\n      this.state.offset = V.add(movement, lastOffset);\n    } else {\n      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];\n    }\n  }\n  computeMovement() {\n    const {\n      offset,\n      lastOffset\n    } = this.state;\n    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];\n  }\n  axisIntent() {\n    const state = this.state;\n    const [_m0, _m1] = state._movement;\n    if (!state.axis) {\n      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);\n      if (axisMovementDifference < 0)\n        state.axis = \"angle\";\n      else if (axisMovementDifference > 0)\n        state.axis = \"scale\";\n    }\n  }\n  restrictToAxis(v6) {\n    if (this.config.lockDirection) {\n      if (this.state.axis === \"scale\")\n        v6[1] = 0;\n      else if (this.state.axis === \"angle\")\n        v6[0] = 0;\n    }\n  }\n  cancel() {\n    const state = this.state;\n    if (state.canceled)\n      return;\n    setTimeout(() => {\n      state.canceled = true;\n      state._active = false;\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n  touchStart(event) {\n    this.ctrl.setEventIds(event);\n    const state = this.state;\n    const ctrlTouchIds = this.ctrl.touchIds;\n    if (state._active) {\n      if (state._touchIds.every((id) => ctrlTouchIds.has(id)))\n        return;\n    }\n    if (ctrlTouchIds.size < 2)\n      return;\n    this.start(event);\n    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);\n    const payload = touchDistanceAngle(event, state._touchIds);\n    this.pinchStart(event, payload);\n  }\n  pointerStart(event) {\n    if (event.buttons != null && event.buttons % 2 !== 1)\n      return;\n    this.ctrl.setEventIds(event);\n    event.target.setPointerCapture(event.pointerId);\n    const state = this.state;\n    const _pointerEvents = state._pointerEvents;\n    const ctrlPointerIds = this.ctrl.pointerIds;\n    if (state._active) {\n      if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id)))\n        return;\n    }\n    if (_pointerEvents.size < 2) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n    if (state._pointerEvents.size < 2)\n      return;\n    this.start(event);\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    this.pinchStart(event, payload);\n  }\n  pinchStart(event, payload) {\n    const state = this.state;\n    state.origin = payload.origin;\n    this.computeValues([payload.distance, payload.angle]);\n    this.computeInitial();\n    this.compute(event);\n    this.emit();\n  }\n  touchMove(event) {\n    if (!this.state._active)\n      return;\n    const payload = touchDistanceAngle(event, this.state._touchIds);\n    this.pinchMove(event, payload);\n  }\n  pointerMove(event) {\n    const _pointerEvents = this.state._pointerEvents;\n    if (_pointerEvents.has(event.pointerId)) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n    if (!this.state._active)\n      return;\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    this.pinchMove(event, payload);\n  }\n  pinchMove(event, payload) {\n    const state = this.state;\n    const prev_a = state._values[1];\n    const delta_a = payload.angle - prev_a;\n    let delta_turns = 0;\n    if (Math.abs(delta_a) > 270)\n      delta_turns += Math.sign(delta_a);\n    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);\n    state.origin = payload.origin;\n    state.turns = delta_turns;\n    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];\n    this.compute(event);\n    this.emit();\n  }\n  touchEnd(event) {\n    this.ctrl.setEventIds(event);\n    if (!this.state._active)\n      return;\n    if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {\n      this.state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n  pointerEnd(event) {\n    const state = this.state;\n    this.ctrl.setEventIds(event);\n    try {\n      event.target.releasePointerCapture(event.pointerId);\n    } catch (_unused) {\n    }\n    if (state._pointerEvents.has(event.pointerId)) {\n      state._pointerEvents.delete(event.pointerId);\n    }\n    if (!state._active)\n      return;\n    if (state._pointerEvents.size < 2) {\n      state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n  gestureStart(event) {\n    if (event.cancelable)\n      event.preventDefault();\n    const state = this.state;\n    if (state._active)\n      return;\n    this.start(event);\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n  gestureMove(event) {\n    if (event.cancelable)\n      event.preventDefault();\n    if (!this.state._active)\n      return;\n    const state = this.state;\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    const _previousMovement = state._movement;\n    state._movement = [event.scale - 1, event.rotation];\n    state._delta = V.sub(state._movement, _previousMovement);\n    this.compute(event);\n    this.emit();\n  }\n  gestureEnd(event) {\n    if (!this.state._active)\n      return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n  wheel(event) {\n    const modifierKey = this.config.modifierKey;\n    if (modifierKey && !event[modifierKey])\n      return;\n    if (!this.state._active)\n      this.wheelStart(event);\n    else\n      this.wheelChange(event);\n    this.timeoutStore.add(\"wheelEnd\", this.wheelEnd.bind(this));\n  }\n  wheelStart(event) {\n    this.start(event);\n    this.wheelChange(event);\n  }\n  wheelChange(event) {\n    const isR3f = \"uv\" in event;\n    if (!isR3f) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      if (!event.defaultPrevented) {\n        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \\`target\\` option.\n\nThis message will only appear in development mode.`);\n      }\n    }\n    const state = this.state;\n    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];\n    V.addTo(state._movement, state._delta);\n    clampStateInternalMovementToBounds(state);\n    this.state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n  wheelEnd() {\n    if (!this.state._active)\n      return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    const device = this.config.device;\n    if (!!device) {\n      bindFunction(device, \"start\", this[device + \"Start\"].bind(this));\n      bindFunction(device, \"change\", this[device + \"Move\"].bind(this));\n      bindFunction(device, \"end\", this[device + \"End\"].bind(this));\n      bindFunction(device, \"cancel\", this[device + \"End\"].bind(this));\n    }\n    if (this.config.pinchOnWheel) {\n      bindFunction(\"wheel\", \"\", this.wheel.bind(this), {\n        passive: false\n      });\n    }\n  }\n};\nvar pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  device(_v, _k, {\n    shared,\n    pointer: {\n      touch = false\n    } = {}\n  }) {\n    const sharedConfig = shared;\n    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture)\n      return \"gesture\";\n    if (SUPPORT.touch && touch)\n      return \"touch\";\n    if (SUPPORT.touchscreen) {\n      if (SUPPORT.pointer)\n        return \"pointer\";\n      if (SUPPORT.touch)\n        return \"touch\";\n    }\n  },\n  bounds(_v, _k, {\n    scaleBounds = {},\n    angleBounds = {}\n  }) {\n    const _scaleBounds = (state) => {\n      const D6 = assignDefault(call(scaleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D6.min, D6.max];\n    };\n    const _angleBounds = (state) => {\n      const A6 = assignDefault(call(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A6.min, A6.max];\n    };\n    if (typeof scaleBounds !== \"function\" && typeof angleBounds !== \"function\")\n      return [_scaleBounds(), _angleBounds()];\n    return (state) => [_scaleBounds(state), _angleBounds(state)];\n  },\n  threshold(value, _k, config) {\n    this.lockDirection = config.axis === \"lock\";\n    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);\n    return threshold;\n  },\n  modifierKey(value) {\n    if (value === void 0)\n      return \"ctrlKey\";\n    return value;\n  },\n  pinchOnWheel(value = true) {\n    return value;\n  }\n});\nvar MoveEngine = class extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", \"moving\");\n  }\n  move(event) {\n    if (this.config.mouseOnly && event.pointerType !== \"mouse\")\n      return;\n    if (!this.state._active)\n      this.moveStart(event);\n    else\n      this.moveChange(event);\n    this.timeoutStore.add(\"moveEnd\", this.moveEnd.bind(this));\n  }\n  moveStart(event) {\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.computeInitial();\n    this.emit();\n  }\n  moveChange(event) {\n    if (!this.state._active)\n      return;\n    const values = pointerValues(event);\n    const state = this.state;\n    state._delta = V.sub(values, state._values);\n    V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n  moveEnd(event) {\n    if (!this.state._active)\n      return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction(\"pointer\", \"change\", this.move.bind(this));\n    bindFunction(\"pointer\", \"leave\", this.moveEnd.bind(this));\n  }\n};\nvar moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\nvar ScrollEngine = class extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", \"scrolling\");\n  }\n  scroll(event) {\n    if (!this.state._active)\n      this.start(event);\n    this.scrollChange(event);\n    this.timeoutStore.add(\"scrollEnd\", this.scrollEnd.bind(this));\n  }\n  scrollChange(event) {\n    if (event.cancelable)\n      event.preventDefault();\n    const state = this.state;\n    const values = scrollValues(event);\n    state._delta = V.sub(values, state._values);\n    V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n  scrollEnd() {\n    if (!this.state._active)\n      return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction(\"scroll\", \"\", this.scroll.bind(this));\n  }\n};\nvar scrollConfigResolver = coordinatesConfigResolver;\nvar WheelEngine = class extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", \"wheeling\");\n  }\n  wheel(event) {\n    if (!this.state._active)\n      this.start(event);\n    this.wheelChange(event);\n    this.timeoutStore.add(\"wheelEnd\", this.wheelEnd.bind(this));\n  }\n  wheelChange(event) {\n    const state = this.state;\n    state._delta = wheelValues(event);\n    V.addTo(state._movement, state._delta);\n    clampStateInternalMovementToBounds(state);\n    this.compute(event);\n    this.emit();\n  }\n  wheelEnd() {\n    if (!this.state._active)\n      return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction(\"wheel\", \"\", this.wheel.bind(this));\n  }\n};\nvar wheelConfigResolver = coordinatesConfigResolver;\nvar HoverEngine = class extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", \"hovering\");\n  }\n  enter(event) {\n    if (this.config.mouseOnly && event.pointerType !== \"mouse\")\n      return;\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.emit();\n  }\n  leave(event) {\n    if (this.config.mouseOnly && event.pointerType !== \"mouse\")\n      return;\n    const state = this.state;\n    if (!state._active)\n      return;\n    state._active = false;\n    const values = pointerValues(event);\n    state._movement = state._delta = V.sub(values, state._values);\n    this.computeValues(values);\n    this.compute(event);\n    state.delta = state.movement;\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction(\"pointer\", \"enter\", this.enter.bind(this));\n    bindFunction(\"pointer\", \"leave\", this.leave.bind(this));\n  }\n};\nvar hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\nvar EngineMap = /* @__PURE__ */ new Map();\nvar ConfigResolverMap = /* @__PURE__ */ new Map();\nfunction registerAction(action) {\n  EngineMap.set(action.key, action.engine);\n  ConfigResolverMap.set(action.key, action.resolver);\n}\nvar dragAction = {\n  key: \"drag\",\n  engine: DragEngine,\n  resolver: dragConfigResolver\n};\nvar hoverAction = {\n  key: \"hover\",\n  engine: HoverEngine,\n  resolver: hoverConfigResolver\n};\nvar moveAction = {\n  key: \"move\",\n  engine: MoveEngine,\n  resolver: moveConfigResolver\n};\nvar pinchAction = {\n  key: \"pinch\",\n  engine: PinchEngine,\n  resolver: pinchConfigResolver\n};\nvar scrollAction = {\n  key: \"scroll\",\n  engine: ScrollEngine,\n  resolver: scrollConfigResolver\n};\nvar wheelAction = {\n  key: \"wheel\",\n  engine: WheelEngine,\n  resolver: wheelConfigResolver\n};\n\n// node_modules/.pnpm/@use-gesture+react@10.2.23_react@18.2.0/node_modules/@use-gesture/react/dist/use-gesture-react.esm.js\nvar import_react4 = __toESM(require(\"react\"));\n\n// node_modules/.pnpm/@use-gesture+core@10.2.23/node_modules/@use-gesture/core/dist/use-gesture-core.esm.js\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null)\n    return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i4;\n  for (i4 = 0; i4 < sourceKeys.length; i4++) {\n    key = sourceKeys[i4];\n    if (excluded.indexOf(key) >= 0)\n      continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null)\n    return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i4;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i4 = 0; i4 < sourceSymbolKeys.length; i4++) {\n      key = sourceSymbolKeys[i4];\n      if (excluded.indexOf(key) >= 0)\n        continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key))\n        continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nvar sharedConfigResolver = {\n  target(value) {\n    if (value) {\n      return () => \"current\" in value ? value.current : value;\n    }\n    return void 0;\n  },\n  enabled(value = true) {\n    return value;\n  },\n  window(value = SUPPORT.isBrowser ? window : void 0) {\n    return value;\n  },\n  eventOptions({\n    passive = true,\n    capture = false\n  } = {}) {\n    return {\n      passive,\n      capture\n    };\n  },\n  transform(value) {\n    return value;\n  }\n};\nvar _excluded = [\"target\", \"eventOptions\", \"window\", \"enabled\", \"transform\"];\nfunction resolveWith(config = {}, resolvers) {\n  const result = {};\n  for (const [key, resolver] of Object.entries(resolvers)) {\n    switch (typeof resolver) {\n      case \"function\":\n        if (true) {\n          const r5 = resolver.call(result, config[key], key, config);\n          if (!Number.isNaN(r5))\n            result[key] = r5;\n        } else {\n          result[key] = resolver.call(result, config[key], key, config);\n        }\n        break;\n      case \"object\":\n        result[key] = resolveWith(config[key], resolver);\n        break;\n      case \"boolean\":\n        if (resolver)\n          result[key] = config[key];\n        break;\n    }\n  }\n  return result;\n}\nfunction parse(newConfig, gestureKey, _config = {}) {\n  const _ref = newConfig, {\n    target,\n    eventOptions,\n    window: window2,\n    enabled,\n    transform\n  } = _ref, rest = _objectWithoutProperties(_ref, _excluded);\n  _config.shared = resolveWith({\n    target,\n    eventOptions,\n    window: window2,\n    enabled,\n    transform\n  }, sharedConfigResolver);\n  if (gestureKey) {\n    const resolver = ConfigResolverMap.get(gestureKey);\n    _config[gestureKey] = resolveWith(_objectSpread2({\n      shared: _config.shared\n    }, rest), resolver);\n  } else {\n    for (const key in rest) {\n      const resolver = ConfigResolverMap.get(key);\n      if (resolver) {\n        _config[key] = resolveWith(_objectSpread2({\n          shared: _config.shared\n        }, rest[key]), resolver);\n      } else if (true) {\n        if (![\"drag\", \"pinch\", \"scroll\", \"wheel\", \"move\", \"hover\"].includes(key)) {\n          if (key === \"domTarget\") {\n            throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n          }\n          console.warn(`[@use-gesture]: Unknown config key \\`${key}\\` was used. Please read the documentation for further information.`);\n        }\n      }\n    }\n  }\n  return _config;\n}\nvar EventStore = class {\n  constructor(ctrl, gestureKey) {\n    _defineProperty(this, \"_listeners\", /* @__PURE__ */ new Set());\n    this._ctrl = ctrl;\n    this._gestureKey = gestureKey;\n  }\n  add(element, device, action, handler, options) {\n    const listeners = this._listeners;\n    const type = toDomEventType(device, action);\n    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};\n    const eventOptions = _objectSpread2(_objectSpread2({}, _options), options);\n    element.addEventListener(type, handler, eventOptions);\n    const remove = () => {\n      element.removeEventListener(type, handler, eventOptions);\n      listeners.delete(remove);\n    };\n    listeners.add(remove);\n    return remove;\n  }\n  clean() {\n    this._listeners.forEach((remove) => remove());\n    this._listeners.clear();\n  }\n};\nvar TimeoutStore = class {\n  constructor() {\n    _defineProperty(this, \"_timeouts\", /* @__PURE__ */ new Map());\n  }\n  add(key, callback, ms = 140, ...args) {\n    this.remove(key);\n    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));\n  }\n  remove(key) {\n    const timeout = this._timeouts.get(key);\n    if (timeout)\n      window.clearTimeout(timeout);\n  }\n  clean() {\n    this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));\n    this._timeouts.clear();\n  }\n};\nvar Controller = class {\n  constructor(handlers) {\n    _defineProperty(this, \"gestures\", /* @__PURE__ */ new Set());\n    _defineProperty(this, \"_targetEventStore\", new EventStore(this));\n    _defineProperty(this, \"gestureEventStores\", {});\n    _defineProperty(this, \"gestureTimeoutStores\", {});\n    _defineProperty(this, \"handlers\", {});\n    _defineProperty(this, \"config\", {});\n    _defineProperty(this, \"pointerIds\", /* @__PURE__ */ new Set());\n    _defineProperty(this, \"touchIds\", /* @__PURE__ */ new Set());\n    _defineProperty(this, \"state\", {\n      shared: {\n        shiftKey: false,\n        metaKey: false,\n        ctrlKey: false,\n        altKey: false\n      }\n    });\n    resolveGestures(this, handlers);\n  }\n  setEventIds(event) {\n    if (isTouch(event)) {\n      this.touchIds = new Set(touchIds(event));\n      return this.touchIds;\n    } else if (\"pointerId\" in event) {\n      if (event.type === \"pointerup\" || event.type === \"pointercancel\")\n        this.pointerIds.delete(event.pointerId);\n      else if (event.type === \"pointerdown\")\n        this.pointerIds.add(event.pointerId);\n      return this.pointerIds;\n    }\n  }\n  applyHandlers(handlers, nativeHandlers) {\n    this.handlers = handlers;\n    this.nativeHandlers = nativeHandlers;\n  }\n  applyConfig(config, gestureKey) {\n    this.config = parse(config, gestureKey, this.config);\n  }\n  clean() {\n    this._targetEventStore.clean();\n    for (const key of this.gestures) {\n      this.gestureEventStores[key].clean();\n      this.gestureTimeoutStores[key].clean();\n    }\n  }\n  effect() {\n    if (this.config.shared.target)\n      this.bind();\n    return () => this._targetEventStore.clean();\n  }\n  bind(...args) {\n    const sharedConfig = this.config.shared;\n    const props = {};\n    let target;\n    if (sharedConfig.target) {\n      target = sharedConfig.target();\n      if (!target)\n        return;\n    }\n    if (sharedConfig.enabled) {\n      for (const gestureKey of this.gestures) {\n        const gestureConfig = this.config[gestureKey];\n        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);\n        if (gestureConfig.enabled) {\n          const Engine2 = EngineMap.get(gestureKey);\n          new Engine2(this, args, gestureKey).bind(bindFunction);\n        }\n      }\n      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);\n      for (const eventKey in this.nativeHandlers) {\n        nativeBindFunction(\n          eventKey,\n          \"\",\n          (event) => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {\n            event,\n            args\n          })),\n          void 0,\n          true\n        );\n      }\n    }\n    for (const handlerProp in props) {\n      props[handlerProp] = chain(...props[handlerProp]);\n    }\n    if (!target)\n      return props;\n    for (const handlerProp in props) {\n      const {\n        device,\n        capture,\n        passive\n      } = parseProp(handlerProp);\n      this._targetEventStore.add(target, device, \"\", props[handlerProp], {\n        capture,\n        passive\n      });\n    }\n  }\n};\nfunction setupGesture(ctrl, gestureKey) {\n  ctrl.gestures.add(gestureKey);\n  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);\n  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();\n}\nfunction resolveGestures(ctrl, internalHandlers) {\n  if (internalHandlers.drag)\n    setupGesture(ctrl, \"drag\");\n  if (internalHandlers.wheel)\n    setupGesture(ctrl, \"wheel\");\n  if (internalHandlers.scroll)\n    setupGesture(ctrl, \"scroll\");\n  if (internalHandlers.move)\n    setupGesture(ctrl, \"move\");\n  if (internalHandlers.pinch)\n    setupGesture(ctrl, \"pinch\");\n  if (internalHandlers.hover)\n    setupGesture(ctrl, \"hover\");\n}\nvar bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {\n  var _options$capture, _options$passive;\n  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;\n  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;\n  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);\n  if (withPassiveOption && passive)\n    handlerProp += \"Passive\";\n  props[handlerProp] = props[handlerProp] || [];\n  props[handlerProp].push(handler);\n};\nvar RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\nfunction sortHandlers(_handlers) {\n  const native = {};\n  const handlers = {};\n  const actions = /* @__PURE__ */ new Set();\n  for (let key in _handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handlers[key] = _handlers[key];\n    } else {\n      native[key] = _handlers[key];\n    }\n  }\n  return [handlers, native, actions];\n}\nfunction registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {\n  if (!actions.has(handlerKey))\n    return;\n  if (!EngineMap.has(key)) {\n    if (true) {\n      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \\`${key}\\` gesture but isn't properly configured.\n\nPlease add \\`${key}Action\\` when creating your handler.`);\n    }\n    return;\n  }\n  const startKey = handlerKey + \"Start\";\n  const endKey = handlerKey + \"End\";\n  const fn2 = (state) => {\n    let memo45 = void 0;\n    if (state.first && startKey in handlers)\n      handlers[startKey](state);\n    if (handlerKey in handlers)\n      memo45 = handlers[handlerKey](state);\n    if (state.last && endKey in handlers)\n      handlers[endKey](state);\n    return memo45;\n  };\n  internalHandlers[key] = fn2;\n  config[key] = config[key] || {};\n}\nfunction parseMergedHandlers(mergedHandlers, mergedConfig) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);\n  const internalHandlers = {};\n  registerGesture(actions, handlers, \"onDrag\", \"drag\", internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, \"onWheel\", \"wheel\", internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, \"onScroll\", \"scroll\", internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, \"onPinch\", \"pinch\", internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, \"onMove\", \"move\", internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, \"onHover\", \"hover\", internalHandlers, mergedConfig);\n  return {\n    handlers: internalHandlers,\n    config: mergedConfig,\n    nativeHandlers\n  };\n}\n\n// node_modules/.pnpm/@use-gesture+react@10.2.23_react@18.2.0/node_modules/@use-gesture/react/dist/use-gesture-react.esm.js\nfunction useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {\n  const ctrl = import_react4.default.useMemo(() => new Controller(handlers), []);\n  ctrl.applyHandlers(handlers, nativeHandlers);\n  ctrl.applyConfig(config, gestureKey);\n  import_react4.default.useEffect(ctrl.effect.bind(ctrl));\n  import_react4.default.useEffect(() => {\n    return ctrl.clean.bind(ctrl);\n  }, []);\n  if (config.target === void 0) {\n    return ctrl.bind.bind(ctrl);\n  }\n  return void 0;\n}\nfunction createUseGesture(actions) {\n  actions.forEach(registerAction);\n  return function useGesture2(_handlers, _config) {\n    const {\n      handlers,\n      nativeHandlers,\n      config\n    } = parseMergedHandlers(_handlers, _config || {});\n    return useRecognizers(handlers, config, void 0, nativeHandlers);\n  };\n}\nfunction useGesture(handlers, config) {\n  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);\n  return hook(handlers, config || {});\n}\n\n// node_modules/.pnpm/@tldraw+core@1.23.2_react-dom@18.2.0_react@18.2.0/node_modules/@tldraw/core/dist/index.mjs\nvar V4 = __toESM(require(\"react\"), 1);\nvar import_react6 = require(\"react\");\nvar ot = __toESM(require(\"react\"), 1);\nvar Me = __toESM(require(\"react\"), 1);\nvar ye2 = __toESM(require(\"react\"), 1);\nvar ve = __toESM(require(\"react\"), 1);\nvar pe3 = __toESM(require(\"react\"), 1);\nvar xe2 = __toESM(require(\"react\"), 1);\nvar ut = __toESM(require(\"react\"), 1);\nvar pt = __toESM(require(\"react\"), 1);\nvar ft = __toESM(require(\"react\"), 1);\nvar gt = __toESM(require(\"react\"), 1);\nvar Ke = __toESM(require(\"react\"), 1);\nvar yt = __toESM(require(\"react\"), 1);\nvar xt = __toESM(require(\"react\"), 1);\nvar W2 = __toESM(require(\"react\"), 1);\n\n// node_modules/.pnpm/perfect-freehand@1.2.0/node_modules/perfect-freehand/dist/esm/index.js\nfunction $(e5, t5, u5, x5 = (h6) => h6) {\n  return e5 * x5(0.5 - t5 * (0.5 - u5));\n}\nfunction se(e5) {\n  return [-e5[0], -e5[1]];\n}\nfunction l(e5, t5) {\n  return [e5[0] + t5[0], e5[1] + t5[1]];\n}\nfunction a(e5, t5) {\n  return [e5[0] - t5[0], e5[1] - t5[1]];\n}\nfunction b(e5, t5) {\n  return [e5[0] * t5, e5[1] * t5];\n}\nfunction he(e5, t5) {\n  return [e5[0] / t5, e5[1] / t5];\n}\nfunction R(e5) {\n  return [e5[1], -e5[0]];\n}\nfunction B(e5, t5) {\n  return e5[0] * t5[0] + e5[1] * t5[1];\n}\nfunction ue(e5, t5) {\n  return e5[0] === t5[0] && e5[1] === t5[1];\n}\nfunction ge(e5) {\n  return Math.hypot(e5[0], e5[1]);\n}\nfunction de(e5) {\n  return e5[0] * e5[0] + e5[1] * e5[1];\n}\nfunction A(e5, t5) {\n  return de(a(e5, t5));\n}\nfunction G(e5) {\n  return he(e5, ge(e5));\n}\nfunction ie(e5, t5) {\n  return Math.hypot(e5[1] - t5[1], e5[0] - t5[0]);\n}\nfunction L(e5, t5, u5) {\n  let x5 = Math.sin(u5), h6 = Math.cos(u5), y6 = e5[0] - t5[0], n5 = e5[1] - t5[1], f5 = y6 * h6 - n5 * x5, d6 = y6 * x5 + n5 * h6;\n  return [f5 + t5[0], d6 + t5[1]];\n}\nfunction K(e5, t5, u5) {\n  return l(e5, b(a(t5, e5), u5));\n}\nfunction ee(e5, t5, u5) {\n  return l(e5, b(t5, u5));\n}\nvar { min: C, PI: xe } = Math;\nvar pe = 0.275;\nvar V2 = xe + 1e-4;\nfunction ce(e5, t5 = {}) {\n  let { size: u5 = 16, smoothing: x5 = 0.5, thinning: h6 = 0.5, simulatePressure: y6 = true, easing: n5 = (r5) => r5, start: f5 = {}, end: d6 = {}, last: D6 = false } = t5, { cap: S4 = true, easing: j4 = (r5) => r5 * (2 - r5) } = f5, { cap: q4 = true, easing: c5 = (r5) => --r5 * r5 * r5 + 1 } = d6;\n  if (e5.length === 0 || u5 <= 0)\n    return [];\n  let p6 = e5[e5.length - 1].runningLength, g6 = f5.taper === false ? 0 : f5.taper === true ? Math.max(u5, p6) : f5.taper, T5 = d6.taper === false ? 0 : d6.taper === true ? Math.max(u5, p6) : d6.taper, te2 = Math.pow(u5 * x5, 2), _3 = [], M3 = [], H5 = e5.slice(0, 10).reduce((r5, i4) => {\n    let o5 = i4.pressure;\n    if (y6) {\n      let s5 = C(1, i4.distance / u5), W5 = C(1, 1 - s5);\n      o5 = C(1, r5 + (W5 - r5) * (s5 * pe));\n    }\n    return (r5 + o5) / 2;\n  }, e5[0].pressure), m6 = $(u5, h6, e5[e5.length - 1].pressure, n5), U4, X3 = e5[0].vector, z5 = e5[0].point, F5 = z5, O6 = z5, E5 = F5, J3 = false;\n  for (let r5 = 0; r5 < e5.length; r5++) {\n    let { pressure: i4 } = e5[r5], { point: o5, vector: s5, distance: W5, runningLength: I3 } = e5[r5];\n    if (r5 < e5.length - 1 && p6 - I3 < 3)\n      continue;\n    if (h6) {\n      if (y6) {\n        let v6 = C(1, W5 / u5), Z3 = C(1, 1 - v6);\n        i4 = C(1, H5 + (Z3 - H5) * (v6 * pe));\n      }\n      m6 = $(u5, h6, i4, n5);\n    } else\n      m6 = u5 / 2;\n    U4 === void 0 && (U4 = m6);\n    let le3 = I3 < g6 ? j4(I3 / g6) : 1, fe2 = p6 - I3 < T5 ? c5((p6 - I3) / T5) : 1;\n    m6 = Math.max(0.01, m6 * Math.min(le3, fe2));\n    let re3 = (r5 < e5.length - 1 ? e5[r5 + 1] : e5[r5]).vector, Y3 = r5 < e5.length - 1 ? B(s5, re3) : 1, be3 = B(s5, X3) < 0 && !J3, ne2 = Y3 !== null && Y3 < 0;\n    if (be3 || ne2) {\n      let v6 = b(R(X3), m6);\n      for (let Z3 = 1 / 13, w7 = 0; w7 <= 1; w7 += Z3)\n        O6 = L(a(o5, v6), o5, V2 * w7), _3.push(O6), E5 = L(l(o5, v6), o5, V2 * -w7), M3.push(E5);\n      z5 = O6, F5 = E5, ne2 && (J3 = true);\n      continue;\n    }\n    if (J3 = false, r5 === e5.length - 1) {\n      let v6 = b(R(s5), m6);\n      _3.push(a(o5, v6)), M3.push(l(o5, v6));\n      continue;\n    }\n    let oe2 = b(R(K(re3, s5, Y3)), m6);\n    O6 = a(o5, oe2), (r5 <= 1 || A(z5, O6) > te2) && (_3.push(O6), z5 = O6), E5 = l(o5, oe2), (r5 <= 1 || A(F5, E5) > te2) && (M3.push(E5), F5 = E5), H5 = i4, X3 = s5;\n  }\n  let P5 = e5[0].point.slice(0, 2), k7 = e5.length > 1 ? e5[e5.length - 1].point.slice(0, 2) : l(e5[0].point, [1, 1]), Q3 = [], N4 = [];\n  if (e5.length === 1) {\n    if (!(g6 || T5) || D6) {\n      let r5 = ee(P5, G(R(a(P5, k7))), -(U4 || m6)), i4 = [];\n      for (let o5 = 1 / 13, s5 = o5; s5 <= 1; s5 += o5)\n        i4.push(L(r5, P5, V2 * 2 * s5));\n      return i4;\n    }\n  } else {\n    if (!(g6 || T5 && e5.length === 1))\n      if (S4)\n        for (let i4 = 1 / 13, o5 = i4; o5 <= 1; o5 += i4) {\n          let s5 = L(M3[0], P5, V2 * o5);\n          Q3.push(s5);\n        }\n      else {\n        let i4 = a(_3[0], M3[0]), o5 = b(i4, 0.5), s5 = b(i4, 0.51);\n        Q3.push(a(P5, o5), a(P5, s5), l(P5, s5), l(P5, o5));\n      }\n    let r5 = R(se(e5[e5.length - 1].vector));\n    if (T5 || g6 && e5.length === 1)\n      N4.push(k7);\n    else if (q4) {\n      let i4 = ee(k7, r5, m6);\n      for (let o5 = 1 / 29, s5 = o5; s5 < 1; s5 += o5)\n        N4.push(L(i4, k7, V2 * 3 * s5));\n    } else\n      N4.push(l(k7, b(r5, m6)), l(k7, b(r5, m6 * 0.99)), a(k7, b(r5, m6 * 0.99)), a(k7, b(r5, m6)));\n  }\n  return _3.concat(N4, M3.reverse(), Q3);\n}\nfunction me(e5, t5 = {}) {\n  var q4;\n  let { streamline: u5 = 0.5, size: x5 = 16, last: h6 = false } = t5;\n  if (e5.length === 0)\n    return [];\n  let y6 = 0.15 + (1 - u5) * 0.85, n5 = Array.isArray(e5[0]) ? e5 : e5.map(({ x: c5, y: p6, pressure: g6 = 0.5 }) => [c5, p6, g6]);\n  if (n5.length === 2) {\n    let c5 = n5[1];\n    n5 = n5.slice(0, -1);\n    for (let p6 = 1; p6 < 5; p6++)\n      n5.push(K(n5[0], c5, p6 / 4));\n  }\n  n5.length === 1 && (n5 = [...n5, [...l(n5[0], [1, 1]), ...n5[0].slice(2)]]);\n  let f5 = [{ point: [n5[0][0], n5[0][1]], pressure: n5[0][2] >= 0 ? n5[0][2] : 0.25, vector: [1, 1], distance: 0, runningLength: 0 }], d6 = false, D6 = 0, S4 = f5[0], j4 = n5.length - 1;\n  for (let c5 = 1; c5 < n5.length; c5++) {\n    let p6 = h6 && c5 === j4 ? n5[c5].slice(0, 2) : K(S4.point, n5[c5], y6);\n    if (ue(S4.point, p6))\n      continue;\n    let g6 = ie(p6, S4.point);\n    if (D6 += g6, c5 < j4 && !d6) {\n      if (D6 < x5)\n        continue;\n      d6 = true;\n    }\n    S4 = { point: p6, pressure: n5[c5][2] >= 0 ? n5[c5][2] : 0.5, vector: G(a(S4.point, p6)), distance: g6, runningLength: D6 }, f5.push(S4);\n  }\n  return f5[0].vector = ((q4 = f5[1]) == null ? void 0 : q4.vector) || [0, 0], f5;\n}\nfunction ae(e5, t5 = {}) {\n  return ce(me(e5, t5), t5);\n}\nvar _e = ae;\n\n// node_modules/.pnpm/@tldraw+core@1.23.2_react-dom@18.2.0_react@18.2.0/node_modules/@tldraw/core/dist/index.mjs\nvar Ue = __toESM(require(\"react\"), 1);\nvar he2 = __toESM(require(\"react\"), 1);\nvar ne = __toESM(require(\"react\"), 1);\nvar G3 = __toESM(require(\"react\"), 1);\nvar K3 = __toESM(require(\"react\"), 1);\nvar ae2 = __toESM(require(\"react\"), 1);\nvar $e = __toESM(require(\"react\"), 1);\nvar $3 = __toESM(require(\"react\"), 1);\nvar q2 = __toESM(require(\"react\"), 1);\nvar fe = __toESM(require(\"react\"), 1);\nvar Ne = __toESM(require(\"react\"), 1);\nvar F2 = __toESM(require(\"react\"), 1);\nvar Te2 = __toESM(require(\"react\"), 1);\nvar ge2 = __toESM(require(\"react\"), 1);\nvar de3 = __toESM(require(\"react\"), 1);\nvar oe = __toESM(require(\"react\"), 1);\nvar re = __toESM(require(\"react\"), 1);\nvar Re = __toESM(require(\"react\"), 1);\nvar We = __toESM(require(\"react\"), 1);\nvar le2 = __toESM(require(\"react\"), 1);\nvar j2 = __toESM(require(\"react\"), 1);\nvar Be = __toESM(require(\"react\"), 1);\nvar ce3 = __toESM(require(\"react\"), 1);\nvar ie3 = __toESM(require(\"react\"), 1);\nvar se3 = __toESM(require(\"react\"), 1);\nvar me2 = __toESM(require(\"react\"), 1);\n\n// node_modules/.pnpm/@tldraw+intersect@1.9.2/node_modules/@tldraw/intersect/dist/index.mjs\nvar A2 = Object.defineProperty;\nvar M = Object.defineProperties;\nvar q = Object.getOwnPropertyDescriptors;\nvar X = Object.getOwnPropertySymbols;\nvar V3 = Object.prototype.hasOwnProperty;\nvar $2 = Object.prototype.propertyIsEnumerable;\nvar Y = (e5, n5, t5) => n5 in e5 ? A2(e5, n5, { enumerable: true, configurable: true, writable: true, value: t5 }) : e5[n5] = t5;\nvar g = (e5, n5) => {\n  for (var t5 in n5 || (n5 = {}))\n    V3.call(n5, t5) && Y(e5, t5, n5[t5]);\n  if (X)\n    for (var t5 of X(n5))\n      $2.call(n5, t5) && Y(e5, t5, n5[t5]);\n  return e5;\n};\nvar T = (e5, n5) => M(e5, q(n5));\nfunction l2(e5, ...n5) {\n  return { didIntersect: n5.length > 0, message: e5, points: n5 };\n}\nfunction I(e5, n5, t5 = 0) {\n  let r5 = [e5[0] + n5[0] / 2, e5[1] + n5[1] / 2], i4 = e.rotWith(e5, r5, t5), u5 = e.rotWith(e.add(e5, [n5[0], 0]), r5, t5), s5 = e.rotWith(e.add(e5, n5), r5, t5), o5 = e.rotWith(e.add(e5, [0, n5[1]]), r5, t5);\n  return [[\"top\", [i4, u5]], [\"right\", [u5, s5]], [\"bottom\", [s5, o5]], [\"left\", [o5, i4]]];\n}\nfunction v(e5, n5, t5) {\n  if (t5 === e5 || t5 === n5)\n    return true;\n  let r5 = Math.PI * 2, i4 = (n5 - e5 + r5) % r5, u5 = (t5 - e5 + r5) % r5;\n  return i4 <= Math.PI != u5 > i4;\n}\nfunction ie2(e5, n5) {\n  let t5 = e.slope(e5[0], e5[1]), r5 = e.slope(n5[0], n5[1]);\n  if (t5 === r5)\n    return;\n  if (Number.isNaN(t5) && !Number.isNaN(r5))\n    return [e5[0][0], (e5[0][0] - n5[0][0]) * r5 + n5[0][1]];\n  if (Number.isNaN(r5) && !Number.isNaN(t5))\n    return [n5[0][0], (n5[0][0] - e5[0][0]) * t5 + e5[0][1]];\n  let i4 = (t5 * e5[0][0] - r5 * n5[0][0] + n5[0][1] - e5[0][1]) / (t5 - r5), u5 = r5 * (i4 - n5[0][0]) + n5[0][1];\n  return [i4, u5];\n}\nfunction x(e5, n5, t5, r5) {\n  let [i4, u5] = e5, [s5, o5] = n5, [c5, m6] = t5, [b6, f5] = r5;\n  if (o5 / s5 !== (f5 - m6) / (b6 - c5)) {\n    let p6 = s5 * (f5 - m6) - o5 * (b6 - c5);\n    if (p6 !== 0) {\n      let L5 = ((u5 - m6) * (b6 - c5) - (i4 - c5) * (f5 - m6)) / p6, h6 = ((u5 - m6) * s5 - (i4 - c5) * o5) / p6;\n      if (L5 >= 0 && h6 >= 0 && h6 <= 1)\n        return l2(\"intersection\", [i4 + L5 * s5, u5 + L5 * o5]);\n    }\n  }\n  return l2(\"no intersection\");\n}\nfunction N(e5, n5, t5, r5, i4 = 0) {\n  return G2(t5, r5, i4, e5, n5);\n}\nfunction F(e5, n5, t5, r5, i4, u5) {\n  let s5 = e5, o5 = e.mul(n5, 999999999);\n  return y(s5, o5, t5, r5, i4, u5);\n}\nfunction se2(e5, n5, t5, r5 = 0) {\n  let { minX: i4, minY: u5, width: s5, height: o5 } = t5;\n  return N(e5, n5, [i4, u5], [s5, o5], r5);\n}\nfunction B2(e5, n5, t5, r5) {\n  let i4 = e.sub(e5, t5), u5 = e.sub(r5, t5), s5 = e.sub(n5, e5), o5 = u5[0] * i4[1] - u5[1] * i4[0], c5 = s5[0] * i4[1] - s5[1] * i4[0], m6 = u5[1] * s5[0] - u5[0] * s5[1];\n  if (o5 === 0 || c5 === 0)\n    return l2(\"coincident\");\n  if (m6 === 0)\n    return l2(\"parallel\");\n  if (m6 !== 0) {\n    let b6 = o5 / m6, f5 = c5 / m6;\n    if (0 <= b6 && b6 <= 1 && 0 <= f5 && f5 <= 1)\n      return l2(\"intersection\", e.add(e5, e.mul(s5, b6)));\n  }\n  return l2(\"no intersection\");\n}\nfunction j(e5, n5, t5, r5) {\n  return E(t5, r5, e5, n5);\n}\nfunction k(e5, n5, t5, r5, i4, u5) {\n  let s5 = e.angle(t5, i4), o5 = e.angle(t5, u5), c5 = U(t5, r5, r5, 0, e5, n5);\n  if (!c5.didIntersect)\n    return l2(\"no intersection\");\n  let m6 = c5.points.filter((b6) => v(s5, o5, e.angle(t5, b6)));\n  return m6.length === 0 ? l2(\"no intersection\") : l2(\"intersection\", ...m6);\n}\nfunction R2(e5, n5, t5, r5) {\n  let i4 = (n5[0] - e5[0]) * (n5[0] - e5[0]) + (n5[1] - e5[1]) * (n5[1] - e5[1]), u5 = 2 * ((n5[0] - e5[0]) * (e5[0] - t5[0]) + (n5[1] - e5[1]) * (e5[1] - t5[1])), s5 = t5[0] * t5[0] + t5[1] * t5[1] + e5[0] * e5[0] + e5[1] * e5[1] - 2 * (t5[0] * e5[0] + t5[1] * e5[1]) - r5 * r5, o5 = u5 * u5 - 4 * i4 * s5;\n  if (o5 < 0)\n    return l2(\"outside\");\n  if (o5 === 0)\n    return l2(\"tangent\");\n  let c5 = Math.sqrt(o5), m6 = (-u5 + c5) / (2 * i4), b6 = (-u5 - c5) / (2 * i4);\n  if ((m6 < 0 || m6 > 1) && (b6 < 0 || b6 > 1))\n    return m6 < 0 && b6 < 0 || m6 > 1 && b6 > 1 ? l2(\"outside\") : l2(\"inside\");\n  let f5 = [];\n  return 0 <= m6 && m6 <= 1 && f5.push(e.lrp(e5, n5, m6)), 0 <= b6 && b6 <= 1 && f5.push(e.lrp(e5, n5, b6)), l2(\"intersection\", ...f5);\n}\nfunction y(e5, n5, t5, r5, i4, u5 = 0) {\n  if (r5 === 0 || i4 === 0 || e.isEqual(e5, n5))\n    return l2(\"no intersection\");\n  r5 = r5 < 0 ? r5 : -r5, i4 = i4 < 0 ? i4 : -i4, e5 = e.sub(e.rotWith(e5, t5, -u5), t5), n5 = e.sub(e.rotWith(n5, t5, -u5), t5);\n  let s5 = e.sub(n5, e5), o5 = s5[0] * s5[0] / r5 / r5 + s5[1] * s5[1] / i4 / i4, c5 = 2 * e5[0] * s5[0] / r5 / r5 + 2 * e5[1] * s5[1] / i4 / i4, m6 = e5[0] * e5[0] / r5 / r5 + e5[1] * e5[1] / i4 / i4 - 1, b6 = [], f5 = c5 * c5 - 4 * o5 * m6;\n  if (f5 === 0)\n    b6.push(-c5 / 2 / o5);\n  else if (f5 > 0) {\n    let L5 = Math.sqrt(f5);\n    b6.push((-c5 + L5) / 2 / o5), b6.push((-c5 - L5) / 2 / o5);\n  }\n  let p6 = b6.filter((L5) => L5 >= 0 && L5 <= 1).map((L5) => e.add(t5, e.add(e5, e.mul(e.sub(n5, e5), L5)))).map((L5) => e.rotWith(L5, t5, u5));\n  return l2(\"intersection\", ...p6);\n}\nfunction ce2(e5, n5, t5) {\n  return z(t5, e5, n5);\n}\nfunction S(e5, n5, t5) {\n  let r5 = [];\n  for (let i4 = 1; i4 < t5.length; i4++) {\n    let u5 = B2(e5, n5, t5[i4 - 1], t5[i4]);\n    u5 && r5.push(...u5.points);\n  }\n  return r5.length === 0 ? l2(\"no intersection\") : l2(\"intersection\", ...t5);\n}\nfunction D(e5, n5, t5) {\n  let r5 = [];\n  for (let i4 = 1; i4 < t5.length + 1; i4++) {\n    let u5 = B2(e5, n5, t5[i4 - 1], t5[i4 % t5.length]);\n    u5 && r5.push(...u5.points);\n  }\n  return r5.length === 0 ? l2(\"no intersection\") : l2(\"intersection\", ...t5);\n}\nfunction G2(e5, n5, t5, r5, i4) {\n  return I(e5, n5, t5).reduce((s5, [o5, [c5, m6]]) => {\n    let b6 = x(r5, i4, c5, m6);\n    return b6 && s5.push(l2(o5, ...b6.points)), s5;\n  }, []).filter((s5) => s5.didIntersect);\n}\nfunction E(e5, n5, t5, r5) {\n  return I(e5, n5).reduce((u5, [s5, [o5, c5]]) => {\n    let m6 = B2(t5, r5, o5, c5);\n    return m6 && u5.push(l2(s5, ...m6.points)), u5;\n  }, []).filter((u5) => u5.didIntersect);\n}\nfunction a2(e5, n5, t5, r5) {\n  return I(e5, n5).reduce((u5, [s5, [o5, c5]]) => {\n    let m6 = E(t5, r5, o5, c5);\n    return u5.push(...m6.map((b6) => l2(`${s5} ${b6.message}`, ...b6.points))), u5;\n  }, []).filter((u5) => u5.didIntersect);\n}\nfunction H(e5, n5, t5, r5, i4, u5) {\n  return I(e5, n5).reduce((o5, [c5, [m6, b6]]) => {\n    let f5 = O(t5, r5, i4, u5, m6, b6);\n    return f5 && o5.push(T(g({}, f5), { message: c5 })), o5;\n  }, []).filter((o5) => o5.didIntersect);\n}\nfunction C2(e5, n5, t5, r5) {\n  return I(e5, n5).reduce((u5, [s5, [o5, c5]]) => {\n    let m6 = R2(o5, c5, t5, r5);\n    return m6 && u5.push(T(g({}, m6), { message: s5 })), u5;\n  }, []).filter((u5) => u5.didIntersect);\n}\nfunction J(e5, n5, t5, r5, i4, u5 = 0) {\n  return I(e5, n5).reduce((o5, [c5, [m6, b6]]) => {\n    let f5 = y(m6, b6, t5, r5, i4, u5);\n    return f5 && o5.push(T(g({}, f5), { message: c5 })), o5;\n  }, []).filter((o5) => o5.didIntersect);\n}\nfunction w(e5, n5, t5) {\n  return I(e5, n5).reduce((i4, [u5, [s5, o5]]) => {\n    let c5 = S(s5, o5, t5);\n    return c5.didIntersect && i4.push(l2(u5, ...c5.points)), i4;\n  }, []).filter((i4) => i4.didIntersect);\n}\nfunction K2(e5, n5, t5) {\n  return I(e5, n5).reduce((i4, [u5, [s5, o5]]) => {\n    let c5 = D(s5, o5, t5);\n    return c5.didIntersect && i4.push(l2(u5, ...c5.points)), i4;\n  }, []).filter((i4) => i4.didIntersect);\n}\nfunction O(e5, n5, t5, r5, i4, u5) {\n  return k(i4, u5, e5, n5, t5, r5);\n}\nfunction _(e5, n5, t5, r5, i4, u5) {\n  return H(i4, u5, e5, n5, t5, r5);\n}\nfunction be(e5, n5, t5, r5, i4) {\n  let { minX: u5, minY: s5, width: o5, height: c5 } = i4;\n  return _(e5, n5, t5, r5, [u5, s5], [o5, c5]);\n}\nfunction de2(e5, n5, t5, r5) {\n  return R2(t5, r5, e5, n5);\n}\nfunction le(e5, n5, t5, r5) {\n  let i4 = t5[0] - e5[0], u5 = t5[1] - e5[1], s5 = Math.sqrt(i4 * i4 + u5 * u5), o5 = (s5 * s5 - r5 * r5 + n5 * n5) / (2 * s5), c5 = Math.sqrt(n5 * n5 - o5 * o5);\n  return i4 /= s5, u5 /= s5, l2(\"intersection\", [e5[0] + i4 * o5 - u5 * c5, e5[1] + u5 * o5 + i4 * c5], [e5[0] + i4 * o5 + u5 * c5, e5[1] + u5 * o5 - i4 * c5]);\n}\nfunction U(e5, n5, t5, r5 = 0, i4, u5) {\n  return n5 === t5 ? R2(i4, u5, e5, n5) : y(i4, u5, e5, n5, t5, r5);\n}\nfunction W(e5, n5, t5, r5 = 0, i4, u5) {\n  return n5 === t5 ? C2(i4, u5, e5, n5) : J(i4, u5, e5, n5, t5, r5);\n}\nfunction pe2(e5, n5, t5, r5, i4) {\n  let { minX: u5, minY: s5, width: o5, height: c5 } = i4;\n  return W(e5, n5, t5, r5, [u5, s5], [o5, c5]);\n}\nfunction z(e5, n5, t5) {\n  let { minX: r5, minY: i4, width: u5, height: s5 } = e5;\n  return j(n5, t5, [r5, i4], [u5, s5]);\n}\nfunction Te(e5, n5) {\n  return a2([e5.minX, e5.minY], [e5.width, e5.height], [n5.minX, n5.minY], [n5.width, n5.height]);\n}\nfunction ye(e5, n5) {\n  return Q(n5, e5);\n}\nfunction Se(e5, n5) {\n  return ee2(n5, e5);\n}\nfunction Q(e5, n5) {\n  return w([n5.minX, n5.minY], [n5.width, n5.height], e5);\n}\nfunction ee2(e5, n5) {\n  return K2([n5.minX, n5.minY], [n5.width, n5.height], e5);\n}\n\n// node_modules/.pnpm/@tldraw+core@1.23.2_react-dom@18.2.0_react@18.2.0/node_modules/@tldraw/core/dist/index.mjs\nvar Ae = __toESM(require(\"react\"), 1);\nvar qt = Object.defineProperty;\nvar Qt = Object.defineProperties;\nvar Jt = Object.getOwnPropertyDescriptors;\nvar Ce = Object.getOwnPropertySymbols;\nvar Ze = Object.prototype.hasOwnProperty;\nvar qe = Object.prototype.propertyIsEnumerable;\nvar Oe = (r5, e5, t5) => e5 in r5 ? qt(r5, e5, { enumerable: true, configurable: true, writable: true, value: t5 }) : r5[e5] = t5;\nvar g2 = (r5, e5) => {\n  for (var t5 in e5 || (e5 = {}))\n    Ze.call(e5, t5) && Oe(r5, t5, e5[t5]);\n  if (Ce)\n    for (var t5 of Ce(e5))\n      qe.call(e5, t5) && Oe(r5, t5, e5[t5]);\n  return r5;\n};\nvar U2 = (r5, e5) => Qt(r5, Jt(e5));\nvar O2 = (r5, e5) => {\n  var t5 = {};\n  for (var n5 in r5)\n    Ze.call(r5, n5) && e5.indexOf(n5) < 0 && (t5[n5] = r5[n5]);\n  if (r5 != null && Ce)\n    for (var n5 of Ce(r5))\n      e5.indexOf(n5) < 0 && qe.call(r5, n5) && (t5[n5] = r5[n5]);\n  return t5;\n};\nvar E2 = (r5, e5, t5) => (Oe(r5, typeof e5 != \"symbol\" ? e5 + \"\" : e5, t5), t5);\nvar Le = Se2.createContext({});\nfunction R3() {\n  return Se2.useContext(Le);\n}\nvar Qe = ((o5) => (o5.TransformSelected = \"transform_selected\", o5.TranslateSelected = \"translate_selected\", o5.TransformAll = \"transform_all\", o5.TranslateAll = \"translate_all\", o5))(Qe || {});\nvar we = ((o5) => (o5.Top = \"top_edge\", o5.Right = \"right_edge\", o5.Bottom = \"bottom_edge\", o5.Left = \"left_edge\", o5))(we || {});\nvar He = ((o5) => (o5.TopLeft = \"top_left_corner\", o5.TopRight = \"top_right_corner\", o5.BottomRight = \"bottom_right_corner\", o5.BottomLeft = \"bottom_left_corner\", o5))(He || {});\nvar Je = ((s5) => (s5.minX = \"minX\", s5.midX = \"midX\", s5.maxX = \"maxX\", s5.minY = \"minY\", s5.midY = \"midY\", s5.maxY = \"maxY\", s5))(Je || {});\nString.prototype.replaceAll || (String.prototype.replaceAll = function(r5, e5) {\n  return Object.prototype.toString.call(r5).toLowerCase() === \"[object regexp]\" ? this.replace(r5, e5) : this.replace(new RegExp(r5, \"g\"), e5);\n});\nvar Ie = Math.PI * 2;\nvar k2 = class {\n  static lerp(e5, t5, n5) {\n    return n5 = k2.clamp(n5, 0, 1), e5 * (1 - n5) + t5 * n5;\n  }\n  static lerpColor(e5, t5, n5 = 0.5) {\n    function o5(l7) {\n      let c5 = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(l7);\n      return [parseInt(c5[1], 16), parseInt(c5[2], 16), parseInt(c5[3], 16)];\n    }\n    function i4(l7) {\n      return \"#\" + ((1 << 24) + (l7[0] << 16) + (l7[1] << 8) + l7[2]).toString(16).slice(1);\n    }\n    let s5 = o5(e5) || [0, 0, 0], a7 = o5(t5) || [0, 0, 0], d6 = s5.slice();\n    for (let l7 = 0; l7 < 3; l7++)\n      d6[l7] = Math.round(d6[l7] + n5 * (a7[l7] - s5[l7]));\n    return i4(d6);\n  }\n  static modulate(e5, t5, n5, o5 = false) {\n    let [i4, s5] = t5, [a7, d6] = n5, l7 = a7 + (e5 - i4) / (s5 - i4) * (d6 - a7);\n    return o5 ? a7 < d6 ? Math.max(Math.min(l7, d6), a7) : Math.max(Math.min(l7, a7), d6) : l7;\n  }\n  static clamp(e5, t5, n5) {\n    return Math.max(t5, typeof n5 != \"undefined\" ? Math.min(e5, n5) : e5);\n  }\n  static deepClone(e5) {\n    if (e5 === null)\n      return e5;\n    if (Array.isArray(e5))\n      return [...e5];\n    if (typeof e5 == \"object\") {\n      let t5 = g2({}, e5);\n      return Object.keys(t5).forEach((n5) => t5[n5] = typeof e5[n5] == \"object\" ? k2.deepClone(e5[n5]) : e5[n5]), t5;\n    }\n    return e5;\n  }\n  static rng(e5 = \"\") {\n    let t5 = 0, n5 = 0, o5 = 0, i4 = 0;\n    function s5() {\n      let a7 = t5 ^ t5 << 11;\n      return t5 = n5, n5 = o5, o5 = i4, i4 ^= (i4 >>> 19 ^ a7 ^ a7 >>> 8) >>> 0, i4 / 4294967296;\n    }\n    for (let a7 = 0; a7 < e5.length + 64; a7++)\n      t5 ^= e5.charCodeAt(a7) | 0, s5();\n    return s5;\n  }\n  static pointsToLineSegments(e5, t5 = false) {\n    let n5 = [];\n    for (let o5 = 1; o5 < e5.length; o5++)\n      n5.push([e5[o5 - 1], e5[o5]]);\n    return t5 && n5.push([e5[e5.length - 1], e5[0]]), n5;\n  }\n  static getRectangleSides(e5, t5, n5 = 0) {\n    let o5 = [e5[0] + t5[0] / 2, e5[1] + t5[1] / 2], i4 = e.rotWith(e5, o5, n5), s5 = e.rotWith(e.add(e5, [t5[0], 0]), o5, n5), a7 = e.rotWith(e.add(e5, t5), o5, n5), d6 = e.rotWith(e.add(e5, [0, t5[1]]), o5, n5);\n    return [[\"top\", [i4, s5]], [\"right\", [s5, a7]], [\"bottom\", [a7, d6]], [\"left\", [d6, i4]]];\n  }\n  static circleFromThreePoints(e5, t5, n5) {\n    let [o5, i4] = e5, [s5, a7] = t5, [d6, l7] = n5, c5 = o5 * (a7 - l7) - i4 * (s5 - d6) + s5 * l7 - d6 * a7, m6 = (o5 * o5 + i4 * i4) * (l7 - a7) + (s5 * s5 + a7 * a7) * (i4 - l7) + (d6 * d6 + l7 * l7) * (a7 - i4), p6 = (o5 * o5 + i4 * i4) * (s5 - d6) + (s5 * s5 + a7 * a7) * (d6 - o5) + (d6 * d6 + l7 * l7) * (o5 - s5), u5 = -m6 / (2 * c5), y6 = -p6 / (2 * c5);\n    return [u5, y6, Math.hypot(u5 - o5, y6 - i4)];\n  }\n  static perimeterOfEllipse(e5, t5) {\n    let n5 = Math.pow(e5 - t5, 2) / Math.pow(e5 + t5, 2);\n    return Math.PI * (e5 + t5) * (1 + 3 * n5 / (10 + Math.sqrt(4 - 3 * n5)));\n  }\n  static shortAngleDist(e5, t5) {\n    let n5 = Math.PI * 2, o5 = (t5 - e5) % n5;\n    return 2 * o5 % n5 - o5;\n  }\n  static longAngleDist(e5, t5) {\n    return Math.PI * 2 - k2.shortAngleDist(e5, t5);\n  }\n  static lerpAngles(e5, t5, n5) {\n    return e5 + k2.shortAngleDist(e5, t5) * n5;\n  }\n  static angleDelta(e5, t5) {\n    return k2.shortAngleDist(e5, t5);\n  }\n  static getSweep(e5, t5, n5) {\n    return k2.angleDelta(e.angle(e5, t5), e.angle(e5, n5));\n  }\n  static clampRadians(e5) {\n    return (Math.PI * 2 + e5) % (Math.PI * 2);\n  }\n  static snapAngleToSegments(e5, t5) {\n    let n5 = Math.PI * 2 / t5;\n    return Math.floor((k2.clampRadians(e5) + n5 / 2) / n5) * n5;\n  }\n  static isAngleBetween(e5, t5, n5) {\n    if (n5 === e5 || n5 === t5)\n      return true;\n    let o5 = (t5 - e5 + Ie) % Ie, i4 = (n5 - e5 + Ie) % Ie;\n    return o5 <= Math.PI != i4 > o5;\n  }\n  static degreesToRadians(e5) {\n    return e5 * Math.PI / 180;\n  }\n  static radiansToDegrees(e5) {\n    return e5 * 180 / Math.PI;\n  }\n  static getArcLength(e5, t5, n5, o5) {\n    let i4 = k2.getSweep(e5, n5, o5);\n    return t5 * (2 * Math.PI) * (i4 / (2 * Math.PI));\n  }\n  static getSweepFlag(e5, t5, n5) {\n    let o5 = e.angle(e5, n5);\n    return (e.angle(e5, t5) - o5 + 3 * Math.PI) % (2 * Math.PI) - Math.PI > 0 ? 0 : 1;\n  }\n  static getLargeArcFlag(e5, t5, n5) {\n    let o5 = e.angle(n5, e5), s5 = (e.angle(n5, t5) - o5 + 3 * Math.PI) % (2 * Math.PI) - Math.PI;\n    return Math.abs(s5) > Math.PI / 2 ? 0 : 1;\n  }\n  static getArcDashOffset(e5, t5, n5, o5, i4) {\n    let s5 = k2.getSweepFlag(e5, n5, o5), a7 = k2.getArcLength(e5, t5, n5, o5);\n    return -(s5 < 0 ? a7 : 2 * Math.PI * e5[2] - a7) / 2 + i4;\n  }\n  static getEllipseDashOffset(e5, t5) {\n    return -(2 * Math.PI * e5[2]) / 2 + -t5;\n  }\n  static pointInCircle(e5, t5, n5) {\n    return e.dist(e5, t5) <= n5;\n  }\n  static pointInEllipse(e5, t5, n5, o5, i4 = 0) {\n    i4 = i4 || 0;\n    let s5 = Math.cos(i4), a7 = Math.sin(i4), d6 = e.sub(e5, t5), l7 = s5 * d6[0] + a7 * d6[1], c5 = a7 * d6[0] - s5 * d6[1];\n    return l7 * l7 / (n5 * n5) + c5 * c5 / (o5 * o5) <= 1;\n  }\n  static pointInRect(e5, t5) {\n    return !(e5[0] < t5[0] || e5[0] > e5[0] + t5[0] || e5[1] < t5[1] || e5[1] > e5[1] + t5[1]);\n  }\n  static pointInPolygon(e5, t5) {\n    let n5 = 0;\n    return t5.forEach((o5, i4) => {\n      let s5 = t5[(i4 + 1) % t5.length];\n      o5[1] <= e5[1] ? s5[1] > e5[1] && e.cross(o5, s5, e5) > 0 && (n5 += 1) : s5[1] <= e5[1] && e.cross(o5, s5, e5) < 0 && (n5 -= 1);\n    }), n5 !== 0;\n  }\n  static pointInBounds(e5, t5) {\n    return !(e5[0] < t5.minX || e5[0] > t5.maxX || e5[1] < t5.minY || e5[1] > t5.maxY);\n  }\n  static pointInPolyline(e5, t5, n5 = 3) {\n    for (let o5 = 1; o5 < t5.length; o5++)\n      if (e.distanceToLineSegment(t5[o5 - 1], t5[o5], e5) < n5)\n        return true;\n    return false;\n  }\n  static getBoundsSides(e5) {\n    return this.getRectangleSides([e5.minX, e5.minY], [e5.width, e5.height]);\n  }\n  static expandBounds(e5, t5) {\n    return { minX: e5.minX - t5, minY: e5.minY - t5, maxX: e5.maxX + t5, maxY: e5.maxY + t5, width: e5.width + t5 * 2, height: e5.height + t5 * 2 };\n  }\n  static boundsCollide(e5, t5) {\n    return !(e5.maxX < t5.minX || e5.minX > t5.maxX || e5.maxY < t5.minY || e5.minY > t5.maxY);\n  }\n  static boundsContain(e5, t5) {\n    return e5.minX < t5.minX && e5.minY < t5.minY && e5.maxY > t5.maxY && e5.maxX > t5.maxX;\n  }\n  static boundsContained(e5, t5) {\n    return k2.boundsContain(t5, e5);\n  }\n  static boundsAreEqual(e5, t5) {\n    return !(t5.maxX !== e5.maxX || t5.minX !== e5.minX || t5.maxY !== e5.maxY || t5.minY !== e5.minY);\n  }\n  static getBoundsFromPoints(e5, t5 = 0) {\n    let n5 = 1 / 0, o5 = 1 / 0, i4 = -1 / 0, s5 = -1 / 0;\n    if (e5.length < 2)\n      n5 = 0, o5 = 0, i4 = 1, s5 = 1;\n    else\n      for (let [a7, d6] of e5)\n        n5 = Math.min(a7, n5), o5 = Math.min(d6, o5), i4 = Math.max(a7, i4), s5 = Math.max(d6, s5);\n    return t5 !== 0 ? k2.getBoundsFromPoints(e5.map((a7) => e.rotWith(a7, [(n5 + i4) / 2, (o5 + s5) / 2], t5))) : { minX: n5, minY: o5, maxX: i4, maxY: s5, width: Math.max(1, i4 - n5), height: Math.max(1, s5 - o5) };\n  }\n  static centerBounds(e5, t5) {\n    let n5 = this.getBoundsCenter(e5), o5 = t5[0] - n5[0], i4 = t5[1] - n5[1];\n    return this.translateBounds(e5, [o5, i4]);\n  }\n  static snapBoundsToGrid(e5, t5) {\n    let n5 = Math.round(e5.minX / t5) * t5, o5 = Math.round(e5.minY / t5) * t5, i4 = Math.round(e5.maxX / t5) * t5, s5 = Math.round(e5.maxY / t5) * t5;\n    return { minX: n5, minY: o5, maxX: i4, maxY: s5, width: Math.max(1, i4 - n5), height: Math.max(1, s5 - o5) };\n  }\n  static translateBounds(e5, t5) {\n    return { minX: e5.minX + t5[0], minY: e5.minY + t5[1], maxX: e5.maxX + t5[0], maxY: e5.maxY + t5[1], width: e5.width, height: e5.height };\n  }\n  static rotateBounds(e5, t5, n5) {\n    let [o5, i4] = e.rotWith([e5.minX, e5.minY], t5, n5), [s5, a7] = e.rotWith([e5.maxX, e5.maxY], t5, n5);\n    return { minX: o5, minY: i4, maxX: s5, maxY: a7, width: e5.width, height: e5.height };\n  }\n  static getRotatedEllipseBounds(e5, t5, n5, o5, i4 = 0) {\n    let s5 = Math.cos(i4), a7 = Math.sin(i4), d6 = Math.hypot(n5 * s5, o5 * a7), l7 = Math.hypot(n5 * a7, o5 * s5);\n    return { minX: e5 + n5 - d6, minY: t5 + o5 - l7, maxX: e5 + n5 + d6, maxY: t5 + o5 + l7, width: d6 * 2, height: l7 * 2 };\n  }\n  static getExpandedBounds(e5, t5) {\n    let n5 = Math.min(e5.minX, t5.minX), o5 = Math.min(e5.minY, t5.minY), i4 = Math.max(e5.maxX, t5.maxX), s5 = Math.max(e5.maxY, t5.maxY), a7 = Math.abs(i4 - n5), d6 = Math.abs(s5 - o5);\n    return { minX: n5, minY: o5, maxX: i4, maxY: s5, width: a7, height: d6 };\n  }\n  static getCommonBounds(e5) {\n    if (e5.length < 2)\n      return e5[0];\n    let t5 = e5[0];\n    for (let n5 = 1; n5 < e5.length; n5++)\n      t5 = k2.getExpandedBounds(t5, e5[n5]);\n    return t5;\n  }\n  static getRotatedCorners(e5, t5 = 0) {\n    let n5 = [e5.minX + e5.width / 2, e5.minY + e5.height / 2];\n    return [[e5.minX, e5.minY], [e5.maxX, e5.minY], [e5.maxX, e5.maxY], [e5.minX, e5.maxY]].map((o5) => e.rotWith(o5, n5, t5));\n  }\n  static getTransformedBoundingBox(e5, t5, n5, o5 = 0, i4 = false) {\n    let [s5, a7] = [e5.minX, e5.minY], [d6, l7] = [e5.maxX, e5.maxY], [c5, m6] = [e5.minX, e5.minY], [p6, u5] = [e5.maxX, e5.maxY];\n    if (t5 === \"center\")\n      return { minX: c5 + n5[0], minY: m6 + n5[1], maxX: p6 + n5[0], maxY: u5 + n5[1], width: p6 - c5, height: u5 - m6, scaleX: 1, scaleY: 1 };\n    let [y6, T5] = e.rot(n5, -o5);\n    switch (t5) {\n      case \"top_edge\":\n      case \"top_left_corner\":\n      case \"top_right_corner\": {\n        m6 += T5;\n        break;\n      }\n      case \"bottom_edge\":\n      case \"bottom_left_corner\":\n      case \"bottom_right_corner\": {\n        u5 += T5;\n        break;\n      }\n    }\n    switch (t5) {\n      case \"left_edge\":\n      case \"top_left_corner\":\n      case \"bottom_left_corner\": {\n        c5 += y6;\n        break;\n      }\n      case \"right_edge\":\n      case \"top_right_corner\":\n      case \"bottom_right_corner\": {\n        p6 += y6;\n        break;\n      }\n    }\n    let v6 = d6 - s5, x5 = l7 - a7, f5 = (p6 - c5) / v6, L5 = (u5 - m6) / x5, Y3 = f5 < 0, X3 = L5 < 0, S4 = Math.abs(p6 - c5), b6 = Math.abs(u5 - m6);\n    if (i4) {\n      let P5 = v6 / x5, B5 = P5 < S4 / b6, M3 = S4 * (L5 < 0 ? 1 : -1) * (1 / P5), I3 = b6 * (f5 < 0 ? 1 : -1) * P5;\n      switch (t5) {\n        case \"top_left_corner\": {\n          B5 ? m6 = u5 + M3 : c5 = p6 + I3;\n          break;\n        }\n        case \"top_right_corner\": {\n          B5 ? m6 = u5 + M3 : p6 = c5 - I3;\n          break;\n        }\n        case \"bottom_right_corner\": {\n          B5 ? u5 = m6 - M3 : p6 = c5 - I3;\n          break;\n        }\n        case \"bottom_left_corner\": {\n          B5 ? u5 = m6 - M3 : c5 = p6 + I3;\n          break;\n        }\n        case \"bottom_edge\":\n        case \"top_edge\": {\n          let A6 = (c5 + p6) / 2, J3 = b6 * P5;\n          c5 = A6 - J3 / 2, p6 = A6 + J3 / 2;\n          break;\n        }\n        case \"left_edge\":\n        case \"right_edge\": {\n          let A6 = (m6 + u5) / 2, J3 = S4 / P5;\n          m6 = A6 - J3 / 2, u5 = A6 + J3 / 2;\n          break;\n        }\n      }\n    }\n    if (o5 % (Math.PI * 2) !== 0) {\n      let P5 = [0, 0], B5 = e.med([s5, a7], [d6, l7]), M3 = e.med([c5, m6], [p6, u5]);\n      switch (t5) {\n        case \"top_left_corner\": {\n          P5 = e.sub(e.rotWith([p6, u5], M3, o5), e.rotWith([d6, l7], B5, o5));\n          break;\n        }\n        case \"top_right_corner\": {\n          P5 = e.sub(e.rotWith([c5, u5], M3, o5), e.rotWith([s5, l7], B5, o5));\n          break;\n        }\n        case \"bottom_right_corner\": {\n          P5 = e.sub(e.rotWith([c5, m6], M3, o5), e.rotWith([s5, a7], B5, o5));\n          break;\n        }\n        case \"bottom_left_corner\": {\n          P5 = e.sub(e.rotWith([p6, m6], M3, o5), e.rotWith([d6, a7], B5, o5));\n          break;\n        }\n        case \"top_edge\": {\n          P5 = e.sub(e.rotWith(e.med([c5, u5], [p6, u5]), M3, o5), e.rotWith(e.med([s5, l7], [d6, l7]), B5, o5));\n          break;\n        }\n        case \"left_edge\": {\n          P5 = e.sub(e.rotWith(e.med([p6, m6], [p6, u5]), M3, o5), e.rotWith(e.med([d6, a7], [d6, l7]), B5, o5));\n          break;\n        }\n        case \"bottom_edge\": {\n          P5 = e.sub(e.rotWith(e.med([c5, m6], [p6, m6]), M3, o5), e.rotWith(e.med([s5, a7], [d6, a7]), B5, o5));\n          break;\n        }\n        case \"right_edge\": {\n          P5 = e.sub(e.rotWith(e.med([c5, m6], [c5, u5]), M3, o5), e.rotWith(e.med([s5, a7], [s5, l7]), B5, o5));\n          break;\n        }\n      }\n      [c5, m6] = e.sub([c5, m6], P5), [p6, u5] = e.sub([p6, u5], P5);\n    }\n    return p6 < c5 && ([p6, c5] = [c5, p6]), u5 < m6 && ([u5, m6] = [m6, u5]), { minX: c5, minY: m6, maxX: p6, maxY: u5, width: p6 - c5, height: u5 - m6, scaleX: (p6 - c5) / (d6 - s5 || 1) * (Y3 ? -1 : 1), scaleY: (u5 - m6) / (l7 - a7 || 1) * (X3 ? -1 : 1) };\n  }\n  static getTransformAnchor(e5, t5, n5) {\n    let o5 = e5;\n    switch (e5) {\n      case \"top_left_corner\": {\n        t5 && n5 ? o5 = \"bottom_right_corner\" : t5 ? o5 = \"top_right_corner\" : n5 ? o5 = \"bottom_left_corner\" : o5 = \"bottom_right_corner\";\n        break;\n      }\n      case \"top_right_corner\": {\n        t5 && n5 ? o5 = \"bottom_left_corner\" : t5 ? o5 = \"top_left_corner\" : n5 ? o5 = \"bottom_right_corner\" : o5 = \"bottom_left_corner\";\n        break;\n      }\n      case \"bottom_right_corner\": {\n        t5 && n5 ? o5 = \"top_left_corner\" : t5 ? o5 = \"bottom_left_corner\" : n5 ? o5 = \"top_right_corner\" : o5 = \"top_left_corner\";\n        break;\n      }\n      case \"bottom_left_corner\": {\n        t5 && n5 ? o5 = \"top_right_corner\" : t5 ? o5 = \"bottom_right_corner\" : n5 ? o5 = \"top_left_corner\" : o5 = \"top_right_corner\";\n        break;\n      }\n    }\n    return o5;\n  }\n  static getRelativeTransformedBoundingBox(e5, t5, n5, o5, i4) {\n    let s5 = (o5 ? t5.maxX - n5.maxX : n5.minX - t5.minX) / t5.width, a7 = (i4 ? t5.maxY - n5.maxY : n5.minY - t5.minY) / t5.height, d6 = n5.width / t5.width, l7 = n5.height / t5.height, c5 = e5.minX + e5.width * s5, m6 = e5.minY + e5.height * a7, p6 = e5.width * d6, u5 = e5.height * l7;\n    return { minX: c5, minY: m6, maxX: c5 + p6, maxY: m6 + u5, width: p6, height: u5 };\n  }\n  static getRotatedSize(e5, t5) {\n    let n5 = e.div(e5, 2), o5 = [[0, 0], [e5[0], 0], e5, [0, e5[1]]].map((s5) => e.rotWith(s5, n5, t5)), i4 = k2.getBoundsFromPoints(o5);\n    return [i4.width, i4.height];\n  }\n  static getBoundsCenter(e5) {\n    return [e5.minX + e5.width / 2, e5.minY + e5.height / 2];\n  }\n  static getBoundsWithCenter(e5) {\n    let t5 = k2.getBoundsCenter(e5);\n    return U2(g2({}, e5), { midX: t5[0], midY: t5[1] });\n  }\n  static getCommonTopLeft(e5) {\n    let t5 = [1 / 0, 1 / 0];\n    return e5.forEach((n5) => {\n      t5[0] = Math.min(t5[0], n5[0]), t5[1] = Math.min(t5[1], n5[1]);\n    }), t5;\n  }\n  static getFromCache(e5, t5, n5) {\n    let o5 = e5.get(t5);\n    if (o5 === void 0 && (e5.set(t5, n5()), o5 = e5.get(t5), o5 === void 0))\n      throw Error(\"Cache did not include item!\");\n    return o5;\n  }\n  static uniqueId(e5 = \"\") {\n    return e5 ? ((Number(e5) ^ Math.random() * 16) >> Number(e5) / 4).toString(16) : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, k2.uniqueId);\n  }\n  static rotateArray(e5, t5) {\n    return e5.map((n5, o5) => e5[(o5 + t5) % e5.length]);\n  }\n  static debounce(e5, t5 = 0) {\n    let n5;\n    return function(...o5) {\n      clearTimeout(n5), n5 = setTimeout(() => e5.apply(o5), t5);\n    };\n  }\n  static getSvgPathFromStroke(e5, t5 = true) {\n    let n5 = e5.length;\n    if (n5 < 4)\n      return \"\";\n    let o5 = e5[0], i4 = e5[1], s5 = e5[2], a7 = `M${o5[0].toFixed(2)},${o5[1].toFixed(2)} Q${i4[0].toFixed(2)},${i4[1].toFixed(2)} ${ee3(i4[0], s5[0]).toFixed(2)},${ee3(i4[1], s5[1]).toFixed(2)} T`;\n    for (let d6 = 2, l7 = n5 - 1; d6 < l7; d6++)\n      o5 = e5[d6], i4 = e5[d6 + 1], a7 += `${ee3(o5[0], i4[0]).toFixed(2)},${ee3(o5[1], i4[1]).toFixed(2)} `;\n    return t5 && (a7 += \"Z\"), a7;\n  }\n  static getSvgPathFromStrokePoints(e5, t5 = false) {\n    let n5 = e5.length;\n    if (n5 < 4)\n      return \"\";\n    let o5 = e5[0].point, i4 = e5[1].point, s5 = e5[2].point, a7 = `M${o5[0].toFixed(2)},${o5[1].toFixed(2)} Q${i4[0].toFixed(2)},${i4[1].toFixed(2)} ${ee3(i4[0], s5[0]).toFixed(2)},${ee3(i4[1], s5[1]).toFixed(2)} T`;\n    for (let d6 = 2, l7 = n5 - 1; d6 < l7; d6++)\n      o5 = e5[d6].point, i4 = e5[d6 + 1].point, a7 += `${ee3(o5[0], i4[0]).toFixed(2)},${ee3(o5[1], i4[1]).toFixed(2)} `;\n    return t5 && (a7 += \"Z\"), a7;\n  }\n  static getPerfectDashProps(e5, t5, n5, o5 = 1, i4 = true, s5 = 2) {\n    let a7, d6, l7;\n    if (n5.toLowerCase() === \"dashed\")\n      a7 = t5 * s5, l7 = 1, d6 = i4 ? (a7 / 2).toString() : \"0\";\n    else if (n5.toLowerCase() === \"dotted\")\n      a7 = t5 / 100, l7 = 100, d6 = \"0\";\n    else\n      return { strokeDasharray: \"none\", strokeDashoffset: \"none\" };\n    let c5 = Math.floor(e5 / a7 / (2 * l7));\n    c5 -= c5 % o5, c5 = Math.max(c5, 4);\n    let m6 = Math.max(a7, (e5 - c5 * a7) / (i4 ? c5 : c5 - 1));\n    return { strokeDasharray: [a7, m6].join(\" \"), strokeDashoffset: d6 };\n  }\n  static isMobileSafari() {\n    if (typeof window == \"undefined\")\n      return false;\n    let e5 = window.navigator.userAgent, t5 = !!e5.match(/iPad/i) || !!e5.match(/iPhone/i), n5 = !!e5.match(/WebKit/i);\n    return t5 && n5 && !e5.match(/CriOS/i);\n  }\n  static throttle(e5, t5) {\n    let n5, o5;\n    return function(...i4) {\n      return n5 || (n5 = true, setTimeout(() => n5 = false, t5), o5 = e5(...i4)), o5;\n    };\n  }\n  static isDarwin() {\n    return /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n  }\n  static metaKey(e5) {\n    return k2.isDarwin() ? e5.metaKey : e5.ctrlKey;\n  }\n  static lns(e5) {\n    let t5 = e5.split(\"\");\n    return t5.push(...t5.splice(0, Math.round(t5.length / 5))), t5.push(...t5.splice(0, Math.round(t5.length / 4))), t5.push(...t5.splice(0, Math.round(t5.length / 3))), t5.push(...t5.splice(0, Math.round(t5.length / 2))), t5.reverse().map((n5) => +n5 ? +n5 < 5 ? 5 + +n5 : +n5 > 5 ? +n5 - 5 : n5 : n5).join(\"\");\n  }\n};\nvar C3 = k2;\nE2(C3, \"getSnapPoints\", (e5, t5, n5) => {\n  let o5 = g2({}, e5), i4 = [0, 0], s5 = [], a7 = { [\"minX\"]: { id: \"minX\", isSnapped: false }, [\"midX\"]: { id: \"midX\", isSnapped: false }, [\"maxX\"]: { id: \"maxX\", isSnapped: false }, [\"minY\"]: { id: \"minY\", isSnapped: false }, [\"midY\"]: { id: \"midY\", isSnapped: false }, [\"maxY\"]: { id: \"maxY\", isSnapped: false } }, d6 = [\"midX\", \"minX\", \"maxX\"], l7 = [\"midY\", \"minY\", \"maxY\"], c5 = t5.map((T5) => {\n    let v6 = d6.flatMap((f5, L5) => d6.map((Y3, X3) => {\n      let S4 = o5[f5] - T5[Y3], b6 = Math.abs(S4);\n      return { f: f5, t: Y3, gap: S4, distance: b6, isCareful: L5 === 0 || L5 + X3 === 3 };\n    })), x5 = l7.flatMap((f5, L5) => l7.map((Y3, X3) => {\n      let S4 = o5[f5] - T5[Y3], b6 = Math.abs(S4);\n      return { f: f5, t: Y3, gap: S4, distance: b6, isCareful: L5 === 0 || L5 + X3 === 3 };\n    }));\n    return [T5, v6, x5];\n  }), m6 = 1 / 0, p6 = 1 / 0, u5 = 1 / 0, y6 = 1 / 0;\n  return c5.forEach(([T5, v6, x5]) => {\n    v6.forEach((f5) => {\n      f5.distance < n5 && f5.distance < u5 && (u5 = f5.distance, m6 = f5.gap);\n    }), x5.forEach((f5) => {\n      f5.distance < n5 && f5.distance < y6 && (y6 = f5.distance, p6 = f5.gap);\n    });\n  }), c5.forEach(([T5, v6, x5]) => {\n    m6 !== 1 / 0 && v6.forEach((f5) => {\n      Math.abs(f5.gap - m6) < 2 && (a7[f5.f] = U2(g2({}, a7[f5.f]), { isSnapped: true, to: T5[f5.t], B: T5, distance: f5.distance }));\n    }), p6 !== 1 / 0 && x5.forEach((f5) => {\n      Math.abs(f5.gap - p6) < 2 && (a7[f5.f] = U2(g2({}, a7[f5.f]), { isSnapped: true, to: T5[f5.t], B: T5, distance: f5.distance }));\n    });\n  }), i4[0] = m6 === 1 / 0 ? 0 : m6, i4[1] = p6 === 1 / 0 ? 0 : p6, o5.minX -= i4[0], o5.midX -= i4[0], o5.maxX -= i4[0], o5.minY -= i4[1], o5.midY -= i4[1], o5.maxY -= i4[1], d6.forEach((T5) => {\n    let v6 = a7[T5];\n    if (!v6.isSnapped)\n      return;\n    let { id: x5, B: f5 } = v6, L5 = o5[x5];\n    s5.push(x5 === \"minX\" ? [[L5, o5.midY], [L5, f5.minY], [L5, f5.maxY]] : [[L5, o5.minY], [L5, o5.maxY], [L5, f5.minY], [L5, f5.maxY]]);\n  }), l7.forEach((T5) => {\n    let v6 = a7[T5];\n    if (!v6.isSnapped)\n      return;\n    let { id: x5, B: f5 } = v6, L5 = o5[x5];\n    s5.push(x5 === \"midY\" ? [[o5.midX, L5], [f5.minX, L5], [f5.maxX, L5]] : [[o5.minX, L5], [o5.maxX, L5], [f5.minX, L5], [f5.maxX, L5]]);\n  }), { offset: i4, snapLines: s5 };\n}), E2(C3, \"deepMerge\", (e5, t5) => {\n  let n5 = g2({}, e5), o5 = Object.entries(t5);\n  for (let [i4, s5] of o5)\n    n5[i4] = s5 === Object(s5) && !Array.isArray(s5) ? k2.deepMerge(n5[i4], s5) : s5;\n  return n5;\n});\nfunction ee3(r5, e5) {\n  return (r5 + e5) / 2;\n}\nvar w2 = C3;\nfunction tt(r5, e5) {\n  let t5 = V4.useRef(void 0), n5 = V4.useRef(void 0), o5 = V4.useRef([0, 0]), i4 = V4.useRef(0), { inputs: s5, bounds: a7, callbacks: d6 } = R3();\n  V4.useEffect(() => {\n    let u5 = (y6) => y6.preventDefault();\n    return document.addEventListener(\"gesturestart\", u5), document.addEventListener(\"gesturechange\", u5), () => {\n      document.removeEventListener(\"gesturestart\", u5), document.removeEventListener(\"gesturechange\", u5);\n    };\n  }, []);\n  let l7 = V4.useCallback(({ event: u5 }) => {\n    var L5, Y3, X3, S4;\n    if (u5.preventDefault(), s5.isPinching || u5.timeStamp <= i4.current)\n      return;\n    i4.current = u5.timeStamp;\n    let [y6, T5, v6] = tn(u5);\n    if ((u5.altKey || u5.ctrlKey || u5.metaKey) && u5.buttons === 0) {\n      let P5 = [...(Y3 = (L5 = s5.pointer) == null ? void 0 : L5.point) != null ? Y3 : [a7.width / 2, a7.height / 2], v6 * 0.618], B5 = s5.pan(P5, u5);\n      (X3 = d6.onZoom) == null || X3.call(d6, U2(g2({}, B5), { delta: P5 }), u5);\n      return;\n    }\n    let x5 = e.mul(u5.shiftKey && !w2.isDarwin() ? [T5, 0] : [y6, T5], 0.5);\n    if (e.isEqual(x5, [0, 0]))\n      return;\n    let f5 = s5.pan(x5, u5);\n    (S4 = d6.onPan) == null || S4.call(d6, f5, u5);\n  }, [d6, s5, a7]), c5 = V4.useCallback(({ origin: u5, event: y6 }) => {\n    var x5;\n    if (y6 instanceof WheelEvent)\n      return;\n    let T5 = e5.current;\n    if (!T5 || !(y6.target === T5 || T5.contains(y6.target)))\n      return;\n    let v6 = s5.pinch(u5, u5);\n    s5.isPinching = true, (x5 = d6.onPinchStart) == null || x5.call(d6, v6, y6), n5.current = v6.point, t5.current = v6.origin, o5.current = [0, 0];\n  }, [d6, s5, a7]), m6 = V4.useCallback(({ origin: u5, offset: y6, event: T5 }) => {\n    var L5;\n    if (T5 instanceof WheelEvent)\n      return;\n    let v6 = e5.current;\n    if (!(T5.target === v6 || (v6 == null ? void 0 : v6.contains(T5.target))) || !t5.current)\n      return;\n    let x5 = s5.pinch(u5, t5.current), f5 = e.sub(x5.delta, o5.current);\n    o5.current = x5.delta, (L5 = d6.onPinch) == null || L5.call(d6, U2(g2({}, x5), { point: x5.point, origin: t5.current, delta: [...f5, y6[0]] }), T5), n5.current = u5;\n  }, [d6, s5, a7]), p6 = V4.useCallback(({ origin: u5, event: y6 }) => {\n    var x5;\n    let T5 = e5.current;\n    if (!(y6.target === T5 || (T5 == null ? void 0 : T5.contains(y6.target))))\n      return;\n    let v6 = s5.pinch(u5, u5);\n    s5.isPinching = false, (x5 = d6.onPinchEnd) == null || x5.call(d6, v6, y6), n5.current = void 0, t5.current = void 0, o5.current = [0, 0];\n  }, []);\n  useGesture({ onWheel: l7, onPinchStart: c5, onPinch: m6, onPinchEnd: p6 }, { target: e5, eventOptions: { passive: false }, pinch: { from: [r5.current, 0], scaleBounds: () => ({ from: r5.current, max: 5, min: 0.1 }) } });\n}\nvar et = 10;\nfunction tn(r5) {\n  let { deltaY: e5, deltaX: t5 } = r5, n5 = 0;\n  if (r5.ctrlKey || r5.metaKey) {\n    let o5 = Math.sign(r5.deltaY), i4 = Math.abs(r5.deltaY), s5 = e5;\n    i4 > et && (s5 = et * o5), n5 = s5;\n  }\n  return [t5, e5, n5];\n}\nfunction nt() {\n  let { callbacks: r5 } = R3();\n  (0, import_react6.useEffect)(() => {\n    function e5() {\n      var t5;\n      (t5 = r5.onShapeBlur) == null || t5.call(r5);\n    }\n    return w2.isMobileSafari() ? (document.addEventListener(\"focusout\", e5), () => document.removeEventListener(\"focusout\", e5)) : () => null;\n  }, [r5]);\n}\nfunction rt() {\n  let { callbacks: r5, inputs: e5 } = R3();\n  return ot.useMemo(() => ({ onPointerDown: (t5) => {\n    var o5, i4, s5;\n    if (t5.dead || (t5.dead = true, !e5.pointerIsValid(t5)))\n      return;\n    if (t5.currentTarget.setPointerCapture(t5.pointerId), t5.button === 2) {\n      (o5 = r5.onRightPointCanvas) == null || o5.call(r5, e5.pointerDown(t5, \"canvas\"), t5);\n      return;\n    }\n    let n5 = e5.pointerDown(t5, \"canvas\");\n    t5.button === 0 && ((i4 = r5.onPointCanvas) == null || i4.call(r5, n5, t5)), (s5 = r5.onPointerDown) == null || s5.call(r5, n5, t5);\n  }, onPointerMove: (t5) => {\n    var o5, i4;\n    if (t5.dead || (t5.dead = true, !e5.pointerIsValid(t5)))\n      return;\n    let n5 = e5.pointerMove(t5, \"canvas\");\n    t5.buttons === 1 && t5.currentTarget.hasPointerCapture(t5.pointerId) && ((o5 = r5.onDragCanvas) == null || o5.call(r5, n5, t5)), (i4 = r5.onPointerMove) == null || i4.call(r5, n5, t5);\n  }, onPointerUp: (t5) => {\n    var i4, s5, a7, d6, l7;\n    if (t5.dead || (t5.dead = true, e5.activePointer = void 0, !e5.pointerIsValid(t5)))\n      return;\n    let n5 = e5.isDoubleClick(), o5 = e5.pointerUp(t5, \"canvas\");\n    if (t5.button === 2) {\n      (i4 = r5.onPointerUp) == null || i4.call(r5, o5, t5);\n      return;\n    }\n    t5.currentTarget.hasPointerCapture(t5.pointerId) && ((s5 = t5.currentTarget) == null || s5.releasePointerCapture(t5.pointerId)), t5.button === 0 && (n5 && !(o5.altKey || o5.metaKey) && ((a7 = r5.onDoubleClickCanvas) == null || a7.call(r5, o5, t5)), (d6 = r5.onReleaseCanvas) == null || d6.call(r5, o5, t5)), (l7 = r5.onPointerUp) == null || l7.call(r5, o5, t5);\n  }, onDrop: r5.onDrop, onDragOver: r5.onDragOver }), [r5, e5]);\n}\nfunction it(r5) {\n  let { rPageState: e5, rSelectionBounds: t5, callbacks: n5, inputs: o5 } = Me.useContext(Le);\n  return Me.useMemo(() => ({ onPointerDown: (i4) => {\n    var a7, d6, l7, c5, m6, p6, u5;\n    if (i4.dead || (i4.dead = true, !o5.pointerIsValid(i4)))\n      return;\n    if (i4.button === 2) {\n      (a7 = n5.onRightPointShape) == null || a7.call(n5, o5.pointerDown(i4, r5), i4);\n      return;\n    }\n    let s5 = o5.pointerDown(i4, r5);\n    if ((d6 = i4.currentTarget) == null || d6.setPointerCapture(i4.pointerId), t5.current && C3.pointInBounds(s5.point, t5.current) && !e5.current.selectedIds.includes(r5)) {\n      i4.button === 0 && ((l7 = n5.onPointBounds) == null || l7.call(n5, o5.pointerDown(i4, \"bounds\"), i4), (c5 = n5.onPointShape) == null || c5.call(n5, s5, i4)), (m6 = n5.onPointerDown) == null || m6.call(n5, s5, i4);\n      return;\n    }\n    i4.button === 0 && ((p6 = n5.onPointShape) == null || p6.call(n5, s5, i4)), (u5 = n5.onPointerDown) == null || u5.call(n5, s5, i4);\n  }, onPointerUp: (i4) => {\n    var d6, l7, c5, m6;\n    if (i4.dead || (i4.dead = true, !o5.pointerIsValid(i4)) || i4.button === 2)\n      return;\n    o5.activePointer = void 0;\n    let s5 = o5.isDoubleClick(), a7 = o5.pointerUp(i4, r5);\n    i4.pointerId && i4.currentTarget.hasPointerCapture(i4.pointerId) && ((d6 = i4.currentTarget) == null || d6.releasePointerCapture(i4.pointerId)), i4.button === 0 && (s5 && !(a7.altKey || a7.metaKey) && ((l7 = n5.onDoubleClickShape) == null || l7.call(n5, a7, i4)), (c5 = n5.onReleaseShape) == null || c5.call(n5, a7, i4)), (m6 = n5.onPointerUp) == null || m6.call(n5, a7, i4);\n  }, onPointerMove: (i4) => {\n    var a7, d6;\n    if (i4.dead || (i4.dead = true, i4.buttons === 2 || !o5.pointerIsValid(i4) || o5.pointer && i4.pointerId !== o5.pointer.pointerId))\n      return;\n    let s5 = o5.pointerMove(i4, r5);\n    i4.buttons === 1 && i4.currentTarget.hasPointerCapture(i4.pointerId) && ((a7 = n5.onDragShape) == null || a7.call(n5, s5, i4)), (d6 = n5.onPointerMove) == null || d6.call(n5, s5, i4);\n  }, onPointerEnter: (i4) => {\n    var a7;\n    if (!o5.pointerIsValid(i4))\n      return;\n    let s5 = o5.pointerEnter(i4, r5);\n    (a7 = n5.onHoverShape) == null || a7.call(n5, s5, i4);\n  }, onPointerLeave: (i4) => {\n    var a7;\n    if (!o5.pointerIsValid(i4))\n      return;\n    let s5 = o5.pointerEnter(i4, r5);\n    (a7 = n5.onUnhoverShape) == null || a7.call(n5, s5, i4);\n  } }), [o5, n5, r5]);\n}\nfunction st(r5, e5, t5, n5, o5, i4 = false, s5 = false, a7, d6) {\n  let l7 = { shape: r5, asset: r5.assetId ? o5[r5.assetId] : void 0, meta: a7, isChildOfSelected: s5, isGhost: r5.isGhost || i4, isEditing: n5.editingId === r5.id, isBinding: d6 === r5.id, isSelected: n5.selectedIds.includes(r5.id), isHovered: n5.hoveredId === r5.id || r5.children !== void 0 && (n5.hoveredId && r5.children.includes(n5.hoveredId) || r5.children.some((c5) => n5.selectedIds.includes(c5))) };\n  e5.push(l7), r5.children && (l7.children = [], r5.children.map((c5) => t5[c5]).filter((c5) => t5[c5.id]).sort((c5, m6) => c5.childIndex - m6.childIndex).forEach((c5) => st(c5, l7.children, t5, n5, o5, l7.isGhost, l7.isSelected || l7.isChildOfSelected, a7)));\n}\nfunction on(r5, e5) {\n  return C3.boundsContain(e5, r5) || C3.boundsCollide(e5, r5);\n}\nfunction at(r5, e5, t5, n5) {\n  let { callbacks: o5, shapeUtils: i4, bounds: s5 } = R3(), a7 = ye2.useRef(), d6 = ye2.useRef(-1), l7 = ye2.useRef(/* @__PURE__ */ new Set()), c5 = ye2.useRef(/* @__PURE__ */ new Set()), { selectedIds: m6, camera: p6 } = e5, [u5, y6] = e.sub(e.div([0, 0], p6.zoom), p6.point), [T5, v6] = e.sub(e.div([s5.width, s5.height], p6.zoom), p6.point), x5 = { minX: u5, minY: y6, maxX: T5, maxY: v6, height: T5 - u5, width: v6 - y6 }, f5 = c5.current, L5 = l7.current;\n  f5.clear(), L5.clear(), Object.values(r5.shapes).filter((b6) => i4[b6.type].isStateful || m6.includes(b6.id) || on(i4[b6.type].getBounds(b6), x5)).forEach((b6) => {\n    if (b6.parentId === r5.id) {\n      L5.add(b6.id), f5.add(b6);\n      return;\n    }\n    let P5 = r5.shapes[b6.parentId];\n    if (P5 === void 0)\n      throw Error(`A shape (${b6.id}) has a parent (${b6.parentId}) that does not exist!`);\n    L5.add(P5.id), f5.add(P5);\n  }), f5.size !== d6.current && (a7.current && clearTimeout(a7.current), a7.current = requestAnimationFrame(() => {\n    var b6;\n    (b6 = o5.onRenderCountChange) == null || b6.call(o5, Array.from(L5.values()));\n  }), d6.current = f5.size);\n  let X3 = e5.bindingId ? r5.bindings[e5.bindingId].toId : void 0, S4 = [];\n  return f5.forEach((b6) => {\n    if (b6 === void 0)\n      throw Error(\"Rendered shapes included a missing shape\");\n    st(b6, S4, r5.shapes, e5, t5, b6.isGhost, false, n5, X3);\n  }), S4.sort((b6, P5) => b6.shape.childIndex - P5.shape.childIndex), S4;\n}\nvar ze = /* @__PURE__ */ new Map();\nfunction rn(r5, e5) {\n  return Object.keys(e5).reduce((t5, n5) => {\n    let o5 = e5[n5];\n    return o5 ? t5 + `${`--${r5}-${n5}`}: ${o5};\n` : t5;\n  }, \"\");\n}\nfunction sn(r5, e5, t5 = \":root\") {\n  ve.useLayoutEffect(() => {\n    let n5 = document.createElement(\"style\"), o5 = rn(r5, e5);\n    return n5.setAttribute(\"id\", `${r5}-theme`), n5.setAttribute(\"data-selector\", t5), n5.innerHTML = `\n        ${t5} {\n          ${o5}\n        }\n      `, document.head.appendChild(n5), () => {\n      n5 && document.head.contains(n5) && document.head.removeChild(n5);\n    };\n  }, [r5, e5, t5]);\n}\nfunction an(r5, e5) {\n  ve.useLayoutEffect(() => {\n    if (ze.get(r5))\n      return () => {\n      };\n    let t5 = document.createElement(\"style\");\n    return t5.innerHTML = e5, t5.setAttribute(\"id\", r5), document.head.appendChild(t5), ze.set(r5, t5), () => {\n      t5 && document.head.contains(t5) && (document.head.removeChild(t5), ze.delete(r5));\n    };\n  }, [r5, e5]);\n}\nvar dn = (r5, ...e5) => r5.reduce((t5, n5, o5) => t5 + n5 + (o5 < e5.length ? e5[o5] : \"\"), \"\");\nvar ln = { accent: \"rgb(255, 0, 0)\", brushFill: \"rgba(0,0,0,.05)\", brushStroke: \"rgba(0,0,0,.25)\", brushDashStroke: \"rgba(0,0,0,.6)\", selectStroke: \"rgb(66, 133, 244)\", selectFill: \"rgba(65, 132, 244, 0.05)\", binding: \"rgba(65, 132, 244, 0.12)\", background: \"rgb(248, 249, 250)\", foreground: \"rgb(51, 51, 51)\", grid: \"rgba(144, 144, 144, 1)\" };\nvar cn = dn`\n  .tl-container {\n    --tl-zoom: 1;\n    --tl-scale: calc(1 / var(--tl-zoom));\n    --tl-padding: calc(64px * max(1, var(--tl-scale)));\n    --tl-performance-all: auto;\n    --tl-performance-selected: auto;\n    position: relative;\n    top: 0px;\n    left: 0px;\n    width: 100%;\n    height: 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n    padding: 0px;\n    margin: 0px;\n    z-index: 100;\n    overflow: hidden;\n    touch-action: none;\n    overscroll-behavior: none;\n    background-color: var(--tl-background);\n  }\n  .tl-container * {\n    box-sizing: border-box;\n  }\n  .tl-overlay {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    touch-action: none;\n    pointer-events: none;\n  }\n  .tl-grid {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    touch-action: none;\n    pointer-events: none;\n    user-select: none;\n  }\n  .tl-snap-line {\n    stroke: var(--tl-accent);\n    stroke-width: calc(1px * var(--tl-scale));\n  }\n  .tl-snap-point {\n    stroke: var(--tl-accent);\n    stroke-width: calc(1px * var(--tl-scale));\n  }\n  .tl-canvas {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    touch-action: none;\n    pointer-events: all;\n    overflow: clip;\n  }\n  .tl-layer {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    height: 0px;\n    width: 0px;\n    contain: layout style size;\n  }\n  .tl-absolute {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    transform-origin: center center;\n    contain: layout style size;\n  }\n  .tl-positioned {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    transform-origin: center center;\n    pointer-events: none;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    contain: layout style size;\n    will-change: var(--tl-performance-all);\n  }\n  .tl-positioned-svg {\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    contain: layout style size;\n  }\n  .tl-positioned-div {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    padding: var(--tl-padding);\n    overflow: hidden;\n    contain: layout style size;\n  }\n  .tl-positioned-selected {\n    will-change: var(--tl-performance-selected);\n  }\n  .tl-inner-div {\n    position: relative;\n    width: 100%;\n    height: 100%;\n  }\n  .tl-stroke-hitarea {\n    fill: none;\n    stroke: transparent;\n    stroke-width: calc(24px * var(--tl-scale));\n    pointer-events: stroke;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n  }\n  .tl-fill-hitarea {\n    fill: transparent;\n    stroke: transparent;\n    stroke-width: calc(24px * var(--tl-scale));\n    pointer-events: all;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n  }\n  .tl-counter-scaled {\n    transform: scale(var(--tl-scale));\n  }\n  .tl-dashed {\n    stroke-dasharray: calc(2px * var(--tl-scale)), calc(2px * var(--tl-scale));\n  }\n  .tl-transparent {\n    fill: transparent;\n    stroke: transparent;\n  }\n  .tl-cursor-ns {\n    cursor: ns-resize;\n  }\n  .tl-cursor-ew {\n    cursor: ew-resize;\n  }\n  .tl-cursor-nesw {\n    cursor: nesw-resize;\n  }\n  .tl-cursor-nwse {\n    cursor: nwse-resize;\n  }\n  .tl-corner-handle {\n    stroke: var(--tl-selectStroke);\n    fill: var(--tl-background);\n    stroke-width: calc(1.5px * var(--tl-scale));\n  }\n  .tl-rotate-handle {\n    stroke: var(--tl-selectStroke);\n    fill: var(--tl-background);\n    stroke-width: calc(1.5px * var(--tl-scale));\n    cursor: grab;\n  }\n  .tl-binding {\n    fill: var(--tl-selectFill);\n    stroke: var(--tl-selectStroke);\n    stroke-width: calc(1px * var(--tl-scale));\n    pointer-events: none;\n  }\n  .tl-user {\n    left: calc(-15px * var(--tl-scale));\n    top: calc(-15px * var(--tl-scale));\n    height: calc(35px * var(--tl-scale));\n    width: calc(35px * var(--tl-scale));\n    transform: scale(var(--tl-scale));\n    pointer-events: none;\n    will-change: transform;\n  }\n  .tl-animated {\n    transition: transform 200ms linear;\n  }\n  .tl-indicator {\n    fill: transparent;\n    stroke-width: calc(1.5px * var(--tl-scale));\n    pointer-events: none;\n  }\n  .tl-user-indicator-bounds {\n    border-style: solid;\n    border-width: calc(1px * var(--tl-scale));\n  }\n  .tl-hovered {\n    stroke: var(--tl-selectStroke);\n  }\n  .tl-selected {\n    stroke: var(--tl-selectStroke);\n  }\n  .tl-locked {\n    stroke-dasharray: calc(3px * var(--tl-scale)) calc(3px * var(--tl-scale));\n  }\n  .tl-editing {\n    stroke-width: calc(2.5px * min(5, var(--tl-scale)));\n  }\n  .tl-performance {\n    will-change: transform, contents;\n  }\n  .tl-clone-target {\n    pointer-events: all;\n  }\n  .tl-clone-target:hover .tl-clone-button {\n    opacity: 1;\n  }\n  .tl-clone-button-target {\n    cursor: pointer;\n    pointer-events: all;\n  }\n  .tl-clone-button-target:hover .tl-clone-button {\n    fill: var(--tl-selectStroke);\n  }\n  .tl-clone-button {\n    opacity: 0;\n    r: calc(8px * var(--tl-scale));\n    stroke-width: calc(1.5px * var(--tl-scale));\n    stroke: var(--tl-selectStroke);\n    fill: var(--tl-background);\n  }\n  .tl-bounds {\n    pointer-events: none;\n    contain: layout style size;\n  }\n  .tl-bounds-bg {\n    stroke: none;\n    fill: var(--tl-selectFill);\n    pointer-events: all;\n    contain: layout style size;\n  }\n  .tl-bounds-center {\n    fill: transparent;\n    stroke: var(--tl-selectStroke);\n    stroke-width: calc(1.5px * var(--tl-scale));\n  }\n  .tl-brush {\n    fill: var(--tl-brushFill);\n    stroke: var(--tl-brushStroke);\n    stroke-width: calc(1px * var(--tl-scale));\n    pointer-events: none;\n    contain: layout style size;\n  }\n  .tl-dashed-brush-line {\n    fill: none;\n    stroke: var(--tl-brushDashStroke);\n    stroke-width: calc(1px * var(--tl-scale));\n    pointer-events: none;\n  }\n  .tl-brush.dashed {\n    stroke: none;\n  }\n  .tl-handle {\n    pointer-events: all;\n    cursor: grab;\n  }\n  .tl-handle:hover .tl-handle-bg {\n    fill: var(--tl-selectFill);\n  }\n  .tl-handle:hover .tl-handle-bg > * {\n    stroke: var(--tl-selectFill);\n  }\n  .tl-handle:active .tl-handle-bg {\n    cursor: grabbing;\n    fill: var(--tl-selectFill);\n  }\n  .tl-handle:active .tl-handle-bg > * {\n    stroke: var(--tl-selectFill);\n  }\n  .tl-handle {\n    fill: var(--tl-background);\n    stroke: var(--tl-selectStroke);\n    stroke-width: 1.5px;\n  }\n  .tl-handle-bg {\n    fill: transparent;\n    stroke: none;\n    pointer-events: all;\n    r: calc(16px / max(1, var(--tl-zoom)));\n  }\n  .tl-binding-indicator {\n    fill: transparent;\n    stroke: var(--tl-binding);\n  }\n  .tl-centered-g {\n    transform: translate(var(--tl-padding), var(--tl-padding));\n  }\n  .tl-current-parent > *[data-shy='true'] {\n    opacity: 1;\n  }\n  .tl-binding {\n    fill: none;\n    stroke: var(--tl-selectStroke);\n    stroke-width: calc(2px * var(--tl-scale));\n  }\n  .tl-grid-dot {\n    fill: var(--tl-grid);\n  }\n  .tl-erase-line {\n    stroke-linejoin: round;\n    stroke-linecap: round;\n    pointer-events: none;\n    fill: var(--tl-grid);\n    opacity: 0.32;\n  }\n`;\nfunction dt(r5, e5) {\n  let t5 = ve.useMemo(() => g2(g2({}, ln), r5), [r5]);\n  sn(\"tl\", t5, e5), an(\"tl-canvas\", cn);\n}\nfunction _2(r5) {\n  let { callbacks: e5, inputs: t5 } = R3(), n5 = pe3.useCallback((d6) => {\n    var c5, m6, p6, u5;\n    if (d6.dead || (d6.dead = true, !t5.pointerIsValid(d6)))\n      return;\n    (c5 = d6.currentTarget) == null || c5.setPointerCapture(d6.pointerId);\n    let l7 = t5.pointerDown(d6, r5);\n    if (d6.button === 2) {\n      (m6 = e5.onRightPointBoundsHandle) == null || m6.call(e5, l7, d6);\n      return;\n    }\n    d6.button === 0 && ((p6 = e5.onPointBoundsHandle) == null || p6.call(e5, l7, d6)), (u5 = e5.onPointerDown) == null || u5.call(e5, l7, d6);\n  }, [t5, e5, r5]), o5 = pe3.useCallback((d6) => {\n    var m6, p6, u5;\n    if (d6.dead || (d6.dead = true, d6.button === 2 || !t5.pointerIsValid(d6)))\n      return;\n    let l7 = t5.pointerUp(d6, r5), c5 = t5.isDoubleClick();\n    d6.button === 0 && (c5 && !(l7.altKey || l7.metaKey) && ((m6 = e5.onDoubleClickBoundsHandle) == null || m6.call(e5, l7, d6)), (p6 = e5.onReleaseBoundsHandle) == null || p6.call(e5, l7, d6)), (u5 = e5.onPointerUp) == null || u5.call(e5, l7, d6);\n  }, [t5, e5, r5]), i4 = pe3.useCallback((d6) => {\n    var c5, m6;\n    if (d6.dead || (d6.dead = true, !t5.pointerIsValid(d6)) || d6.buttons === 2)\n      return;\n    let l7 = t5.pointerMove(d6, r5);\n    d6.buttons === 1 && d6.currentTarget.hasPointerCapture(d6.pointerId) && ((c5 = e5.onDragBoundsHandle) == null || c5.call(e5, l7, d6)), (m6 = e5.onPointerMove) == null || m6.call(e5, l7, d6);\n  }, [t5, e5, r5]), s5 = pe3.useCallback((d6) => {\n    var l7;\n    !t5.pointerIsValid(d6) || (l7 = e5.onHoverBoundsHandle) == null || l7.call(e5, t5.pointerEnter(d6, r5), d6);\n  }, [t5, e5, r5]), a7 = pe3.useCallback((d6) => {\n    var l7;\n    !t5.pointerIsValid(d6) || (l7 = e5.onUnhoverBoundsHandle) == null || l7.call(e5, t5.pointerEnter(d6, r5), d6);\n  }, [t5, e5, r5]);\n  return { onPointerDown: n5, onPointerUp: o5, onPointerEnter: s5, onPointerMove: i4, onPointerLeave: a7 };\n}\nfunction lt(r5, e5, t5) {\n  let n5 = xe2.useRef(), o5 = xe2.useRef();\n  xe2.useLayoutEffect(() => {\n    let { zoom: i4, point: s5 } = t5.camera, a7 = i4 !== n5.current, d6 = s5 !== o5.current;\n    if (n5.current = i4, o5.current = s5, a7 || d6) {\n      let l7 = r5.current;\n      if (e5 && \"current\" in e5) {\n        let c5 = e5.current;\n        a7 && c5 && c5.style.setProperty(\"--tl-zoom\", i4.toString()), l7 && l7.style.setProperty(\"transform\", `scale(${i4}) translateX(${s5[0]}px) translateY(${s5[1]}px)`);\n      }\n    }\n  }, [t5.camera.zoom, t5.camera.point]);\n}\nfunction ct(r5, e5) {\n  return [(r5[0] + e5.point[0]) * e5.zoom, (r5[1] + e5.point[1]) * e5.zoom];\n}\nfunction Fe(r5, e5) {\n  return r5[e5.type];\n}\nfunction mt(r5, e5, t5) {\n  let { rSelectionBounds: n5 } = R3(), { selectedIds: o5 } = e5, i4 = ut.useRef(), s5, a7 = 0, d6 = false, l7 = false;\n  if (o5.length === 1) {\n    let m6 = o5[0], p6 = r5.shapes[m6];\n    if (!p6)\n      throw Error(`selectedIds is set to the id of a shape that doesn't exist: ${m6}`);\n    a7 = p6.rotation || 0, d6 = p6.isLocked || false;\n    let u5 = Fe(t5, p6);\n    s5 = u5.hideBounds ? void 0 : u5.getBounds(p6);\n  } else if (o5.length > 1) {\n    let m6 = o5.map((p6) => r5.shapes[p6]);\n    a7 = 0, d6 = m6.every((p6) => p6.isLocked), s5 = m6.reduce((p6, u5, y6) => y6 === 0 ? Fe(t5, u5).getRotatedBounds(u5) : w2.getExpandedBounds(p6, Fe(t5, u5).getRotatedBounds(u5)), {});\n  }\n  if (s5) {\n    let [m6, p6] = ct([s5.minX, s5.minY], e5.camera), [u5, y6] = ct([s5.maxX, s5.maxY], e5.camera);\n    l7 = !!Object.values(r5.bindings).find((T5) => o5.includes(T5.toId) || o5.includes(T5.fromId)), n5.current = { minX: m6, minY: p6, maxX: u5, maxY: y6, width: u5 - m6, height: y6 - p6 };\n  } else\n    n5.current = null;\n  let c5 = i4.current;\n  return !c5 || !s5 ? i4.current = s5 : s5 && c5.minX === s5.minX && c5.minY === s5.minY && c5.maxX === s5.maxX && c5.maxY === s5.maxY && (s5 = i4.current), { bounds: s5, rotation: a7, isLocked: d6, isLinked: l7 };\n}\nfunction ht(r5) {\n  let { inputs: e5, callbacks: t5 } = R3();\n  return pt.useMemo(() => ({ onPointerDown: (n5) => {\n    var i4, s5, a7;\n    if (n5.dead || (n5.dead = true, !e5.pointerIsValid(n5)) || n5.button === 2)\n      return;\n    (i4 = n5.currentTarget) == null || i4.setPointerCapture(n5.pointerId);\n    let o5 = e5.pointerDown(n5, r5);\n    n5.button === 0 && ((s5 = t5.onPointHandle) == null || s5.call(t5, o5, n5)), (a7 = t5.onPointerDown) == null || a7.call(t5, o5, n5);\n  }, onPointerUp: (n5) => {\n    var s5, a7, d6, l7;\n    if (n5.dead || (n5.dead = true, !e5.pointerIsValid(n5)) || n5.button === 2)\n      return;\n    let o5 = e5.isDoubleClick(), i4 = e5.pointerUp(n5, r5);\n    n5.currentTarget.hasPointerCapture(n5.pointerId) && ((s5 = n5.currentTarget) == null || s5.releasePointerCapture(n5.pointerId), n5.button === 0 && (o5 && !(i4.altKey || i4.metaKey) && ((a7 = t5.onDoubleClickHandle) == null || a7.call(t5, i4, n5)), (d6 = t5.onReleaseHandle) == null || d6.call(t5, i4, n5))), (l7 = t5.onPointerUp) == null || l7.call(t5, i4, n5);\n  }, onPointerMove: (n5) => {\n    var i4, s5;\n    if (n5.dead || (n5.dead = true, !e5.pointerIsValid(n5)) || n5.buttons === 2)\n      return;\n    let o5 = e5.pointerMove(n5, r5);\n    n5.buttons === 1 && n5.currentTarget.hasPointerCapture(n5.pointerId) && ((i4 = t5.onDragHandle) == null || i4.call(t5, o5, n5)), (s5 = t5.onPointerMove) == null || s5.call(t5, o5, n5);\n  }, onPointerEnter: (n5) => {\n    var i4;\n    if (!e5.pointerIsValid(n5))\n      return;\n    let o5 = e5.pointerEnter(n5, r5);\n    (i4 = t5.onHoverHandle) == null || i4.call(t5, o5, n5);\n  }, onPointerLeave: (n5) => {\n    var i4;\n    if (!e5.pointerIsValid(n5))\n      return;\n    let o5 = e5.pointerEnter(n5, r5);\n    (i4 = t5.onUnhoverHandle) == null || i4.call(t5, o5, n5);\n  } }), [e5, t5, r5]);\n}\nfunction Tt(r5) {\n  let { bounds: e5 } = R3();\n  ft.useEffect(() => {\n    let t5 = (i4) => {\n      i4.preventDefault();\n    }, n5 = (i4) => {\n      let s5 = i4.touches[0].pageX, a7 = i4.touches[0].radiusX || 0;\n      (s5 - a7 < 10 || s5 + a7 > e5.width - 10) && i4.preventDefault();\n    }, o5 = r5.current;\n    return o5 ? (o5.addEventListener(\"gestureend\", t5), o5.addEventListener(\"gesturechange\", t5), o5.addEventListener(\"gesturestart\", t5), o5.addEventListener(\"touchstart\", n5), () => {\n      o5 && (o5.removeEventListener(\"gestureend\", t5), o5.removeEventListener(\"gesturechange\", t5), o5.removeEventListener(\"gesturestart\", t5), o5.removeEventListener(\"touchstart\", n5));\n    }) : () => {\n    };\n  }, [r5, e5.width]);\n}\nfunction Lt() {\n  let { callbacks: r5, inputs: e5 } = R3();\n  return gt.useMemo(() => ({ onPointerDown: (t5) => {\n    var o5, i4, s5, a7;\n    if (t5.dead || (t5.dead = true, !e5.pointerIsValid(t5)))\n      return;\n    if (t5.button === 2) {\n      (o5 = r5.onRightPointBounds) == null || o5.call(r5, e5.pointerDown(t5, \"bounds\"), t5);\n      return;\n    }\n    let n5 = e5.pointerDown(t5, \"bounds\");\n    (i4 = t5.currentTarget) == null || i4.setPointerCapture(t5.pointerId), t5.button === 0 && ((s5 = r5.onPointBounds) == null || s5.call(r5, n5, t5)), (a7 = r5.onPointerDown) == null || a7.call(r5, n5, t5);\n  }, onPointerUp: (t5) => {\n    var i4, s5, a7, d6;\n    if (t5.dead || (t5.dead = true, t5.button === 2) || (e5.activePointer = void 0, !e5.pointerIsValid(t5)))\n      return;\n    let n5 = e5.isDoubleClick(), o5 = e5.pointerUp(t5, \"bounds\");\n    t5.currentTarget.hasPointerCapture(t5.pointerId) && ((i4 = t5.currentTarget) == null || i4.releasePointerCapture(t5.pointerId)), t5.button === 0 && (n5 && !(o5.altKey || o5.metaKey) && ((s5 = r5.onDoubleClickBounds) == null || s5.call(r5, o5, t5)), (a7 = r5.onReleaseBounds) == null || a7.call(r5, o5, t5)), (d6 = r5.onPointerUp) == null || d6.call(r5, o5, t5);\n  }, onPointerMove: (t5) => {\n    var o5, i4;\n    if (t5.dead || (t5.dead = true, !e5.pointerIsValid(t5)))\n      return;\n    t5.buttons === 1 && t5.currentTarget.hasPointerCapture(t5.pointerId) && ((o5 = r5.onDragBounds) == null || o5.call(r5, e5.pointerMove(t5, \"bounds\"), t5));\n    let n5 = e5.pointerMove(t5, \"bounds\");\n    (i4 = r5.onPointerMove) == null || i4.call(r5, n5, t5);\n  }, onPointerEnter: (t5) => {\n    var n5;\n    !e5.pointerIsValid(t5) || (n5 = r5.onHoverBounds) == null || n5.call(r5, e5.pointerEnter(t5, \"bounds\"), t5);\n  }, onPointerLeave: (t5) => {\n    var n5;\n    !e5.pointerIsValid(t5) || (n5 = r5.onUnhoverBounds) == null || n5.call(r5, e5.pointerEnter(t5, \"bounds\"), t5);\n  } }), [e5, r5]);\n}\nfunction De(r5, e5 = 0) {\n  let t5 = Ke.useRef(null);\n  return Ke.useLayoutEffect(() => {\n    let n5 = t5.current, o5 = `\n    translate(\n      calc(${r5.minX}px - var(--tl-padding)),\n      calc(${r5.minY}px - var(--tl-padding))\n    )\n    rotate(${e5 + (r5.rotation || 0)}rad)`;\n    n5.style.setProperty(\"transform\", o5), n5.style.setProperty(\"width\", `calc(${Math.floor(r5.width)}px + (var(--tl-padding) * 2))`), n5.style.setProperty(\"height\", `calc(${Math.floor(r5.height)}px + (var(--tl-padding) * 2))`);\n  }, [r5, e5]), t5;\n}\nfunction vt() {\n  let { inputs: r5, callbacks: e5 } = R3();\n  yt.useEffect(() => {\n    let t5 = (o5) => {\n      var i4;\n      (i4 = e5.onKeyDown) == null || i4.call(e5, o5.key, r5.keydown(o5), o5);\n    }, n5 = (o5) => {\n      var i4;\n      r5.keyup(o5), (i4 = e5.onKeyUp) == null || i4.call(e5, o5.key, r5.keyup(o5), o5);\n    };\n    return window.addEventListener(\"keydown\", t5), window.addEventListener(\"keyup\", n5), () => {\n      window.removeEventListener(\"keydown\", t5), window.removeEventListener(\"keyup\", n5);\n    };\n  }, [r5, e5]);\n}\nfunction bt(r5, e5) {\n  xt.useLayoutEffect(() => {\n    if (e5 && \"current\" in e5) {\n      let t5 = e5 == null ? void 0 : e5.current;\n      if (!t5)\n        return;\n      switch (r5) {\n        case \"transform_selected\": {\n          t5.style.setProperty(\"--tl-performance-all\", \"auto\"), t5.style.setProperty(\"--tl-performance-selected\", \"transform, contents\");\n          break;\n        }\n        case \"transform_all\": {\n          t5.style.setProperty(\"--tl-performance-all\", \"transform, contents\"), t5.style.setProperty(\"--tl-performance-selected\", \"transform, contents\");\n          break;\n        }\n        case \"translate_selected\": {\n          t5.style.setProperty(\"--tl-performance-all\", \"auto\"), t5.style.setProperty(\"--tl-performance-selected\", \"transform\");\n          break;\n        }\n        case \"translate_all\": {\n          t5.style.setProperty(\"--tl-performance-all\", \"transform\"), t5.style.setProperty(\"--tl-performance-selected\", \"transform\");\n          break;\n        }\n        default:\n          t5.style.setProperty(\"--tl-performance-all\", \"auto\"), t5.style.setProperty(\"--tl-performance-selected\", \"auto\");\n      }\n    }\n  }, [r5]);\n}\nfunction un(a7) {\n  var d6 = a7, { id: r5, bounds: e5, rotation: t5 = 0, isGhost: n5 = false, isSelected: o5 = false, children: i4 } = d6, s5 = O2(d6, [\"id\", \"bounds\", \"rotation\", \"isGhost\", \"isSelected\", \"children\"]);\n  let l7 = De(e5, t5);\n  return Ye.createElement(\"div\", g2({ id: r5, ref: l7, className: `tl-positioned${n5 ? \" tl-ghost\" : \"\"}${o5 ? \" tl-positioned-selected\" : \"\"}`, \"aria-label\": \"container\", \"data-testid\": \"container\" }, s5), i4);\n}\nvar Z = Ye.memo(un);\nfunction mn({ brush: r5, zoom: e5, dashed: t5 }) {\n  return z2.createElement(Z, { bounds: r5, rotation: 0 }, z2.createElement(te, null, z2.createElement(\"rect\", { className: \"tl-brush\" + (t5 ? \" dashed\" : \"\"), opacity: 1, x: 0, y: 0, width: r5.width, height: r5.height, \"aria-label\": \"brush\" }), t5 && z2.createElement(\"g\", { className: \"tl-dashed-brush-line\" }, z2.createElement(Xe, { x1: 0, y1: 0, x2: r5.width, y2: 0, zoom: e5 }), z2.createElement(Xe, { x1: r5.width, y1: 0, x2: r5.width, y2: r5.height, zoom: e5 }), z2.createElement(Xe, { x1: 0, y1: r5.height, x2: r5.width, y2: r5.height, zoom: e5 }), z2.createElement(Xe, { x1: 0, y1: 0, x2: 0, y2: r5.height, zoom: e5 }))));\n}\nvar Pt = z2.memo(mn);\nfunction Xe({ x1: r5, y1: e5, x2: t5, y2: n5, zoom: o5 }) {\n  let i4 = w2.getPerfectDashProps(Math.hypot(t5 - r5, n5 - e5), 1 / o5, \"dashed\", 1, true, 3);\n  return z2.createElement(\"line\", { x1: r5, y1: e5, x2: t5, y2: n5, strokeWidth: 1 / o5, strokeDasharray: i4.strokeDasharray, strokeDashoffset: i4.strokeDashoffset });\n}\nvar Rt = W2.memo(({ color: r5 }) => W2.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", viewBox: \"0 0 35 35\", fill: \"none\", fillRule: \"evenodd\" }, W2.createElement(\"g\", { fill: \"rgba(0,0,0,.2)\", transform: \"translate(1,1)\" }, W2.createElement(\"path\", { d: \"m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z\" }), W2.createElement(\"path\", { d: \"m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z\" })), W2.createElement(\"g\", { fill: \"white\" }, W2.createElement(\"path\", { d: \"m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z\" }), W2.createElement(\"path\", { d: \"m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z\" })), W2.createElement(\"g\", { fill: r5 }, W2.createElement(\"path\", { d: \"m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z\" }), W2.createElement(\"path\", { d: \"m13 10.814v11.188l2.969-2.866.428-.139h4.768z\" }))));\nfunction hn({ points: r5, zoom: e5 }) {\n  if (r5.length === 0)\n    return null;\n  let t5 = w2.getSvgPathFromStroke(_e(r5, { size: 16 / e5, start: { taper: true } }));\n  return Ue.createElement(\"path\", { d: t5, className: \"tl-erase-line\" });\n}\nvar Et = Ue.memo(hn);\nvar Bt = [[-1, 0.15, 64], [0.05, 0.375, 16], [0.15, 1, 4], [0.7, 2.5, 1]];\nfunction Ct({ grid: r5, camera: e5 }) {\n  return he2.createElement(\"svg\", { className: \"tl-grid\", version: \"1.1\", xmlns: \"http://www.w3.org/2000/svg\" }, he2.createElement(\"defs\", null, Bt.map(([t5, n5, o5], i4) => {\n    let s5 = o5 * r5 * e5.zoom, a7 = e5.point[0] * e5.zoom, d6 = e5.point[1] * e5.zoom, l7 = a7 > 0 ? a7 % s5 : s5 + a7 % s5, c5 = d6 > 0 ? d6 % s5 : s5 + d6 % s5, m6 = e5.zoom < n5 ? w2.modulate(e5.zoom, [t5, n5], [0, 1]) : 1;\n    return he2.createElement(\"pattern\", { key: `grid-pattern-${i4}`, id: `grid-${i4}`, width: s5, height: s5, patternUnits: \"userSpaceOnUse\" }, he2.createElement(\"circle\", { className: \"tl-grid-dot\", cx: l7, cy: c5, r: 1, opacity: m6 }));\n  })), Bt.map((t5, n5) => he2.createElement(\"rect\", { key: `grid-rect-${n5}`, width: \"100%\", height: \"100%\", fill: `url(#grid-${n5})` })));\n}\nfunction fn({ camera: { zoom: r5, point: e5 }, children: t5 }) {\n  let n5 = 2.5 / r5;\n  return ne.createElement(\"svg\", { className: \"tl-overlay\" }, ne.createElement(\"defs\", null, ne.createElement(\"g\", { id: \"tl-snap-point\" }, ne.createElement(\"path\", { className: \"tl-snap-point\", d: `M ${-n5},${-n5} L ${n5},${n5} M ${-n5},${n5} L ${n5},${-n5}` }))), ne.createElement(\"g\", { transform: `scale(${r5}) translate(${e5})` }, t5));\n}\nvar St = ne.memo(fn);\nvar te = ae2.memo(ae2.forwardRef(function(s5, i4) {\n  var a7 = s5, { id: e5, className: t5 = \"\", children: n5 } = a7, o5 = O2(a7, [\"id\", \"className\", \"children\"]);\n  return ae2.createElement(\"svg\", g2({ ref: i4, className: `tl-positioned-svg ${t5}` }, o5), ae2.createElement(\"g\", { id: e5, className: \"tl-centered-g\" }, n5));\n}));\nfunction Tn({ bounds: r5, isLocked: e5, isHidden: t5 }) {\n  return $e.createElement(\"rect\", { className: [\"tl-bounds-center\", e5 ? \"tl-dashed\" : \"\"].join(\" \"), x: -1, y: -1, width: r5.width + 2, height: r5.height + 2, opacity: t5 ? 0 : 1, pointerEvents: \"none\", \"aria-label\": \"center handle\" });\n}\nvar wt = $e.memo(Tn);\nvar gn = { right: 0, bottomRight: 45, bottom: 90, bottomLeft: 135, left: 180, topLeft: 225, top: 270, topRight: 315 };\nfunction Ln({ bounds: r5, side: e5, targetSize: t5, size: n5 }) {\n  let o5 = t5 * 2, i4 = { left: -o5, topLeft: -o5, bottomLeft: -o5, right: r5.width, topRight: r5.width, bottomRight: r5.width, top: r5.width / 2 - o5 / 2, bottom: r5.width / 2 - o5 / 2 }[e5], s5 = { left: r5.height / 2 - o5 / 2, right: r5.height / 2 - o5 / 2, top: -o5 * 2, topLeft: -o5, topRight: -o5, bottom: r5.height, bottomLeft: r5.height, bottomRight: r5.height }[e5], { callbacks: a7, inputs: d6 } = R3(), l7 = q2.useCallback((c5) => {\n    var p6;\n    c5.stopPropagation();\n    let m6 = d6.pointerDown(c5, e5);\n    (p6 = a7.onShapeClone) == null || p6.call(a7, m6, c5);\n  }, [a7.onShapeClone]);\n  return q2.createElement(\"g\", { className: \"tl-clone-target\", transform: `translate(${i4}, ${s5})`, \"aria-label\": \"clone button\" }, q2.createElement(\"rect\", { className: \"tl-transparent\", width: t5 * 2, height: t5 * 2 }), q2.createElement(\"g\", { className: \"tl-clone-button-target\", onPointerDown: l7, transform: `translate(${t5}, ${t5}) rotate(${gn[e5]})` }, q2.createElement(\"circle\", { className: \"tl-transparent \", r: t5 }), q2.createElement(\"path\", { className: \"tl-clone-button\", d: `M -${n5 / 2},-${n5 / 2} L ${n5 / 2},0 -${n5 / 2},${n5 / 2} Z`, strokeLinejoin: \"round\" })));\n}\nvar Q2 = q2.memo(Ln);\nfunction yn({ targetSize: r5, size: e5, bounds: t5 }) {\n  return $3.createElement($3.Fragment, null, $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: \"top\" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: \"right\" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: \"bottom\" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: \"left\" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: \"topLeft\" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: \"topRight\" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: \"bottomLeft\" }), $3.createElement(Q2, { targetSize: r5, size: e5, bounds: t5, side: \"bottomRight\" }));\n}\nvar Ht = $3.memo(yn);\nvar vn = { [\"top_left_corner\"]: \"tl-cursor-nwse\", [\"top_right_corner\"]: \"tl-cursor-nesw\", [\"bottom_right_corner\"]: \"tl-cursor-nwse\", [\"bottom_left_corner\"]: \"tl-cursor-nesw\" };\nfunction xn({ size: r5, targetSize: e5, isHidden: t5, corner: n5, bounds: o5 }) {\n  let i4 = _2(n5), s5 = n5 === \"top_left_corner\" || n5 === \"top_right_corner\", a7 = n5 === \"top_left_corner\" || n5 === \"bottom_left_corner\";\n  return fe.createElement(\"g\", { opacity: t5 ? 0 : 1 }, fe.createElement(\"rect\", g2({ className: \"tl-transparent \" + (t5 ? \"\" : vn[n5]), \"aria-label\": \"corner transparent\", x: (a7 ? -1 : o5.width + 1) - e5, y: (s5 ? -1 : o5.height + 1) - e5, width: e5 * 2, height: e5 * 2, pointerEvents: t5 ? \"none\" : \"all\" }, i4)), fe.createElement(\"rect\", { className: \"tl-corner-handle\", \"aria-label\": \"corner handle\", x: (a7 ? -1 : o5.width + 1) - r5 / 2, y: (s5 ? -1 : o5.height + 1) - r5 / 2, width: r5, height: r5, pointerEvents: \"none\" }));\n}\nvar be2 = fe.memo(xn);\nvar bn = { [\"top_edge\"]: \"tl-cursor-ns\", [\"right_edge\"]: \"tl-cursor-ew\", [\"bottom_edge\"]: \"tl-cursor-ns\", [\"left_edge\"]: \"tl-cursor-ew\" };\nfunction Pn({ size: r5, isHidden: e5, bounds: t5, edge: n5 }) {\n  let o5 = _2(n5), i4 = n5 === \"top_edge\" || n5 === \"bottom_edge\", s5 = n5 === \"right_edge\" || n5 === \"bottom_edge\", { height: a7, width: d6 } = t5;\n  return Ne.createElement(\"rect\", g2({ pointerEvents: e5 ? \"none\" : \"all\", className: \"tl-transparent tl-edge-handle \" + (e5 ? \"\" : bn[n5]), \"aria-label\": `${n5} handle`, opacity: e5 ? 0 : 1, x: i4 ? r5 / 2 : (s5 ? d6 + 1 : -1) - r5 / 2, y: i4 ? (s5 ? a7 + 1 : -1) - r5 / 2 : r5 / 2, width: i4 ? Math.max(0, d6 + 1 - r5) : r5, height: i4 ? r5 : Math.max(0, a7 + 1 - r5) }, o5));\n}\nvar Pe = Ne.memo(Pn);\nfunction Rn({ size: r5, bounds: e5, isHidden: t5 }) {\n  let n5 = _2(\"left\"), o5 = _2(\"center\"), i4 = _2(\"right\");\n  return F2.createElement(\"g\", { cursor: \"grab\", transform: `translate(${e5.width / 2 - r5 * 4}, ${e5.height + r5 * 2})`, \"aria-label\": \"link handle\" }, F2.createElement(\"g\", { className: \"tl-transparent\", pointerEvents: t5 ? \"none\" : \"all\" }, F2.createElement(\"rect\", g2({ x: 0, y: 0, width: r5 * 2, height: r5 * 2 }, n5)), F2.createElement(\"rect\", g2({ x: r5 * 3, y: 0, width: r5 * 2, height: r5 * 2 }, o5)), F2.createElement(\"rect\", g2({ x: r5 * 6, y: 0, width: r5 * 2, height: r5 * 2 }, i4))), F2.createElement(\"g\", { className: \"tl-rotate-handle\", transform: `translate(${r5 / 2}, ${r5 / 2})`, \"aria-label\": \"link rotate handle\" }, F2.createElement(\"path\", { d: `M 0,${r5 / 2} L ${r5},${r5} ${r5},0 Z`, pointerEvents: \"none\", opacity: t5 ? 0 : 1 }), F2.createElement(\"path\", { transform: `translate(${r5 * 3}, 0)`, d: `M 0,0 L ${r5},0 ${r5 / 2},${r5} Z`, pointerEvents: \"none\", opacity: t5 ? 0 : 1 }), F2.createElement(\"path\", { transform: `translate(${r5 * 6}, 0)`, d: `M ${r5},${r5 / 2} L 0,0 0,${r5} Z`, pointerEvents: \"none\", opacity: t5 ? 0 : 1 })));\n}\nvar It = F2.memo(Rn);\nfunction En({ bounds: r5, targetSize: e5, size: t5, isHidden: n5 }) {\n  let o5 = _2(\"rotate\");\n  return Te2.createElement(\"g\", { cursor: \"grab\", opacity: n5 ? 0 : 1 }, Te2.createElement(\"circle\", g2({ className: \"tl-transparent\", \"aria-label\": \"rotate handle transparent\", cx: r5.width / 2, cy: t5 * -2, r: e5, pointerEvents: n5 ? \"none\" : \"all\" }, o5)), Te2.createElement(\"circle\", { className: \"tl-rotate-handle\", \"aria-label\": \"rotate handle\", cx: r5.width / 2, cy: t5 * -2, r: t5 / 2, pointerEvents: \"none\" }));\n}\nvar Mt = Te2.memo(En);\nvar Bn = function({ zoom: e5, bounds: t5, viewportWidth: n5, rotation: o5, isHidden: i4, isLocked: s5, hideCloneHandles: a7, hideResizeHandles: d6, hideRotateHandle: l7, hideBindingHandles: c5 }) {\n  let m6 = (n5 < 768 ? 16 : 8) / e5, p6 = 8 / e5, u5 = Math.min(t5.width, t5.height) * e5, y6 = !l7 && !i4 && !s5 && u5 > 32, T5 = !i4 && !s5 && u5 > 24, v6 = !i4 && !s5 && u5 > 20, x5 = !a7 && u5 > 24;\n  return K3.createElement(Z, { bounds: t5, rotation: o5 }, K3.createElement(te, null, K3.createElement(wt, { bounds: t5, isLocked: s5, isHidden: i4 }), !d6 && !s5 ? K3.createElement(K3.Fragment, null, K3.createElement(Pe, { targetSize: m6, size: p6, bounds: t5, edge: \"top_edge\", isHidden: !T5 }), K3.createElement(Pe, { targetSize: m6, size: p6, bounds: t5, edge: \"right_edge\", isHidden: !T5 }), K3.createElement(Pe, { targetSize: m6, size: p6, bounds: t5, edge: \"bottom_edge\", isHidden: !T5 }), K3.createElement(Pe, { targetSize: m6, size: p6, bounds: t5, edge: \"left_edge\", isHidden: !T5 }), K3.createElement(be2, { targetSize: m6, size: p6, bounds: t5, isHidden: i4 || !v6, corner: \"top_left_corner\" }), K3.createElement(be2, { targetSize: m6, size: p6, bounds: t5, isHidden: i4 || !v6, corner: \"top_right_corner\" }), K3.createElement(be2, { targetSize: m6, size: p6, bounds: t5, isHidden: i4 || !v6, corner: \"bottom_right_corner\" }), K3.createElement(be2, { targetSize: m6, size: p6, bounds: t5, isHidden: i4 || !v6, corner: \"bottom_left_corner\" })) : null, y6 && K3.createElement(Mt, { targetSize: m6, size: p6, bounds: t5, isHidden: !T5 }), x5 && K3.createElement(Ht, { bounds: t5, targetSize: m6, size: p6 }), !c5 && K3.createElement(It, { targetSize: m6, size: p6, bounds: t5, isHidden: !T5 })));\n};\nvar kt = K3.memo(Bn);\nfunction Cn({ bounds: r5, rotation: e5, isHidden: t5 }) {\n  let n5 = Lt();\n  return ge2.createElement(Z, { bounds: r5, rotation: e5 }, ge2.createElement(te, null, ge2.createElement(\"rect\", g2({ className: \"tl-bounds-bg\", \"aria-label\": \"bounds bg\", width: r5.width, height: r5.height, opacity: t5 ? 0 : 1 }, n5))));\n}\nvar Kt = ge2.memo(Cn);\nfunction Sn({ id: r5, point: e5 }) {\n  let t5 = ht(r5);\n  return oe.createElement(Z, { bounds: w2.translateBounds({ minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0 }, e5) }, oe.createElement(te, null, oe.createElement(\"g\", g2({ className: \"tl-handle\", \"aria-label\": \"handle\" }, t5), oe.createElement(\"circle\", { className: \"tl-handle-bg\", pointerEvents: \"all\" }), oe.createElement(\"circle\", { className: \"tl-counter-scaled tl-handle\", pointerEvents: \"none\", r: 4 }))));\n}\nvar Dt = oe.memo(Sn);\nfunction wn({ shape: r5, zoom: e5 }) {\n  if (r5.handles === void 0)\n    return null;\n  let t5 = null, n5 = Object.values(r5.handles).reduce((o5, i4) => {\n    let s5 = e.add(i4.point, r5.point);\n    return (!t5 || e.dist(s5, t5) * e5 >= 32) && (o5.push(i4), t5 = s5), o5;\n  }, []);\n  return n5.length === 1 ? null : de3.createElement(de3.Fragment, null, n5.map((o5) => de3.createElement(Dt, { key: r5.id + \"_\" + o5.id, id: o5.id, point: e.add(o5.point, r5.point) })));\n}\nvar Yt = de3.memo(wn);\nfunction Hn(r5) {\n  let e5 = r5.utils.getRef(r5.shape);\n  return We.createElement(r5.utils.Component, g2({ ref: e5 }, r5));\n}\nvar Xt = We.memo(Hn, (r5, e5) => r5.isHovered !== e5.isHovered || r5.isSelected !== e5.isSelected || r5.isEditing !== e5.isEditing || r5.isBinding !== e5.isBinding || r5.isGhost !== e5.isGhost || r5.meta !== e5.meta ? false : e5.shape !== r5.shape ? !e5.utils.shouldRender(e5.shape, r5.shape) : true);\nfunction In(o5) {\n  var i4 = o5, { shape: r5, utils: e5, meta: t5 } = i4, n5 = O2(i4, [\"shape\", \"utils\", \"meta\"]);\n  let { callbacks: s5 } = R3(), a7 = e5.getBounds(r5), d6 = it(r5.id);\n  return Re.createElement(Z, { id: r5.id, bounds: a7, rotation: r5.rotation, \"data-shape\": r5.type, isGhost: n5.isGhost, isSelected: n5.isSelected }, Re.createElement(Xt, g2({ shape: r5, utils: e5, meta: t5, events: d6, bounds: a7, onShapeChange: s5.onShapeChange, onShapeBlur: s5.onShapeBlur }, n5)));\n}\nvar Ut = Re.memo(In);\nfunction Mn(i4) {\n  var s5 = i4, { shape: r5, utils: e5, meta: t5, children: n5 } = s5, o5 = O2(s5, [\"shape\", \"utils\", \"meta\", \"children\"]);\n  return re.createElement(re.Fragment, null, re.createElement(Ut, g2({ shape: r5, utils: e5[r5.type], meta: t5 }, o5)), n5 && n5.map((a7) => re.createElement(je, g2({ key: a7.shape.id, utils: e5 }, a7))));\n}\nvar je = re.memo(Mn);\nfunction kn({ isHovered: r5 = false, isSelected: e5 = false, isEditing: t5 = false, shape: n5, user: o5, meta: i4 }) {\n  let { shapeUtils: s5 } = R3(), a7 = s5[n5.type], d6 = a7.getBounds(n5), l7 = De(d6, n5.rotation);\n  return le2.createElement(\"div\", { ref: l7, draggable: false, className: [\"tl-indicator\", \"tl-absolute\", e5 && !o5 ? \"tl-selected\" : \"tl-hovered\", t5 ? \"tl-editing\" : \"\", n5.isLocked ? \"tl-locked\" : \"\"].join(\" \") }, le2.createElement(\"svg\", { width: \"100%\", height: \"100%\" }, le2.createElement(\"g\", { className: \"tl-centered-g\", stroke: o5 == null ? void 0 : o5.color }, le2.createElement(a7.Indicator, { shape: n5, meta: i4, user: o5, bounds: d6, isSelected: e5, isHovered: r5 }))));\n}\nvar Ee = le2.memo(kn);\nfunction Kn({ page: r5, pageState: e5, assets: t5, hideBounds: n5, hideHandles: o5, hideIndicators: i4, hideBindingHandles: s5, hideCloneHandles: a7, hideRotateHandle: d6, hideResizeHandles: l7, meta: c5 }) {\n  let { bounds: m6, shapeUtils: p6 } = R3(), u5 = at(r5, e5, t5, c5), { bounds: y6, isLinked: T5, isLocked: v6, rotation: x5 } = mt(r5, e5, p6), { selectedIds: f5, hoveredId: L5, editingId: Y3, camera: { zoom: X3 } } = e5, S4 = i4, b6 = true, P5 = false, B5, M3 = f5.map((I3) => r5.shapes[I3]);\n  if (M3.length === 1) {\n    let I3 = M3[0];\n    P5 = Y3 === I3.id, P5 && (S4 = true);\n    let A6 = p6[I3.type];\n    b6 = a7 || !A6.showCloneHandles, I3.handles !== void 0 && !P5 && (B5 = I3);\n  }\n  return G3.createElement(G3.Fragment, null, y6 && G3.createElement(Kt, { bounds: y6, rotation: x5, isHidden: n5 }), u5.map((I3) => G3.createElement(je, g2({ key: I3.shape.id, utils: p6 }, I3))), !S4 && M3.map((I3) => G3.createElement(Ee, { key: \"selected_\" + I3.id, shape: I3, meta: c5, isSelected: true, isEditing: P5 })), !S4 && L5 && L5 !== Y3 && G3.createElement(Ee, { key: \"hovered_\" + L5, shape: r5.shapes[L5], meta: c5, isHovered: true }), y6 && G3.createElement(kt, { zoom: X3, bounds: y6, viewportWidth: m6.width, isLocked: v6, rotation: x5, isHidden: n5, hideRotateHandle: d6, hideResizeHandles: l7, hideBindingHandles: s5 || !T5, hideCloneHandles: b6 }), !o5 && B5 && G3.createElement(Yt, { shape: B5, zoom: X3 }));\n}\nvar $t = G3.memo(Kn);\nfunction Dn({ snapLines: r5 }) {\n  return j2.createElement(j2.Fragment, null, r5.map((e5, t5) => j2.createElement(Xn, { key: t5, snapLine: e5 })));\n}\nfunction Yn({ snapLine: r5 }) {\n  let e5 = w2.getBoundsFromPoints(r5);\n  return j2.createElement(j2.Fragment, null, j2.createElement(\"line\", { className: \"tl-snap-line\", x1: e5.minX, y1: e5.minY, x2: e5.maxX, y2: e5.maxY }), r5.map(([t5, n5], o5) => j2.createElement(\"use\", { key: o5, href: \"#tl-snap-point\", x: t5, y: n5 })));\n}\nvar Xn = j2.memo(Yn);\nvar Nt = j2.memo(Dn);\nfunction Wt({ user: r5, Cursor: e5 }) {\n  let t5 = ce3.useRef(null);\n  return ce3.useLayoutEffect(() => {\n    t5.current && (t5.current.style.transform = `translate(${r5.point[0]}px, ${r5.point[1]}px)`);\n  }, [r5.point]), ce3.createElement(\"div\", { ref: t5, className: `tl-absolute tl-user tl-counter-scaled ${r5.session ? \"\" : \"tl-animated\"}` }, ce3.createElement(e5, { id: r5.id, color: r5.color, metadata: r5.metadata }));\n}\nfunction At({ userId: r5, users: e5, Cursor: t5 }) {\n  return Be.createElement(Be.Fragment, null, Object.values(e5).filter((n5) => n5 && n5.id !== r5).map((n5) => Be.createElement(Wt, { key: n5.id, user: n5, Cursor: t5 })));\n}\nfunction Ot({ userId: r5, users: e5, meta: t5, page: n5 }) {\n  let { shapeUtils: o5 } = R3();\n  return ie3.createElement(ie3.Fragment, null, Object.values(e5).filter(Boolean).filter((i4) => i4.id !== r5 && i4.selectedIds.length > 0).map((i4) => {\n    let s5 = i4.selectedIds.map((d6) => n5.shapes[d6]).filter(Boolean);\n    if (s5.length === 0)\n      return null;\n    let a7 = w2.getCommonBounds(s5.map((d6) => o5[d6.type].getBounds(d6)));\n    return ie3.createElement(ie3.Fragment, { key: i4.id + \"_shapes\" }, ie3.createElement(\"div\", { className: \"tl-absolute tl-user-indicator-bounds\", style: { backgroundColor: i4.color + \"0d\", borderColor: i4.color + \"78\", transform: `translate(${a7.minX}px, ${a7.minY}px)`, width: a7.width, height: a7.height, pointerEvents: \"none\" } }), s5.map((d6) => ie3.createElement(Ee, { key: `${i4.id}_${d6.id}_indicator`, shape: d6, user: i4, meta: t5, isHovered: true })));\n  }));\n}\nvar Un = (r5) => {\n  let e5 = r5.parentElement;\n  for (; e5; ) {\n    if (e5 === document.body)\n      return document;\n    let { overflowY: t5 } = window.getComputedStyle(e5);\n    if (e5.scrollHeight > e5.clientHeight && (t5 === \"auto\" || t5 === \"scroll\" || t5 === \"overlay\"))\n      return e5;\n    e5 = e5.parentElement;\n  }\n  return document;\n};\nfunction Vt(r5, e5) {\n  let { inputs: t5, callbacks: n5 } = R3(), o5 = se3.useRef(false), i4 = se3.useCallback(() => {\n    var s5, a7;\n    if (o5.current) {\n      let d6 = (s5 = r5.current) == null ? void 0 : s5.getBoundingClientRect();\n      if (d6) {\n        let l7 = { minX: d6.left, maxX: d6.left + d6.width, minY: d6.top, maxY: d6.top + d6.height, width: d6.width, height: d6.height };\n        t5.bounds = l7, e5(l7), (a7 = n5.onBoundsChange) == null || a7.call(n5, l7);\n      }\n    } else\n      o5.current = true;\n  }, [r5, t5, n5.onBoundsChange]);\n  se3.useEffect(() => {\n    let s5 = r5.current ? Un(r5.current) : document, a7 = C3.debounce(i4, 100);\n    return s5.addEventListener(\"scroll\", a7), window.addEventListener(\"resize\", a7), () => {\n      s5.removeEventListener(\"scroll\", a7), window.removeEventListener(\"resize\", a7);\n    };\n  }, []), se3.useEffect(() => {\n    let s5 = new ResizeObserver((a7) => {\n      t5.isPinching || a7[0].contentRect && i4();\n    });\n    return r5.current && s5.observe(r5.current), () => {\n      s5.disconnect();\n    };\n  }, [r5, t5]), se3.useEffect(() => {\n    i4();\n  }, [r5]);\n}\nfunction $n({ id: r5, page: e5, pageState: t5, assets: n5, snapLines: o5, eraseLine: i4, grid: s5, users: a7, userId: d6, components: l7 = {}, meta: c5, performanceMode: m6, showDashedBrush: p6, hideHandles: u5, hideBounds: y6, hideIndicators: T5, hideBindingHandles: v6, hideCloneHandles: x5, hideResizeHandles: f5, hideRotateHandle: L5, hideGrid: Y3, onBoundsChange: X3, hideCursors: S4 }) {\n  var A6;\n  let b6 = D2.useRef(null), P5 = D2.useRef(t5.camera.zoom);\n  P5.current = t5.camera.zoom, tt(P5, b6), Vt(b6, X3), nt(), Tt(b6);\n  let B5 = D2.useRef(null), M3 = D2.useRef(null);\n  lt(M3, B5, t5), bt(m6, B5), vt();\n  let I3 = rt();\n  return D2.createElement(\"div\", { id: r5, className: \"tl-container\", ref: B5 }, D2.createElement(\"div\", g2({ id: \"canvas\", className: \"tl-absolute tl-canvas\", ref: b6 }, I3), !Y3 && s5 && D2.createElement(Ct, { grid: s5, camera: t5.camera }), D2.createElement(\"div\", { ref: M3, className: \"tl-absolute tl-layer\", \"data-testid\": \"layer\" }, D2.createElement($t, { page: e5, pageState: t5, assets: n5, hideBounds: y6, hideIndicators: T5, hideHandles: u5, hideBindingHandles: v6, hideCloneHandles: x5, hideResizeHandles: f5, hideRotateHandle: L5, meta: c5 }), a7 && d6 && D2.createElement(Ot, { userId: d6, users: a7, page: e5, meta: c5 }), t5.brush && D2.createElement(Pt, { brush: t5.brush, dashed: p6, zoom: t5.camera.zoom }), a7 && !S4 && D2.createElement(At, { userId: d6, users: a7, Cursor: (A6 = l7 == null ? void 0 : l7.Cursor) != null ? A6 : Rt })), D2.createElement(St, { camera: t5.camera }, i4 && D2.createElement(Et, { points: i4, zoom: t5.camera.zoom }), o5 && D2.createElement(Nt, { snapLines: o5 }))));\n}\nvar zt = D2.memo($n);\nvar Nn = 250;\nvar H2 = class {\n  constructor() {\n    E2(this, \"pointer\");\n    E2(this, \"keyboard\");\n    E2(this, \"keys\", {});\n    E2(this, \"isPinching\", false);\n    E2(this, \"bounds\", { minX: 0, maxX: 640, minY: 0, maxY: 480, width: 640, height: 480 });\n    E2(this, \"pointerUpTime\", 0);\n    E2(this, \"activePointer\");\n    E2(this, \"panStart\", (e5) => {\n      var a7, d6;\n      let { shiftKey: t5, ctrlKey: n5, metaKey: o5, altKey: i4 } = e5, s5 = { target: \"wheel\", pointerId: ((a7 = this.pointer) == null ? void 0 : a7.pointerId) || 0, origin: ((d6 = this.pointer) == null ? void 0 : d6.origin) || [0, 0], delta: [0, 0], pressure: 0.5, point: H2.getPoint(e5, this.bounds), shiftKey: t5, ctrlKey: n5, metaKey: o5, altKey: i4, spaceKey: this.keys[\" \"] };\n      return this.pointer = s5, s5;\n    });\n    E2(this, \"pan\", (e5, t5) => {\n      if (!this.pointer || this.pointer.target !== \"wheel\")\n        return this.panStart(t5);\n      let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = t5, a7 = this.pointer, d6 = H2.getPoint(t5, this.bounds), l7 = U2(g2({}, a7), { target: \"wheel\", delta: e5, point: d6, shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5, spaceKey: this.keys[\" \"] });\n      return this.pointer = l7, l7;\n    });\n    E2(this, \"keydown\", (e5) => {\n      var s5, a7;\n      let { shiftKey: t5, ctrlKey: n5, metaKey: o5, altKey: i4 } = e5;\n      return this.keys[e5.key] = true, { point: ((s5 = this.pointer) == null ? void 0 : s5.point) || [0, 0], origin: ((a7 = this.pointer) == null ? void 0 : a7.origin) || [0, 0], key: e5.key, keys: Object.keys(this.keys), shiftKey: t5, ctrlKey: n5, metaKey: C3.isDarwin() ? o5 : n5, altKey: i4 };\n    });\n    E2(this, \"keyup\", (e5) => {\n      var s5, a7;\n      let { shiftKey: t5, ctrlKey: n5, metaKey: o5, altKey: i4 } = e5;\n      return delete this.keys[e5.key], { point: ((s5 = this.pointer) == null ? void 0 : s5.point) || [0, 0], origin: ((a7 = this.pointer) == null ? void 0 : a7.origin) || [0, 0], key: e5.key, keys: Object.keys(this.keys), shiftKey: t5, ctrlKey: n5, metaKey: C3.isDarwin() ? o5 : n5, altKey: i4 };\n    });\n  }\n  pointerIsValid(e5) {\n    if (\"pointerId\" in e5 && this.activePointer && this.activePointer !== e5.pointerId)\n      return false;\n    if (\"touches\" in e5) {\n      let t5 = e5.changedTouches[0];\n      if (this.activePointer && this.activePointer !== t5.identifier)\n        return false;\n    }\n    return true;\n  }\n  touchStart(e5, t5) {\n    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = e5.changedTouches[0];\n    this.activePointer = a7.identifier;\n    let d6 = { target: t5, pointerId: a7.identifier, origin: H2.getPoint(a7, this.bounds), delta: [0, 0], point: H2.getPoint(a7, this.bounds), pressure: H2.getPressure(a7), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[\" \"] };\n    return this.pointer = d6, d6;\n  }\n  touchEnd(e5, t5) {\n    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = e5.changedTouches[0], d6 = { target: t5, pointerId: a7.identifier, origin: H2.getPoint(a7, this.bounds), delta: [0, 0], point: H2.getPoint(a7, this.bounds), pressure: H2.getPressure(a7), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[\" \"] };\n    return this.pointer = d6, this.activePointer = void 0, d6;\n  }\n  touchMove(e5, t5) {\n    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = e5.changedTouches[0], d6 = this.pointer, l7 = H2.getPoint(a7, this.bounds), c5 = (d6 == null ? void 0 : d6.point) ? e.sub(l7, d6.point) : [0, 0], m6 = U2(g2({ origin: l7 }, d6), { target: t5, pointerId: a7.identifier, point: l7, delta: c5, pressure: H2.getPressure(a7), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[\" \"] });\n    return this.pointer = m6, m6;\n  }\n  pointerDown(e5, t5) {\n    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = H2.getPoint(e5, this.bounds);\n    this.activePointer = e5.pointerId;\n    let d6 = { target: t5, pointerId: e5.pointerId, origin: a7, point: a7, delta: [0, 0], pressure: H2.getPressure(e5), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[\" \"] };\n    return this.pointer = d6, d6;\n  }\n  pointerEnter(e5, t5) {\n    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = H2.getPoint(e5, this.bounds), d6 = { target: t5, pointerId: e5.pointerId, origin: a7, delta: [0, 0], point: a7, pressure: H2.getPressure(e5), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[\" \"] };\n    return this.pointer = d6, d6;\n  }\n  pointerMove(e5, t5) {\n    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = this.pointer, d6 = H2.getPoint(e5, this.bounds), l7 = (a7 == null ? void 0 : a7.point) ? e.sub(d6, a7.point) : [0, 0], c5 = U2(g2({ origin: d6 }, a7), { target: t5, pointerId: e5.pointerId, point: d6, delta: l7, pressure: H2.getPressure(e5), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[\" \"] });\n    return this.pointer = c5, c5;\n  }\n  pointerUp(e5, t5) {\n    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = e5, a7 = this.pointer, d6 = H2.getPoint(e5, this.bounds), l7 = (a7 == null ? void 0 : a7.point) ? e.sub(d6, a7.point) : [0, 0];\n    this.activePointer = void 0;\n    let c5 = U2(g2({ origin: d6 }, a7), { target: t5, pointerId: e5.pointerId, point: d6, delta: l7, pressure: H2.getPressure(e5), shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[\" \"] });\n    return this.pointer = c5, this.pointerUpTime = performance.now(), c5;\n  }\n  isDoubleClick() {\n    if (!this.pointer)\n      return false;\n    let { origin: e5, point: t5 } = this.pointer, n5 = performance.now() - this.pointerUpTime < Nn && e.dist(e5, t5) < 4;\n    return n5 && (this.activePointer = void 0), n5;\n  }\n  clear() {\n    this.pointer = void 0;\n  }\n  resetDoubleClick() {\n    this.pointerUpTime = 0;\n  }\n  pinch(e5, t5) {\n    let { shiftKey: n5, ctrlKey: o5, metaKey: i4, altKey: s5 } = this.keys, a7 = e.sub(t5, e5), d6 = { pointerId: 0, target: \"pinch\", origin: t5, delta: a7, point: e.sub(e.toFixed(e5), [this.bounds.minX, this.bounds.minY]), pressure: 0.5, shiftKey: n5, ctrlKey: o5, metaKey: C3.isDarwin() ? i4 : o5, altKey: s5, spaceKey: this.keys[\" \"] };\n    return this.pointer = d6, d6;\n  }\n  reset() {\n    this.pointerUpTime = 0, this.pointer = void 0, this.keyboard = void 0, this.activePointer = void 0, this.keys = {};\n  }\n  static getPoint(e5, t5) {\n    return [+e5.clientX.toFixed(2) - t5.minX, +e5.clientY.toFixed(2) - t5.minY];\n  }\n  static getPressure(e5) {\n    return \"pressure\" in e5 && +e5.pressure.toFixed(2) || 0.5;\n  }\n  static commandKey() {\n    return C3.isDarwin() ? \"\\u2318\" : \"Ctrl\";\n  }\n};\nvar Cs = new H2();\nvar Wn = Object.freeze({});\nfunction An(M3) {\n  var I3 = M3, { id: r5 = \"tl\", shapeUtils: e5, page: t5, pageState: n5, assets: o5 = Wn, users: i4, userId: s5, theme: a7, meta: d6, snapLines: l7, eraseLine: c5, grid: m6, containerRef: p6, performanceMode: u5, components: y6, hideHandles: T5 = false, hideIndicators: v6 = false, hideCloneHandles: x5 = false, hideBindingHandles: f5 = false, hideResizeHandles: L5 = false, hideRotateHandles: Y3 = false, hideBounds: X3 = false, hideGrid: S4 = true, showDashedBrush: b6 = false, hideCursors: P5 } = I3, B5 = O2(I3, [\"id\", \"shapeUtils\", \"page\", \"pageState\", \"assets\", \"users\", \"userId\", \"theme\", \"meta\", \"snapLines\", \"eraseLine\", \"grid\", \"containerRef\", \"performanceMode\", \"components\", \"hideHandles\", \"hideIndicators\", \"hideCloneHandles\", \"hideBindingHandles\", \"hideResizeHandles\", \"hideRotateHandles\", \"hideBounds\", \"hideGrid\", \"showDashedBrush\", \"hideCursors\"]);\n  dt(a7, \"#\" + r5);\n  let A6 = N2.useRef(null), J3 = N2.useRef(n5);\n  N2.useEffect(() => {\n    J3.current = n5;\n  }, [n5]);\n  let [Ft, Gt] = N2.useState(() => ({ callbacks: B5, shapeUtils: e5, rSelectionBounds: A6, rPageState: J3, bounds: { minX: 0, minY: 0, maxX: 1 / 0, maxY: 1 / 0, width: 1 / 0, height: 1 / 0 }, inputs: new H2() })), jt = N2.useCallback((_t) => {\n    Gt((Zt) => U2(g2({}, Zt), { bounds: _t }));\n  }, []);\n  return N2.createElement(Le.Provider, { value: Ft }, N2.createElement(zt, { id: r5, page: t5, pageState: n5, assets: o5, snapLines: l7, eraseLine: c5, grid: m6, users: i4, userId: s5, externalContainerRef: p6, hideBounds: X3, hideIndicators: v6, hideHandles: T5, hideCloneHandles: x5, hideBindingHandles: f5, hideRotateHandle: Y3, hideResizeHandles: L5, hideGrid: S4, showDashedBrush: b6, onBoundsChange: jt, performanceMode: u5, components: y6, meta: d6, hideCursors: P5 }));\n}\nvar ks = N2.memo(An);\nvar Xs = me2.memo(me2.forwardRef(function(i4, o5) {\n  var s5 = i4, { children: e5, className: t5 = \"\" } = s5, n5 = O2(s5, [\"children\", \"className\"]);\n  return me2.createElement(\"div\", g2({ ref: o5, className: `tl-positioned-div ${t5}`, draggable: false }, n5), me2.createElement(\"div\", { className: \"tl-inner-div\" }, e5));\n}));\nvar _e2 = class {\n  constructor() {\n    E2(this, \"refMap\", /* @__PURE__ */ new Map());\n    E2(this, \"boundsCache\", /* @__PURE__ */ new WeakMap());\n    E2(this, \"showCloneHandles\", false);\n    E2(this, \"hideBounds\", false);\n    E2(this, \"isStateful\", false);\n    E2(this, \"shouldRender\", (e5, t5) => true);\n    E2(this, \"getRef\", (e5) => (this.refMap.has(e5.id) || this.refMap.set(e5.id, Ae.createRef()), this.refMap.get(e5.id)));\n    E2(this, \"hitTestBounds\", (e5, t5) => {\n      let n5 = this.getBounds(e5), o5 = w2.getRotatedCorners(n5, e5.rotation);\n      return o5.every((i4) => w2.pointInBounds(i4, t5)) || ee2(o5, t5).length > 0;\n    });\n    E2(this, \"getRotatedBounds\", (e5) => w2.getBoundsFromPoints(w2.getRotatedCorners(this.getBounds(e5), e5.rotation)));\n  }\n};\nE2(_e2, \"Component\", (e5) => Ae.forwardRef(e5)), E2(_e2, \"Indicator\", (e5) => e5);\n\n// node_modules/.pnpm/@babel+runtime@7.20.7/node_modules/@babel/runtime/helpers/esm/extends.js\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i4 = 1; i4 < arguments.length; i4++) {\n      var source = arguments[i4];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// node_modules/.pnpm/@radix-ui+react-context-menu@2.1.4_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-context-menu/dist/index.mjs\nvar import_react29 = require(\"react\");\n\n// node_modules/.pnpm/@radix-ui+primitive@1.0.1/node_modules/@radix-ui/primitive/dist/index.mjs\nfunction $e42e1063c40fb3ef$export$b9ecd428b558ff10(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {\n  return function handleEvent(event) {\n    originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);\n    if (checkForDefaultPrevented === false || !event.defaultPrevented)\n      return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);\n  };\n}\n\n// node_modules/.pnpm/@radix-ui+react-context@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-context/dist/index.mjs\nvar import_react7 = require(\"react\");\nfunction $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {\n  const Context = /* @__PURE__ */ (0, import_react7.createContext)(defaultContext);\n  function Provider(props) {\n    const { children, ...context } = props;\n    const value = (0, import_react7.useMemo)(\n      () => context,\n      Object.values(context)\n    );\n    return /* @__PURE__ */ (0, import_react7.createElement)(Context.Provider, {\n      value\n    }, children);\n  }\n  function useContext6(consumerName) {\n    const context = (0, import_react7.useContext)(Context);\n    if (context)\n      return context;\n    if (defaultContext !== void 0)\n      return defaultContext;\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n  }\n  Provider.displayName = rootComponentName + \"Provider\";\n  return [\n    Provider,\n    useContext6\n  ];\n}\nfunction $c512c27ab02ef895$export$50c7b4e9d9f19c1(scopeName, createContextScopeDeps = []) {\n  let defaultContexts = [];\n  function $c512c27ab02ef895$export$fd42f52fd3ae11092(rootComponentName, defaultContext) {\n    const BaseContext = /* @__PURE__ */ (0, import_react7.createContext)(defaultContext);\n    const index2 = defaultContexts.length;\n    defaultContexts = [\n      ...defaultContexts,\n      defaultContext\n    ];\n    function Provider(props) {\n      const { scope, children, ...context } = props;\n      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;\n      const value = (0, import_react7.useMemo)(\n        () => context,\n        Object.values(context)\n      );\n      return /* @__PURE__ */ (0, import_react7.createElement)(Context.Provider, {\n        value\n      }, children);\n    }\n    function useContext6(consumerName, scope) {\n      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;\n      const context = (0, import_react7.useContext)(Context);\n      if (context)\n        return context;\n      if (defaultContext !== void 0)\n        return defaultContext;\n      throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n    }\n    Provider.displayName = rootComponentName + \"Provider\";\n    return [\n      Provider,\n      useContext6\n    ];\n  }\n  const createScope = () => {\n    const scopeContexts = defaultContexts.map((defaultContext) => {\n      return /* @__PURE__ */ (0, import_react7.createContext)(defaultContext);\n    });\n    return function useScope(scope) {\n      const contexts = (scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts;\n      return (0, import_react7.useMemo)(\n        () => ({\n          [`__scope${scopeName}`]: {\n            ...scope,\n            [scopeName]: contexts\n          }\n        }),\n        [\n          scope,\n          contexts\n        ]\n      );\n    };\n  };\n  createScope.scopeName = scopeName;\n  return [\n    $c512c27ab02ef895$export$fd42f52fd3ae11092,\n    $c512c27ab02ef895$var$composeContextScopes(createScope, ...createContextScopeDeps)\n  ];\n}\nfunction $c512c27ab02ef895$var$composeContextScopes(...scopes) {\n  const baseScope = scopes[0];\n  if (scopes.length === 1)\n    return baseScope;\n  const createScope1 = () => {\n    const scopeHooks = scopes.map(\n      (createScope) => ({\n        useScope: createScope(),\n        scopeName: createScope.scopeName\n      })\n    );\n    return function useComposedScopes(overrideScopes) {\n      const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {\n        const scopeProps = useScope(overrideScopes);\n        const currentScope = scopeProps[`__scope${scopeName}`];\n        return {\n          ...nextScopes,\n          ...currentScope\n        };\n      }, {});\n      return (0, import_react7.useMemo)(\n        () => ({\n          [`__scope${baseScope.scopeName}`]: nextScopes1\n        }),\n        [\n          nextScopes1\n        ]\n      );\n    };\n  };\n  createScope1.scopeName = baseScope.scopeName;\n  return createScope1;\n}\n\n// node_modules/.pnpm/@radix-ui+react-primitive@1.0.3_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-primitive/dist/index.mjs\nvar import_react10 = require(\"react\");\nvar import_react_dom = require(\"react-dom\");\n\n// node_modules/.pnpm/@radix-ui+react-slot@1.0.2_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-slot/dist/index.mjs\nvar import_react9 = require(\"react\");\n\n// node_modules/.pnpm/@radix-ui+react-compose-refs@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-compose-refs/dist/index.mjs\nvar import_react8 = require(\"react\");\nfunction $6ed0406888f73fc4$var$setRef(ref, value) {\n  if (typeof ref === \"function\")\n    ref(value);\n  else if (ref !== null && ref !== void 0)\n    ref.current = value;\n}\nfunction $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {\n  return (node) => refs.forEach(\n    (ref) => $6ed0406888f73fc4$var$setRef(ref, node)\n  );\n}\nfunction $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...refs) {\n  return (0, import_react8.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af(...refs), refs);\n}\n\n// node_modules/.pnpm/@radix-ui+react-slot@1.0.2_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-slot/dist/index.mjs\nvar $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /* @__PURE__ */ (0, import_react9.forwardRef)((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n  const childrenArray = import_react9.Children.toArray(children);\n  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);\n  if (slottable) {\n    const newElement = slottable.props.children;\n    const newChildren = childrenArray.map((child) => {\n      if (child === slottable) {\n        if (import_react9.Children.count(newElement) > 1)\n          return import_react9.Children.only(null);\n        return /* @__PURE__ */ (0, import_react9.isValidElement)(newElement) ? newElement.props.children : null;\n      } else\n        return child;\n    });\n    return /* @__PURE__ */ (0, import_react9.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {\n      ref: forwardedRef\n    }), /* @__PURE__ */ (0, import_react9.isValidElement)(newElement) ? /* @__PURE__ */ (0, import_react9.cloneElement)(newElement, void 0, newChildren) : null);\n  }\n  return /* @__PURE__ */ (0, import_react9.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {\n    ref: forwardedRef\n  }), children);\n});\n$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = \"Slot\";\nvar $5e63c961fc1ce211$var$SlotClone = /* @__PURE__ */ (0, import_react9.forwardRef)((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n  if (/* @__PURE__ */ (0, import_react9.isValidElement)(children))\n    return /* @__PURE__ */ (0, import_react9.cloneElement)(children, {\n      ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),\n      ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref) : children.ref\n    });\n  return import_react9.Children.count(children) > 1 ? import_react9.Children.only(null) : null;\n});\n$5e63c961fc1ce211$var$SlotClone.displayName = \"SlotClone\";\nvar $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {\n  return /* @__PURE__ */ (0, import_react9.createElement)(import_react9.Fragment, null, children);\n};\nfunction $5e63c961fc1ce211$var$isSlottable(child) {\n  return /* @__PURE__ */ (0, import_react9.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;\n}\nfunction $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {\n  const overrideProps = {\n    ...childProps\n  };\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      if (slotPropValue && childPropValue)\n        overrideProps[propName] = (...args) => {\n          childPropValue(...args);\n          slotPropValue(...args);\n        };\n      else if (slotPropValue)\n        overrideProps[propName] = slotPropValue;\n    } else if (propName === \"style\")\n      overrideProps[propName] = {\n        ...slotPropValue,\n        ...childPropValue\n      };\n    else if (propName === \"className\")\n      overrideProps[propName] = [\n        slotPropValue,\n        childPropValue\n      ].filter(Boolean).join(\" \");\n  }\n  return {\n    ...slotProps,\n    ...overrideProps\n  };\n}\n\n// node_modules/.pnpm/@radix-ui+react-primitive@1.0.3_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-primitive/dist/index.mjs\nvar $8927f6f2acc4f386$var$NODES = [\n  \"a\",\n  \"button\",\n  \"div\",\n  \"form\",\n  \"h2\",\n  \"h3\",\n  \"img\",\n  \"input\",\n  \"label\",\n  \"li\",\n  \"nav\",\n  \"ol\",\n  \"p\",\n  \"span\",\n  \"svg\",\n  \"ul\"\n];\nvar $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce((primitive, node) => {\n  const Node = /* @__PURE__ */ (0, import_react10.forwardRef)((props, forwardedRef) => {\n    const { asChild, ...primitiveProps } = props;\n    const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : node;\n    (0, import_react10.useEffect)(() => {\n      window[Symbol.for(\"radix-ui\")] = true;\n    }, []);\n    return /* @__PURE__ */ (0, import_react10.createElement)(Comp, _extends({}, primitiveProps, {\n      ref: forwardedRef\n    }));\n  });\n  Node.displayName = `Primitive.${node}`;\n  return {\n    ...primitive,\n    [node]: Node\n  };\n}, {});\nfunction $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event) {\n  if (target)\n    (0, import_react_dom.flushSync)(\n      () => target.dispatchEvent(event)\n    );\n}\n\n// node_modules/.pnpm/@radix-ui+react-menu@2.0.5_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-menu/dist/index.mjs\nvar import_react28 = require(\"react\");\n\n// node_modules/.pnpm/@radix-ui+react-collection@1.0.3_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-collection/dist/index.mjs\nvar import_react11 = __toESM(require(\"react\"), 1);\nfunction $e02a7d9cb1dc128c$export$c74125a8e3af6bb2(name) {\n  const PROVIDER_NAME = name + \"CollectionProvider\";\n  const [createCollectionContext, createCollectionScope] = $c512c27ab02ef895$export$50c7b4e9d9f19c1(PROVIDER_NAME);\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, {\n    collectionRef: {\n      current: null\n    },\n    itemMap: /* @__PURE__ */ new Map()\n  });\n  const CollectionProvider = (props) => {\n    const { scope, children } = props;\n    const ref = import_react11.default.useRef(null);\n    const itemMap = import_react11.default.useRef(/* @__PURE__ */ new Map()).current;\n    return /* @__PURE__ */ import_react11.default.createElement(CollectionProviderImpl, {\n      scope,\n      itemMap,\n      collectionRef: ref\n    }, children);\n  };\n  /* @__PURE__ */ Object.assign(CollectionProvider, {\n    displayName: PROVIDER_NAME\n  });\n  const COLLECTION_SLOT_NAME = name + \"CollectionSlot\";\n  const CollectionSlot = /* @__PURE__ */ import_react11.default.forwardRef((props, forwardedRef) => {\n    const { scope, children } = props;\n    const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.collectionRef);\n    return /* @__PURE__ */ import_react11.default.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {\n      ref: composedRefs\n    }, children);\n  });\n  /* @__PURE__ */ Object.assign(CollectionSlot, {\n    displayName: COLLECTION_SLOT_NAME\n  });\n  const ITEM_SLOT_NAME = name + \"CollectionItemSlot\";\n  const ITEM_DATA_ATTR = \"data-radix-collection-item\";\n  const CollectionItemSlot = /* @__PURE__ */ import_react11.default.forwardRef((props, forwardedRef) => {\n    const { scope, children, ...itemData } = props;\n    const ref = import_react11.default.useRef(null);\n    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);\n    const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n    import_react11.default.useEffect(() => {\n      context.itemMap.set(ref, {\n        ref,\n        ...itemData\n      });\n      return () => void context.itemMap.delete(ref);\n    });\n    return /* @__PURE__ */ import_react11.default.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {\n      [ITEM_DATA_ATTR]: \"\",\n      ref: composedRefs\n    }, children);\n  });\n  /* @__PURE__ */ Object.assign(CollectionItemSlot, {\n    displayName: ITEM_SLOT_NAME\n  });\n  function useCollection(scope) {\n    const context = useCollectionContext(name + \"CollectionConsumer\", scope);\n    const getItems = import_react11.default.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode)\n        return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a7, b6) => orderedNodes.indexOf(a7.ref.current) - orderedNodes.indexOf(b6.ref.current)\n      );\n      return orderedItems;\n    }, [\n      context.collectionRef,\n      context.itemMap\n    ]);\n    return getItems;\n  }\n  return [\n    {\n      Provider: CollectionProvider,\n      Slot: CollectionSlot,\n      ItemSlot: CollectionItemSlot\n    },\n    useCollection,\n    createCollectionScope\n  ];\n}\n\n// node_modules/.pnpm/@radix-ui+react-direction@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-direction/dist/index.mjs\nvar import_react12 = require(\"react\");\nvar $f631663db3294ace$var$DirectionContext = /* @__PURE__ */ (0, import_react12.createContext)(void 0);\nfunction $f631663db3294ace$export$b39126d51d94e6f3(localDir) {\n  const globalDir = (0, import_react12.useContext)($f631663db3294ace$var$DirectionContext);\n  return localDir || globalDir || \"ltr\";\n}\n\n// node_modules/.pnpm/@radix-ui+react-dismissable-layer@1.0.4_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs\nvar import_react15 = require(\"react\");\n\n// node_modules/.pnpm/@radix-ui+react-use-callback-ref@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs\nvar import_react13 = require(\"react\");\nfunction $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback) {\n  const callbackRef = (0, import_react13.useRef)(callback);\n  (0, import_react13.useEffect)(() => {\n    callbackRef.current = callback;\n  });\n  return (0, import_react13.useMemo)(\n    () => (...args) => {\n      var _callbackRef$current;\n      return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);\n    },\n    []\n  );\n}\n\n// node_modules/.pnpm/@radix-ui+react-use-escape-keydown@1.0.3_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs\nvar import_react14 = require(\"react\");\nfunction $addc16e1bbe58fd0$export$3a72a57244d6e765(onEscapeKeyDownProp, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {\n  const onEscapeKeyDown = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEscapeKeyDownProp);\n  (0, import_react14.useEffect)(() => {\n    const handleKeyDown = (event) => {\n      if (event.key === \"Escape\")\n        onEscapeKeyDown(event);\n    };\n    ownerDocument.addEventListener(\"keydown\", handleKeyDown);\n    return () => ownerDocument.removeEventListener(\"keydown\", handleKeyDown);\n  }, [\n    onEscapeKeyDown,\n    ownerDocument\n  ]);\n}\n\n// node_modules/.pnpm/@radix-ui+react-dismissable-layer@1.0.4_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs\nvar $5cb92bef7577960e$var$CONTEXT_UPDATE = \"dismissableLayer.update\";\nvar $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE = \"dismissableLayer.pointerDownOutside\";\nvar $5cb92bef7577960e$var$FOCUS_OUTSIDE = \"dismissableLayer.focusOutside\";\nvar $5cb92bef7577960e$var$originalBodyPointerEvents;\nvar $5cb92bef7577960e$var$DismissableLayerContext = /* @__PURE__ */ (0, import_react15.createContext)({\n  layers: /* @__PURE__ */ new Set(),\n  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),\n  branches: /* @__PURE__ */ new Set()\n});\nvar $5cb92bef7577960e$export$177fb62ff3ec1f22 = /* @__PURE__ */ (0, import_react15.forwardRef)((props, forwardedRef) => {\n  var _node$ownerDocument;\n  const { disableOutsidePointerEvents = false, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, ...layerProps } = props;\n  const context = (0, import_react15.useContext)($5cb92bef7577960e$var$DismissableLayerContext);\n  const [node1, setNode] = (0, import_react15.useState)(null);\n  const ownerDocument = (_node$ownerDocument = node1 === null || node1 === void 0 ? void 0 : node1.ownerDocument) !== null && _node$ownerDocument !== void 0 ? _node$ownerDocument : globalThis === null || globalThis === void 0 ? void 0 : globalThis.document;\n  const [, force] = (0, import_react15.useState)({});\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(\n    forwardedRef,\n    (node) => setNode(node)\n  );\n  const layers = Array.from(context.layers);\n  const [highestLayerWithOutsidePointerEventsDisabled] = [\n    ...context.layersWithOutsidePointerEventsDisabled\n  ].slice(-1);\n  const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);\n  const index2 = node1 ? layers.indexOf(node1) : -1;\n  const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;\n  const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;\n  const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside((event) => {\n    const target = event.target;\n    const isPointerDownOnBranch = [\n      ...context.branches\n    ].some(\n      (branch) => branch.contains(target)\n    );\n    if (!isPointerEventsEnabled || isPointerDownOnBranch)\n      return;\n    onPointerDownOutside === null || onPointerDownOutside === void 0 || onPointerDownOutside(event);\n    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);\n    if (!event.defaultPrevented)\n      onDismiss === null || onDismiss === void 0 || onDismiss();\n  }, ownerDocument);\n  const focusOutside = $5cb92bef7577960e$var$useFocusOutside((event) => {\n    const target = event.target;\n    const isFocusInBranch = [\n      ...context.branches\n    ].some(\n      (branch) => branch.contains(target)\n    );\n    if (isFocusInBranch)\n      return;\n    onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event);\n    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);\n    if (!event.defaultPrevented)\n      onDismiss === null || onDismiss === void 0 || onDismiss();\n  }, ownerDocument);\n  $addc16e1bbe58fd0$export$3a72a57244d6e765((event) => {\n    const isHighestLayer = index2 === context.layers.size - 1;\n    if (!isHighestLayer)\n      return;\n    onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event);\n    if (!event.defaultPrevented && onDismiss) {\n      event.preventDefault();\n      onDismiss();\n    }\n  }, ownerDocument);\n  (0, import_react15.useEffect)(() => {\n    if (!node1)\n      return;\n    if (disableOutsidePointerEvents) {\n      if (context.layersWithOutsidePointerEventsDisabled.size === 0) {\n        $5cb92bef7577960e$var$originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;\n        ownerDocument.body.style.pointerEvents = \"none\";\n      }\n      context.layersWithOutsidePointerEventsDisabled.add(node1);\n    }\n    context.layers.add(node1);\n    $5cb92bef7577960e$var$dispatchUpdate();\n    return () => {\n      if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1)\n        ownerDocument.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents;\n    };\n  }, [\n    node1,\n    ownerDocument,\n    disableOutsidePointerEvents,\n    context\n  ]);\n  (0, import_react15.useEffect)(() => {\n    return () => {\n      if (!node1)\n        return;\n      context.layers.delete(node1);\n      context.layersWithOutsidePointerEventsDisabled.delete(node1);\n      $5cb92bef7577960e$var$dispatchUpdate();\n    };\n  }, [\n    node1,\n    context\n  ]);\n  (0, import_react15.useEffect)(() => {\n    const handleUpdate = () => force({});\n    document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);\n    return () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);\n  }, []);\n  return /* @__PURE__ */ (0, import_react15.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, layerProps, {\n    ref: composedRefs,\n    style: {\n      pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? \"auto\" : \"none\" : void 0,\n      ...props.style\n    },\n    onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusCapture, focusOutside.onFocusCapture),\n    onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlurCapture, focusOutside.onBlurCapture),\n    onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)\n  }));\n});\nfunction $5cb92bef7577960e$var$usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {\n  const handlePointerDownOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPointerDownOutside);\n  const isPointerInsideReactTreeRef = (0, import_react15.useRef)(false);\n  const handleClickRef = (0, import_react15.useRef)(() => {\n  });\n  (0, import_react15.useEffect)(() => {\n    const handlePointerDown = (event) => {\n      if (event.target && !isPointerInsideReactTreeRef.current) {\n        let handleAndDispatchPointerDownOutsideEvent = function() {\n          $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {\n            discrete: true\n          });\n        };\n        const eventDetail = {\n          originalEvent: event\n        };\n        if (event.pointerType === \"touch\") {\n          ownerDocument.removeEventListener(\"click\", handleClickRef.current);\n          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;\n          ownerDocument.addEventListener(\"click\", handleClickRef.current, {\n            once: true\n          });\n        } else\n          handleAndDispatchPointerDownOutsideEvent();\n      }\n      isPointerInsideReactTreeRef.current = false;\n    };\n    const timerId = window.setTimeout(() => {\n      ownerDocument.addEventListener(\"pointerdown\", handlePointerDown);\n    }, 0);\n    return () => {\n      window.clearTimeout(timerId);\n      ownerDocument.removeEventListener(\"pointerdown\", handlePointerDown);\n      ownerDocument.removeEventListener(\"click\", handleClickRef.current);\n    };\n  }, [\n    ownerDocument,\n    handlePointerDownOutside\n  ]);\n  return {\n    // ensures we check React component tree (not just DOM tree)\n    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true\n  };\n}\nfunction $5cb92bef7577960e$var$useFocusOutside(onFocusOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {\n  const handleFocusOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onFocusOutside);\n  const isFocusInsideReactTreeRef = (0, import_react15.useRef)(false);\n  (0, import_react15.useEffect)(() => {\n    const handleFocus = (event) => {\n      if (event.target && !isFocusInsideReactTreeRef.current) {\n        const eventDetail = {\n          originalEvent: event\n        };\n        $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {\n          discrete: false\n        });\n      }\n    };\n    ownerDocument.addEventListener(\"focusin\", handleFocus);\n    return () => ownerDocument.removeEventListener(\"focusin\", handleFocus);\n  }, [\n    ownerDocument,\n    handleFocusOutside\n  ]);\n  return {\n    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,\n    onBlurCapture: () => isFocusInsideReactTreeRef.current = false\n  };\n}\nfunction $5cb92bef7577960e$var$dispatchUpdate() {\n  const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE);\n  document.dispatchEvent(event);\n}\nfunction $5cb92bef7577960e$var$handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {\n  const target = detail.originalEvent.target;\n  const event = new CustomEvent(name, {\n    bubbles: false,\n    cancelable: true,\n    detail\n  });\n  if (handler)\n    target.addEventListener(name, handler, {\n      once: true\n    });\n  if (discrete)\n    $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event);\n  else\n    target.dispatchEvent(event);\n}\n\n// node_modules/.pnpm/@radix-ui+react-focus-guards@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-focus-guards/dist/index.mjs\nvar import_react16 = require(\"react\");\nvar $3db38b7d1fb3fe6a$var$count = 0;\nfunction $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c() {\n  (0, import_react16.useEffect)(() => {\n    var _edgeGuards$, _edgeGuards$2;\n    const edgeGuards = document.querySelectorAll(\"[data-radix-focus-guard]\");\n    document.body.insertAdjacentElement(\"afterbegin\", (_edgeGuards$ = edgeGuards[0]) !== null && _edgeGuards$ !== void 0 ? _edgeGuards$ : $3db38b7d1fb3fe6a$var$createFocusGuard());\n    document.body.insertAdjacentElement(\"beforeend\", (_edgeGuards$2 = edgeGuards[1]) !== null && _edgeGuards$2 !== void 0 ? _edgeGuards$2 : $3db38b7d1fb3fe6a$var$createFocusGuard());\n    $3db38b7d1fb3fe6a$var$count++;\n    return () => {\n      if ($3db38b7d1fb3fe6a$var$count === 1)\n        document.querySelectorAll(\"[data-radix-focus-guard]\").forEach(\n          (node) => node.remove()\n        );\n      $3db38b7d1fb3fe6a$var$count--;\n    };\n  }, []);\n}\nfunction $3db38b7d1fb3fe6a$var$createFocusGuard() {\n  const element = document.createElement(\"span\");\n  element.setAttribute(\"data-radix-focus-guard\", \"\");\n  element.tabIndex = 0;\n  element.style.cssText = \"outline: none; opacity: 0; position: fixed; pointer-events: none\";\n  return element;\n}\n\n// node_modules/.pnpm/@radix-ui+react-focus-scope@1.0.3_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-focus-scope/dist/index.mjs\nvar import_react17 = require(\"react\");\nvar $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = \"focusScope.autoFocusOnMount\";\nvar $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = \"focusScope.autoFocusOnUnmount\";\nvar $d3863c46a17e8a28$var$EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\nvar $d3863c46a17e8a28$export$20e40289641fbbb6 = /* @__PURE__ */ (0, import_react17.forwardRef)((props, forwardedRef) => {\n  const { loop = false, trapped = false, onMountAutoFocus: onMountAutoFocusProp, onUnmountAutoFocus: onUnmountAutoFocusProp, ...scopeProps } = props;\n  const [container1, setContainer] = (0, import_react17.useState)(null);\n  const onMountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onMountAutoFocusProp);\n  const onUnmountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = (0, import_react17.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(\n    forwardedRef,\n    (node) => setContainer(node)\n  );\n  const focusScope = (0, import_react17.useRef)({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    }\n  }).current;\n  (0, import_react17.useEffect)(() => {\n    if (trapped) {\n      let handleFocusIn = function(event) {\n        if (focusScope.paused || !container1)\n          return;\n        const target = event.target;\n        if (container1.contains(target))\n          lastFocusedElementRef.current = target;\n        else\n          $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {\n            select: true\n          });\n      }, handleFocusOut = function(event) {\n        if (focusScope.paused || !container1)\n          return;\n        const relatedTarget = event.relatedTarget;\n        if (relatedTarget === null)\n          return;\n        if (!container1.contains(relatedTarget))\n          $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {\n            select: true\n          });\n      }, handleMutations = function(mutations) {\n        const focusedElement = document.activeElement;\n        for (const mutation of mutations) {\n          if (mutation.removedNodes.length > 0) {\n            if (!(container1 !== null && container1 !== void 0 && container1.contains(focusedElement)))\n              $d3863c46a17e8a28$var$focus(container1);\n          }\n        }\n      };\n      document.addEventListener(\"focusin\", handleFocusIn);\n      document.addEventListener(\"focusout\", handleFocusOut);\n      const mutationObserver = new MutationObserver(handleMutations);\n      if (container1)\n        mutationObserver.observe(container1, {\n          childList: true,\n          subtree: true\n        });\n      return () => {\n        document.removeEventListener(\"focusin\", handleFocusIn);\n        document.removeEventListener(\"focusout\", handleFocusOut);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [\n    trapped,\n    container1,\n    focusScope.paused\n  ]);\n  (0, import_react17.useEffect)(() => {\n    if (container1) {\n      $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement;\n      const hasFocusedCandidate = container1.contains(previouslyFocusedElement);\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);\n        container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container1.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {\n            select: true\n          });\n          if (document.activeElement === previouslyFocusedElement)\n            $d3863c46a17e8a28$var$focus(container1);\n        }\n      }\n      return () => {\n        container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);\n          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container1.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented)\n            $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {\n              select: true\n            });\n          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [\n    container1,\n    onMountAutoFocus,\n    onUnmountAutoFocus,\n    focusScope\n  ]);\n  const handleKeyDown = (0, import_react17.useCallback)((event) => {\n    if (!loop && !trapped)\n      return;\n    if (focusScope.paused)\n      return;\n    const isTabKey = event.key === \"Tab\" && !event.altKey && !event.ctrlKey && !event.metaKey;\n    const focusedElement = document.activeElement;\n    if (isTabKey && focusedElement) {\n      const container = event.currentTarget;\n      const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges(container);\n      const hasTabbableElementsInside = first && last;\n      if (!hasTabbableElementsInside) {\n        if (focusedElement === container)\n          event.preventDefault();\n      } else {\n        if (!event.shiftKey && focusedElement === last) {\n          event.preventDefault();\n          if (loop)\n            $d3863c46a17e8a28$var$focus(first, {\n              select: true\n            });\n        } else if (event.shiftKey && focusedElement === first) {\n          event.preventDefault();\n          if (loop)\n            $d3863c46a17e8a28$var$focus(last, {\n              select: true\n            });\n        }\n      }\n    }\n  }, [\n    loop,\n    trapped,\n    focusScope.paused\n  ]);\n  return /* @__PURE__ */ (0, import_react17.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({\n    tabIndex: -1\n  }, scopeProps, {\n    ref: composedRefs,\n    onKeyDown: handleKeyDown\n  }));\n});\nfunction $d3863c46a17e8a28$var$focusFirst(candidates, { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    $d3863c46a17e8a28$var$focus(candidate, {\n      select\n    });\n    if (document.activeElement !== previouslyFocusedElement)\n      return;\n  }\n}\nfunction $d3863c46a17e8a28$var$getTabbableEdges(container) {\n  const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);\n  const first = $d3863c46a17e8a28$var$findVisible(candidates, container);\n  const last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);\n  return [\n    first,\n    last\n  ];\n}\nfunction $d3863c46a17e8a28$var$getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node) => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput)\n        return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode())\n    nodes.push(walker.currentNode);\n  return nodes;\n}\nfunction $d3863c46a17e8a28$var$findVisible(elements, container) {\n  for (const element of elements) {\n    if (!$d3863c46a17e8a28$var$isHidden(element, {\n      upTo: container\n    }))\n      return element;\n  }\n}\nfunction $d3863c46a17e8a28$var$isHidden(node, { upTo }) {\n  if (getComputedStyle(node).visibility === \"hidden\")\n    return true;\n  while (node) {\n    if (upTo !== void 0 && node === upTo)\n      return false;\n    if (getComputedStyle(node).display === \"none\")\n      return true;\n    node = node.parentElement;\n  }\n  return false;\n}\nfunction $d3863c46a17e8a28$var$isSelectableInput(element) {\n  return element instanceof HTMLInputElement && \"select\" in element;\n}\nfunction $d3863c46a17e8a28$var$focus(element, { select = false } = {}) {\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    element.focus({\n      preventScroll: true\n    });\n    if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select)\n      element.select();\n  }\n}\nvar $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();\nfunction $d3863c46a17e8a28$var$createFocusScopesStack() {\n  let stack = [];\n  return {\n    add(focusScope) {\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope)\n        activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();\n      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n    remove(focusScope) {\n      var _stack$;\n      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);\n      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();\n    }\n  };\n}\nfunction $d3863c46a17e8a28$var$arrayRemove(array, item) {\n  const updatedArray = [\n    ...array\n  ];\n  const index2 = updatedArray.indexOf(item);\n  if (index2 !== -1)\n    updatedArray.splice(index2, 1);\n  return updatedArray;\n}\nfunction $d3863c46a17e8a28$var$removeLinks(items) {\n  return items.filter(\n    (item) => item.tagName !== \"A\"\n  );\n}\n\n// node_modules/.pnpm/@radix-ui+react-id@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-id/dist/index.mjs\nvar $2AODx$react = __toESM(require(\"react\"), 1);\n\n// node_modules/.pnpm/@radix-ui+react-use-layout-effect@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs\nvar import_react18 = require(\"react\");\nvar $9f79659886946c16$export$e5c5a5f917a5871c = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? import_react18.useLayoutEffect : () => {\n};\n\n// node_modules/.pnpm/@radix-ui+react-id@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-id/dist/index.mjs\nvar $1746a345f3d73bb7$var$useReactId = $2AODx$react[\"useId\".toString()] || (() => void 0);\nvar $1746a345f3d73bb7$var$count = 0;\nfunction $1746a345f3d73bb7$export$f680877a34711e37(deterministicId) {\n  const [id, setId] = $2AODx$react.useState($1746a345f3d73bb7$var$useReactId());\n  $9f79659886946c16$export$e5c5a5f917a5871c(() => {\n    if (!deterministicId)\n      setId(\n        (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count++)\n      );\n  }, [\n    deterministicId\n  ]);\n  return deterministicId || (id ? `radix-${id}` : \"\");\n}\n\n// node_modules/.pnpm/@radix-ui+react-popper@1.1.2_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-popper/dist/index.mjs\nvar import_react22 = require(\"react\");\n\n// node_modules/.pnpm/@floating-ui+core@1.2.6/node_modules/@floating-ui/core/dist/floating-ui.core.browser.min.mjs\nfunction t2(t5) {\n  return t5.split(\"-\")[1];\n}\nfunction e2(t5) {\n  return \"y\" === t5 ? \"height\" : \"width\";\n}\nfunction n(t5) {\n  return t5.split(\"-\")[0];\n}\nfunction o(t5) {\n  return [\"top\", \"bottom\"].includes(n(t5)) ? \"x\" : \"y\";\n}\nfunction i(i4, r5, a7) {\n  let { reference: l7, floating: s5 } = i4;\n  const c5 = l7.x + l7.width / 2 - s5.width / 2, f5 = l7.y + l7.height / 2 - s5.height / 2, m6 = o(r5), u5 = e2(m6), g6 = l7[u5] / 2 - s5[u5] / 2, d6 = \"x\" === m6;\n  let p6;\n  switch (n(r5)) {\n    case \"top\":\n      p6 = { x: c5, y: l7.y - s5.height };\n      break;\n    case \"bottom\":\n      p6 = { x: c5, y: l7.y + l7.height };\n      break;\n    case \"right\":\n      p6 = { x: l7.x + l7.width, y: f5 };\n      break;\n    case \"left\":\n      p6 = { x: l7.x - s5.width, y: f5 };\n      break;\n    default:\n      p6 = { x: l7.x, y: l7.y };\n  }\n  switch (t2(r5)) {\n    case \"start\":\n      p6[m6] -= g6 * (a7 && d6 ? -1 : 1);\n      break;\n    case \"end\":\n      p6[m6] += g6 * (a7 && d6 ? -1 : 1);\n  }\n  return p6;\n}\nvar r = async (t5, e5, n5) => {\n  const { placement: o5 = \"bottom\", strategy: r5 = \"absolute\", middleware: a7 = [], platform: l7 } = n5, s5 = a7.filter(Boolean), c5 = await (null == l7.isRTL ? void 0 : l7.isRTL(e5));\n  let f5 = await l7.getElementRects({ reference: t5, floating: e5, strategy: r5 }), { x: m6, y: u5 } = i(f5, o5, c5), g6 = o5, d6 = {}, p6 = 0;\n  for (let n6 = 0; n6 < s5.length; n6++) {\n    const { name: a8, fn: h6 } = s5[n6], { x: y6, y: x5, data: w7, reset: v6 } = await h6({ x: m6, y: u5, initialPlacement: o5, placement: g6, strategy: r5, middlewareData: d6, rects: f5, platform: l7, elements: { reference: t5, floating: e5 } });\n    m6 = null != y6 ? y6 : m6, u5 = null != x5 ? x5 : u5, d6 = { ...d6, [a8]: { ...d6[a8], ...w7 } }, v6 && p6 <= 50 && (p6++, \"object\" == typeof v6 && (v6.placement && (g6 = v6.placement), v6.rects && (f5 = true === v6.rects ? await l7.getElementRects({ reference: t5, floating: e5, strategy: r5 }) : v6.rects), { x: m6, y: u5 } = i(f5, g6, c5)), n6 = -1);\n  }\n  return { x: m6, y: u5, placement: g6, strategy: r5, middlewareData: d6 };\n};\nfunction a3(t5) {\n  return \"number\" != typeof t5 ? function(t6) {\n    return { top: 0, right: 0, bottom: 0, left: 0, ...t6 };\n  }(t5) : { top: t5, right: t5, bottom: t5, left: t5 };\n}\nfunction l3(t5) {\n  return { ...t5, top: t5.y, left: t5.x, right: t5.x + t5.width, bottom: t5.y + t5.height };\n}\nasync function s(t5, e5) {\n  var n5;\n  void 0 === e5 && (e5 = {});\n  const { x: o5, y: i4, platform: r5, rects: s5, elements: c5, strategy: f5 } = t5, { boundary: m6 = \"clippingAncestors\", rootBoundary: u5 = \"viewport\", elementContext: g6 = \"floating\", altBoundary: d6 = false, padding: p6 = 0 } = e5, h6 = a3(p6), y6 = c5[d6 ? \"floating\" === g6 ? \"reference\" : \"floating\" : g6], x5 = l3(await r5.getClippingRect({ element: null == (n5 = await (null == r5.isElement ? void 0 : r5.isElement(y6))) || n5 ? y6 : y6.contextElement || await (null == r5.getDocumentElement ? void 0 : r5.getDocumentElement(c5.floating)), boundary: m6, rootBoundary: u5, strategy: f5 })), w7 = \"floating\" === g6 ? { ...s5.floating, x: o5, y: i4 } : s5.reference, v6 = await (null == r5.getOffsetParent ? void 0 : r5.getOffsetParent(c5.floating)), b6 = await (null == r5.isElement ? void 0 : r5.isElement(v6)) && await (null == r5.getScale ? void 0 : r5.getScale(v6)) || { x: 1, y: 1 }, A6 = l3(r5.convertOffsetParentRelativeRectToViewportRelativeRect ? await r5.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: w7, offsetParent: v6, strategy: f5 }) : w7);\n  return { top: (x5.top - A6.top + h6.top) / b6.y, bottom: (A6.bottom - x5.bottom + h6.bottom) / b6.y, left: (x5.left - A6.left + h6.left) / b6.x, right: (A6.right - x5.right + h6.right) / b6.x };\n}\nvar c = Math.min;\nvar f = Math.max;\nfunction m2(t5, e5, n5) {\n  return f(t5, c(e5, n5));\n}\nvar u = (n5) => ({ name: \"arrow\", options: n5, async fn(i4) {\n  const { element: r5, padding: l7 = 0 } = n5 || {}, { x: s5, y: c5, placement: f5, rects: u5, platform: g6, elements: d6 } = i4;\n  if (null == r5)\n    return {};\n  const p6 = a3(l7), h6 = { x: s5, y: c5 }, y6 = o(f5), x5 = e2(y6), w7 = await g6.getDimensions(r5), v6 = \"y\" === y6, b6 = v6 ? \"top\" : \"left\", A6 = v6 ? \"bottom\" : \"right\", R7 = v6 ? \"clientHeight\" : \"clientWidth\", P5 = u5.reference[x5] + u5.reference[y6] - h6[y6] - u5.floating[x5], E5 = h6[y6] - u5.reference[y6], T5 = await (null == g6.getOffsetParent ? void 0 : g6.getOffsetParent(r5));\n  let D6 = T5 ? T5[R7] : 0;\n  D6 && await (null == g6.isElement ? void 0 : g6.isElement(T5)) || (D6 = d6.floating[R7] || u5.floating[x5]);\n  const L5 = P5 / 2 - E5 / 2, k7 = p6[b6], O6 = D6 - w7[x5] - p6[A6], B5 = D6 / 2 - w7[x5] / 2 + L5, C6 = m2(k7, B5, O6), H5 = null != t2(f5) && B5 != C6 && u5.reference[x5] / 2 - (B5 < k7 ? p6[b6] : p6[A6]) - w7[x5] / 2 < 0;\n  return { [y6]: h6[y6] - (H5 ? B5 < k7 ? k7 - B5 : O6 - B5 : 0), data: { [y6]: C6, centerOffset: B5 - C6 } };\n} });\nvar g3 = [\"top\", \"right\", \"bottom\", \"left\"];\nvar d2 = g3.reduce((t5, e5) => t5.concat(e5, e5 + \"-start\", e5 + \"-end\"), []);\nvar p2 = { left: \"right\", right: \"left\", bottom: \"top\", top: \"bottom\" };\nfunction h2(t5) {\n  return t5.replace(/left|right|bottom|top/g, (t6) => p2[t6]);\n}\nfunction y2(n5, i4, r5) {\n  void 0 === r5 && (r5 = false);\n  const a7 = t2(n5), l7 = o(n5), s5 = e2(l7);\n  let c5 = \"x\" === l7 ? a7 === (r5 ? \"end\" : \"start\") ? \"right\" : \"left\" : \"start\" === a7 ? \"bottom\" : \"top\";\n  return i4.reference[s5] > i4.floating[s5] && (c5 = h2(c5)), { main: c5, cross: h2(c5) };\n}\nvar x2 = { start: \"end\", end: \"start\" };\nfunction w3(t5) {\n  return t5.replace(/start|end/g, (t6) => x2[t6]);\n}\nvar b2 = function(e5) {\n  return void 0 === e5 && (e5 = {}), { name: \"flip\", options: e5, async fn(o5) {\n    var i4;\n    const { placement: r5, middlewareData: a7, rects: l7, initialPlacement: c5, platform: f5, elements: m6 } = o5, { mainAxis: u5 = true, crossAxis: g6 = true, fallbackPlacements: d6, fallbackStrategy: p6 = \"bestFit\", fallbackAxisSideDirection: x5 = \"none\", flipAlignment: v6 = true, ...b6 } = e5, A6 = n(r5), R7 = n(c5) === c5, P5 = await (null == f5.isRTL ? void 0 : f5.isRTL(m6.floating)), E5 = d6 || (R7 || !v6 ? [h2(c5)] : function(t5) {\n      const e6 = h2(t5);\n      return [w3(t5), e6, w3(e6)];\n    }(c5));\n    d6 || \"none\" === x5 || E5.push(...function(e6, o6, i5, r6) {\n      const a8 = t2(e6);\n      let l8 = function(t5, e7, n5) {\n        const o7 = [\"left\", \"right\"], i6 = [\"right\", \"left\"], r7 = [\"top\", \"bottom\"], a9 = [\"bottom\", \"top\"];\n        switch (t5) {\n          case \"top\":\n          case \"bottom\":\n            return n5 ? e7 ? i6 : o7 : e7 ? o7 : i6;\n          case \"left\":\n          case \"right\":\n            return e7 ? r7 : a9;\n          default:\n            return [];\n        }\n      }(n(e6), \"start\" === i5, r6);\n      return a8 && (l8 = l8.map((t5) => t5 + \"-\" + a8), o6 && (l8 = l8.concat(l8.map(w3)))), l8;\n    }(c5, v6, x5, P5));\n    const T5 = [c5, ...E5], D6 = await s(o5, b6), L5 = [];\n    let k7 = (null == (i4 = a7.flip) ? void 0 : i4.overflows) || [];\n    if (u5 && L5.push(D6[A6]), g6) {\n      const { main: t5, cross: e6 } = y2(r5, l7, P5);\n      L5.push(D6[t5], D6[e6]);\n    }\n    if (k7 = [...k7, { placement: r5, overflows: L5 }], !L5.every((t5) => t5 <= 0)) {\n      var O6, B5;\n      const t5 = ((null == (O6 = a7.flip) ? void 0 : O6.index) || 0) + 1, e6 = T5[t5];\n      if (e6)\n        return { data: { index: t5, overflows: k7 }, reset: { placement: e6 } };\n      let n5 = null == (B5 = k7.filter((t6) => t6.overflows[0] <= 0).sort((t6, e7) => t6.overflows[1] - e7.overflows[1])[0]) ? void 0 : B5.placement;\n      if (!n5)\n        switch (p6) {\n          case \"bestFit\": {\n            var C6;\n            const t6 = null == (C6 = k7.map((t7) => [t7.placement, t7.overflows.filter((t8) => t8 > 0).reduce((t8, e7) => t8 + e7, 0)]).sort((t7, e7) => t7[1] - e7[1])[0]) ? void 0 : C6[0];\n            t6 && (n5 = t6);\n            break;\n          }\n          case \"initialPlacement\":\n            n5 = c5;\n        }\n      if (r5 !== n5)\n        return { reset: { placement: n5 } };\n    }\n    return {};\n  } };\n};\nfunction A3(t5, e5) {\n  return { top: t5.top - e5.height, right: t5.right - e5.width, bottom: t5.bottom - e5.height, left: t5.left - e5.width };\n}\nfunction R4(t5) {\n  return g3.some((e5) => t5[e5] >= 0);\n}\nvar P = function(t5) {\n  return void 0 === t5 && (t5 = {}), { name: \"hide\", options: t5, async fn(e5) {\n    const { strategy: n5 = \"referenceHidden\", ...o5 } = t5, { rects: i4 } = e5;\n    switch (n5) {\n      case \"referenceHidden\": {\n        const t6 = A3(await s(e5, { ...o5, elementContext: \"reference\" }), i4.reference);\n        return { data: { referenceHiddenOffsets: t6, referenceHidden: R4(t6) } };\n      }\n      case \"escaped\": {\n        const t6 = A3(await s(e5, { ...o5, altBoundary: true }), i4.floating);\n        return { data: { escapedOffsets: t6, escaped: R4(t6) } };\n      }\n      default:\n        return {};\n    }\n  } };\n};\nvar D3 = function(e5) {\n  return void 0 === e5 && (e5 = 0), { name: \"offset\", options: e5, async fn(i4) {\n    const { x: r5, y: a7 } = i4, l7 = await async function(e6, i5) {\n      const { placement: r6, platform: a8, elements: l8 } = e6, s5 = await (null == a8.isRTL ? void 0 : a8.isRTL(l8.floating)), c5 = n(r6), f5 = t2(r6), m6 = \"x\" === o(r6), u5 = [\"left\", \"top\"].includes(c5) ? -1 : 1, g6 = s5 && m6 ? -1 : 1, d6 = \"function\" == typeof i5 ? i5(e6) : i5;\n      let { mainAxis: p6, crossAxis: h6, alignmentAxis: y6 } = \"number\" == typeof d6 ? { mainAxis: d6, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...d6 };\n      return f5 && \"number\" == typeof y6 && (h6 = \"end\" === f5 ? -1 * y6 : y6), m6 ? { x: h6 * g6, y: p6 * u5 } : { x: p6 * u5, y: h6 * g6 };\n    }(i4, e5);\n    return { x: r5 + l7.x, y: a7 + l7.y, data: l7 };\n  } };\n};\nfunction L2(t5) {\n  return \"x\" === t5 ? \"y\" : \"x\";\n}\nvar k3 = function(t5) {\n  return void 0 === t5 && (t5 = {}), { name: \"shift\", options: t5, async fn(e5) {\n    const { x: i4, y: r5, placement: a7 } = e5, { mainAxis: l7 = true, crossAxis: c5 = false, limiter: f5 = { fn: (t6) => {\n      let { x: e6, y: n5 } = t6;\n      return { x: e6, y: n5 };\n    } }, ...u5 } = t5, g6 = { x: i4, y: r5 }, d6 = await s(e5, u5), p6 = o(n(a7)), h6 = L2(p6);\n    let y6 = g6[p6], x5 = g6[h6];\n    if (l7) {\n      const t6 = \"y\" === p6 ? \"bottom\" : \"right\";\n      y6 = m2(y6 + d6[\"y\" === p6 ? \"top\" : \"left\"], y6, y6 - d6[t6]);\n    }\n    if (c5) {\n      const t6 = \"y\" === h6 ? \"bottom\" : \"right\";\n      x5 = m2(x5 + d6[\"y\" === h6 ? \"top\" : \"left\"], x5, x5 - d6[t6]);\n    }\n    const w7 = f5.fn({ ...e5, [p6]: y6, [h6]: x5 });\n    return { ...w7, data: { x: w7.x - i4, y: w7.y - r5 } };\n  } };\n};\nvar O3 = function(t5) {\n  return void 0 === t5 && (t5 = {}), { options: t5, fn(e5) {\n    const { x: i4, y: r5, placement: a7, rects: l7, middlewareData: s5 } = e5, { offset: c5 = 0, mainAxis: f5 = true, crossAxis: m6 = true } = t5, u5 = { x: i4, y: r5 }, g6 = o(a7), d6 = L2(g6);\n    let p6 = u5[g6], h6 = u5[d6];\n    const y6 = \"function\" == typeof c5 ? c5(e5) : c5, x5 = \"number\" == typeof y6 ? { mainAxis: y6, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...y6 };\n    if (f5) {\n      const t6 = \"y\" === g6 ? \"height\" : \"width\", e6 = l7.reference[g6] - l7.floating[t6] + x5.mainAxis, n5 = l7.reference[g6] + l7.reference[t6] - x5.mainAxis;\n      p6 < e6 ? p6 = e6 : p6 > n5 && (p6 = n5);\n    }\n    if (m6) {\n      var w7, v6;\n      const t6 = \"y\" === g6 ? \"width\" : \"height\", e6 = [\"top\", \"left\"].includes(n(a7)), o5 = l7.reference[d6] - l7.floating[t6] + (e6 && (null == (w7 = s5.offset) ? void 0 : w7[d6]) || 0) + (e6 ? 0 : x5.crossAxis), i5 = l7.reference[d6] + l7.reference[t6] + (e6 ? 0 : (null == (v6 = s5.offset) ? void 0 : v6[d6]) || 0) - (e6 ? x5.crossAxis : 0);\n      h6 < o5 ? h6 = o5 : h6 > i5 && (h6 = i5);\n    }\n    return { [g6]: p6, [d6]: h6 };\n  } };\n};\nvar B3 = function(e5) {\n  return void 0 === e5 && (e5 = {}), { name: \"size\", options: e5, async fn(i4) {\n    const { placement: r5, rects: a7, platform: l7, elements: m6 } = i4, { apply: u5 = () => {\n    }, ...g6 } = e5, d6 = await s(i4, g6), p6 = n(r5), h6 = t2(r5), y6 = \"x\" === o(r5), { width: x5, height: w7 } = a7.floating;\n    let v6, b6;\n    \"top\" === p6 || \"bottom\" === p6 ? (v6 = p6, b6 = h6 === (await (null == l7.isRTL ? void 0 : l7.isRTL(m6.floating)) ? \"start\" : \"end\") ? \"left\" : \"right\") : (b6 = p6, v6 = \"end\" === h6 ? \"top\" : \"bottom\");\n    const A6 = w7 - d6[v6], R7 = x5 - d6[b6], P5 = !i4.middlewareData.shift;\n    let E5 = A6, T5 = R7;\n    if (y6) {\n      const t5 = x5 - d6.left - d6.right;\n      T5 = h6 || P5 ? c(R7, t5) : t5;\n    } else {\n      const t5 = w7 - d6.top - d6.bottom;\n      E5 = h6 || P5 ? c(A6, t5) : t5;\n    }\n    if (P5 && !h6) {\n      const t5 = f(d6.left, 0), e6 = f(d6.right, 0), n5 = f(d6.top, 0), o5 = f(d6.bottom, 0);\n      y6 ? T5 = x5 - 2 * (0 !== t5 || 0 !== e6 ? t5 + e6 : f(d6.left, d6.right)) : E5 = w7 - 2 * (0 !== n5 || 0 !== o5 ? n5 + o5 : f(d6.top, d6.bottom));\n    }\n    await u5({ ...i4, availableWidth: T5, availableHeight: E5 });\n    const D6 = await l7.getDimensions(m6.floating);\n    return x5 !== D6.width || w7 !== D6.height ? { reset: { rects: true } } : {};\n  } };\n};\n\n// node_modules/.pnpm/@floating-ui+dom@1.2.8/node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.min.mjs\nfunction n2(t5) {\n  var e5;\n  return (null == (e5 = t5.ownerDocument) ? void 0 : e5.defaultView) || window;\n}\nfunction o2(t5) {\n  return n2(t5).getComputedStyle(t5);\n}\nfunction i2(t5) {\n  return t5 instanceof n2(t5).Node;\n}\nfunction r2(t5) {\n  return i2(t5) ? (t5.nodeName || \"\").toLowerCase() : \"\";\n}\nvar l4;\nfunction c2() {\n  if (l4)\n    return l4;\n  const t5 = navigator.userAgentData;\n  return t5 && Array.isArray(t5.brands) ? (l4 = t5.brands.map((t6) => t6.brand + \"/\" + t6.version).join(\" \"), l4) : navigator.userAgent;\n}\nfunction s2(t5) {\n  return t5 instanceof n2(t5).HTMLElement;\n}\nfunction f2(t5) {\n  return t5 instanceof n2(t5).Element;\n}\nfunction u2(t5) {\n  if (\"undefined\" == typeof ShadowRoot)\n    return false;\n  return t5 instanceof n2(t5).ShadowRoot || t5 instanceof ShadowRoot;\n}\nfunction a4(t5) {\n  const { overflow: e5, overflowX: n5, overflowY: i4, display: r5 } = o2(t5);\n  return /auto|scroll|overlay|hidden|clip/.test(e5 + i4 + n5) && ![\"inline\", \"contents\"].includes(r5);\n}\nfunction d3(t5) {\n  return [\"table\", \"td\", \"th\"].includes(r2(t5));\n}\nfunction h3(t5) {\n  const e5 = /firefox/i.test(c2()), n5 = o2(t5), i4 = n5.backdropFilter || n5.WebkitBackdropFilter;\n  return \"none\" !== n5.transform || \"none\" !== n5.perspective || !!i4 && \"none\" !== i4 || e5 && \"filter\" === n5.willChange || e5 && !!n5.filter && \"none\" !== n5.filter || [\"transform\", \"perspective\"].some((t6) => n5.willChange.includes(t6)) || [\"paint\", \"layout\", \"strict\", \"content\"].some((t6) => {\n    const e6 = n5.contain;\n    return null != e6 && e6.includes(t6);\n  });\n}\nfunction p3() {\n  return /^((?!chrome|android).)*safari/i.test(c2());\n}\nfunction g4(t5) {\n  return [\"html\", \"body\", \"#document\"].includes(r2(t5));\n}\nvar m3 = Math.min;\nvar y3 = Math.max;\nvar x3 = Math.round;\nfunction w4(t5) {\n  const e5 = o2(t5);\n  let n5 = parseFloat(e5.width) || 0, i4 = parseFloat(e5.height) || 0;\n  const r5 = s2(t5), l7 = r5 ? t5.offsetWidth : n5, c5 = r5 ? t5.offsetHeight : i4, f5 = x3(n5) !== l7 || x3(i4) !== c5;\n  return f5 && (n5 = l7, i4 = c5), { width: n5, height: i4, fallback: f5 };\n}\nfunction v3(t5) {\n  return f2(t5) ? t5 : t5.contextElement;\n}\nvar b3 = { x: 1, y: 1 };\nfunction L3(t5) {\n  const e5 = v3(t5);\n  if (!s2(e5))\n    return b3;\n  const n5 = e5.getBoundingClientRect(), { width: o5, height: i4, fallback: r5 } = w4(e5);\n  let l7 = (r5 ? x3(n5.width) : n5.width) / o5, c5 = (r5 ? x3(n5.height) : n5.height) / i4;\n  return l7 && Number.isFinite(l7) || (l7 = 1), c5 && Number.isFinite(c5) || (c5 = 1), { x: l7, y: c5 };\n}\nfunction E3(e5, o5, i4, r5) {\n  var l7, c5;\n  void 0 === o5 && (o5 = false), void 0 === i4 && (i4 = false);\n  const s5 = e5.getBoundingClientRect(), u5 = v3(e5);\n  let a7 = b3;\n  o5 && (r5 ? f2(r5) && (a7 = L3(r5)) : a7 = L3(e5));\n  const d6 = u5 ? n2(u5) : window, h6 = p3() && i4;\n  let g6 = (s5.left + (h6 && (null == (l7 = d6.visualViewport) ? void 0 : l7.offsetLeft) || 0)) / a7.x, m6 = (s5.top + (h6 && (null == (c5 = d6.visualViewport) ? void 0 : c5.offsetTop) || 0)) / a7.y, y6 = s5.width / a7.x, x5 = s5.height / a7.y;\n  if (u5) {\n    const t5 = n2(u5), e6 = r5 && f2(r5) ? n2(r5) : r5;\n    let o6 = t5.frameElement;\n    for (; o6 && r5 && e6 !== t5; ) {\n      const t6 = L3(o6), e7 = o6.getBoundingClientRect(), i5 = getComputedStyle(o6);\n      e7.x += (o6.clientLeft + parseFloat(i5.paddingLeft)) * t6.x, e7.y += (o6.clientTop + parseFloat(i5.paddingTop)) * t6.y, g6 *= t6.x, m6 *= t6.y, y6 *= t6.x, x5 *= t6.y, g6 += e7.x, m6 += e7.y, o6 = n2(o6).frameElement;\n    }\n  }\n  return l3({ width: y6, height: x5, x: g6, y: m6 });\n}\nfunction T3(t5) {\n  return ((i2(t5) ? t5.ownerDocument : t5.document) || window.document).documentElement;\n}\nfunction R5(t5) {\n  return f2(t5) ? { scrollLeft: t5.scrollLeft, scrollTop: t5.scrollTop } : { scrollLeft: t5.pageXOffset, scrollTop: t5.pageYOffset };\n}\nfunction C4(t5) {\n  return E3(T3(t5)).left + R5(t5).scrollLeft;\n}\nfunction F3(t5) {\n  if (\"html\" === r2(t5))\n    return t5;\n  const e5 = t5.assignedSlot || t5.parentNode || u2(t5) && t5.host || T3(t5);\n  return u2(e5) ? e5.host : e5;\n}\nfunction S2(t5) {\n  const e5 = F3(t5);\n  return g4(e5) ? e5.ownerDocument.body : s2(e5) && a4(e5) ? e5 : S2(e5);\n}\nfunction W3(t5, e5) {\n  var o5;\n  void 0 === e5 && (e5 = []);\n  const i4 = S2(t5), r5 = i4 === (null == (o5 = t5.ownerDocument) ? void 0 : o5.body), l7 = n2(i4);\n  return r5 ? e5.concat(l7, l7.visualViewport || [], a4(i4) ? i4 : []) : e5.concat(i4, W3(i4));\n}\nfunction D4(e5, i4, r5) {\n  let l7;\n  if (\"viewport\" === i4)\n    l7 = function(t5, e6) {\n      const o5 = n2(t5), i5 = T3(t5), r6 = o5.visualViewport;\n      let l8 = i5.clientWidth, c6 = i5.clientHeight, s5 = 0, f5 = 0;\n      if (r6) {\n        l8 = r6.width, c6 = r6.height;\n        const t6 = p3();\n        (!t6 || t6 && \"fixed\" === e6) && (s5 = r6.offsetLeft, f5 = r6.offsetTop);\n      }\n      return { width: l8, height: c6, x: s5, y: f5 };\n    }(e5, r5);\n  else if (\"document\" === i4)\n    l7 = function(t5) {\n      const e6 = T3(t5), n5 = R5(t5), i5 = t5.ownerDocument.body, r6 = y3(e6.scrollWidth, e6.clientWidth, i5.scrollWidth, i5.clientWidth), l8 = y3(e6.scrollHeight, e6.clientHeight, i5.scrollHeight, i5.clientHeight);\n      let c6 = -n5.scrollLeft + C4(t5);\n      const s5 = -n5.scrollTop;\n      return \"rtl\" === o2(i5).direction && (c6 += y3(e6.clientWidth, i5.clientWidth) - r6), { width: r6, height: l8, x: c6, y: s5 };\n    }(T3(e5));\n  else if (f2(i4))\n    l7 = function(t5, e6) {\n      const n5 = E3(t5, true, \"fixed\" === e6), o5 = n5.top + t5.clientTop, i5 = n5.left + t5.clientLeft, r6 = s2(t5) ? L3(t5) : { x: 1, y: 1 };\n      return { width: t5.clientWidth * r6.x, height: t5.clientHeight * r6.y, x: i5 * r6.x, y: o5 * r6.y };\n    }(i4, r5);\n  else {\n    const t5 = { ...i4 };\n    if (p3()) {\n      var c5, u5;\n      const o5 = n2(e5);\n      t5.x -= (null == (c5 = o5.visualViewport) ? void 0 : c5.offsetLeft) || 0, t5.y -= (null == (u5 = o5.visualViewport) ? void 0 : u5.offsetTop) || 0;\n    }\n    l7 = t5;\n  }\n  return l3(l7);\n}\nfunction V5(t5, e5) {\n  const n5 = F3(t5);\n  return !(n5 === e5 || !f2(n5) || g4(n5)) && (\"fixed\" === o2(n5).position || V5(n5, e5));\n}\nfunction A4(t5, e5) {\n  return s2(t5) && \"fixed\" !== o2(t5).position ? e5 ? e5(t5) : t5.offsetParent : null;\n}\nfunction H3(t5, e5) {\n  const i4 = n2(t5);\n  if (!s2(t5))\n    return i4;\n  let l7 = A4(t5, e5);\n  for (; l7 && d3(l7) && \"static\" === o2(l7).position; )\n    l7 = A4(l7, e5);\n  return l7 && (\"html\" === r2(l7) || \"body\" === r2(l7) && \"static\" === o2(l7).position && !h3(l7)) ? i4 : l7 || function(t6) {\n    let e6 = F3(t6);\n    for (; s2(e6) && !g4(e6); ) {\n      if (h3(e6))\n        return e6;\n      e6 = F3(e6);\n    }\n    return null;\n  }(t5) || i4;\n}\nfunction O4(t5, e5, n5) {\n  const o5 = s2(e5), i4 = T3(e5), l7 = E3(t5, true, \"fixed\" === n5, e5);\n  let c5 = { scrollLeft: 0, scrollTop: 0 };\n  const f5 = { x: 0, y: 0 };\n  if (o5 || !o5 && \"fixed\" !== n5)\n    if ((\"body\" !== r2(e5) || a4(i4)) && (c5 = R5(e5)), s2(e5)) {\n      const t6 = E3(e5, true);\n      f5.x = t6.x + e5.clientLeft, f5.y = t6.y + e5.clientTop;\n    } else\n      i4 && (f5.x = C4(i4));\n  return { x: l7.left + c5.scrollLeft - f5.x, y: l7.top + c5.scrollTop - f5.y, width: l7.width, height: l7.height };\n}\nvar P2 = { getClippingRect: function(t5) {\n  let { element: e5, boundary: n5, rootBoundary: i4, strategy: l7 } = t5;\n  const c5 = \"clippingAncestors\" === n5 ? function(t6, e6) {\n    const n6 = e6.get(t6);\n    if (n6)\n      return n6;\n    let i5 = W3(t6).filter((t7) => f2(t7) && \"body\" !== r2(t7)), l8 = null;\n    const c6 = \"fixed\" === o2(t6).position;\n    let s6 = c6 ? F3(t6) : t6;\n    for (; f2(s6) && !g4(s6); ) {\n      const e7 = o2(s6), n7 = h3(s6);\n      n7 || \"fixed\" !== e7.position || (l8 = null), (c6 ? !n7 && !l8 : !n7 && \"static\" === e7.position && l8 && [\"absolute\", \"fixed\"].includes(l8.position) || a4(s6) && !n7 && V5(t6, s6)) ? i5 = i5.filter((t7) => t7 !== s6) : l8 = e7, s6 = F3(s6);\n    }\n    return e6.set(t6, i5), i5;\n  }(e5, this._c) : [].concat(n5), s5 = [...c5, i4], u5 = s5[0], d6 = s5.reduce((t6, n6) => {\n    const o5 = D4(e5, n6, l7);\n    return t6.top = y3(o5.top, t6.top), t6.right = m3(o5.right, t6.right), t6.bottom = m3(o5.bottom, t6.bottom), t6.left = y3(o5.left, t6.left), t6;\n  }, D4(e5, u5, l7));\n  return { width: d6.right - d6.left, height: d6.bottom - d6.top, x: d6.left, y: d6.top };\n}, convertOffsetParentRelativeRectToViewportRelativeRect: function(t5) {\n  let { rect: e5, offsetParent: n5, strategy: o5 } = t5;\n  const i4 = s2(n5), l7 = T3(n5);\n  if (n5 === l7)\n    return e5;\n  let c5 = { scrollLeft: 0, scrollTop: 0 }, f5 = { x: 1, y: 1 };\n  const u5 = { x: 0, y: 0 };\n  if ((i4 || !i4 && \"fixed\" !== o5) && ((\"body\" !== r2(n5) || a4(l7)) && (c5 = R5(n5)), s2(n5))) {\n    const t6 = E3(n5);\n    f5 = L3(n5), u5.x = t6.x + n5.clientLeft, u5.y = t6.y + n5.clientTop;\n  }\n  return { width: e5.width * f5.x, height: e5.height * f5.y, x: e5.x * f5.x - c5.scrollLeft * f5.x + u5.x, y: e5.y * f5.y - c5.scrollTop * f5.y + u5.y };\n}, isElement: f2, getDimensions: function(t5) {\n  return w4(t5);\n}, getOffsetParent: H3, getDocumentElement: T3, getScale: L3, async getElementRects(t5) {\n  let { reference: e5, floating: n5, strategy: o5 } = t5;\n  const i4 = this.getOffsetParent || H3, r5 = this.getDimensions;\n  return { reference: O4(e5, await i4(n5), o5), floating: { x: 0, y: 0, ...await r5(n5) } };\n}, getClientRects: (t5) => Array.from(t5.getClientRects()), isRTL: (t5) => \"rtl\" === o2(t5).direction };\nfunction z3(t5, e5, n5, o5) {\n  void 0 === o5 && (o5 = {});\n  const { ancestorScroll: i4 = true, ancestorResize: r5 = true, elementResize: l7 = true, animationFrame: c5 = false } = o5, s5 = i4 || r5 ? [...f2(t5) ? W3(t5) : t5.contextElement ? W3(t5.contextElement) : [], ...W3(e5)] : [];\n  s5.forEach((t6) => {\n    const e6 = !f2(t6) && t6.toString().includes(\"V\");\n    !i4 || c5 && !e6 || t6.addEventListener(\"scroll\", n5, { passive: true }), r5 && t6.addEventListener(\"resize\", n5);\n  });\n  let u5, a7 = null;\n  l7 && (a7 = new ResizeObserver(() => {\n    n5();\n  }), f2(t5) && !c5 && a7.observe(t5), f2(t5) || !t5.contextElement || c5 || a7.observe(t5.contextElement), a7.observe(e5));\n  let d6 = c5 ? E3(t5) : null;\n  return c5 && function e6() {\n    const o6 = E3(t5);\n    !d6 || o6.x === d6.x && o6.y === d6.y && o6.width === d6.width && o6.height === d6.height || n5();\n    d6 = o6, u5 = requestAnimationFrame(e6);\n  }(), n5(), () => {\n    var t6;\n    s5.forEach((t7) => {\n      i4 && t7.removeEventListener(\"scroll\", n5), r5 && t7.removeEventListener(\"resize\", n5);\n    }), null == (t6 = a7) || t6.disconnect(), a7 = null, c5 && cancelAnimationFrame(u5);\n  };\n}\nvar k4 = (t5, n5, o5) => {\n  const i4 = /* @__PURE__ */ new Map(), r5 = { platform: P2, ...o5 }, l7 = { ...r5.platform, _c: i4 };\n  return r(t5, n5, { ...r5, platform: l7 });\n};\n\n// node_modules/.pnpm/@floating-ui+react-dom@2.0.0_react-dom@18.2.0_react@18.2.0/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js\nvar React2 = __toESM(require(\"react\"));\nvar import_react19 = require(\"react\");\nvar ReactDOM = __toESM(require(\"react-dom\"));\nvar arrow = (options) => {\n  const {\n    element,\n    padding\n  } = options;\n  function isRef(value) {\n    return {}.hasOwnProperty.call(value, \"current\");\n  }\n  return {\n    name: \"arrow\",\n    options,\n    fn(args) {\n      if (element && isRef(element)) {\n        if (element.current != null) {\n          return u({\n            element: element.current,\n            padding\n          }).fn(args);\n        }\n        return {};\n      } else if (element) {\n        return u({\n          element,\n          padding\n        }).fn(args);\n      }\n      return {};\n    }\n  };\n};\nvar index = typeof document !== \"undefined\" ? import_react19.useLayoutEffect : import_react19.useEffect;\nfunction deepEqual(a7, b6) {\n  if (a7 === b6) {\n    return true;\n  }\n  if (typeof a7 !== typeof b6) {\n    return false;\n  }\n  if (typeof a7 === \"function\" && a7.toString() === b6.toString()) {\n    return true;\n  }\n  let length, i4, keys;\n  if (a7 && b6 && typeof a7 == \"object\") {\n    if (Array.isArray(a7)) {\n      length = a7.length;\n      if (length != b6.length)\n        return false;\n      for (i4 = length; i4-- !== 0; ) {\n        if (!deepEqual(a7[i4], b6[i4])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a7);\n    length = keys.length;\n    if (length !== Object.keys(b6).length) {\n      return false;\n    }\n    for (i4 = length; i4-- !== 0; ) {\n      if (!{}.hasOwnProperty.call(b6, keys[i4])) {\n        return false;\n      }\n    }\n    for (i4 = length; i4-- !== 0; ) {\n      const key = keys[i4];\n      if (key === \"_owner\" && a7.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a7[key], b6[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a7 !== a7 && b6 !== b6;\n}\nfunction getDPR(element) {\n  if (typeof window === \"undefined\") {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\nfunction useLatestRef(value) {\n  const ref = React2.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = \"bottom\",\n    strategy = \"absolute\",\n    middleware = [],\n    platform,\n    elements: {\n      reference: externalReference,\n      floating: externalFloating\n    } = {},\n    transform = true,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = React2.useState({\n    x: 0,\n    y: 0,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = React2.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const [_reference, _setReference] = React2.useState(null);\n  const [_floating, _setFloating] = React2.useState(null);\n  const setReference = React2.useCallback((node) => {\n    if (node != referenceRef.current) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, [_setReference]);\n  const setFloating = React2.useCallback((node) => {\n    if (node !== floatingRef.current) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, [_setFloating]);\n  const referenceEl = externalReference || _reference;\n  const floatingEl = externalFloating || _floating;\n  const referenceRef = React2.useRef(null);\n  const floatingRef = React2.useRef(null);\n  const dataRef = React2.useRef(data);\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform);\n  const update = React2.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    k4(referenceRef.current, floatingRef.current, config).then((data2) => {\n      const fullData = {\n        ...data2,\n        isPositioned: true\n      };\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        ReactDOM.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData((data2) => ({\n        ...data2,\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = React2.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  index(() => {\n    if (referenceEl)\n      referenceRef.current = referenceEl;\n    if (floatingEl)\n      floatingRef.current = floatingEl;\n    if (referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      } else {\n        update();\n      }\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef]);\n  const refs = React2.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = React2.useMemo(() => ({\n    reference: referenceEl,\n    floating: floatingEl\n  }), [referenceEl, floatingEl]);\n  const floatingStyles = React2.useMemo(() => {\n    const initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n    if (!elements.floating) {\n      return initialStyles;\n    }\n    const x5 = roundByDPR(elements.floating, data.x);\n    const y6 = roundByDPR(elements.floating, data.y);\n    if (transform) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + x5 + \"px, \" + y6 + \"px)\",\n        ...getDPR(elements.floating) >= 1.5 && {\n          willChange: \"transform\"\n        }\n      };\n    }\n    return {\n      position: strategy,\n      left: x5,\n      top: y6\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return React2.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    elements,\n    floatingStyles\n  }), [data, update, refs, elements, floatingStyles]);\n}\n\n// node_modules/.pnpm/@radix-ui+react-arrow@1.0.3_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-arrow/dist/index.mjs\nvar import_react20 = require(\"react\");\nvar $7e8f5cd07187803e$export$21b07c8f274aebd5 = /* @__PURE__ */ (0, import_react20.forwardRef)((props, forwardedRef) => {\n  const { children, width = 10, height = 5, ...arrowProps } = props;\n  return /* @__PURE__ */ (0, import_react20.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.svg, _extends({}, arrowProps, {\n    ref: forwardedRef,\n    width,\n    height,\n    viewBox: \"0 0 30 10\",\n    preserveAspectRatio: \"none\"\n  }), props.asChild ? children : /* @__PURE__ */ (0, import_react20.createElement)(\"polygon\", {\n    points: \"0,0 30,0 15,10\"\n  }));\n});\nvar $7e8f5cd07187803e$export$be92b6f5f03c0fe9 = $7e8f5cd07187803e$export$21b07c8f274aebd5;\n\n// node_modules/.pnpm/@radix-ui+react-use-size@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-use-size/dist/index.mjs\nvar import_react21 = require(\"react\");\nfunction $db6c3485150b8e66$export$1ab7ae714698c4b8(element) {\n  const [size, setSize] = (0, import_react21.useState)(void 0);\n  $9f79659886946c16$export$e5c5a5f917a5871c(() => {\n    if (element) {\n      setSize({\n        width: element.offsetWidth,\n        height: element.offsetHeight\n      });\n      const resizeObserver = new ResizeObserver((entries) => {\n        if (!Array.isArray(entries))\n          return;\n        if (!entries.length)\n          return;\n        const entry = entries[0];\n        let width;\n        let height;\n        if (\"borderBoxSize\" in entry) {\n          const borderSizeEntry = entry[\"borderBoxSize\"];\n          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;\n          width = borderSize[\"inlineSize\"];\n          height = borderSize[\"blockSize\"];\n        } else {\n          width = element.offsetWidth;\n          height = element.offsetHeight;\n        }\n        setSize({\n          width,\n          height\n        });\n      });\n      resizeObserver.observe(element, {\n        box: \"border-box\"\n      });\n      return () => resizeObserver.unobserve(element);\n    } else\n      setSize(void 0);\n  }, [\n    element\n  ]);\n  return size;\n}\n\n// node_modules/.pnpm/@radix-ui+react-popper@1.1.2_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-popper/dist/index.mjs\nvar $cf1ac5d9fe0e8206$var$POPPER_NAME = \"Popper\";\nvar [$cf1ac5d9fe0e8206$var$createPopperContext, $cf1ac5d9fe0e8206$export$722aac194ae923] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cf1ac5d9fe0e8206$var$POPPER_NAME);\nvar [$cf1ac5d9fe0e8206$var$PopperProvider, $cf1ac5d9fe0e8206$var$usePopperContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$POPPER_NAME);\nvar $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9 = (props) => {\n  const { __scopePopper, children } = props;\n  const [anchor, setAnchor] = (0, import_react22.useState)(null);\n  return /* @__PURE__ */ (0, import_react22.createElement)($cf1ac5d9fe0e8206$var$PopperProvider, {\n    scope: __scopePopper,\n    anchor,\n    onAnchorChange: setAnchor\n  }, children);\n};\nvar $cf1ac5d9fe0e8206$var$ANCHOR_NAME = \"PopperAnchor\";\nvar $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d = /* @__PURE__ */ (0, import_react22.forwardRef)((props, forwardedRef) => {\n  const { __scopePopper, virtualRef, ...anchorProps } = props;\n  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$ANCHOR_NAME, __scopePopper);\n  const ref = (0, import_react22.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);\n  (0, import_react22.useEffect)(() => {\n    context.onAnchorChange((virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current);\n  });\n  return virtualRef ? null : /* @__PURE__ */ (0, import_react22.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, anchorProps, {\n    ref: composedRefs\n  }));\n});\nvar $cf1ac5d9fe0e8206$var$CONTENT_NAME = \"PopperContent\";\nvar [$cf1ac5d9fe0e8206$var$PopperContentProvider, $cf1ac5d9fe0e8206$var$useContentContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME);\nvar $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc = /* @__PURE__ */ (0, import_react22.forwardRef)((props, forwardedRef) => {\n  var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$trans, _middlewareData$trans2, _middlewareData$hide;\n  const { __scopePopper, side = \"bottom\", sideOffset = 0, align = \"center\", alignOffset = 0, arrowPadding = 0, collisionBoundary = [], collisionPadding: collisionPaddingProp = 0, sticky = \"partial\", hideWhenDetached = false, avoidCollisions = true, onPlaced, ...contentProps } = props;\n  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);\n  const [content, setContent] = (0, import_react22.useState)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(\n    forwardedRef,\n    (node) => setContent(node)\n  );\n  const [arrow2, setArrow] = (0, import_react22.useState)(null);\n  const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow2);\n  const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;\n  const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;\n  const desiredPlacement = side + (align !== \"center\" ? \"-\" + align : \"\");\n  const collisionPadding = typeof collisionPaddingProp === \"number\" ? collisionPaddingProp : {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...collisionPaddingProp\n  };\n  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [\n    collisionBoundary\n  ];\n  const hasExplicitBoundaries = boundary.length > 0;\n  const detectOverflowOptions = {\n    padding: collisionPadding,\n    boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull),\n    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n    altBoundary: hasExplicitBoundaries\n  };\n  const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({\n    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues\n    strategy: \"fixed\",\n    placement: desiredPlacement,\n    whileElementsMounted: z3,\n    elements: {\n      reference: context.anchor\n    },\n    middleware: [\n      D3({\n        mainAxis: sideOffset + arrowHeight,\n        alignmentAxis: alignOffset\n      }),\n      avoidCollisions && k3({\n        mainAxis: true,\n        crossAxis: false,\n        limiter: sticky === \"partial\" ? O3() : void 0,\n        ...detectOverflowOptions\n      }),\n      avoidCollisions && b2({\n        ...detectOverflowOptions\n      }),\n      B3({\n        ...detectOverflowOptions,\n        apply: ({ elements, rects, availableWidth, availableHeight }) => {\n          const { width: anchorWidth, height: anchorHeight } = rects.reference;\n          const contentStyle = elements.floating.style;\n          contentStyle.setProperty(\"--radix-popper-available-width\", `${availableWidth}px`);\n          contentStyle.setProperty(\"--radix-popper-available-height\", `${availableHeight}px`);\n          contentStyle.setProperty(\"--radix-popper-anchor-width\", `${anchorWidth}px`);\n          contentStyle.setProperty(\"--radix-popper-anchor-height\", `${anchorHeight}px`);\n        }\n      }),\n      arrow2 && arrow({\n        element: arrow2,\n        padding: arrowPadding\n      }),\n      $cf1ac5d9fe0e8206$var$transformOrigin({\n        arrowWidth,\n        arrowHeight\n      }),\n      hideWhenDetached && P({\n        strategy: \"referenceHidden\"\n      })\n    ]\n  });\n  const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);\n  const handlePlaced = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPlaced);\n  $9f79659886946c16$export$e5c5a5f917a5871c(() => {\n    if (isPositioned)\n      handlePlaced === null || handlePlaced === void 0 || handlePlaced();\n  }, [\n    isPositioned,\n    handlePlaced\n  ]);\n  const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;\n  const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;\n  const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;\n  const [contentZIndex, setContentZIndex] = (0, import_react22.useState)();\n  $9f79659886946c16$export$e5c5a5f917a5871c(() => {\n    if (content)\n      setContentZIndex(window.getComputedStyle(content).zIndex);\n  }, [\n    content\n  ]);\n  return /* @__PURE__ */ (0, import_react22.createElement)(\"div\", {\n    ref: refs.setFloating,\n    \"data-radix-popper-content-wrapper\": \"\",\n    style: {\n      ...floatingStyles,\n      transform: isPositioned ? floatingStyles.transform : \"translate(0, -200%)\",\n      // keep off the page when measuring\n      minWidth: \"max-content\",\n      zIndex: contentZIndex,\n      [\"--radix-popper-transform-origin\"]: [\n        (_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x,\n        (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y\n      ].join(\" \")\n    },\n    dir: props.dir\n  }, /* @__PURE__ */ (0, import_react22.createElement)($cf1ac5d9fe0e8206$var$PopperContentProvider, {\n    scope: __scopePopper,\n    placedSide,\n    onArrowChange: setArrow,\n    arrowX,\n    arrowY,\n    shouldHideArrow: cannotCenterArrow\n  }, /* @__PURE__ */ (0, import_react22.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({\n    \"data-side\": placedSide,\n    \"data-align\": placedAlign\n  }, contentProps, {\n    ref: composedRefs,\n    style: {\n      ...contentProps.style,\n      // if the PopperContent hasn't been placed yet (not all measurements done)\n      // we prevent animations so that users's animation don't kick in too early referring wrong sides\n      animation: !isPositioned ? \"none\" : void 0,\n      // hide the content if using the hide middleware and should be hidden\n      opacity: (_middlewareData$hide = middlewareData.hide) !== null && _middlewareData$hide !== void 0 && _middlewareData$hide.referenceHidden ? 0 : void 0\n    }\n  }))));\n});\nvar $cf1ac5d9fe0e8206$var$ARROW_NAME = \"PopperArrow\";\nvar $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n};\nvar $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0 = /* @__PURE__ */ (0, import_react22.forwardRef)(function $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd02(props, forwardedRef) {\n  const { __scopePopper, ...arrowProps } = props;\n  const contentContext = $cf1ac5d9fe0e8206$var$useContentContext($cf1ac5d9fe0e8206$var$ARROW_NAME, __scopePopper);\n  const baseSide = $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE[contentContext.placedSide];\n  return (\n    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)\n    // doesn't report size as we'd expect on SVG elements.\n    // it reports their bounding box which is effectively the largest path inside the SVG.\n    /* @__PURE__ */ (0, import_react22.createElement)(\"span\", {\n      ref: contentContext.onArrowChange,\n      style: {\n        position: \"absolute\",\n        left: contentContext.arrowX,\n        top: contentContext.arrowY,\n        [baseSide]: 0,\n        transformOrigin: {\n          top: \"\",\n          right: \"0 0\",\n          bottom: \"center 0\",\n          left: \"100% 0\"\n        }[contentContext.placedSide],\n        transform: {\n          top: \"translateY(100%)\",\n          right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\n          bottom: `rotate(180deg)`,\n          left: \"translateY(50%) rotate(-90deg) translateX(50%)\"\n        }[contentContext.placedSide],\n        visibility: contentContext.shouldHideArrow ? \"hidden\" : void 0\n      }\n    }, /* @__PURE__ */ (0, import_react22.createElement)($7e8f5cd07187803e$export$be92b6f5f03c0fe9, _extends({}, arrowProps, {\n      ref: forwardedRef,\n      style: {\n        ...arrowProps.style,\n        // ensures the element can be measured correctly (mostly for if SVG)\n        display: \"block\"\n      }\n    })))\n  );\n});\nfunction $cf1ac5d9fe0e8206$var$isNotNull(value) {\n  return value !== null;\n}\nvar $cf1ac5d9fe0e8206$var$transformOrigin = (options) => ({\n  name: \"transformOrigin\",\n  options,\n  fn(data) {\n    var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;\n    const { placement, rects, middlewareData } = data;\n    const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;\n    const isArrowHidden = cannotCenterArrow;\n    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n    const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);\n    const noArrowAlign = {\n      start: \"0%\",\n      center: \"50%\",\n      end: \"100%\"\n    }[placedAlign];\n    const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;\n    const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;\n    let x5 = \"\";\n    let y6 = \"\";\n    if (placedSide === \"bottom\") {\n      x5 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y6 = `${-arrowHeight}px`;\n    } else if (placedSide === \"top\") {\n      x5 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y6 = `${rects.floating.height + arrowHeight}px`;\n    } else if (placedSide === \"right\") {\n      x5 = `${-arrowHeight}px`;\n      y6 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    } else if (placedSide === \"left\") {\n      x5 = `${rects.floating.width + arrowHeight}px`;\n      y6 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    }\n    return {\n      data: {\n        x: x5,\n        y: y6\n      }\n    };\n  }\n});\nfunction $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement) {\n  const [side, align = \"center\"] = placement.split(\"-\");\n  return [\n    side,\n    align\n  ];\n}\nvar $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9 = $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9;\nvar $cf1ac5d9fe0e8206$export$b688253958b8dfe7 = $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d;\nvar $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc;\nvar $cf1ac5d9fe0e8206$export$21b07c8f274aebd5 = $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0;\n\n// node_modules/.pnpm/@radix-ui+react-portal@1.0.3_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-portal/dist/index.mjs\nvar import_react23 = require(\"react\");\nvar import_react_dom3 = __toESM(require(\"react-dom\"), 1);\nvar $f1701beae083dbae$export$602eac185826482c = /* @__PURE__ */ (0, import_react23.forwardRef)((props, forwardedRef) => {\n  var _globalThis$document;\n  const { container = globalThis === null || globalThis === void 0 ? void 0 : (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.body, ...portalProps } = props;\n  return container ? /* @__PURE__ */ import_react_dom3.default.createPortal(/* @__PURE__ */ (0, import_react23.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, portalProps, {\n    ref: forwardedRef\n  })), container) : null;\n});\n\n// node_modules/.pnpm/@radix-ui+react-presence@1.0.1_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-presence/dist/index.mjs\nvar import_react24 = require(\"react\");\nvar import_react_dom4 = require(\"react-dom\");\nfunction $fe963b355347cc68$export$3e6543de14f8614f(initialState, machine) {\n  return (0, import_react24.useReducer)((state, event) => {\n    const nextState = machine[state][event];\n    return nextState !== null && nextState !== void 0 ? nextState : state;\n  }, initialState);\n}\nvar $921a889cee6df7e8$export$99c2b779aa4e8b8b = (props) => {\n  const { present, children } = props;\n  const presence = $921a889cee6df7e8$var$usePresence(present);\n  const child = typeof children === \"function\" ? children({\n    present: presence.isPresent\n  }) : import_react24.Children.only(children);\n  const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(presence.ref, child.ref);\n  const forceMount = typeof children === \"function\";\n  return forceMount || presence.isPresent ? /* @__PURE__ */ (0, import_react24.cloneElement)(child, {\n    ref\n  }) : null;\n};\n$921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = \"Presence\";\nfunction $921a889cee6df7e8$var$usePresence(present) {\n  const [node1, setNode] = (0, import_react24.useState)();\n  const stylesRef = (0, import_react24.useRef)({});\n  const prevPresentRef = (0, import_react24.useRef)(present);\n  const prevAnimationNameRef = (0, import_react24.useRef)(\"none\");\n  const initialState = present ? \"mounted\" : \"unmounted\";\n  const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f(initialState, {\n    mounted: {\n      UNMOUNT: \"unmounted\",\n      ANIMATION_OUT: \"unmountSuspended\"\n    },\n    unmountSuspended: {\n      MOUNT: \"mounted\",\n      ANIMATION_END: \"unmounted\"\n    },\n    unmounted: {\n      MOUNT: \"mounted\"\n    }\n  });\n  (0, import_react24.useEffect)(() => {\n    const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === \"mounted\" ? currentAnimationName : \"none\";\n  }, [\n    state\n  ]);\n  $9f79659886946c16$export$e5c5a5f917a5871c(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(styles);\n      if (present)\n        send(\"MOUNT\");\n      else if (currentAnimationName === \"none\" || (styles === null || styles === void 0 ? void 0 : styles.display) === \"none\")\n        send(\"UNMOUNT\");\n      else {\n        const isAnimating = prevAnimationName !== currentAnimationName;\n        if (wasPresent && isAnimating)\n          send(\"ANIMATION_OUT\");\n        else\n          send(\"UNMOUNT\");\n      }\n      prevPresentRef.current = present;\n    }\n  }, [\n    present,\n    send\n  ]);\n  $9f79659886946c16$export$e5c5a5f917a5871c(() => {\n    if (node1) {\n      const handleAnimationEnd = (event) => {\n        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node1 && isCurrentAnimation)\n          (0, import_react_dom4.flushSync)(\n            () => send(\"ANIMATION_END\")\n          );\n      };\n      const handleAnimationStart = (event) => {\n        if (event.target === node1)\n          prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);\n      };\n      node1.addEventListener(\"animationstart\", handleAnimationStart);\n      node1.addEventListener(\"animationcancel\", handleAnimationEnd);\n      node1.addEventListener(\"animationend\", handleAnimationEnd);\n      return () => {\n        node1.removeEventListener(\"animationstart\", handleAnimationStart);\n        node1.removeEventListener(\"animationcancel\", handleAnimationEnd);\n        node1.removeEventListener(\"animationend\", handleAnimationEnd);\n      };\n    } else\n      send(\"ANIMATION_END\");\n  }, [\n    node1,\n    send\n  ]);\n  return {\n    isPresent: [\n      \"mounted\",\n      \"unmountSuspended\"\n    ].includes(state),\n    ref: (0, import_react24.useCallback)((node) => {\n      if (node)\n        stylesRef.current = getComputedStyle(node);\n      setNode(node);\n    }, [])\n  };\n}\nfunction $921a889cee6df7e8$var$getAnimationName(styles) {\n  return (styles === null || styles === void 0 ? void 0 : styles.animationName) || \"none\";\n}\n\n// node_modules/.pnpm/@radix-ui+react-roving-focus@1.0.4_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-roving-focus/dist/index.mjs\nvar import_react26 = require(\"react\");\n\n// node_modules/.pnpm/@radix-ui+react-use-controllable-state@1.0.1_@types+react@18.2.7_react@18.2.0/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs\nvar import_react25 = require(\"react\");\nfunction $71cd76cc60e0454e$export$6f32135080cb4c3({ prop, defaultProp, onChange = () => {\n} }) {\n  const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState({\n    defaultProp,\n    onChange\n  });\n  const isControlled = prop !== void 0;\n  const value1 = isControlled ? prop : uncontrolledProp;\n  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);\n  const setValue = (0, import_react25.useCallback)((nextValue) => {\n    if (isControlled) {\n      const setter = nextValue;\n      const value = typeof nextValue === \"function\" ? setter(prop) : nextValue;\n      if (value !== prop)\n        handleChange(value);\n    } else\n      setUncontrolledProp(nextValue);\n  }, [\n    isControlled,\n    prop,\n    setUncontrolledProp,\n    handleChange\n  ]);\n  return [\n    value1,\n    setValue\n  ];\n}\nfunction $71cd76cc60e0454e$var$useUncontrolledState({ defaultProp, onChange }) {\n  const uncontrolledState = (0, import_react25.useState)(defaultProp);\n  const [value] = uncontrolledState;\n  const prevValueRef = (0, import_react25.useRef)(value);\n  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);\n  (0, import_react25.useEffect)(() => {\n    if (prevValueRef.current !== value) {\n      handleChange(value);\n      prevValueRef.current = value;\n    }\n  }, [\n    value,\n    prevValueRef,\n    handleChange\n  ]);\n  return uncontrolledState;\n}\n\n// node_modules/.pnpm/@radix-ui+react-roving-focus@1.0.4_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-roving-focus/dist/index.mjs\nvar $d7bdfb9eb0fdf311$var$ENTRY_FOCUS = \"rovingFocusGroup.onEntryFocus\";\nvar $d7bdfb9eb0fdf311$var$EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\nvar $d7bdfb9eb0fdf311$var$GROUP_NAME = \"RovingFocusGroup\";\nvar [$d7bdfb9eb0fdf311$var$Collection, $d7bdfb9eb0fdf311$var$useCollection, $d7bdfb9eb0fdf311$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($d7bdfb9eb0fdf311$var$GROUP_NAME);\nvar [$d7bdfb9eb0fdf311$var$createRovingFocusGroupContext, $d7bdfb9eb0fdf311$export$c7109489551a4f4] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d7bdfb9eb0fdf311$var$GROUP_NAME, [\n  $d7bdfb9eb0fdf311$var$createCollectionScope\n]);\nvar [$d7bdfb9eb0fdf311$var$RovingFocusProvider, $d7bdfb9eb0fdf311$var$useRovingFocusContext] = $d7bdfb9eb0fdf311$var$createRovingFocusGroupContext($d7bdfb9eb0fdf311$var$GROUP_NAME);\nvar $d7bdfb9eb0fdf311$export$8699f7c8af148338 = /* @__PURE__ */ (0, import_react26.forwardRef)((props, forwardedRef) => {\n  return /* @__PURE__ */ (0, import_react26.createElement)($d7bdfb9eb0fdf311$var$Collection.Provider, {\n    scope: props.__scopeRovingFocusGroup\n  }, /* @__PURE__ */ (0, import_react26.createElement)($d7bdfb9eb0fdf311$var$Collection.Slot, {\n    scope: props.__scopeRovingFocusGroup\n  }, /* @__PURE__ */ (0, import_react26.createElement)($d7bdfb9eb0fdf311$var$RovingFocusGroupImpl, _extends({}, props, {\n    ref: forwardedRef\n  }))));\n});\nvar $d7bdfb9eb0fdf311$var$RovingFocusGroupImpl = /* @__PURE__ */ (0, import_react26.forwardRef)((props, forwardedRef) => {\n  const { __scopeRovingFocusGroup, orientation, loop = false, dir, currentTabStopId: currentTabStopIdProp, defaultCurrentTabStopId, onCurrentTabStopIdChange, onEntryFocus, ...groupProps } = props;\n  const ref = (0, import_react26.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);\n  const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);\n  const [currentTabStopId = null, setCurrentTabStopId] = $71cd76cc60e0454e$export$6f32135080cb4c3({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId,\n    onChange: onCurrentTabStopIdChange\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = (0, import_react26.useState)(false);\n  const handleEntryFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEntryFocus);\n  const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = (0, import_react26.useRef)(false);\n  const [focusableItemsCount, setFocusableItemsCount] = (0, import_react26.useState)(0);\n  (0, import_react26.useEffect)(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [\n    handleEntryFocus\n  ]);\n  return /* @__PURE__ */ (0, import_react26.createElement)($d7bdfb9eb0fdf311$var$RovingFocusProvider, {\n    scope: __scopeRovingFocusGroup,\n    orientation,\n    dir: direction,\n    loop,\n    currentTabStopId,\n    onItemFocus: (0, import_react26.useCallback)(\n      (tabStopId) => setCurrentTabStopId(tabStopId),\n      [\n        setCurrentTabStopId\n      ]\n    ),\n    onItemShiftTab: (0, import_react26.useCallback)(\n      () => setIsTabbingBackOut(true),\n      []\n    ),\n    onFocusableItemAdd: (0, import_react26.useCallback)(\n      () => setFocusableItemsCount(\n        (prevCount) => prevCount + 1\n      ),\n      []\n    ),\n    onFocusableItemRemove: (0, import_react26.useCallback)(\n      () => setFocusableItemsCount(\n        (prevCount) => prevCount - 1\n      ),\n      []\n    )\n  }, /* @__PURE__ */ (0, import_react26.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({\n    tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,\n    \"data-orientation\": orientation\n  }, groupProps, {\n    ref: composedRefs,\n    style: {\n      outline: \"none\",\n      ...props.style\n    },\n    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, () => {\n      isClickFocusRef.current = true;\n    }),\n    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, (event) => {\n      const isKeyboardFocus = !isClickFocusRef.current;\n      if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n        const entryFocusEvent = new CustomEvent($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, $d7bdfb9eb0fdf311$var$EVENT_OPTIONS);\n        event.currentTarget.dispatchEvent(entryFocusEvent);\n        if (!entryFocusEvent.defaultPrevented) {\n          const items = getItems().filter(\n            (item) => item.focusable\n          );\n          const activeItem = items.find(\n            (item) => item.active\n          );\n          const currentItem = items.find(\n            (item) => item.id === currentTabStopId\n          );\n          const candidateItems = [\n            activeItem,\n            currentItem,\n            ...items\n          ].filter(Boolean);\n          const candidateNodes = candidateItems.map(\n            (item) => item.ref.current\n          );\n          $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes);\n        }\n      }\n      isClickFocusRef.current = false;\n    }),\n    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(\n      props.onBlur,\n      () => setIsTabbingBackOut(false)\n    )\n  })));\n});\nvar $d7bdfb9eb0fdf311$var$ITEM_NAME = \"RovingFocusGroupItem\";\nvar $d7bdfb9eb0fdf311$export$ab9df7c53fe8454 = /* @__PURE__ */ (0, import_react26.forwardRef)((props, forwardedRef) => {\n  const { __scopeRovingFocusGroup, focusable = true, active = false, tabStopId, ...itemProps } = props;\n  const autoId = $1746a345f3d73bb7$export$f680877a34711e37();\n  const id = tabStopId || autoId;\n  const context = $d7bdfb9eb0fdf311$var$useRovingFocusContext($d7bdfb9eb0fdf311$var$ITEM_NAME, __scopeRovingFocusGroup);\n  const isCurrentTabStop = context.currentTabStopId === id;\n  const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);\n  const { onFocusableItemAdd, onFocusableItemRemove } = context;\n  (0, import_react26.useEffect)(() => {\n    if (focusable) {\n      onFocusableItemAdd();\n      return () => onFocusableItemRemove();\n    }\n  }, [\n    focusable,\n    onFocusableItemAdd,\n    onFocusableItemRemove\n  ]);\n  return /* @__PURE__ */ (0, import_react26.createElement)($d7bdfb9eb0fdf311$var$Collection.ItemSlot, {\n    scope: __scopeRovingFocusGroup,\n    id,\n    focusable,\n    active\n  }, /* @__PURE__ */ (0, import_react26.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({\n    tabIndex: isCurrentTabStop ? 0 : -1,\n    \"data-orientation\": context.orientation\n  }, itemProps, {\n    ref: forwardedRef,\n    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, (event) => {\n      if (!focusable)\n        event.preventDefault();\n      else\n        context.onItemFocus(id);\n    }),\n    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(\n      props.onFocus,\n      () => context.onItemFocus(id)\n    ),\n    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {\n      if (event.key === \"Tab\" && event.shiftKey) {\n        context.onItemShiftTab();\n        return;\n      }\n      if (event.target !== event.currentTarget)\n        return;\n      const focusIntent = $d7bdfb9eb0fdf311$var$getFocusIntent(event, context.orientation, context.dir);\n      if (focusIntent !== void 0) {\n        event.preventDefault();\n        const items = getItems().filter(\n          (item) => item.focusable\n        );\n        let candidateNodes = items.map(\n          (item) => item.ref.current\n        );\n        if (focusIntent === \"last\")\n          candidateNodes.reverse();\n        else if (focusIntent === \"prev\" || focusIntent === \"next\") {\n          if (focusIntent === \"prev\")\n            candidateNodes.reverse();\n          const currentIndex = candidateNodes.indexOf(event.currentTarget);\n          candidateNodes = context.loop ? $d7bdfb9eb0fdf311$var$wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);\n        }\n        setTimeout(\n          () => $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes)\n        );\n      }\n    })\n  })));\n});\nvar $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\nfunction $d7bdfb9eb0fdf311$var$getDirectionAwareKey(key, dir) {\n  if (dir !== \"rtl\")\n    return key;\n  return key === \"ArrowLeft\" ? \"ArrowRight\" : key === \"ArrowRight\" ? \"ArrowLeft\" : key;\n}\nfunction $d7bdfb9eb0fdf311$var$getFocusIntent(event, orientation, dir) {\n  const key = $d7bdfb9eb0fdf311$var$getDirectionAwareKey(event.key, dir);\n  if (orientation === \"vertical\" && [\n    \"ArrowLeft\",\n    \"ArrowRight\"\n  ].includes(key))\n    return void 0;\n  if (orientation === \"horizontal\" && [\n    \"ArrowUp\",\n    \"ArrowDown\"\n  ].includes(key))\n    return void 0;\n  return $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT[key];\n}\nfunction $d7bdfb9eb0fdf311$var$focusFirst(candidates) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)\n      return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)\n      return;\n  }\n}\nfunction $d7bdfb9eb0fdf311$var$wrapArray(array, startIndex) {\n  return array.map(\n    (_3, index2) => array[(startIndex + index2) % array.length]\n  );\n}\nvar $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9 = $d7bdfb9eb0fdf311$export$8699f7c8af148338;\nvar $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2 = $d7bdfb9eb0fdf311$export$ab9df7c53fe8454;\n\n// node_modules/.pnpm/aria-hidden@1.2.2_@types+react@18.2.7_react@18.2.0/node_modules/aria-hidden/dist/es2015/index.js\nvar getDefaultParent = function(originalTarget) {\n  if (typeof document === \"undefined\") {\n    return null;\n  }\n  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;\n  return sampleTarget.ownerDocument.body;\n};\nvar counterMap = /* @__PURE__ */ new WeakMap();\nvar uncontrolledNodes = /* @__PURE__ */ new WeakMap();\nvar markerMap = {};\nvar lockCount = 0;\nvar unwrapHost = function(node) {\n  return node && (node.host || unwrapHost(node.parentNode));\n};\nvar correctTargets = function(parent, targets) {\n  return targets.map(function(target) {\n    if (parent.contains(target)) {\n      return target;\n    }\n    var correctedTarget = unwrapHost(target);\n    if (correctedTarget && parent.contains(correctedTarget)) {\n      return correctedTarget;\n    }\n    console.error(\"aria-hidden\", target, \"in not contained inside\", parent, \". Doing nothing\");\n    return null;\n  }).filter(function(x5) {\n    return Boolean(x5);\n  });\n};\nvar applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {\n  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\n  if (!markerMap[markerName]) {\n    markerMap[markerName] = /* @__PURE__ */ new WeakMap();\n  }\n  var markerCounter = markerMap[markerName];\n  var hiddenNodes = [];\n  var elementsToKeep = /* @__PURE__ */ new Set();\n  var elementsToStop = new Set(targets);\n  var keep = function(el) {\n    if (!el || elementsToKeep.has(el)) {\n      return;\n    }\n    elementsToKeep.add(el);\n    keep(el.parentNode);\n  };\n  targets.forEach(keep);\n  var deep = function(parent) {\n    if (!parent || elementsToStop.has(parent)) {\n      return;\n    }\n    Array.prototype.forEach.call(parent.children, function(node) {\n      if (elementsToKeep.has(node)) {\n        deep(node);\n      } else {\n        var attr = node.getAttribute(controlAttribute);\n        var alreadyHidden = attr !== null && attr !== \"false\";\n        var counterValue = (counterMap.get(node) || 0) + 1;\n        var markerValue = (markerCounter.get(node) || 0) + 1;\n        counterMap.set(node, counterValue);\n        markerCounter.set(node, markerValue);\n        hiddenNodes.push(node);\n        if (counterValue === 1 && alreadyHidden) {\n          uncontrolledNodes.set(node, true);\n        }\n        if (markerValue === 1) {\n          node.setAttribute(markerName, \"true\");\n        }\n        if (!alreadyHidden) {\n          node.setAttribute(controlAttribute, \"true\");\n        }\n      }\n    });\n  };\n  deep(parentNode);\n  elementsToKeep.clear();\n  lockCount++;\n  return function() {\n    hiddenNodes.forEach(function(node) {\n      var counterValue = counterMap.get(node) - 1;\n      var markerValue = markerCounter.get(node) - 1;\n      counterMap.set(node, counterValue);\n      markerCounter.set(node, markerValue);\n      if (!counterValue) {\n        if (!uncontrolledNodes.has(node)) {\n          node.removeAttribute(controlAttribute);\n        }\n        uncontrolledNodes.delete(node);\n      }\n      if (!markerValue) {\n        node.removeAttribute(markerName);\n      }\n    });\n    lockCount--;\n    if (!lockCount) {\n      counterMap = /* @__PURE__ */ new WeakMap();\n      counterMap = /* @__PURE__ */ new WeakMap();\n      uncontrolledNodes = /* @__PURE__ */ new WeakMap();\n      markerMap = {};\n    }\n  };\n};\nvar hideOthers = function(originalTarget, parentNode, markerName) {\n  if (markerName === void 0) {\n    markerName = \"data-aria-hidden\";\n  }\n  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\n  var activeParentNode = parentNode || getDefaultParent(originalTarget);\n  if (!activeParentNode) {\n    return function() {\n      return null;\n    };\n  }\n  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll(\"[aria-live]\")));\n  return applyAttributeToOthers(targets, activeParentNode, markerName, \"aria-hidden\");\n};\n\n// node_modules/.pnpm/tslib@2.5.2/node_modules/tslib/tslib.es6.js\nvar __assign = function() {\n  __assign = Object.assign || function __assign2(t5) {\n    for (var s5, i4 = 1, n5 = arguments.length; i4 < n5; i4++) {\n      s5 = arguments[i4];\n      for (var p6 in s5)\n        if (Object.prototype.hasOwnProperty.call(s5, p6))\n          t5[p6] = s5[p6];\n    }\n    return t5;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction __rest(s5, e5) {\n  var t5 = {};\n  for (var p6 in s5)\n    if (Object.prototype.hasOwnProperty.call(s5, p6) && e5.indexOf(p6) < 0)\n      t5[p6] = s5[p6];\n  if (s5 != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i4 = 0, p6 = Object.getOwnPropertySymbols(s5); i4 < p6.length; i4++) {\n      if (e5.indexOf(p6[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p6[i4]))\n        t5[p6[i4]] = s5[p6[i4]];\n    }\n  return t5;\n}\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2)\n    for (var i4 = 0, l7 = from.length, ar; i4 < l7; i4++) {\n      if (ar || !(i4 in from)) {\n        if (!ar)\n          ar = Array.prototype.slice.call(from, 0, i4);\n        ar[i4] = from[i4];\n      }\n    }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\n// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/Combination.js\nvar React8 = __toESM(require(\"react\"));\n\n// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/UI.js\nvar React4 = __toESM(require(\"react\"));\n\n// node_modules/.pnpm/react-remove-scroll-bar@2.3.4_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll-bar/dist/es2015/constants.js\nvar zeroRightClassName = \"right-scroll-bar-position\";\nvar fullWidthClassName = \"width-before-scroll-bar\";\nvar noScrollbarsClassName = \"with-scroll-bars-hidden\";\nvar removedBarSizeVariable = \"--removed-body-scroll-bar-size\";\n\n// node_modules/.pnpm/use-callback-ref@1.3.0_@types+react@18.2.7_react@18.2.0/node_modules/use-callback-ref/dist/es2015/assignRef.js\nfunction assignRef(ref, value) {\n  if (typeof ref === \"function\") {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n  return ref;\n}\n\n// node_modules/.pnpm/use-callback-ref@1.3.0_@types+react@18.2.7_react@18.2.0/node_modules/use-callback-ref/dist/es2015/useRef.js\nvar import_react27 = require(\"react\");\nfunction useCallbackRef(initialValue, callback) {\n  var ref = (0, import_react27.useState)(function() {\n    return {\n      // value\n      value: initialValue,\n      // last callback\n      callback,\n      // \"memoized\" public interface\n      facade: {\n        get current() {\n          return ref.value;\n        },\n        set current(value) {\n          var last = ref.value;\n          if (last !== value) {\n            ref.value = value;\n            ref.callback(value, last);\n          }\n        }\n      }\n    };\n  })[0];\n  ref.callback = callback;\n  return ref.facade;\n}\n\n// node_modules/.pnpm/use-callback-ref@1.3.0_@types+react@18.2.7_react@18.2.0/node_modules/use-callback-ref/dist/es2015/useMergeRef.js\nfunction useMergeRefs(refs, defaultValue) {\n  return useCallbackRef(defaultValue || null, function(newValue) {\n    return refs.forEach(function(ref) {\n      return assignRef(ref, newValue);\n    });\n  });\n}\n\n// node_modules/.pnpm/use-sidecar@1.1.2_@types+react@18.2.7_react@18.2.0/node_modules/use-sidecar/dist/es2015/medium.js\nfunction ItoI(a7) {\n  return a7;\n}\nfunction innerCreateMedium(defaults, middleware) {\n  if (middleware === void 0) {\n    middleware = ItoI;\n  }\n  var buffer = [];\n  var assigned = false;\n  var medium = {\n    read: function() {\n      if (assigned) {\n        throw new Error(\"Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.\");\n      }\n      if (buffer.length) {\n        return buffer[buffer.length - 1];\n      }\n      return defaults;\n    },\n    useMedium: function(data) {\n      var item = middleware(data, assigned);\n      buffer.push(item);\n      return function() {\n        buffer = buffer.filter(function(x5) {\n          return x5 !== item;\n        });\n      };\n    },\n    assignSyncMedium: function(cb) {\n      assigned = true;\n      while (buffer.length) {\n        var cbs = buffer;\n        buffer = [];\n        cbs.forEach(cb);\n      }\n      buffer = {\n        push: function(x5) {\n          return cb(x5);\n        },\n        filter: function() {\n          return buffer;\n        }\n      };\n    },\n    assignMedium: function(cb) {\n      assigned = true;\n      var pendingQueue = [];\n      if (buffer.length) {\n        var cbs = buffer;\n        buffer = [];\n        cbs.forEach(cb);\n        pendingQueue = buffer;\n      }\n      var executeQueue = function() {\n        var cbs2 = pendingQueue;\n        pendingQueue = [];\n        cbs2.forEach(cb);\n      };\n      var cycle = function() {\n        return Promise.resolve().then(executeQueue);\n      };\n      cycle();\n      buffer = {\n        push: function(x5) {\n          pendingQueue.push(x5);\n          cycle();\n        },\n        filter: function(filter) {\n          pendingQueue = pendingQueue.filter(filter);\n          return buffer;\n        }\n      };\n    }\n  };\n  return medium;\n}\nfunction createSidecarMedium(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var medium = innerCreateMedium(null);\n  medium.options = __assign({ async: true, ssr: false }, options);\n  return medium;\n}\n\n// node_modules/.pnpm/use-sidecar@1.1.2_@types+react@18.2.7_react@18.2.0/node_modules/use-sidecar/dist/es2015/exports.js\nvar React3 = __toESM(require(\"react\"));\nvar SideCar = function(_a) {\n  var sideCar = _a.sideCar, rest = __rest(_a, [\"sideCar\"]);\n  if (!sideCar) {\n    throw new Error(\"Sidecar: please provide `sideCar` property to import the right car\");\n  }\n  var Target = sideCar.read();\n  if (!Target) {\n    throw new Error(\"Sidecar medium not found\");\n  }\n  return React3.createElement(Target, __assign({}, rest));\n};\nSideCar.isSideCarExport = true;\nfunction exportSidecar(medium, exported) {\n  medium.useMedium(exported);\n  return SideCar;\n}\n\n// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/medium.js\nvar effectCar = createSidecarMedium();\n\n// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/UI.js\nvar nothing = function() {\n  return;\n};\nvar RemoveScroll = React4.forwardRef(function(props, parentRef) {\n  var ref = React4.useRef(null);\n  var _a = React4.useState({\n    onScrollCapture: nothing,\n    onWheelCapture: nothing,\n    onTouchMoveCapture: nothing\n  }), callbacks = _a[0], setCallbacks = _a[1];\n  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? \"div\" : _b, rest = __rest(props, [\"forwardProps\", \"children\", \"className\", \"removeScrollBar\", \"enabled\", \"shards\", \"sideCar\", \"noIsolation\", \"inert\", \"allowPinchZoom\", \"as\"]);\n  var SideCar2 = sideCar;\n  var containerRef = useMergeRefs([ref, parentRef]);\n  var containerProps = __assign(__assign({}, rest), callbacks);\n  return React4.createElement(\n    React4.Fragment,\n    null,\n    enabled && React4.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),\n    forwardProps ? React4.cloneElement(React4.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React4.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)\n  );\n});\nRemoveScroll.defaultProps = {\n  enabled: true,\n  removeScrollBar: true,\n  inert: false\n};\nRemoveScroll.classNames = {\n  fullWidth: fullWidthClassName,\n  zeroRight: zeroRightClassName\n};\n\n// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/SideEffect.js\nvar React7 = __toESM(require(\"react\"));\n\n// node_modules/.pnpm/react-remove-scroll-bar@2.3.4_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll-bar/dist/es2015/component.js\nvar React6 = __toESM(require(\"react\"));\n\n// node_modules/.pnpm/react-style-singleton@2.2.1_@types+react@18.2.7_react@18.2.0/node_modules/react-style-singleton/dist/es2015/hook.js\nvar React5 = __toESM(require(\"react\"));\n\n// node_modules/.pnpm/get-nonce@1.0.1/node_modules/get-nonce/dist/es2015/index.js\nvar currentNonce;\nvar getNonce = function() {\n  if (currentNonce) {\n    return currentNonce;\n  }\n  if (typeof __webpack_nonce__ !== \"undefined\") {\n    return __webpack_nonce__;\n  }\n  return void 0;\n};\n\n// node_modules/.pnpm/react-style-singleton@2.2.1_@types+react@18.2.7_react@18.2.0/node_modules/react-style-singleton/dist/es2015/singleton.js\nfunction makeStyleTag() {\n  if (!document)\n    return null;\n  var tag = document.createElement(\"style\");\n  tag.type = \"text/css\";\n  var nonce = getNonce();\n  if (nonce) {\n    tag.setAttribute(\"nonce\", nonce);\n  }\n  return tag;\n}\nfunction injectStyles(tag, css) {\n  if (tag.styleSheet) {\n    tag.styleSheet.cssText = css;\n  } else {\n    tag.appendChild(document.createTextNode(css));\n  }\n}\nfunction insertStyleTag(tag) {\n  var head = document.head || document.getElementsByTagName(\"head\")[0];\n  head.appendChild(tag);\n}\nvar stylesheetSingleton = function() {\n  var counter = 0;\n  var stylesheet = null;\n  return {\n    add: function(style) {\n      if (counter == 0) {\n        if (stylesheet = makeStyleTag()) {\n          injectStyles(stylesheet, style);\n          insertStyleTag(stylesheet);\n        }\n      }\n      counter++;\n    },\n    remove: function() {\n      counter--;\n      if (!counter && stylesheet) {\n        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);\n        stylesheet = null;\n      }\n    }\n  };\n};\n\n// node_modules/.pnpm/react-style-singleton@2.2.1_@types+react@18.2.7_react@18.2.0/node_modules/react-style-singleton/dist/es2015/hook.js\nvar styleHookSingleton = function() {\n  var sheet = stylesheetSingleton();\n  return function(styles, isDynamic) {\n    React5.useEffect(function() {\n      sheet.add(styles);\n      return function() {\n        sheet.remove();\n      };\n    }, [styles && isDynamic]);\n  };\n};\n\n// node_modules/.pnpm/react-style-singleton@2.2.1_@types+react@18.2.7_react@18.2.0/node_modules/react-style-singleton/dist/es2015/component.js\nvar styleSingleton = function() {\n  var useStyle = styleHookSingleton();\n  var Sheet = function(_a) {\n    var styles = _a.styles, dynamic = _a.dynamic;\n    useStyle(styles, dynamic);\n    return null;\n  };\n  return Sheet;\n};\n\n// node_modules/.pnpm/react-remove-scroll-bar@2.3.4_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll-bar/dist/es2015/utils.js\nvar zeroGap = {\n  left: 0,\n  top: 0,\n  right: 0,\n  gap: 0\n};\nvar parse2 = function(x5) {\n  return parseInt(x5 || \"\", 10) || 0;\n};\nvar getOffset = function(gapMode) {\n  var cs = window.getComputedStyle(document.body);\n  var left = cs[gapMode === \"padding\" ? \"paddingLeft\" : \"marginLeft\"];\n  var top2 = cs[gapMode === \"padding\" ? \"paddingTop\" : \"marginTop\"];\n  var right = cs[gapMode === \"padding\" ? \"paddingRight\" : \"marginRight\"];\n  return [parse2(left), parse2(top2), parse2(right)];\n};\nvar getGapWidth = function(gapMode) {\n  if (gapMode === void 0) {\n    gapMode = \"margin\";\n  }\n  if (typeof window === \"undefined\") {\n    return zeroGap;\n  }\n  var offsets = getOffset(gapMode);\n  var documentWidth = document.documentElement.clientWidth;\n  var windowWidth = window.innerWidth;\n  return {\n    left: offsets[0],\n    top: offsets[1],\n    right: offsets[2],\n    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])\n  };\n};\n\n// node_modules/.pnpm/react-remove-scroll-bar@2.3.4_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll-bar/dist/es2015/component.js\nvar Style = styleSingleton();\nvar getStyles = function(_a, allowRelative, gapMode, important) {\n  var left = _a.left, top2 = _a.top, right = _a.right, gap = _a.gap;\n  if (gapMode === void 0) {\n    gapMode = \"margin\";\n  }\n  return \"\\n  .\".concat(noScrollbarsClassName, \" {\\n   overflow: hidden \").concat(important, \";\\n   padding-right: \").concat(gap, \"px \").concat(important, \";\\n  }\\n  body {\\n    overflow: hidden \").concat(important, \";\\n    overscroll-behavior: contain;\\n    \").concat([\n    allowRelative && \"position: relative \".concat(important, \";\"),\n    gapMode === \"margin\" && \"\\n    padding-left: \".concat(left, \"px;\\n    padding-top: \").concat(top2, \"px;\\n    padding-right: \").concat(right, \"px;\\n    margin-left:0;\\n    margin-top:0;\\n    margin-right: \").concat(gap, \"px \").concat(important, \";\\n    \"),\n    gapMode === \"padding\" && \"padding-right: \".concat(gap, \"px \").concat(important, \";\")\n  ].filter(Boolean).join(\"\"), \"\\n  }\\n  \\n  .\").concat(zeroRightClassName, \" {\\n    right: \").concat(gap, \"px \").concat(important, \";\\n  }\\n  \\n  .\").concat(fullWidthClassName, \" {\\n    margin-right: \").concat(gap, \"px \").concat(important, \";\\n  }\\n  \\n  .\").concat(zeroRightClassName, \" .\").concat(zeroRightClassName, \" {\\n    right: 0 \").concat(important, \";\\n  }\\n  \\n  .\").concat(fullWidthClassName, \" .\").concat(fullWidthClassName, \" {\\n    margin-right: 0 \").concat(important, \";\\n  }\\n  \\n  body {\\n    \").concat(removedBarSizeVariable, \": \").concat(gap, \"px;\\n  }\\n\");\n};\nvar RemoveScrollBar = function(props) {\n  var noRelative = props.noRelative, noImportant = props.noImportant, _a = props.gapMode, gapMode = _a === void 0 ? \"margin\" : _a;\n  var gap = React6.useMemo(function() {\n    return getGapWidth(gapMode);\n  }, [gapMode]);\n  return React6.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? \"!important\" : \"\") });\n};\n\n// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js\nvar passiveSupported = false;\nif (typeof window !== \"undefined\") {\n  try {\n    options = Object.defineProperty({}, \"passive\", {\n      get: function() {\n        passiveSupported = true;\n        return true;\n      }\n    });\n    window.addEventListener(\"test\", options, options);\n    window.removeEventListener(\"test\", options, options);\n  } catch (err) {\n    passiveSupported = false;\n  }\n}\nvar options;\nvar nonPassive = passiveSupported ? { passive: false } : false;\n\n// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/handleScroll.js\nvar alwaysContainsScroll = function(node) {\n  return node.tagName === \"TEXTAREA\";\n};\nvar elementCanBeScrolled = function(node, overflow) {\n  var styles = window.getComputedStyle(node);\n  return (\n    // not-not-scrollable\n    styles[overflow] !== \"hidden\" && // contains scroll inside self\n    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === \"visible\")\n  );\n};\nvar elementCouldBeVScrolled = function(node) {\n  return elementCanBeScrolled(node, \"overflowY\");\n};\nvar elementCouldBeHScrolled = function(node) {\n  return elementCanBeScrolled(node, \"overflowX\");\n};\nvar locationCouldBeScrolled = function(axis, node) {\n  var current = node;\n  do {\n    if (typeof ShadowRoot !== \"undefined\" && current instanceof ShadowRoot) {\n      current = current.host;\n    }\n    var isScrollable = elementCouldBeScrolled(axis, current);\n    if (isScrollable) {\n      var _a = getScrollVariables(axis, current), s5 = _a[1], d6 = _a[2];\n      if (s5 > d6) {\n        return true;\n      }\n    }\n    current = current.parentNode;\n  } while (current && current !== document.body);\n  return false;\n};\nvar getVScrollVariables = function(_a) {\n  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;\n  return [\n    scrollTop,\n    scrollHeight,\n    clientHeight\n  ];\n};\nvar getHScrollVariables = function(_a) {\n  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;\n  return [\n    scrollLeft,\n    scrollWidth,\n    clientWidth\n  ];\n};\nvar elementCouldBeScrolled = function(axis, node) {\n  return axis === \"v\" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);\n};\nvar getScrollVariables = function(axis, node) {\n  return axis === \"v\" ? getVScrollVariables(node) : getHScrollVariables(node);\n};\nvar getDirectionFactor = function(axis, direction) {\n  return axis === \"h\" && direction === \"rtl\" ? -1 : 1;\n};\nvar handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {\n  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);\n  var delta = directionFactor * sourceDelta;\n  var target = event.target;\n  var targetInLock = endTarget.contains(target);\n  var shouldCancelScroll = false;\n  var isDeltaPositive = delta > 0;\n  var availableScroll = 0;\n  var availableScrollTop = 0;\n  do {\n    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];\n    var elementScroll = scroll_1 - capacity - directionFactor * position;\n    if (position || elementScroll) {\n      if (elementCouldBeScrolled(axis, target)) {\n        availableScroll += elementScroll;\n        availableScrollTop += position;\n      }\n    }\n    target = target.parentNode;\n  } while (\n    // portaled content\n    !targetInLock && target !== document.body || // self content\n    targetInLock && (endTarget.contains(target) || endTarget === target)\n  );\n  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {\n    shouldCancelScroll = true;\n  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {\n    shouldCancelScroll = true;\n  }\n  return shouldCancelScroll;\n};\n\n// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/SideEffect.js\nvar getTouchXY = function(event) {\n  return \"changedTouches\" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];\n};\nvar getDeltaXY = function(event) {\n  return [event.deltaX, event.deltaY];\n};\nvar extractRef = function(ref) {\n  return ref && \"current\" in ref ? ref.current : ref;\n};\nvar deltaCompare = function(x5, y6) {\n  return x5[0] === y6[0] && x5[1] === y6[1];\n};\nvar generateStyle = function(id) {\n  return \"\\n  .block-interactivity-\".concat(id, \" {pointer-events: none;}\\n  .allow-interactivity-\").concat(id, \" {pointer-events: all;}\\n\");\n};\nvar idCounter = 0;\nvar lockStack = [];\nfunction RemoveScrollSideCar(props) {\n  var shouldPreventQueue = React7.useRef([]);\n  var touchStartRef = React7.useRef([0, 0]);\n  var activeAxis = React7.useRef();\n  var id = React7.useState(idCounter++)[0];\n  var Style2 = React7.useState(function() {\n    return styleSingleton();\n  })[0];\n  var lastProps = React7.useRef(props);\n  React7.useEffect(function() {\n    lastProps.current = props;\n  }, [props]);\n  React7.useEffect(function() {\n    if (props.inert) {\n      document.body.classList.add(\"block-interactivity-\".concat(id));\n      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);\n      allow_1.forEach(function(el) {\n        return el.classList.add(\"allow-interactivity-\".concat(id));\n      });\n      return function() {\n        document.body.classList.remove(\"block-interactivity-\".concat(id));\n        allow_1.forEach(function(el) {\n          return el.classList.remove(\"allow-interactivity-\".concat(id));\n        });\n      };\n    }\n    return;\n  }, [props.inert, props.lockRef.current, props.shards]);\n  var shouldCancelEvent = React7.useCallback(function(event, parent) {\n    if (\"touches\" in event && event.touches.length === 2) {\n      return !lastProps.current.allowPinchZoom;\n    }\n    var touch = getTouchXY(event);\n    var touchStart = touchStartRef.current;\n    var deltaX = \"deltaX\" in event ? event.deltaX : touchStart[0] - touch[0];\n    var deltaY = \"deltaY\" in event ? event.deltaY : touchStart[1] - touch[1];\n    var currentAxis;\n    var target = event.target;\n    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? \"h\" : \"v\";\n    if (\"touches\" in event && moveDirection === \"h\" && target.type === \"range\") {\n      return false;\n    }\n    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);\n    if (!canBeScrolledInMainDirection) {\n      return true;\n    }\n    if (canBeScrolledInMainDirection) {\n      currentAxis = moveDirection;\n    } else {\n      currentAxis = moveDirection === \"v\" ? \"h\" : \"v\";\n      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);\n    }\n    if (!canBeScrolledInMainDirection) {\n      return false;\n    }\n    if (!activeAxis.current && \"changedTouches\" in event && (deltaX || deltaY)) {\n      activeAxis.current = currentAxis;\n    }\n    if (!currentAxis) {\n      return true;\n    }\n    var cancelingAxis = activeAxis.current || currentAxis;\n    return handleScroll(cancelingAxis, parent, event, cancelingAxis === \"h\" ? deltaX : deltaY, true);\n  }, []);\n  var shouldPrevent = React7.useCallback(function(_event) {\n    var event = _event;\n    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {\n      return;\n    }\n    var delta = \"deltaY\" in event ? getDeltaXY(event) : getTouchXY(event);\n    var sourceEvent = shouldPreventQueue.current.filter(function(e5) {\n      return e5.name === event.type && e5.target === event.target && deltaCompare(e5.delta, delta);\n    })[0];\n    if (sourceEvent && sourceEvent.should) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      return;\n    }\n    if (!sourceEvent) {\n      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {\n        return node.contains(event.target);\n      });\n      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;\n      if (shouldStop) {\n        if (event.cancelable) {\n          event.preventDefault();\n        }\n      }\n    }\n  }, []);\n  var shouldCancel = React7.useCallback(function(name, delta, target, should) {\n    var event = { name, delta, target, should };\n    shouldPreventQueue.current.push(event);\n    setTimeout(function() {\n      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e5) {\n        return e5 !== event;\n      });\n    }, 1);\n  }, []);\n  var scrollTouchStart = React7.useCallback(function(event) {\n    touchStartRef.current = getTouchXY(event);\n    activeAxis.current = void 0;\n  }, []);\n  var scrollWheel = React7.useCallback(function(event) {\n    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));\n  }, []);\n  var scrollTouchMove = React7.useCallback(function(event) {\n    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));\n  }, []);\n  React7.useEffect(function() {\n    lockStack.push(Style2);\n    props.setCallbacks({\n      onScrollCapture: scrollWheel,\n      onWheelCapture: scrollWheel,\n      onTouchMoveCapture: scrollTouchMove\n    });\n    document.addEventListener(\"wheel\", shouldPrevent, nonPassive);\n    document.addEventListener(\"touchmove\", shouldPrevent, nonPassive);\n    document.addEventListener(\"touchstart\", scrollTouchStart, nonPassive);\n    return function() {\n      lockStack = lockStack.filter(function(inst) {\n        return inst !== Style2;\n      });\n      document.removeEventListener(\"wheel\", shouldPrevent, nonPassive);\n      document.removeEventListener(\"touchmove\", shouldPrevent, nonPassive);\n      document.removeEventListener(\"touchstart\", scrollTouchStart, nonPassive);\n    };\n  }, []);\n  var removeScrollBar = props.removeScrollBar, inert = props.inert;\n  return React7.createElement(\n    React7.Fragment,\n    null,\n    inert ? React7.createElement(Style2, { styles: generateStyle(id) }) : null,\n    removeScrollBar ? React7.createElement(RemoveScrollBar, { gapMode: \"margin\" }) : null\n  );\n}\n\n// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/sidecar.js\nvar sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);\n\n// node_modules/.pnpm/react-remove-scroll@2.5.5_@types+react@18.2.7_react@18.2.0/node_modules/react-remove-scroll/dist/es2015/Combination.js\nvar ReactRemoveScroll = React8.forwardRef(function(props, ref) {\n  return React8.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));\n});\nReactRemoveScroll.classNames = RemoveScroll.classNames;\nvar Combination_default = ReactRemoveScroll;\n\n// node_modules/.pnpm/@radix-ui+react-menu@2.0.5_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-menu/dist/index.mjs\nvar $6cc32821e9371a1c$var$SELECTION_KEYS = [\n  \"Enter\",\n  \" \"\n];\nvar $6cc32821e9371a1c$var$FIRST_KEYS = [\n  \"ArrowDown\",\n  \"PageUp\",\n  \"Home\"\n];\nvar $6cc32821e9371a1c$var$LAST_KEYS = [\n  \"ArrowUp\",\n  \"PageDown\",\n  \"End\"\n];\nvar $6cc32821e9371a1c$var$FIRST_LAST_KEYS = [\n  ...$6cc32821e9371a1c$var$FIRST_KEYS,\n  ...$6cc32821e9371a1c$var$LAST_KEYS\n];\nvar $6cc32821e9371a1c$var$SUB_OPEN_KEYS = {\n  ltr: [\n    ...$6cc32821e9371a1c$var$SELECTION_KEYS,\n    \"ArrowRight\"\n  ],\n  rtl: [\n    ...$6cc32821e9371a1c$var$SELECTION_KEYS,\n    \"ArrowLeft\"\n  ]\n};\nvar $6cc32821e9371a1c$var$SUB_CLOSE_KEYS = {\n  ltr: [\n    \"ArrowLeft\"\n  ],\n  rtl: [\n    \"ArrowRight\"\n  ]\n};\nvar $6cc32821e9371a1c$var$MENU_NAME = \"Menu\";\nvar [$6cc32821e9371a1c$var$Collection, $6cc32821e9371a1c$var$useCollection, $6cc32821e9371a1c$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($6cc32821e9371a1c$var$MENU_NAME);\nvar [$6cc32821e9371a1c$var$createMenuContext, $6cc32821e9371a1c$export$4027731b685e72eb] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($6cc32821e9371a1c$var$MENU_NAME, [\n  $6cc32821e9371a1c$var$createCollectionScope,\n  $cf1ac5d9fe0e8206$export$722aac194ae923,\n  $d7bdfb9eb0fdf311$export$c7109489551a4f4\n]);\nvar $6cc32821e9371a1c$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();\nvar $6cc32821e9371a1c$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4();\nvar [$6cc32821e9371a1c$var$MenuProvider, $6cc32821e9371a1c$var$useMenuContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME);\nvar [$6cc32821e9371a1c$var$MenuRootProvider, $6cc32821e9371a1c$var$useMenuRootContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME);\nvar $6cc32821e9371a1c$export$d9b273488cd8ce6f = (props) => {\n  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;\n  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);\n  const [content, setContent] = (0, import_react28.useState)(null);\n  const isUsingKeyboardRef = (0, import_react28.useRef)(false);\n  const handleOpenChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);\n  const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);\n  (0, import_react28.useEffect)(() => {\n    const handleKeyDown = () => {\n      isUsingKeyboardRef.current = true;\n      document.addEventListener(\"pointerdown\", handlePointer, {\n        capture: true,\n        once: true\n      });\n      document.addEventListener(\"pointermove\", handlePointer, {\n        capture: true,\n        once: true\n      });\n    };\n    const handlePointer = () => isUsingKeyboardRef.current = false;\n    document.addEventListener(\"keydown\", handleKeyDown, {\n      capture: true\n    });\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown, {\n        capture: true\n      });\n      document.removeEventListener(\"pointerdown\", handlePointer, {\n        capture: true\n      });\n      document.removeEventListener(\"pointermove\", handlePointer, {\n        capture: true\n      });\n    };\n  }, []);\n  return /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuProvider, {\n    scope: __scopeMenu,\n    open,\n    onOpenChange: handleOpenChange,\n    content,\n    onContentChange: setContent\n  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuRootProvider, {\n    scope: __scopeMenu,\n    onClose: (0, import_react28.useCallback)(\n      () => handleOpenChange(false),\n      [\n        handleOpenChange\n      ]\n    ),\n    isUsingKeyboardRef,\n    dir: direction,\n    modal\n  }, children)));\n};\nvar $6cc32821e9371a1c$export$9fa5ebd18bee4d43 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { __scopeMenu, ...anchorProps } = props;\n  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);\n  return /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({}, popperScope, anchorProps, {\n    ref: forwardedRef\n  }));\n});\nvar $6cc32821e9371a1c$var$PORTAL_NAME = \"MenuPortal\";\nvar [$6cc32821e9371a1c$var$PortalProvider, $6cc32821e9371a1c$var$usePortalContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$PORTAL_NAME, {\n  forceMount: void 0\n});\nvar $6cc32821e9371a1c$export$793392f970497feb = (props) => {\n  const { __scopeMenu, forceMount, children, container } = props;\n  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$PORTAL_NAME, __scopeMenu);\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$PortalProvider, {\n    scope: __scopeMenu,\n    forceMount\n  }, /* @__PURE__ */ (0, import_react28.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {\n    present: forceMount || context.open\n  }, /* @__PURE__ */ (0, import_react28.createElement)($f1701beae083dbae$export$602eac185826482c, {\n    asChild: true,\n    container\n  }, children)));\n};\nvar $6cc32821e9371a1c$var$CONTENT_NAME = \"MenuContent\";\nvar [$6cc32821e9371a1c$var$MenuContentProvider, $6cc32821e9371a1c$var$useMenuContentContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$CONTENT_NAME);\nvar $6cc32821e9371a1c$export$479f0f2f71193efe = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const portalContext = $6cc32821e9371a1c$var$usePortalContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);\n  const { forceMount = portalContext.forceMount, ...contentProps } = props;\n  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);\n  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$Collection.Provider, {\n    scope: props.__scopeMenu\n  }, /* @__PURE__ */ (0, import_react28.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {\n    present: forceMount || context.open\n  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$Collection.Slot, {\n    scope: props.__scopeMenu\n  }, rootContext.modal ? /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuRootContentModal, _extends({}, contentProps, {\n    ref: forwardedRef\n  })) : /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuRootContentNonModal, _extends({}, contentProps, {\n    ref: forwardedRef\n  })))));\n});\nvar $6cc32821e9371a1c$var$MenuRootContentModal = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);\n  const ref = (0, import_react28.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);\n  (0, import_react28.useEffect)(() => {\n    const content = ref.current;\n    if (content)\n      return hideOthers(content);\n  }, []);\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuContentImpl, _extends({}, props, {\n    ref: composedRefs,\n    trapFocus: context.open,\n    disableOutsidePointerEvents: context.open,\n    disableOutsideScroll: true,\n    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(\n      props.onFocusOutside,\n      (event) => event.preventDefault(),\n      {\n        checkForDefaultPrevented: false\n      }\n    ),\n    onDismiss: () => context.onOpenChange(false)\n  }));\n});\nvar $6cc32821e9371a1c$var$MenuRootContentNonModal = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuContentImpl, _extends({}, props, {\n    ref: forwardedRef,\n    trapFocus: false,\n    disableOutsidePointerEvents: false,\n    disableOutsideScroll: false,\n    onDismiss: () => context.onOpenChange(false)\n  }));\n});\nvar $6cc32821e9371a1c$var$MenuContentImpl = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { __scopeMenu, loop = false, trapFocus, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, onEntryFocus, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, disableOutsideScroll, ...contentProps } = props;\n  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, __scopeMenu);\n  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, __scopeMenu);\n  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);\n  const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu);\n  const getItems = $6cc32821e9371a1c$var$useCollection(__scopeMenu);\n  const [currentItemId, setCurrentItemId] = (0, import_react28.useState)(null);\n  const contentRef = (0, import_react28.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef, context.onContentChange);\n  const timerRef = (0, import_react28.useRef)(0);\n  const searchRef = (0, import_react28.useRef)(\"\");\n  const pointerGraceTimerRef = (0, import_react28.useRef)(0);\n  const pointerGraceIntentRef = (0, import_react28.useRef)(null);\n  const pointerDirRef = (0, import_react28.useRef)(\"right\");\n  const lastPointerXRef = (0, import_react28.useRef)(0);\n  const ScrollLockWrapper = disableOutsideScroll ? Combination_default : import_react28.Fragment;\n  const scrollLockWrapperProps = disableOutsideScroll ? {\n    as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,\n    allowPinchZoom: true\n  } : void 0;\n  const handleTypeaheadSearch = (key) => {\n    var _items$find, _items$find2;\n    const search = searchRef.current + key;\n    const items = getItems().filter(\n      (item) => !item.disabled\n    );\n    const currentItem = document.activeElement;\n    const currentMatch = (_items$find = items.find(\n      (item) => item.ref.current === currentItem\n    )) === null || _items$find === void 0 ? void 0 : _items$find.textValue;\n    const values = items.map(\n      (item) => item.textValue\n    );\n    const nextMatch = $6cc32821e9371a1c$var$getNextMatch(values, search, currentMatch);\n    const newItem = (_items$find2 = items.find(\n      (item) => item.textValue === nextMatch\n    )) === null || _items$find2 === void 0 ? void 0 : _items$find2.ref.current;\n    (function updateSearch(value) {\n      searchRef.current = value;\n      window.clearTimeout(timerRef.current);\n      if (value !== \"\")\n        timerRef.current = window.setTimeout(\n          () => updateSearch(\"\"),\n          1e3\n        );\n    })(search);\n    if (newItem)\n      setTimeout(\n        () => newItem.focus()\n      );\n  };\n  (0, import_react28.useEffect)(() => {\n    return () => window.clearTimeout(timerRef.current);\n  }, []);\n  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();\n  const isPointerMovingToSubmenu = (0, import_react28.useCallback)((event) => {\n    var _pointerGraceIntentRe, _pointerGraceIntentRe2;\n    const isMovingTowards = pointerDirRef.current === ((_pointerGraceIntentRe = pointerGraceIntentRef.current) === null || _pointerGraceIntentRe === void 0 ? void 0 : _pointerGraceIntentRe.side);\n    return isMovingTowards && $6cc32821e9371a1c$var$isPointerInGraceArea(event, (_pointerGraceIntentRe2 = pointerGraceIntentRef.current) === null || _pointerGraceIntentRe2 === void 0 ? void 0 : _pointerGraceIntentRe2.area);\n  }, []);\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuContentProvider, {\n    scope: __scopeMenu,\n    searchRef,\n    onItemEnter: (0, import_react28.useCallback)((event) => {\n      if (isPointerMovingToSubmenu(event))\n        event.preventDefault();\n    }, [\n      isPointerMovingToSubmenu\n    ]),\n    onItemLeave: (0, import_react28.useCallback)((event) => {\n      var _contentRef$current;\n      if (isPointerMovingToSubmenu(event))\n        return;\n      (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 || _contentRef$current.focus();\n      setCurrentItemId(null);\n    }, [\n      isPointerMovingToSubmenu\n    ]),\n    onTriggerLeave: (0, import_react28.useCallback)((event) => {\n      if (isPointerMovingToSubmenu(event))\n        event.preventDefault();\n    }, [\n      isPointerMovingToSubmenu\n    ]),\n    pointerGraceTimerRef,\n    onPointerGraceIntentChange: (0, import_react28.useCallback)((intent) => {\n      pointerGraceIntentRef.current = intent;\n    }, [])\n  }, /* @__PURE__ */ (0, import_react28.createElement)(ScrollLockWrapper, scrollLockWrapperProps, /* @__PURE__ */ (0, import_react28.createElement)($d3863c46a17e8a28$export$20e40289641fbbb6, {\n    asChild: true,\n    trapped: trapFocus,\n    onMountAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onOpenAutoFocus, (event) => {\n      var _contentRef$current2;\n      event.preventDefault();\n      (_contentRef$current2 = contentRef.current) === null || _contentRef$current2 === void 0 || _contentRef$current2.focus();\n    }),\n    onUnmountAutoFocus: onCloseAutoFocus\n  }, /* @__PURE__ */ (0, import_react28.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, {\n    asChild: true,\n    disableOutsidePointerEvents,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside,\n    onInteractOutside,\n    onDismiss\n  }, /* @__PURE__ */ (0, import_react28.createElement)($d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9, _extends({\n    asChild: true\n  }, rovingFocusGroupScope, {\n    dir: rootContext.dir,\n    orientation: \"vertical\",\n    loop,\n    currentTabStopId: currentItemId,\n    onCurrentTabStopIdChange: setCurrentItemId,\n    onEntryFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onEntryFocus, (event) => {\n      if (!rootContext.isUsingKeyboardRef.current)\n        event.preventDefault();\n    })\n  }), /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({\n    role: \"menu\",\n    \"aria-orientation\": \"vertical\",\n    \"data-state\": $6cc32821e9371a1c$var$getOpenState(context.open),\n    \"data-radix-menu-content\": \"\",\n    dir: rootContext.dir\n  }, popperScope, contentProps, {\n    ref: composedRefs,\n    style: {\n      outline: \"none\",\n      ...contentProps.style\n    },\n    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(contentProps.onKeyDown, (event) => {\n      const target = event.target;\n      const isKeyDownInside = target.closest(\"[data-radix-menu-content]\") === event.currentTarget;\n      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n      const isCharacterKey = event.key.length === 1;\n      if (isKeyDownInside) {\n        if (event.key === \"Tab\")\n          event.preventDefault();\n        if (!isModifierKey && isCharacterKey)\n          handleTypeaheadSearch(event.key);\n      }\n      const content = contentRef.current;\n      if (event.target !== content)\n        return;\n      if (!$6cc32821e9371a1c$var$FIRST_LAST_KEYS.includes(event.key))\n        return;\n      event.preventDefault();\n      const items = getItems().filter(\n        (item) => !item.disabled\n      );\n      const candidateNodes = items.map(\n        (item) => item.ref.current\n      );\n      if ($6cc32821e9371a1c$var$LAST_KEYS.includes(event.key))\n        candidateNodes.reverse();\n      $6cc32821e9371a1c$var$focusFirst(candidateNodes);\n    }),\n    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, (event) => {\n      if (!event.currentTarget.contains(event.target)) {\n        window.clearTimeout(timerRef.current);\n        searchRef.current = \"\";\n      }\n    }),\n    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {\n      const target = event.target;\n      const pointerXHasChanged = lastPointerXRef.current !== event.clientX;\n      if (event.currentTarget.contains(target) && pointerXHasChanged) {\n        const newDir = event.clientX > lastPointerXRef.current ? \"right\" : \"left\";\n        pointerDirRef.current = newDir;\n        lastPointerXRef.current = event.clientX;\n      }\n    }))\n  })))))));\n});\nvar $6cc32821e9371a1c$export$22a631d1f72787bb = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { __scopeMenu, ...groupProps } = props;\n  return /* @__PURE__ */ (0, import_react28.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({\n    role: \"group\"\n  }, groupProps, {\n    ref: forwardedRef\n  }));\n});\nvar $6cc32821e9371a1c$var$ITEM_NAME = \"MenuItem\";\nvar $6cc32821e9371a1c$var$ITEM_SELECT = \"menu.itemSelect\";\nvar $6cc32821e9371a1c$export$2ce376c2cc3355c8 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { disabled = false, onSelect, ...itemProps } = props;\n  const ref = (0, import_react28.useRef)(null);\n  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$ITEM_NAME, props.__scopeMenu);\n  const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$ITEM_NAME, props.__scopeMenu);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);\n  const isPointerDownRef = (0, import_react28.useRef)(false);\n  const handleSelect = () => {\n    const menuItem = ref.current;\n    if (!disabled && menuItem) {\n      const itemSelectEvent = new CustomEvent($6cc32821e9371a1c$var$ITEM_SELECT, {\n        bubbles: true,\n        cancelable: true\n      });\n      menuItem.addEventListener(\n        $6cc32821e9371a1c$var$ITEM_SELECT,\n        (event) => onSelect === null || onSelect === void 0 ? void 0 : onSelect(event),\n        {\n          once: true\n        }\n      );\n      $8927f6f2acc4f386$export$6d1a0317bde7de7f(menuItem, itemSelectEvent);\n      if (itemSelectEvent.defaultPrevented)\n        isPointerDownRef.current = false;\n      else\n        rootContext.onClose();\n    }\n  };\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuItemImpl, _extends({}, itemProps, {\n    ref: composedRefs,\n    disabled,\n    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, handleSelect),\n    onPointerDown: (event) => {\n      var _props$onPointerDown;\n      (_props$onPointerDown = props.onPointerDown) === null || _props$onPointerDown === void 0 || _props$onPointerDown.call(props, event);\n      isPointerDownRef.current = true;\n    },\n    onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, (event) => {\n      var _event$currentTarget;\n      if (!isPointerDownRef.current)\n        (_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || _event$currentTarget.click();\n    }),\n    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {\n      const isTypingAhead = contentContext.searchRef.current !== \"\";\n      if (disabled || isTypingAhead && event.key === \" \")\n        return;\n      if ($6cc32821e9371a1c$var$SELECTION_KEYS.includes(event.key)) {\n        event.currentTarget.click();\n        event.preventDefault();\n      }\n    })\n  }));\n});\nvar $6cc32821e9371a1c$var$MenuItemImpl = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;\n  const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$ITEM_NAME, __scopeMenu);\n  const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu);\n  const ref = (0, import_react28.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);\n  const [isFocused, setIsFocused] = (0, import_react28.useState)(false);\n  const [textContent, setTextContent] = (0, import_react28.useState)(\"\");\n  (0, import_react28.useEffect)(() => {\n    const menuItem = ref.current;\n    if (menuItem) {\n      var _menuItem$textContent;\n      setTextContent(((_menuItem$textContent = menuItem.textContent) !== null && _menuItem$textContent !== void 0 ? _menuItem$textContent : \"\").trim());\n    }\n  }, [\n    itemProps.children\n  ]);\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$Collection.ItemSlot, {\n    scope: __scopeMenu,\n    disabled,\n    textValue: textValue !== null && textValue !== void 0 ? textValue : textContent\n  }, /* @__PURE__ */ (0, import_react28.createElement)($d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, _extends({\n    asChild: true\n  }, rovingFocusGroupScope, {\n    focusable: !disabled\n  }), /* @__PURE__ */ (0, import_react28.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({\n    role: \"menuitem\",\n    \"data-highlighted\": isFocused ? \"\" : void 0,\n    \"aria-disabled\": disabled || void 0,\n    \"data-disabled\": disabled ? \"\" : void 0\n  }, itemProps, {\n    ref: composedRefs,\n    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {\n      if (disabled)\n        contentContext.onItemLeave(event);\n      else {\n        contentContext.onItemEnter(event);\n        if (!event.defaultPrevented) {\n          const item = event.currentTarget;\n          item.focus();\n        }\n      }\n    })),\n    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $6cc32821e9371a1c$var$whenMouse(\n      (event) => contentContext.onItemLeave(event)\n    )),\n    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(\n      props.onFocus,\n      () => setIsFocused(true)\n    ),\n    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(\n      props.onBlur,\n      () => setIsFocused(false)\n    )\n  }))));\n});\nvar $6cc32821e9371a1c$export$f6f243521332502d = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { checked = false, onCheckedChange, ...checkboxItemProps } = props;\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$ItemIndicatorProvider, {\n    scope: props.__scopeMenu,\n    checked\n  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$export$2ce376c2cc3355c8, _extends({\n    role: \"menuitemcheckbox\",\n    \"aria-checked\": $6cc32821e9371a1c$var$isIndeterminate(checked) ? \"mixed\" : checked\n  }, checkboxItemProps, {\n    ref: forwardedRef,\n    \"data-state\": $6cc32821e9371a1c$var$getCheckedState(checked),\n    onSelect: $e42e1063c40fb3ef$export$b9ecd428b558ff10(\n      checkboxItemProps.onSelect,\n      () => onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange($6cc32821e9371a1c$var$isIndeterminate(checked) ? true : !checked),\n      {\n        checkForDefaultPrevented: false\n      }\n    )\n  })));\n});\nvar $6cc32821e9371a1c$var$RADIO_GROUP_NAME = \"MenuRadioGroup\";\nvar [$6cc32821e9371a1c$var$RadioGroupProvider, $6cc32821e9371a1c$var$useRadioGroupContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$RADIO_GROUP_NAME, {\n  value: void 0,\n  onValueChange: () => {\n  }\n});\nvar $6cc32821e9371a1c$export$ea2200c9eee416b3 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { value, onValueChange, ...groupProps } = props;\n  const handleValueChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onValueChange);\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$RadioGroupProvider, {\n    scope: props.__scopeMenu,\n    value,\n    onValueChange: handleValueChange\n  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$export$22a631d1f72787bb, _extends({}, groupProps, {\n    ref: forwardedRef\n  })));\n});\nvar $6cc32821e9371a1c$var$RADIO_ITEM_NAME = \"MenuRadioItem\";\nvar $6cc32821e9371a1c$export$69bd225e9817f6d0 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { value, ...radioItemProps } = props;\n  const context = $6cc32821e9371a1c$var$useRadioGroupContext($6cc32821e9371a1c$var$RADIO_ITEM_NAME, props.__scopeMenu);\n  const checked = value === context.value;\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$ItemIndicatorProvider, {\n    scope: props.__scopeMenu,\n    checked\n  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$export$2ce376c2cc3355c8, _extends({\n    role: \"menuitemradio\",\n    \"aria-checked\": checked\n  }, radioItemProps, {\n    ref: forwardedRef,\n    \"data-state\": $6cc32821e9371a1c$var$getCheckedState(checked),\n    onSelect: $e42e1063c40fb3ef$export$b9ecd428b558ff10(radioItemProps.onSelect, () => {\n      var _context$onValueChang;\n      return (_context$onValueChang = context.onValueChange) === null || _context$onValueChang === void 0 ? void 0 : _context$onValueChang.call(context, value);\n    }, {\n      checkForDefaultPrevented: false\n    })\n  })));\n});\nvar $6cc32821e9371a1c$var$ITEM_INDICATOR_NAME = \"MenuItemIndicator\";\nvar [$6cc32821e9371a1c$var$ItemIndicatorProvider, $6cc32821e9371a1c$var$useItemIndicatorContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$ITEM_INDICATOR_NAME, {\n  checked: false\n});\nvar $6cc32821e9371a1c$export$a2593e23056970a3 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;\n  const indicatorContext = $6cc32821e9371a1c$var$useItemIndicatorContext($6cc32821e9371a1c$var$ITEM_INDICATOR_NAME, __scopeMenu);\n  return /* @__PURE__ */ (0, import_react28.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {\n    present: forceMount || $6cc32821e9371a1c$var$isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true\n  }, /* @__PURE__ */ (0, import_react28.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({}, itemIndicatorProps, {\n    ref: forwardedRef,\n    \"data-state\": $6cc32821e9371a1c$var$getCheckedState(indicatorContext.checked)\n  })));\n});\nvar $6cc32821e9371a1c$export$1cec7dcdd713e220 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { __scopeMenu, ...separatorProps } = props;\n  return /* @__PURE__ */ (0, import_react28.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({\n    role: \"separator\",\n    \"aria-orientation\": \"horizontal\"\n  }, separatorProps, {\n    ref: forwardedRef\n  }));\n});\nvar $6cc32821e9371a1c$export$bcdda4773debf5fa = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const { __scopeMenu, ...arrowProps } = props;\n  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);\n  return /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends({}, popperScope, arrowProps, {\n    ref: forwardedRef\n  }));\n});\nvar $6cc32821e9371a1c$var$SUB_NAME = \"MenuSub\";\nvar [$6cc32821e9371a1c$var$MenuSubProvider, $6cc32821e9371a1c$var$useMenuSubContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$SUB_NAME);\nvar $6cc32821e9371a1c$export$71bdb9d1e2909932 = (props) => {\n  const { __scopeMenu, children, open = false, onOpenChange } = props;\n  const parentMenuContext = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$SUB_NAME, __scopeMenu);\n  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);\n  const [trigger, setTrigger] = (0, import_react28.useState)(null);\n  const [content, setContent] = (0, import_react28.useState)(null);\n  const handleOpenChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);\n  (0, import_react28.useEffect)(() => {\n    if (parentMenuContext.open === false)\n      handleOpenChange(false);\n    return () => handleOpenChange(false);\n  }, [\n    parentMenuContext.open,\n    handleOpenChange\n  ]);\n  return /* @__PURE__ */ (0, import_react28.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuProvider, {\n    scope: __scopeMenu,\n    open,\n    onOpenChange: handleOpenChange,\n    content,\n    onContentChange: setContent\n  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuSubProvider, {\n    scope: __scopeMenu,\n    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),\n    triggerId: $1746a345f3d73bb7$export$f680877a34711e37(),\n    trigger,\n    onTriggerChange: setTrigger\n  }, children)));\n};\nvar $6cc32821e9371a1c$var$SUB_TRIGGER_NAME = \"MenuSubTrigger\";\nvar $6cc32821e9371a1c$export$5fbbb3ba7297405f = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);\n  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);\n  const subContext = $6cc32821e9371a1c$var$useMenuSubContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);\n  const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);\n  const openTimerRef = (0, import_react28.useRef)(null);\n  const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;\n  const scope = {\n    __scopeMenu: props.__scopeMenu\n  };\n  const clearOpenTimer = (0, import_react28.useCallback)(() => {\n    if (openTimerRef.current)\n      window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = null;\n  }, []);\n  (0, import_react28.useEffect)(\n    () => clearOpenTimer,\n    [\n      clearOpenTimer\n    ]\n  );\n  (0, import_react28.useEffect)(() => {\n    const pointerGraceTimer = pointerGraceTimerRef.current;\n    return () => {\n      window.clearTimeout(pointerGraceTimer);\n      onPointerGraceIntentChange(null);\n    };\n  }, [\n    pointerGraceTimerRef,\n    onPointerGraceIntentChange\n  ]);\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$export$9fa5ebd18bee4d43, _extends({\n    asChild: true\n  }, scope), /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuItemImpl, _extends({\n    id: subContext.triggerId,\n    \"aria-haspopup\": \"menu\",\n    \"aria-expanded\": context.open,\n    \"aria-controls\": subContext.contentId,\n    \"data-state\": $6cc32821e9371a1c$var$getOpenState(context.open)\n  }, props, {\n    ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, subContext.onTriggerChange),\n    onClick: (event) => {\n      var _props$onClick;\n      (_props$onClick = props.onClick) === null || _props$onClick === void 0 || _props$onClick.call(props, event);\n      if (props.disabled || event.defaultPrevented)\n        return;\n      event.currentTarget.focus();\n      if (!context.open)\n        context.onOpenChange(true);\n    },\n    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {\n      contentContext.onItemEnter(event);\n      if (event.defaultPrevented)\n        return;\n      if (!props.disabled && !context.open && !openTimerRef.current) {\n        contentContext.onPointerGraceIntentChange(null);\n        openTimerRef.current = window.setTimeout(() => {\n          context.onOpenChange(true);\n          clearOpenTimer();\n        }, 100);\n      }\n    })),\n    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $6cc32821e9371a1c$var$whenMouse((event) => {\n      var _context$content;\n      clearOpenTimer();\n      const contentRect = (_context$content = context.content) === null || _context$content === void 0 ? void 0 : _context$content.getBoundingClientRect();\n      if (contentRect) {\n        var _context$content2;\n        const side = (_context$content2 = context.content) === null || _context$content2 === void 0 ? void 0 : _context$content2.dataset.side;\n        const rightSide = side === \"right\";\n        const bleed = rightSide ? -5 : 5;\n        const contentNearEdge = contentRect[rightSide ? \"left\" : \"right\"];\n        const contentFarEdge = contentRect[rightSide ? \"right\" : \"left\"];\n        contentContext.onPointerGraceIntentChange({\n          area: [\n            // consistently within polygon bounds\n            {\n              x: event.clientX + bleed,\n              y: event.clientY\n            },\n            {\n              x: contentNearEdge,\n              y: contentRect.top\n            },\n            {\n              x: contentFarEdge,\n              y: contentRect.top\n            },\n            {\n              x: contentFarEdge,\n              y: contentRect.bottom\n            },\n            {\n              x: contentNearEdge,\n              y: contentRect.bottom\n            }\n          ],\n          side\n        });\n        window.clearTimeout(pointerGraceTimerRef.current);\n        pointerGraceTimerRef.current = window.setTimeout(\n          () => contentContext.onPointerGraceIntentChange(null),\n          300\n        );\n      } else {\n        contentContext.onTriggerLeave(event);\n        if (event.defaultPrevented)\n          return;\n        contentContext.onPointerGraceIntentChange(null);\n      }\n    })),\n    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {\n      const isTypingAhead = contentContext.searchRef.current !== \"\";\n      if (props.disabled || isTypingAhead && event.key === \" \")\n        return;\n      if ($6cc32821e9371a1c$var$SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {\n        var _context$content3;\n        context.onOpenChange(true);\n        (_context$content3 = context.content) === null || _context$content3 === void 0 || _context$content3.focus();\n        event.preventDefault();\n      }\n    })\n  })));\n});\nvar $6cc32821e9371a1c$var$SUB_CONTENT_NAME = \"MenuSubContent\";\nvar $6cc32821e9371a1c$export$e7142ab31822bde6 = /* @__PURE__ */ (0, import_react28.forwardRef)((props, forwardedRef) => {\n  const portalContext = $6cc32821e9371a1c$var$usePortalContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);\n  const { forceMount = portalContext.forceMount, ...subContentProps } = props;\n  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);\n  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);\n  const subContext = $6cc32821e9371a1c$var$useMenuSubContext($6cc32821e9371a1c$var$SUB_CONTENT_NAME, props.__scopeMenu);\n  const ref = (0, import_react28.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);\n  return /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$Collection.Provider, {\n    scope: props.__scopeMenu\n  }, /* @__PURE__ */ (0, import_react28.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {\n    present: forceMount || context.open\n  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$Collection.Slot, {\n    scope: props.__scopeMenu\n  }, /* @__PURE__ */ (0, import_react28.createElement)($6cc32821e9371a1c$var$MenuContentImpl, _extends({\n    id: subContext.contentId,\n    \"aria-labelledby\": subContext.triggerId\n  }, subContentProps, {\n    ref: composedRefs,\n    align: \"start\",\n    side: rootContext.dir === \"rtl\" ? \"left\" : \"right\",\n    disableOutsidePointerEvents: false,\n    disableOutsideScroll: false,\n    trapFocus: false,\n    onOpenAutoFocus: (event) => {\n      var _ref$current;\n      if (rootContext.isUsingKeyboardRef.current)\n        (_ref$current = ref.current) === null || _ref$current === void 0 || _ref$current.focus();\n      event.preventDefault();\n    },\n    onCloseAutoFocus: (event) => event.preventDefault(),\n    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusOutside, (event) => {\n      if (event.target !== subContext.trigger)\n        context.onOpenChange(false);\n    }),\n    onEscapeKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onEscapeKeyDown, (event) => {\n      rootContext.onClose();\n      event.preventDefault();\n    }),\n    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {\n      const isKeyDownInside = event.currentTarget.contains(event.target);\n      const isCloseKey = $6cc32821e9371a1c$var$SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);\n      if (isKeyDownInside && isCloseKey) {\n        var _subContext$trigger;\n        context.onOpenChange(false);\n        (_subContext$trigger = subContext.trigger) === null || _subContext$trigger === void 0 || _subContext$trigger.focus();\n        event.preventDefault();\n      }\n    })\n  })))));\n});\nfunction $6cc32821e9371a1c$var$getOpenState(open) {\n  return open ? \"open\" : \"closed\";\n}\nfunction $6cc32821e9371a1c$var$isIndeterminate(checked) {\n  return checked === \"indeterminate\";\n}\nfunction $6cc32821e9371a1c$var$getCheckedState(checked) {\n  return $6cc32821e9371a1c$var$isIndeterminate(checked) ? \"indeterminate\" : checked ? \"checked\" : \"unchecked\";\n}\nfunction $6cc32821e9371a1c$var$focusFirst(candidates) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)\n      return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)\n      return;\n  }\n}\nfunction $6cc32821e9371a1c$var$wrapArray(array, startIndex) {\n  return array.map(\n    (_3, index2) => array[(startIndex + index2) % array.length]\n  );\n}\nfunction $6cc32821e9371a1c$var$getNextMatch(values, search, currentMatch) {\n  const isRepeated = search.length > 1 && Array.from(search).every(\n    (char) => char === search[0]\n  );\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n  let wrappedValues = $6cc32821e9371a1c$var$wrapArray(values, Math.max(currentMatchIndex, 0));\n  const excludeCurrentMatch = normalizedSearch.length === 1;\n  if (excludeCurrentMatch)\n    wrappedValues = wrappedValues.filter(\n      (v6) => v6 !== currentMatch\n    );\n  const nextMatch = wrappedValues.find(\n    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextMatch !== currentMatch ? nextMatch : void 0;\n}\nfunction $6cc32821e9371a1c$var$isPointInPolygon(point, polygon) {\n  const { x: x5, y: y6 } = point;\n  let inside = false;\n  for (let i4 = 0, j4 = polygon.length - 1; i4 < polygon.length; j4 = i4++) {\n    const xi = polygon[i4].x;\n    const yi = polygon[i4].y;\n    const xj = polygon[j4].x;\n    const yj = polygon[j4].y;\n    const intersect = yi > y6 !== yj > y6 && x5 < (xj - xi) * (y6 - yi) / (yj - yi) + xi;\n    if (intersect)\n      inside = !inside;\n  }\n  return inside;\n}\nfunction $6cc32821e9371a1c$var$isPointerInGraceArea(event, area) {\n  if (!area)\n    return false;\n  const cursorPos = {\n    x: event.clientX,\n    y: event.clientY\n  };\n  return $6cc32821e9371a1c$var$isPointInPolygon(cursorPos, area);\n}\nfunction $6cc32821e9371a1c$var$whenMouse(handler) {\n  return (event) => event.pointerType === \"mouse\" ? handler(event) : void 0;\n}\nvar $6cc32821e9371a1c$export$be92b6f5f03c0fe9 = $6cc32821e9371a1c$export$d9b273488cd8ce6f;\nvar $6cc32821e9371a1c$export$b688253958b8dfe7 = $6cc32821e9371a1c$export$9fa5ebd18bee4d43;\nvar $6cc32821e9371a1c$export$602eac185826482c = $6cc32821e9371a1c$export$793392f970497feb;\nvar $6cc32821e9371a1c$export$7c6e2c02157bb7d2 = $6cc32821e9371a1c$export$479f0f2f71193efe;\nvar $6cc32821e9371a1c$export$6d08773d2e66f8f2 = $6cc32821e9371a1c$export$2ce376c2cc3355c8;\nvar $6cc32821e9371a1c$export$16ce288f89fa631c = $6cc32821e9371a1c$export$f6f243521332502d;\nvar $6cc32821e9371a1c$export$a98f0dcb43a68a25 = $6cc32821e9371a1c$export$ea2200c9eee416b3;\nvar $6cc32821e9371a1c$export$371ab307eab489c0 = $6cc32821e9371a1c$export$69bd225e9817f6d0;\nvar $6cc32821e9371a1c$export$c3468e2714d175fa = $6cc32821e9371a1c$export$a2593e23056970a3;\nvar $6cc32821e9371a1c$export$1ff3c3f08ae963c0 = $6cc32821e9371a1c$export$1cec7dcdd713e220;\nvar $6cc32821e9371a1c$export$21b07c8f274aebd5 = $6cc32821e9371a1c$export$bcdda4773debf5fa;\nvar $6cc32821e9371a1c$export$d7a01e11500dfb6f = $6cc32821e9371a1c$export$71bdb9d1e2909932;\nvar $6cc32821e9371a1c$export$2ea8a7a591ac5eac = $6cc32821e9371a1c$export$5fbbb3ba7297405f;\nvar $6cc32821e9371a1c$export$6d4de93b380beddf = $6cc32821e9371a1c$export$e7142ab31822bde6;\n\n// node_modules/.pnpm/@radix-ui+react-context-menu@2.1.4_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-context-menu/dist/index.mjs\nvar $1b0217ee4a91d156$var$CONTEXT_MENU_NAME = \"ContextMenu\";\nvar [$1b0217ee4a91d156$var$createContextMenuContext, $1b0217ee4a91d156$export$1059331f43ddcc82] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($1b0217ee4a91d156$var$CONTEXT_MENU_NAME, [\n  $6cc32821e9371a1c$export$4027731b685e72eb\n]);\nvar $1b0217ee4a91d156$var$useMenuScope = $6cc32821e9371a1c$export$4027731b685e72eb();\nvar [$1b0217ee4a91d156$var$ContextMenuProvider, $1b0217ee4a91d156$var$useContextMenuContext] = $1b0217ee4a91d156$var$createContextMenuContext($1b0217ee4a91d156$var$CONTEXT_MENU_NAME);\nvar $1b0217ee4a91d156$export$8dc6765e8be191c7 = (props) => {\n  const { __scopeContextMenu, children, onOpenChange, dir, modal = true } = props;\n  const [open1, setOpen] = (0, import_react29.useState)(false);\n  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);\n  const handleOpenChangeProp = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);\n  const handleOpenChange = (0, import_react29.useCallback)((open) => {\n    setOpen(open);\n    handleOpenChangeProp(open);\n  }, [\n    handleOpenChangeProp\n  ]);\n  return /* @__PURE__ */ (0, import_react29.createElement)($1b0217ee4a91d156$var$ContextMenuProvider, {\n    scope: __scopeContextMenu,\n    open: open1,\n    onOpenChange: handleOpenChange,\n    modal\n  }, /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$be92b6f5f03c0fe9, _extends({}, menuScope, {\n    dir,\n    open: open1,\n    onOpenChange: handleOpenChange,\n    modal\n  }), children));\n};\nvar $1b0217ee4a91d156$var$TRIGGER_NAME = \"ContextMenuTrigger\";\nvar $1b0217ee4a91d156$export$be6fc7b1d5b0beb9 = /* @__PURE__ */ (0, import_react29.forwardRef)((props, forwardedRef) => {\n  const { __scopeContextMenu, disabled = false, ...triggerProps } = props;\n  const context = $1b0217ee4a91d156$var$useContextMenuContext($1b0217ee4a91d156$var$TRIGGER_NAME, __scopeContextMenu);\n  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);\n  const pointRef = (0, import_react29.useRef)({\n    x: 0,\n    y: 0\n  });\n  const virtualRef = (0, import_react29.useRef)({\n    getBoundingClientRect: () => DOMRect.fromRect({\n      width: 0,\n      height: 0,\n      ...pointRef.current\n    })\n  });\n  const longPressTimerRef = (0, import_react29.useRef)(0);\n  const clearLongPress = (0, import_react29.useCallback)(\n    () => window.clearTimeout(longPressTimerRef.current),\n    []\n  );\n  const handleOpen = (event) => {\n    pointRef.current = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    context.onOpenChange(true);\n  };\n  (0, import_react29.useEffect)(\n    () => clearLongPress,\n    [\n      clearLongPress\n    ]\n  );\n  (0, import_react29.useEffect)(\n    () => void (disabled && clearLongPress()),\n    [\n      disabled,\n      clearLongPress\n    ]\n  );\n  return /* @__PURE__ */ (0, import_react29.createElement)(import_react29.Fragment, null, /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$b688253958b8dfe7, _extends({}, menuScope, {\n    virtualRef\n  })), /* @__PURE__ */ (0, import_react29.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({\n    \"data-state\": context.open ? \"open\" : \"closed\",\n    \"data-disabled\": disabled ? \"\" : void 0\n  }, triggerProps, {\n    ref: forwardedRef,\n    style: {\n      WebkitTouchCallout: \"none\",\n      ...props.style\n    },\n    onContextMenu: disabled ? props.onContextMenu : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onContextMenu, (event) => {\n      clearLongPress();\n      handleOpen(event);\n      event.preventDefault();\n    }),\n    onPointerDown: disabled ? props.onPointerDown : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, $1b0217ee4a91d156$var$whenTouchOrPen((event) => {\n      clearLongPress();\n      longPressTimerRef.current = window.setTimeout(\n        () => handleOpen(event),\n        700\n      );\n    })),\n    onPointerMove: disabled ? props.onPointerMove : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $1b0217ee4a91d156$var$whenTouchOrPen(clearLongPress)),\n    onPointerCancel: disabled ? props.onPointerCancel : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerCancel, $1b0217ee4a91d156$var$whenTouchOrPen(clearLongPress)),\n    onPointerUp: disabled ? props.onPointerUp : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, $1b0217ee4a91d156$var$whenTouchOrPen(clearLongPress))\n  })));\n});\nvar $1b0217ee4a91d156$export$14afd0be83e45060 = (props) => {\n  const { __scopeContextMenu, ...portalProps } = props;\n  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);\n  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$602eac185826482c, _extends({}, menuScope, portalProps));\n};\nvar $1b0217ee4a91d156$var$CONTENT_NAME = \"ContextMenuContent\";\nvar $1b0217ee4a91d156$export$572205900c9369e = /* @__PURE__ */ (0, import_react29.forwardRef)((props, forwardedRef) => {\n  const { __scopeContextMenu, ...contentProps } = props;\n  const context = $1b0217ee4a91d156$var$useContextMenuContext($1b0217ee4a91d156$var$CONTENT_NAME, __scopeContextMenu);\n  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);\n  const hasInteractedOutsideRef = (0, import_react29.useRef)(false);\n  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$7c6e2c02157bb7d2, _extends({}, menuScope, contentProps, {\n    ref: forwardedRef,\n    side: \"right\",\n    sideOffset: 2,\n    align: \"start\",\n    onCloseAutoFocus: (event) => {\n      var _props$onCloseAutoFoc;\n      (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);\n      if (!event.defaultPrevented && hasInteractedOutsideRef.current)\n        event.preventDefault();\n      hasInteractedOutsideRef.current = false;\n    },\n    onInteractOutside: (event) => {\n      var _props$onInteractOuts;\n      (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);\n      if (!event.defaultPrevented && !context.modal)\n        hasInteractedOutsideRef.current = true;\n    },\n    style: {\n      ...props.style,\n      \"--radix-context-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-context-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-context-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-context-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-context-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    }\n  }));\n});\nvar $1b0217ee4a91d156$export$16a26dc176a49100 = /* @__PURE__ */ (0, import_react29.forwardRef)((props, forwardedRef) => {\n  const { __scopeContextMenu, ...itemProps } = props;\n  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);\n  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$6d08773d2e66f8f2, _extends({}, menuScope, itemProps, {\n    ref: forwardedRef\n  }));\n});\nvar $1b0217ee4a91d156$export$f47d0a58228a61e2 = /* @__PURE__ */ (0, import_react29.forwardRef)((props, forwardedRef) => {\n  const { __scopeContextMenu, ...arrowProps } = props;\n  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);\n  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$21b07c8f274aebd5, _extends({}, menuScope, arrowProps, {\n    ref: forwardedRef\n  }));\n});\nvar $1b0217ee4a91d156$export$5bc21d1c00c4b201 = (props) => {\n  const { __scopeContextMenu, children, onOpenChange, open: openProp, defaultOpen } = props;\n  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);\n  const [open, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange\n  });\n  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$d7a01e11500dfb6f, _extends({}, menuScope, {\n    open,\n    onOpenChange: setOpen\n  }), children);\n};\nvar $1b0217ee4a91d156$export$30b2b5c64556d316 = /* @__PURE__ */ (0, import_react29.forwardRef)((props, forwardedRef) => {\n  const { __scopeContextMenu, ...triggerItemProps } = props;\n  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);\n  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$2ea8a7a591ac5eac, _extends({}, menuScope, triggerItemProps, {\n    ref: forwardedRef\n  }));\n});\nvar $1b0217ee4a91d156$export$2c967063bd2dc512 = /* @__PURE__ */ (0, import_react29.forwardRef)((props, forwardedRef) => {\n  const { __scopeContextMenu, ...subContentProps } = props;\n  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);\n  return /* @__PURE__ */ (0, import_react29.createElement)($6cc32821e9371a1c$export$6d4de93b380beddf, _extends({}, menuScope, subContentProps, {\n    ref: forwardedRef,\n    style: {\n      ...props.style,\n      \"--radix-context-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-context-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-context-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-context-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-context-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    }\n  }));\n});\nfunction $1b0217ee4a91d156$var$whenTouchOrPen(handler) {\n  return (event) => event.pointerType !== \"mouse\" ? handler(event) : void 0;\n}\nvar $1b0217ee4a91d156$export$be92b6f5f03c0fe9 = $1b0217ee4a91d156$export$8dc6765e8be191c7;\nvar $1b0217ee4a91d156$export$41fb9f06171c75f4 = $1b0217ee4a91d156$export$be6fc7b1d5b0beb9;\nvar $1b0217ee4a91d156$export$602eac185826482c = $1b0217ee4a91d156$export$14afd0be83e45060;\nvar $1b0217ee4a91d156$export$7c6e2c02157bb7d2 = $1b0217ee4a91d156$export$572205900c9369e;\nvar $1b0217ee4a91d156$export$d7a01e11500dfb6f = $1b0217ee4a91d156$export$5bc21d1c00c4b201;\nvar $1b0217ee4a91d156$export$2ea8a7a591ac5eac = $1b0217ee4a91d156$export$30b2b5c64556d316;\nvar $1b0217ee4a91d156$export$6d4de93b380beddf = $1b0217ee4a91d156$export$2c967063bd2dc512;\n\n// node_modules/.pnpm/@radix-ui+react-icons@1.3.0_react@18.2.0/node_modules/@radix-ui/react-icons/dist/react-icons.esm.js\nvar import_react30 = require(\"react\");\nfunction _objectWithoutPropertiesLoose2(source, excluded) {\n  if (source == null)\n    return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i4;\n  for (i4 = 0; i4 < sourceKeys.length; i4++) {\n    key = sourceKeys[i4];\n    if (excluded.indexOf(key) >= 0)\n      continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nvar _excluded$3 = [\"color\"];\nvar AlignBottomIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M9 3C9 2.44772 8.55229 2 8 2H7C6.44772 2 6 2.44772 6 3L6 14H1.5C1.22386 14 1 14.2239 1 14.5C1 14.7761 1.22386 15 1.5 15L6 15H9H13.5C13.7761 15 14 14.7761 14 14.5C14 14.2239 13.7761 14 13.5 14H9V3Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$4 = [\"color\"];\nvar AlignCenterHorizontallyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M1.99988 6C1.44759 6 0.999877 6.44772 0.999877 7L0.999877 8C0.999877 8.55228 1.44759 9 1.99988 9L6.99988 9L6.99988 13.5C6.99988 13.7761 7.22374 14 7.49988 14C7.77602 14 7.99988 13.7761 7.99988 13.5L7.99988 9L12.9999 9C13.5522 9 13.9999 8.55228 13.9999 8L13.9999 7C13.9999 6.44772 13.5522 6 12.9999 6L7.99988 6L7.99988 1.5C7.99988 1.22386 7.77602 1 7.49988 1C7.22373 1 6.99988 1.22386 6.99988 1.5L6.99988 6L1.99988 6Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$5 = [\"color\"];\nvar AlignCenterVerticallyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$5);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M6.99988 1C6.44759 1 5.99988 1.44772 5.99988 2V7H1.49988C1.22374 7 0.999878 7.22386 0.999878 7.5C0.999878 7.77614 1.22374 8 1.49988 8H5.99988V13C5.99988 13.5523 6.44759 14 6.99988 14H7.99988C8.55216 14 8.99988 13.5523 8.99988 13V8H13.4999C13.776 8 13.9999 7.77614 13.9999 7.5C13.9999 7.22386 13.776 7 13.4999 7H8.99988V2C8.99988 1.44772 8.55216 1 7.99988 1L6.99988 1Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$6 = [\"color\"];\nvar AlignLeftIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$6);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M0.499995 0.999995C0.223855 0.999995 -5.58458e-07 1.22385 -5.46388e-07 1.49999L-2.18554e-08 13.4999C-9.78492e-09 13.776 0.223855 13.9999 0.499995 13.9999C0.776136 13.9999 0.999991 13.776 0.999991 13.4999L0.999991 8.99993L12 8.99993C12.5523 8.99993 13 8.55222 13 7.99993L13 6.99994C13 6.44766 12.5523 5.99995 12 5.99995L0.999991 5.99995L0.999991 1.49999C0.999991 1.22385 0.776135 0.999995 0.499995 0.999995Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$7 = [\"color\"];\nvar AlignRightIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$7);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M14.4999 1C14.2237 1 13.9999 1.22386 13.9999 1.5L13.9999 6L2.99988 6C2.44759 6 1.99988 6.44772 1.99988 7L1.99988 8C1.99988 8.55228 2.44759 9 2.99988 9L13.9999 9L13.9999 13.5C13.9999 13.7761 14.2237 14 14.4999 14C14.776 14 14.9999 13.7761 14.9999 13.5L14.9999 9L14.9999 6L14.9999 1.5C14.9999 1.22386 14.776 1 14.4999 1Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$8 = [\"color\"];\nvar AlignTopIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$8);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M1.5 0C1.22386 0 1 0.223858 1 0.5C1 0.776142 1.22386 1 1.5 1H6V12C6 12.5523 6.44772 13 7 13H8C8.55228 13 9 12.5523 9 12V1H13.5C13.7761 1 14 0.776142 14 0.5C14 0.223858 13.7761 0 13.5 0H9H6H1.5Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$a = [\"color\"];\nvar AngleIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$a);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M8.8914 2.1937C9.1158 2.35464 9.16725 2.66701 9.00631 2.89141L2.47388 12H13.5C13.7761 12 14 12.2239 14 12.5C14 12.7762 13.7761 13 13.5 13H1.5C1.31254 13 1.14082 12.8952 1.0552 12.7284C0.969578 12.5616 0.984438 12.361 1.09369 12.2086L8.19369 2.30862C8.35462 2.08422 8.667 2.03277 8.8914 2.1937ZM11.1 6.50001C11.1 6.22387 11.3238 6.00001 11.6 6.00001C11.8761 6.00001 12.1 6.22387 12.1 6.50001C12.1 6.77615 11.8761 7.00001 11.6 7.00001C11.3238 7.00001 11.1 6.77615 11.1 6.50001ZM10.4 4.00001C10.1239 4.00001 9.90003 4.22387 9.90003 4.50001C9.90003 4.77615 10.1239 5.00001 10.4 5.00001C10.6762 5.00001 10.9 4.77615 10.9 4.50001C10.9 4.22387 10.6762 4.00001 10.4 4.00001ZM12.1 8.50001C12.1 8.22387 12.3238 8.00001 12.6 8.00001C12.8761 8.00001 13.1 8.22387 13.1 8.50001C13.1 8.77615 12.8761 9.00001 12.6 9.00001C12.3238 9.00001 12.1 8.77615 12.1 8.50001ZM13.4 10C13.1239 10 12.9 10.2239 12.9 10.5C12.9 10.7761 13.1239 11 13.4 11C13.6762 11 13.9 10.7761 13.9 10.5C13.9 10.2239 13.6762 10 13.4 10Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$e = [\"color\"];\nvar ArrowDownIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$e);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M7.5 2C7.77614 2 8 2.22386 8 2.5L8 11.2929L11.1464 8.14645C11.3417 7.95118 11.6583 7.95118 11.8536 8.14645C12.0488 8.34171 12.0488 8.65829 11.8536 8.85355L7.85355 12.8536C7.75979 12.9473 7.63261 13 7.5 13C7.36739 13 7.24021 12.9473 7.14645 12.8536L3.14645 8.85355C2.95118 8.65829 2.95118 8.34171 3.14645 8.14645C3.34171 7.95118 3.65829 7.95118 3.85355 8.14645L7 11.2929L7 2.5C7 2.22386 7.22386 2 7.5 2Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$i = [\"color\"];\nvar ArrowTopRightIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$i);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M3.64645 11.3536C3.45118 11.1583 3.45118 10.8417 3.64645 10.6465L10.2929 4L6 4C5.72386 4 5.5 3.77614 5.5 3.5C5.5 3.22386 5.72386 3 6 3L11.5 3C11.6326 3 11.7598 3.05268 11.8536 3.14645C11.9473 3.24022 12 3.36739 12 3.5L12 9.00001C12 9.27615 11.7761 9.50001 11.5 9.50001C11.2239 9.50001 11 9.27615 11 9.00001V4.70711L4.35355 11.3536C4.15829 11.5488 3.84171 11.5488 3.64645 11.3536Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$j = [\"color\"];\nvar ArrowUpIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$j);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M7.14645 2.14645C7.34171 1.95118 7.65829 1.95118 7.85355 2.14645L11.8536 6.14645C12.0488 6.34171 12.0488 6.65829 11.8536 6.85355C11.6583 7.04882 11.3417 7.04882 11.1464 6.85355L8 3.70711L8 12.5C8 12.7761 7.77614 13 7.5 13C7.22386 13 7 12.7761 7 12.5L7 3.70711L3.85355 6.85355C3.65829 7.04882 3.34171 7.04882 3.14645 6.85355C2.95118 6.65829 2.95118 6.34171 3.14645 6.14645L7.14645 2.14645Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$k = [\"color\"];\nvar AspectRatioIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$k);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M2.5 2H12.5C12.7761 2 13 2.22386 13 2.5V12.5C13 12.7761 12.7761 13 12.5 13H2.5C2.22386 13 2 12.7761 2 12.5V2.5C2 2.22386 2.22386 2 2.5 2ZM1 2.5C1 1.67157 1.67157 1 2.5 1H12.5C13.3284 1 14 1.67157 14 2.5V12.5C14 13.3284 13.3284 14 12.5 14H2.5C1.67157 14 1 13.3284 1 12.5V2.5ZM7.5 4C7.77614 4 8 3.77614 8 3.5C8 3.22386 7.77614 3 7.5 3C7.22386 3 7 3.22386 7 3.5C7 3.77614 7.22386 4 7.5 4ZM8 5.5C8 5.77614 7.77614 6 7.5 6C7.22386 6 7 5.77614 7 5.5C7 5.22386 7.22386 5 7.5 5C7.77614 5 8 5.22386 8 5.5ZM7.5 8C7.77614 8 8 7.77614 8 7.5C8 7.22386 7.77614 7 7.5 7C7.22386 7 7 7.22386 7 7.5C7 7.77614 7.22386 8 7.5 8ZM10 7.5C10 7.77614 9.77614 8 9.5 8C9.22386 8 9 7.77614 9 7.5C9 7.22386 9.22386 7 9.5 7C9.77614 7 10 7.22386 10 7.5ZM11.5 8C11.7761 8 12 7.77614 12 7.5C12 7.22386 11.7761 7 11.5 7C11.2239 7 11 7.22386 11 7.5C11 7.77614 11.2239 8 11.5 8Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$F = [\"color\"];\nvar BoxIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$F);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M12.5 2H2.5C2.22386 2 2 2.22386 2 2.5V12.5C2 12.7761 2.22386 13 2.5 13H12.5C12.7761 13 13 12.7761 13 12.5V2.5C13 2.22386 12.7761 2 12.5 2ZM2.5 1C1.67157 1 1 1.67157 1 2.5V12.5C1 13.3284 1.67157 14 2.5 14H12.5C13.3284 14 14 13.3284 14 12.5V2.5C14 1.67157 13.3284 1 12.5 1H2.5Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$T = [\"color\"];\nvar CheckIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$T);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$Y = [\"color\"];\nvar ChevronRightIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$Y);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M6.1584 3.13508C6.35985 2.94621 6.67627 2.95642 6.86514 3.15788L10.6151 7.15788C10.7954 7.3502 10.7954 7.64949 10.6151 7.84182L6.86514 11.8418C6.67627 12.0433 6.35985 12.0535 6.1584 11.8646C5.95694 11.6757 5.94673 11.3593 6.1356 11.1579L9.565 7.49985L6.1356 3.84182C5.94673 3.64036 5.95694 3.32394 6.1584 3.13508Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$_ = [\"color\"];\nvar CircleIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$_);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M0.877075 7.49991C0.877075 3.84222 3.84222 0.877075 7.49991 0.877075C11.1576 0.877075 14.1227 3.84222 14.1227 7.49991C14.1227 11.1576 11.1576 14.1227 7.49991 14.1227C3.84222 14.1227 0.877075 11.1576 0.877075 7.49991ZM7.49991 1.82708C4.36689 1.82708 1.82708 4.36689 1.82708 7.49991C1.82708 10.6329 4.36689 13.1727 7.49991 13.1727C10.6329 13.1727 13.1727 10.6329 13.1727 7.49991C13.1727 4.36689 10.6329 1.82708 7.49991 1.82708Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$1h = [\"color\"];\nvar CopyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$1h);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M1 9.50006C1 10.3285 1.67157 11.0001 2.5 11.0001H4L4 10.0001H2.5C2.22386 10.0001 2 9.7762 2 9.50006L2 2.50006C2 2.22392 2.22386 2.00006 2.5 2.00006L9.5 2.00006C9.77614 2.00006 10 2.22392 10 2.50006V4.00002H5.5C4.67158 4.00002 4 4.67159 4 5.50002V12.5C4 13.3284 4.67158 14 5.5 14H12.5C13.3284 14 14 13.3284 14 12.5V5.50002C14 4.67159 13.3284 4.00002 12.5 4.00002H11V2.50006C11 1.67163 10.3284 1.00006 9.5 1.00006H2.5C1.67157 1.00006 1 1.67163 1 2.50006V9.50006ZM5 5.50002C5 5.22388 5.22386 5.00002 5.5 5.00002H12.5C12.7761 5.00002 13 5.22388 13 5.50002V12.5C13 12.7762 12.7761 13 12.5 13H5.5C5.22386 13 5 12.7762 5 12.5V5.50002Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$1x = [\"color\"];\nvar CursorArrowIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$1x);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M3.29227 0.048984C3.47033 -0.032338 3.67946 -0.00228214 3.8274 0.125891L12.8587 7.95026C13.0134 8.08432 13.0708 8.29916 13.0035 8.49251C12.9362 8.68586 12.7578 8.81866 12.5533 8.82768L9.21887 8.97474L11.1504 13.2187C11.2648 13.47 11.1538 13.7664 10.9026 13.8808L8.75024 14.8613C8.499 14.9758 8.20255 14.8649 8.08802 14.6137L6.15339 10.3703L3.86279 12.7855C3.72196 12.934 3.50487 12.9817 3.31479 12.9059C3.1247 12.8301 3 12.6461 3 12.4414V0.503792C3 0.308048 3.11422 0.130306 3.29227 0.048984ZM4 1.59852V11.1877L5.93799 9.14425C6.05238 9.02363 6.21924 8.96776 6.38319 8.99516C6.54715 9.02256 6.68677 9.12965 6.75573 9.2809L8.79056 13.7441L10.0332 13.178L8.00195 8.71497C7.93313 8.56376 7.94391 8.38824 8.03072 8.24659C8.11753 8.10494 8.26903 8.01566 8.435 8.00834L11.2549 7.88397L4 1.59852Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$1I = [\"color\"];\nvar DotFilledIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$1I);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M9.875 7.5C9.875 8.81168 8.81168 9.875 7.5 9.875C6.18832 9.875 5.125 8.81168 5.125 7.5C5.125 6.18832 6.18832 5.125 7.5 5.125C8.81168 5.125 9.875 6.18832 9.875 7.5Z\",\n    fill: color\n  }));\n});\nvar _excluded$1J = [\"color\"];\nvar DotsHorizontalIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$1J);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M3.625 7.5C3.625 8.12132 3.12132 8.625 2.5 8.625C1.87868 8.625 1.375 8.12132 1.375 7.5C1.375 6.87868 1.87868 6.375 2.5 6.375C3.12132 6.375 3.625 6.87868 3.625 7.5ZM8.625 7.5C8.625 8.12132 8.12132 8.625 7.5 8.625C6.87868 8.625 6.375 8.12132 6.375 7.5C6.375 6.87868 6.87868 6.375 7.5 6.375C8.12132 6.375 8.625 6.87868 8.625 7.5ZM12.5 8.625C13.1213 8.625 13.625 8.12132 13.625 7.5C13.625 6.87868 13.1213 6.375 12.5 6.375C11.8787 6.375 11.375 6.87868 11.375 7.5C11.375 8.12132 11.8787 8.625 12.5 8.625Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$2p = [\"color\"];\nvar GroupIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$2p);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M1.44995 0.949951C1.31734 0.949951 1.19016 1.00263 1.0964 1.0964C1.00263 1.19017 0.949951 1.31735 0.949951 1.44995L0.949966 3.44995C0.949969 3.7261 1.17383 3.94995 1.44997 3.94995C1.72611 3.94995 1.94997 3.72609 1.94997 3.44995L1.94995 1.94995H3.44997C3.72611 1.94995 3.94997 1.72609 3.94997 1.44995C3.94997 1.17381 3.72611 0.949951 3.44997 0.949951H1.44995ZM5.94995 0.949951C5.67381 0.949951 5.44995 1.17381 5.44995 1.44995C5.44995 1.72609 5.67381 1.94995 5.94995 1.94995H8.94995C9.22609 1.94995 9.44995 1.72609 9.44995 1.44995C9.44995 1.17381 9.22609 0.949951 8.94995 0.949951H5.94995ZM5.44995 13.45C5.44995 13.1738 5.67381 12.95 5.94995 12.95H8.94995C9.22609 12.95 9.44995 13.1738 9.44995 13.45C9.44995 13.7261 9.22609 13.95 8.94995 13.95H5.94995C5.67381 13.95 5.44995 13.7261 5.44995 13.45ZM1.94995 5.94995C1.94995 5.67381 1.72609 5.44995 1.44995 5.44995C1.17381 5.44995 0.949951 5.67381 0.949951 5.94995V8.94995C0.949951 9.22609 1.17381 9.44995 1.44995 9.44995C1.72609 9.44995 1.94995 9.22609 1.94995 8.94995V5.94995ZM13.45 5.44995C13.7261 5.44995 13.95 5.67381 13.95 5.94995V8.94995C13.95 9.22609 13.7261 9.44995 13.45 9.44995C13.1738 9.44995 12.95 9.22609 12.95 8.94995V5.94995C12.95 5.67381 13.1738 5.44995 13.45 5.44995ZM11.45 0.949951C11.1738 0.949951 10.95 1.17381 10.95 1.44995C10.95 1.72609 11.1738 1.94995 11.45 1.94995H12.9499V3.44995C12.9499 3.72609 13.1738 3.94995 13.4499 3.94995C13.7261 3.94995 13.9499 3.72609 13.9499 3.44995V1.44995C13.9499 1.17381 13.7252 0.949951 13.449 0.949951H11.45ZM1.44995 10.95C1.72609 10.95 1.94995 11.1738 1.94995 11.45V12.95H3.44997C3.72611 12.95 3.94997 13.1738 3.94997 13.45C3.94997 13.7261 3.72611 13.95 3.44997 13.95H1.44995C1.17381 13.95 0.949951 13.7261 0.949951 13.45V11.45C0.949951 11.1738 1.17381 10.95 1.44995 10.95ZM13.95 11.45C13.95 11.1738 13.7261 10.95 13.45 10.95C13.1738 10.9499 12.95 11.1738 12.95 11.4499L12.9491 12.95H11.45C11.1738 12.95 10.95 13.1738 10.95 13.45C10.95 13.7261 11.1738 13.95 11.45 13.95H13.4499C13.7261 13.95 13.9499 13.7261 13.9499 13.45L13.95 11.45Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$2s = [\"color\"];\nvar HamburgerMenuIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$2s);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M1.5 3C1.22386 3 1 3.22386 1 3.5C1 3.77614 1.22386 4 1.5 4H13.5C13.7761 4 14 3.77614 14 3.5C14 3.22386 13.7761 3 13.5 3H1.5ZM1 7.5C1 7.22386 1.22386 7 1.5 7H13.5C13.7761 7 14 7.22386 14 7.5C14 7.77614 13.7761 8 13.5 8H1.5C1.22386 8 1 7.77614 1 7.5ZM1 11.5C1 11.2239 1.22386 11 1.5 11H13.5C13.7761 11 14 11.2239 14 11.5C14 11.7761 13.7761 12 13.5 12H1.5C1.22386 12 1 11.7761 1 11.5Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$2C = [\"color\"];\nvar ImageIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$2C);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M2.5 1H12.5C13.3284 1 14 1.67157 14 2.5V12.5C14 13.3284 13.3284 14 12.5 14H2.5C1.67157 14 1 13.3284 1 12.5V2.5C1 1.67157 1.67157 1 2.5 1ZM2.5 2C2.22386 2 2 2.22386 2 2.5V8.3636L3.6818 6.6818C3.76809 6.59551 3.88572 6.54797 4.00774 6.55007C4.12975 6.55216 4.24568 6.60372 4.32895 6.69293L7.87355 10.4901L10.6818 7.6818C10.8575 7.50607 11.1425 7.50607 11.3182 7.6818L13 9.3636V2.5C13 2.22386 12.7761 2 12.5 2H2.5ZM2 12.5V9.6364L3.98887 7.64753L7.5311 11.4421L8.94113 13H2.5C2.22386 13 2 12.7761 2 12.5ZM12.5 13H10.155L8.48336 11.153L11 8.6364L13 10.6364V12.5C13 12.7761 12.7761 13 12.5 13ZM6.64922 5.5C6.64922 5.03013 7.03013 4.64922 7.5 4.64922C7.96987 4.64922 8.35078 5.03013 8.35078 5.5C8.35078 5.96987 7.96987 6.35078 7.5 6.35078C7.03013 6.35078 6.64922 5.96987 6.64922 5.5ZM7.5 3.74922C6.53307 3.74922 5.74922 4.53307 5.74922 5.5C5.74922 6.46693 6.53307 7.25078 7.5 7.25078C8.46693 7.25078 9.25078 6.46693 9.25078 5.5C9.25078 4.53307 8.46693 3.74922 7.5 3.74922Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$2_ = [\"color\"];\nvar LockClosedIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$2_);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M5 4.63601C5 3.76031 5.24219 3.1054 5.64323 2.67357C6.03934 2.24705 6.64582 1.9783 7.5014 1.9783C8.35745 1.9783 8.96306 2.24652 9.35823 2.67208C9.75838 3.10299 10 3.75708 10 4.63325V5.99999H5V4.63601ZM4 5.99999V4.63601C4 3.58148 4.29339 2.65754 4.91049 1.99307C5.53252 1.32329 6.42675 0.978302 7.5014 0.978302C8.57583 0.978302 9.46952 1.32233 10.091 1.99162C10.7076 2.65557 11 3.57896 11 4.63325V5.99999H12C12.5523 5.99999 13 6.44771 13 6.99999V13C13 13.5523 12.5523 14 12 14H3C2.44772 14 2 13.5523 2 13V6.99999C2 6.44771 2.44772 5.99999 3 5.99999H4ZM3 6.99999H12V13H3V6.99999Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$2$ = [\"color\"];\nvar LockOpen1Icon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$2$);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M7.4986 0C6.3257 0 5.36107 0.38943 4.73753 1.19361C4.23745 1.83856 4 2.68242 4 3.63325H5C5 2.84313 5.19691 2.23312 5.5278 1.80636C5.91615 1.30552 6.55152 1 7.4986 1C8.35683 1 8.96336 1.26502 9.35846 1.68623C9.75793 2.11211 10 2.76044 10 3.63601V6H3C2.44772 6 2 6.44772 2 7V13C2 13.5523 2.44772 14 3 14H12C12.5523 14 13 13.5523 13 13V7C13 6.44771 12.5523 6 12 6H11V3.63601C11 2.58135 10.7065 1.66167 10.0878 1.0021C9.46477 0.337871 8.57061 0 7.4986 0ZM3 7H12V13H3V7Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$3b = [\"color\"];\nvar MixerVerticalIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3b);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M5 1.5C5 1.22386 4.77614 1 4.5 1C4.22386 1 4 1.22386 4 1.5L4 7C4 7.01671 4.00082 7.03323 4.00242 7.04952C2.86009 7.28022 2 8.28967 2 9.5C2 10.7103 2.86009 11.7198 4.00242 11.9505C4.00082 11.9668 4 11.9833 4 12V13.5C4 13.7761 4.22386 14 4.5 14C4.77614 14 5 13.7761 5 13.5V12C5 11.9833 4.99918 11.9668 4.99758 11.9505C6.1399 11.7198 7 10.7103 7 9.5C7 8.28967 6.1399 7.28022 4.99758 7.04952C4.99918 7.03323 5 7.01671 5 7L5 1.5ZM11 1.5C11 1.22386 10.7761 1 10.5 1C10.2239 1 10 1.22386 10 1.5V3C10 3.01671 10.0008 3.03323 10.0024 3.04952C8.8601 3.28022 8 4.28967 8 5.5C8 6.71033 8.8601 7.71978 10.0024 7.95048C10.0008 7.96677 10 7.98329 10 8V13.5C10 13.7761 10.2239 14 10.5 14C10.7761 14 11 13.7761 11 13.5V8C11 7.98329 10.9992 7.96677 10.9976 7.95048C12.1399 7.71978 13 6.71033 13 5.5C13 4.28967 12.1399 3.28022 10.9976 3.04952C10.9992 3.03323 11 3.01671 11 3V1.5ZM4.5 8C3.67157 8 3 8.67157 3 9.5C3 10.3284 3.67157 11 4.5 11C5.32843 11 6 10.3284 6 9.5C6 8.67157 5.32843 8 4.5 8ZM9 5.5C9 4.67157 9.67157 4 10.5 4C11.3284 4 12 4.67157 12 5.5C12 6.32843 11.3284 7 10.5 7C9.67157 7 9 6.32843 9 5.5Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$3n = [\"color\"];\nvar Pencil1Icon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3n);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M11.8536 1.14645C11.6583 0.951184 11.3417 0.951184 11.1465 1.14645L3.71455 8.57836C3.62459 8.66832 3.55263 8.77461 3.50251 8.89155L2.04044 12.303C1.9599 12.491 2.00189 12.709 2.14646 12.8536C2.29103 12.9981 2.50905 13.0401 2.69697 12.9596L6.10847 11.4975C6.2254 11.4474 6.3317 11.3754 6.42166 11.2855L13.8536 3.85355C14.0488 3.65829 14.0488 3.34171 13.8536 3.14645L11.8536 1.14645ZM4.42166 9.28547L11.5 2.20711L12.7929 3.5L5.71455 10.5784L4.21924 11.2192L3.78081 10.7808L4.42166 9.28547Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$3o = [\"color\"];\nvar Pencil2Icon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3o);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M12.1464 1.14645C12.3417 0.951184 12.6583 0.951184 12.8535 1.14645L14.8535 3.14645C15.0488 3.34171 15.0488 3.65829 14.8535 3.85355L10.9109 7.79618C10.8349 7.87218 10.7471 7.93543 10.651 7.9835L6.72359 9.94721C6.53109 10.0435 6.29861 10.0057 6.14643 9.85355C5.99425 9.70137 5.95652 9.46889 6.05277 9.27639L8.01648 5.34897C8.06455 5.25283 8.1278 5.16507 8.2038 5.08907L12.1464 1.14645ZM12.5 2.20711L8.91091 5.79618L7.87266 7.87267L8.12731 8.12732L10.2038 7.08907L13.7929 3.5L12.5 2.20711ZM9.99998 2L8.99998 3H4.9C4.47171 3 4.18056 3.00039 3.95552 3.01877C3.73631 3.03668 3.62421 3.06915 3.54601 3.10899C3.35785 3.20487 3.20487 3.35785 3.10899 3.54601C3.06915 3.62421 3.03669 3.73631 3.01878 3.95552C3.00039 4.18056 3 4.47171 3 4.9V11.1C3 11.5283 3.00039 11.8194 3.01878 12.0445C3.03669 12.2637 3.06915 12.3758 3.10899 12.454C3.20487 12.6422 3.35785 12.7951 3.54601 12.891C3.62421 12.9309 3.73631 12.9633 3.95552 12.9812C4.18056 12.9996 4.47171 13 4.9 13H11.1C11.5283 13 11.8194 12.9996 12.0445 12.9812C12.2637 12.9633 12.3758 12.9309 12.454 12.891C12.6422 12.7951 12.7951 12.6422 12.891 12.454C12.9309 12.3758 12.9633 12.2637 12.9812 12.0445C12.9996 11.8194 13 11.5283 13 11.1V6.99998L14 5.99998V11.1V11.1207C14 11.5231 14 11.8553 13.9779 12.1259C13.9549 12.407 13.9057 12.6653 13.782 12.908C13.5903 13.2843 13.2843 13.5903 12.908 13.782C12.6653 13.9057 12.407 13.9549 12.1259 13.9779C11.8553 14 11.5231 14 11.1207 14H11.1H4.9H4.87934C4.47686 14 4.14468 14 3.87409 13.9779C3.59304 13.9549 3.33469 13.9057 3.09202 13.782C2.7157 13.5903 2.40973 13.2843 2.21799 12.908C2.09434 12.6653 2.04506 12.407 2.0221 12.1259C1.99999 11.8553 1.99999 11.5231 2 11.1207V11.1206V11.1V4.9V4.87935V4.87932V4.87931C1.99999 4.47685 1.99999 4.14468 2.0221 3.87409C2.04506 3.59304 2.09434 3.33469 2.21799 3.09202C2.40973 2.71569 2.7157 2.40973 3.09202 2.21799C3.33469 2.09434 3.59304 2.04506 3.87409 2.0221C4.14468 1.99999 4.47685 1.99999 4.87932 2H4.87935H4.9H9.99998Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$3s = [\"color\"];\nvar PinBottomIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3s);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M13.5 13.95C13.7485 13.95 13.95 13.7485 13.95 13.5C13.95 13.2514 13.7485 13.05 13.5 13.05L1.49995 13.05C1.25142 13.05 1.04995 13.2514 1.04995 13.5C1.04995 13.7485 1.25142 13.95 1.49995 13.95L13.5 13.95ZM11.0681 7.5683C11.2439 7.39257 11.2439 7.10764 11.0681 6.93191C10.8924 6.75617 10.6075 6.75617 10.4317 6.93191L7.94993 9.41371L7.94993 1.49998C7.94993 1.25146 7.74846 1.04998 7.49993 1.04998C7.2514 1.04998 7.04993 1.25146 7.04993 1.49998L7.04993 9.41371L4.56813 6.93191C4.39239 6.75617 4.10746 6.75617 3.93173 6.93191C3.75599 7.10764 3.75599 7.39257 3.93173 7.5683L7.18173 10.8183C7.35746 10.994 7.64239 10.994 7.81812 10.8183L11.0681 7.5683Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$3v = [\"color\"];\nvar PinTopIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3v);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M1.50005 1.05005C1.25152 1.05005 1.05005 1.25152 1.05005 1.50005C1.05005 1.74858 1.25152 1.95005 1.50005 1.95005L13.5 1.95005C13.7486 1.95005 13.95 1.74858 13.95 1.50005C13.95 1.25152 13.7486 1.05005 13.5 1.05005H1.50005ZM3.93188 7.43169C3.75614 7.60743 3.75614 7.89236 3.93188 8.06809C4.10761 8.24383 4.39254 8.24383 4.56827 8.06809L7.05007 5.58629V13.5C7.05007 13.7485 7.25155 13.95 7.50007 13.95C7.7486 13.95 7.95007 13.7485 7.95007 13.5L7.95007 5.58629L10.4319 8.06809C10.6076 8.24383 10.8925 8.24383 11.0683 8.06809C11.244 7.89235 11.244 7.60743 11.0683 7.43169L7.81827 4.18169C7.64254 4.00596 7.35761 4.00596 7.18188 4.18169L3.93188 7.43169Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$3x = [\"color\"];\nvar PlusIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3x);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M8 2.75C8 2.47386 7.77614 2.25 7.5 2.25C7.22386 2.25 7 2.47386 7 2.75V7H2.75C2.47386 7 2.25 7.22386 2.25 7.5C2.25 7.77614 2.47386 8 2.75 8H7V12.25C7 12.5261 7.22386 12.75 7.5 12.75C7.77614 12.75 8 12.5261 8 12.25V8H12.25C12.5261 8 12.75 7.77614 12.75 7.5C12.75 7.22386 12.5261 7 12.25 7H8V2.75Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$3I = [\"color\"];\nvar RotateCounterClockwiseIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$3I);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M7.59664 2.93628C7.76085 3.06401 8.00012 2.94698 8.00012 2.73895V1.99998C9.98143 2 11.1848 2.3637 11.9105 3.08945C12.6363 3.81522 13 5.0186 13 6.99998C13 7.27613 13.2239 7.49998 13.5 7.49998C13.7761 7.49998 14 7.27613 14 6.99998C14 4.9438 13.6325 3.39719 12.6176 2.38234C11.6028 1.36752 10.0562 0.999999 8.00012 0.999984V0.261266C8.00012 0.0532293 7.76085 -0.0637944 7.59664 0.063928L6.00384 1.30277C5.87516 1.40286 5.87516 1.59735 6.00384 1.69744L7.59664 2.93628ZM9.5 5H2.5C2.22386 5 2 5.22386 2 5.5V12.5C2 12.7761 2.22386 13 2.5 13H9.5C9.77614 13 10 12.7761 10 12.5V5.5C10 5.22386 9.77614 5 9.5 5ZM2.5 4C1.67157 4 1 4.67157 1 5.5V12.5C1 13.3284 1.67157 14 2.5 14H9.5C10.3284 14 11 13.3284 11 12.5V5.5C11 4.67157 10.3284 4 9.5 4H2.5Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$42 = [\"color\"];\nvar SpaceEvenlyHorizontallyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$42);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M14.4999 0.999992C14.2237 0.999992 13.9999 1.22385 13.9999 1.49999L13.9999 13.4999C13.9999 13.776 14.2237 13.9999 14.4999 13.9999C14.776 13.9999 14.9999 13.776 14.9999 13.4999L14.9999 1.49999C14.9999 1.22385 14.776 0.999992 14.4999 0.999992ZM0.499996 0.999992C0.223856 0.999992 -9.78509e-09 1.22385 -2.18556e-08 1.49999L4.07279e-07 13.4999C3.95208e-07 13.776 0.223855 13.9999 0.499996 13.9999C0.776136 13.9999 0.999992 13.776 0.999992 13.4999L0.999992 1.49999C0.999992 1.22385 0.776136 0.999992 0.499996 0.999992ZM1.99998 6.99994C1.99998 6.44766 2.44769 5.99995 2.99998 5.99995L5.99995 5.99995C6.55223 5.99995 6.99994 6.44766 6.99994 6.99994L6.99994 7.99993C6.99994 8.55221 6.55223 8.99992 5.99995 8.99992L2.99998 8.99992C2.4477 8.99992 1.99998 8.55221 1.99998 7.99993L1.99998 6.99994ZM8.99993 5.99995C8.44765 5.99995 7.99993 6.44766 7.99993 6.99994L7.99993 7.99993C7.99993 8.55221 8.44765 8.99992 8.99993 8.99992L11.9999 8.99992C12.5522 8.99992 12.9999 8.55221 12.9999 7.99993L12.9999 6.99994C12.9999 6.44766 12.5522 5.99995 11.9999 5.99995L8.99993 5.99995Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$43 = [\"color\"];\nvar SpaceEvenlyVerticallyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$43);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M0.999878 0.5C0.999878 0.223858 1.22374 0 1.49988 0H13.4999C13.776 0 13.9999 0.223858 13.9999 0.5C13.9999 0.776142 13.776 1 13.4999 1H1.49988C1.22374 1 0.999878 0.776142 0.999878 0.5ZM7 2C6.44772 2 6 2.44772 6 3V6C6 6.55228 6.44772 7 7 7H8C8.55228 7 9 6.55228 9 6V3C9 2.44772 8.55228 2 8 2H7ZM7 8C6.44772 8 6 8.44771 6 9V12C6 12.5523 6.44772 13 7 13H8C8.55228 13 9 12.5523 9 12V9C9 8.44772 8.55228 8 8 8H7ZM1.49988 14C1.22374 14 0.999878 14.2239 0.999878 14.5C0.999878 14.7761 1.22374 15 1.49988 15H13.4999C13.776 15 13.9999 14.7761 13.9999 14.5C13.9999 14.2239 13.776 14 13.4999 14H1.49988Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$48 = [\"color\"];\nvar SquareIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$48);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M1 1H1.5H13.5H14V1.5V13.5V14H13.5H1.5H1V13.5V1.5V1ZM2 2V13H13V2H2Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$4f = [\"color\"];\nvar StretchHorizontallyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4f);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M14.4999 0.999992C14.2237 0.999992 13.9999 1.22385 13.9999 1.49999L13.9999 5.99995L0.999992 5.99995L0.999992 1.49999C0.999992 1.22385 0.776136 0.999992 0.499996 0.999992C0.223856 0.999992 -9.78509e-09 1.22385 -2.18556e-08 1.49999L4.07279e-07 13.4999C3.95208e-07 13.776 0.223855 13.9999 0.499996 13.9999C0.776136 13.9999 0.999992 13.776 0.999992 13.4999L0.999992 8.99992L13.9999 8.99992L13.9999 13.4999C13.9999 13.776 14.2237 13.9999 14.4999 13.9999C14.776 13.9999 14.9999 13.776 14.9999 13.4999L14.9999 1.49999C14.9999 1.22385 14.776 0.999992 14.4999 0.999992Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$4g = [\"color\"];\nvar StretchVerticallyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4g);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M0.999878 0.5C0.999878 0.223858 1.22374 0 1.49988 0H13.4999C13.776 0 13.9999 0.223858 13.9999 0.5C13.9999 0.776142 13.776 1 13.4999 1H6H1.49988C1.22374 1 0.999878 0.776142 0.999878 0.5ZM9 14V1L6 1V14H1.49988C1.22374 14 0.999878 14.2239 0.999878 14.5C0.999878 14.7761 1.22374 15 1.49988 15H13.4999C13.776 15 13.9999 14.7761 13.9999 14.5C13.9999 14.2239 13.776 14 13.4999 14H9Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$4n = [\"color\"];\nvar TextIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4n);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M3.94993 2.95002L3.94993 4.49998C3.94993 4.74851 3.74845 4.94998 3.49993 4.94998C3.2514 4.94998 3.04993 4.74851 3.04993 4.49998V2.50004C3.04993 2.45246 3.05731 2.40661 3.07099 2.36357C3.12878 2.18175 3.29897 2.05002 3.49993 2.05002H11.4999C11.6553 2.05002 11.7922 2.12872 11.8731 2.24842C11.9216 2.32024 11.9499 2.40682 11.9499 2.50002L11.9499 2.50004V4.49998C11.9499 4.74851 11.7485 4.94998 11.4999 4.94998C11.2514 4.94998 11.0499 4.74851 11.0499 4.49998V2.95002H8.04993V12.05H9.25428C9.50281 12.05 9.70428 12.2515 9.70428 12.5C9.70428 12.7486 9.50281 12.95 9.25428 12.95H5.75428C5.50575 12.95 5.30428 12.7486 5.30428 12.5C5.30428 12.2515 5.50575 12.05 5.75428 12.05H6.94993V2.95002H3.94993Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$4p = [\"color\"];\nvar TextAlignCenterIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4p);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM4 7.5C4 7.22386 4.22386 7 4.5 7H10.5C10.7761 7 11 7.22386 11 7.5C11 7.77614 10.7761 8 10.5 8H4.5C4.22386 8 4 7.77614 4 7.5ZM3 10.5C3 10.2239 3.22386 10 3.5 10H11.5C11.7761 10 12 10.2239 12 10.5C12 10.7761 11.7761 11 11.5 11H3.5C3.22386 11 3 10.7761 3 10.5Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$4q = [\"color\"];\nvar TextAlignJustifyIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4q);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M2.5 4C2.22386 4 2 4.22386 2 4.5C2 4.77614 2.22386 5 2.5 5H12.5C12.7761 5 13 4.77614 13 4.5C13 4.22386 12.7761 4 12.5 4H2.5ZM2 7.5C2 7.22386 2.22386 7 2.5 7H12.5C12.7761 7 13 7.22386 13 7.5C13 7.77614 12.7761 8 12.5 8H2.5C2.22386 8 2 7.77614 2 7.5ZM2 10.5C2 10.2239 2.22386 10 2.5 10H12.5C12.7761 10 13 10.2239 13 10.5C13 10.7761 12.7761 11 12.5 11H2.5C2.22386 11 2 10.7761 2 10.5Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$4r = [\"color\"];\nvar TextAlignLeftIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4r);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM2 7.5C2 7.22386 2.22386 7 2.5 7H7.5C7.77614 7 8 7.22386 8 7.5C8 7.77614 7.77614 8 7.5 8H2.5C2.22386 8 2 7.77614 2 7.5ZM2 10.5C2 10.2239 2.22386 10 2.5 10H10.5C10.7761 10 11 10.2239 11 10.5C11 10.7761 10.7761 11 10.5 11H2.5C2.22386 11 2 10.7761 2 10.5Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$4t = [\"color\"];\nvar TextAlignRightIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4t);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM7 7.5C7 7.22386 7.22386 7 7.5 7H12.5C12.7761 7 13 7.22386 13 7.5C13 7.77614 12.7761 8 12.5 8H7.5C7.22386 8 7 7.77614 7 7.5ZM4 10.5C4 10.2239 4.22386 10 4.5 10H12.5C12.7761 10 13 10.2239 13 10.5C13 10.7761 12.7761 11 12.5 11H4.5C4.22386 11 4 10.7761 4 10.5Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\nvar _excluded$4R = [\"color\"];\nvar VercelLogoIcon = /* @__PURE__ */ (0, import_react30.forwardRef)(function(_ref, forwardedRef) {\n  var _ref$color = _ref.color, color = _ref$color === void 0 ? \"currentColor\" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, _excluded$4R);\n  return (0, import_react30.createElement)(\"svg\", Object.assign({\n    width: \"15\",\n    height: \"15\",\n    viewBox: \"0 0 15 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props, {\n    ref: forwardedRef\n  }), (0, import_react30.createElement)(\"path\", {\n    d: \"M7.49998 1L6.92321 2.00307L1.17498 12L0.599976 13H1.7535H13.2464H14.4L13.825 12L8.07674 2.00307L7.49998 1ZM7.49998 3.00613L2.3285 12H12.6714L7.49998 3.00613Z\",\n    fill: color,\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  }));\n});\n\n// src/components/Tldraw/components/ContextMenu/ContextMenu.tsx\nvar React16 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/translations/main.json\nvar main_default = {\n  \"style.menu.color\": \"Color\",\n  \"style.menu.fill\": \"Fill\",\n  \"style.menu.dash\": \"Dash\",\n  \"style.menu.size\": \"Size\",\n  \"style.menu.keep.open\": \"Keep Open\",\n  \"style.menu.font\": \"Font\",\n  \"style.menu.align\": \"Align\",\n  styles: \"Styles\",\n  \"zoom.in\": \"Zoom In\",\n  \"zoom.out\": \"Zoom Out\",\n  to: \"To\",\n  \"menu.tools\": \"Tools\",\n  \"menu.transform\": \"Transform\",\n  \"menu.file\": \"File\",\n  \"menu.edit\": \"Edit\",\n  \"menu.view\": \"View\",\n  \"menu.preferences\": \"Preferences\",\n  \"menu.sign.in\": \"Sign In\",\n  \"menu.sign.out\": \"Sign Out\",\n  \"become.a.sponsor\": \"Become a Sponsor\",\n  \"zoom.to.content\": \"Back to content\",\n  \"zoom.to.selection\": \"Zoom to Selection\",\n  \"zoom.to.fit\": \"Zoom to Fit\",\n  \"zoom.to\": \"Zoom to\",\n  \"preferences.dark.mode\": \"Dark Mode\",\n  \"preferences.focus.mode\": \"Focus Mode\",\n  \"preferences.debug.mode\": \"Debug Mode\",\n  \"preferences.show.grid\": \"Show Grid\",\n  \"preferences.use.cad.selection\": \"Use CAD Selection\",\n  \"preferences.keep.stylemenu.open\": \"Keep Style Menu Open\",\n  \"preferences.always.show.snaps\": \"Always Show Snaps\",\n  \"preferences.rotate.handles\": \"Rotate Handles\",\n  \"preferences.binding.handles\": \"Binding Handles\",\n  \"preferences.clone.handles\": \"Clone Handles\",\n  undo: \"Undo\",\n  redo: \"Redo\",\n  cut: \"Cut\",\n  copy: \"Copy\",\n  paste: \"Paste\",\n  \"copy.as\": \"Copy As\",\n  \"export.as\": \"Export As\",\n  \"select.all\": \"Select All\",\n  \"select.none\": \"Select None\",\n  delete: \"Delete\",\n  \"new.project\": \"New Project\",\n  open: \"Open\",\n  save: \"Save\",\n  \"save.as\": \"Save As\",\n  \"upload.media\": \"Upload Media\",\n  \"create.page\": \"Create Page\",\n  \"new.page\": \"New Page\",\n  \"page.name\": \"Page Name\",\n  duplicate: \"Duplicate\",\n  cancel: \"Cancel\",\n  \"copy.invite.link\": \"Copy Invite Link\",\n  \"copy.readonly.link\": \"Copy ReadOnly Link\",\n  \"create.multiplayer.project\": \"Create a Multiplayer Project\",\n  \"copy.multiplayer.project\": \"Copy to Multiplayer Project\",\n  select: \"Select\",\n  eraser: \"Eraser\",\n  draw: \"Draw\",\n  arrow: \"Arrow\",\n  text: \"Text\",\n  sticky: \"Sticky\",\n  rectangle: \"Rectangle\",\n  ellipse: \"Ellipse\",\n  triangle: \"Triangle\",\n  line: \"Line\",\n  rotate: \"Rotate\",\n  \"lock.aspect.ratio\": \"Lock Aspect Ratio\",\n  \"unlock.aspect.ratio\": \"Unlock Aspect Ratio\",\n  group: \"Group\",\n  ungroup: \"Ungroup\",\n  \"move.to.back\": \"Move to Back\",\n  \"move.backward\": \"Move Backward\",\n  \"move.forward\": \"Move Forward\",\n  \"move.to.front\": \"Move to Front\",\n  \"reset.angle\": \"Reset Angle\",\n  lock: \"Lock\",\n  unlock: \"Unlock\",\n  \"align.distribute\": \"Align / Distribute\",\n  \"move.to.page\": \"Move to Page\",\n  \"flip.horizontal\": \"Flip Horizontal\",\n  \"flip.vertical\": \"Flip Vertical\",\n  move: \"Move\",\n  \"to.front\": \"To Front\",\n  forward: \"Forward\",\n  backward: \"Backward\",\n  back: \"To Back\",\n  language: \"Language\",\n  \"translation.link\": \"Learn More\",\n  \"dock.position\": \"Dock Position\",\n  bottom: \"Bottom\",\n  left: \"Left\",\n  right: \"Right\",\n  top: \"Top\",\n  page: \"Page\",\n  \"keyboard.shortcuts\": \"Keyboard shortcuts\",\n  search: \"Search\",\n  loading: \"Loading{dots}\",\n  \"export.background\": \"Export Background\",\n  transparent: \"Transparent\",\n  auto: \"Auto\",\n  light: \"Light\",\n  dark: \"Dark\",\n  github: \"Github\",\n  twitter: \"Twitter\",\n  discord: \"Discord\",\n  image: \"Image\",\n  \"align.left\": \"Align Left\",\n  \"align.center.x\": \"Align Horizontal Center\",\n  \"align.right\": \"Align Right\",\n  \"align.top\": \"Align Top\",\n  \"align.center.y\": \"Align Vertical Center\",\n  \"align.bottom\": \"Align Bottom\",\n  \"distribute.x\": \"Distribute Horizontal\",\n  \"distribute.y\": \"Distribute Vertical\",\n  \"stretch.x\": \"Stretch Horizontal\",\n  \"stretch.y\": \"Stretch Vertical\",\n  \"dialog.save.firsttime\": \"Do you want to save your current project?\",\n  \"dialog.save.again\": \"Do you want to save changes to your current project?\",\n  \"dialog.cancel\": \"Cancel\",\n  \"dialog.no\": \"No\",\n  \"dialog.yes\": \"Yes\",\n  \"enter.file.name\": \"Enter file name\"\n};\n\n// src/components/Tldraw/translations/FormattedMessage.tsx\nvar import_jsx_runtime = require(\"react/jsx-runtime\");\nfunction FormattedMessage({ id }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(\"span\", { children: main_default[id] });\n}\nfunction useIntl() {\n  return {\n    formatMessage({ id }) {\n      return main_default[id];\n    }\n  };\n}\n\n// node_modules/.pnpm/@stitches+react@1.2.8_react@18.2.0/node_modules/@stitches/react/dist/index.mjs\nvar import_react31 = __toESM(require(\"react\"), 1);\nvar e3 = \"colors\";\nvar t3 = \"sizes\";\nvar r3 = \"space\";\nvar n3 = { gap: r3, gridGap: r3, columnGap: r3, gridColumnGap: r3, rowGap: r3, gridRowGap: r3, inset: r3, insetBlock: r3, insetBlockEnd: r3, insetBlockStart: r3, insetInline: r3, insetInlineEnd: r3, insetInlineStart: r3, margin: r3, marginTop: r3, marginRight: r3, marginBottom: r3, marginLeft: r3, marginBlock: r3, marginBlockEnd: r3, marginBlockStart: r3, marginInline: r3, marginInlineEnd: r3, marginInlineStart: r3, padding: r3, paddingTop: r3, paddingRight: r3, paddingBottom: r3, paddingLeft: r3, paddingBlock: r3, paddingBlockEnd: r3, paddingBlockStart: r3, paddingInline: r3, paddingInlineEnd: r3, paddingInlineStart: r3, top: r3, right: r3, bottom: r3, left: r3, scrollMargin: r3, scrollMarginTop: r3, scrollMarginRight: r3, scrollMarginBottom: r3, scrollMarginLeft: r3, scrollMarginX: r3, scrollMarginY: r3, scrollMarginBlock: r3, scrollMarginBlockEnd: r3, scrollMarginBlockStart: r3, scrollMarginInline: r3, scrollMarginInlineEnd: r3, scrollMarginInlineStart: r3, scrollPadding: r3, scrollPaddingTop: r3, scrollPaddingRight: r3, scrollPaddingBottom: r3, scrollPaddingLeft: r3, scrollPaddingX: r3, scrollPaddingY: r3, scrollPaddingBlock: r3, scrollPaddingBlockEnd: r3, scrollPaddingBlockStart: r3, scrollPaddingInline: r3, scrollPaddingInlineEnd: r3, scrollPaddingInlineStart: r3, fontSize: \"fontSizes\", background: e3, backgroundColor: e3, backgroundImage: e3, borderImage: e3, border: e3, borderBlock: e3, borderBlockEnd: e3, borderBlockStart: e3, borderBottom: e3, borderBottomColor: e3, borderColor: e3, borderInline: e3, borderInlineEnd: e3, borderInlineStart: e3, borderLeft: e3, borderLeftColor: e3, borderRight: e3, borderRightColor: e3, borderTop: e3, borderTopColor: e3, caretColor: e3, color: e3, columnRuleColor: e3, fill: e3, outline: e3, outlineColor: e3, stroke: e3, textDecorationColor: e3, fontFamily: \"fonts\", fontWeight: \"fontWeights\", lineHeight: \"lineHeights\", letterSpacing: \"letterSpacings\", blockSize: t3, minBlockSize: t3, maxBlockSize: t3, inlineSize: t3, minInlineSize: t3, maxInlineSize: t3, width: t3, minWidth: t3, maxWidth: t3, height: t3, minHeight: t3, maxHeight: t3, flexBasis: t3, gridTemplateColumns: t3, gridTemplateRows: t3, borderWidth: \"borderWidths\", borderTopWidth: \"borderWidths\", borderRightWidth: \"borderWidths\", borderBottomWidth: \"borderWidths\", borderLeftWidth: \"borderWidths\", borderStyle: \"borderStyles\", borderTopStyle: \"borderStyles\", borderRightStyle: \"borderStyles\", borderBottomStyle: \"borderStyles\", borderLeftStyle: \"borderStyles\", borderRadius: \"radii\", borderTopLeftRadius: \"radii\", borderTopRightRadius: \"radii\", borderBottomRightRadius: \"radii\", borderBottomLeftRadius: \"radii\", boxShadow: \"shadows\", textShadow: \"shadows\", transition: \"transitions\", zIndex: \"zIndices\" };\nvar i3 = (e5, t5) => \"function\" == typeof t5 ? { \"()\": Function.prototype.toString.call(t5) } : t5;\nvar o3 = () => {\n  const e5 = /* @__PURE__ */ Object.create(null);\n  return (t5, r5, ...n5) => {\n    const o5 = ((e6) => JSON.stringify(e6, i3))(t5);\n    return o5 in e5 ? e5[o5] : e5[o5] = r5(t5, ...n5);\n  };\n};\nvar l5 = Symbol.for(\"sxs.internal\");\nvar s3 = (e5, t5) => Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t5));\nvar a5 = (e5) => {\n  for (const t5 in e5)\n    return true;\n  return false;\n};\nvar { hasOwnProperty: c3 } = Object.prototype;\nvar d4 = (e5) => e5.includes(\"-\") ? e5 : e5.replace(/[A-Z]/g, (e6) => \"-\" + e6.toLowerCase());\nvar g5 = /\\s+(?![^()]*\\))/;\nvar p4 = (e5) => (t5) => e5(...\"string\" == typeof t5 ? String(t5).split(g5) : [t5]);\nvar u3 = { appearance: (e5) => ({ WebkitAppearance: e5, appearance: e5 }), backfaceVisibility: (e5) => ({ WebkitBackfaceVisibility: e5, backfaceVisibility: e5 }), backdropFilter: (e5) => ({ WebkitBackdropFilter: e5, backdropFilter: e5 }), backgroundClip: (e5) => ({ WebkitBackgroundClip: e5, backgroundClip: e5 }), boxDecorationBreak: (e5) => ({ WebkitBoxDecorationBreak: e5, boxDecorationBreak: e5 }), clipPath: (e5) => ({ WebkitClipPath: e5, clipPath: e5 }), content: (e5) => ({ content: e5.includes('\"') || e5.includes(\"'\") || /^([A-Za-z]+\\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e5) ? e5 : `\"${e5}\"` }), hyphens: (e5) => ({ WebkitHyphens: e5, hyphens: e5 }), maskImage: (e5) => ({ WebkitMaskImage: e5, maskImage: e5 }), maskSize: (e5) => ({ WebkitMaskSize: e5, maskSize: e5 }), tabSize: (e5) => ({ MozTabSize: e5, tabSize: e5 }), textSizeAdjust: (e5) => ({ WebkitTextSizeAdjust: e5, textSizeAdjust: e5 }), userSelect: (e5) => ({ WebkitUserSelect: e5, userSelect: e5 }), marginBlock: p4((e5, t5) => ({ marginBlockStart: e5, marginBlockEnd: t5 || e5 })), marginInline: p4((e5, t5) => ({ marginInlineStart: e5, marginInlineEnd: t5 || e5 })), maxSize: p4((e5, t5) => ({ maxBlockSize: e5, maxInlineSize: t5 || e5 })), minSize: p4((e5, t5) => ({ minBlockSize: e5, minInlineSize: t5 || e5 })), paddingBlock: p4((e5, t5) => ({ paddingBlockStart: e5, paddingBlockEnd: t5 || e5 })), paddingInline: p4((e5, t5) => ({ paddingInlineStart: e5, paddingInlineEnd: t5 || e5 })) };\nvar h4 = /([\\d.]+)([^]*)/;\nvar f3 = (e5, t5) => e5.length ? e5.reduce((e6, r5) => (e6.push(...t5.map((e7) => e7.includes(\"&\") ? e7.replace(/&/g, /[ +>|~]/.test(r5) && /&.*&/.test(e7) ? `:is(${r5})` : r5) : r5 + \" \" + e7)), e6), []) : t5;\nvar m4 = (e5, t5) => e5 in b4 && \"string\" == typeof t5 ? t5.replace(/^((?:[^]*[^\\w-])?)(fit-content|stretch)((?:[^\\w-][^]*)?)$/, (t6, r5, n5, i4) => r5 + (\"stretch\" === n5 ? `-moz-available${i4};${d4(e5)}:${r5}-webkit-fill-available` : `-moz-fit-content${i4};${d4(e5)}:${r5}fit-content`) + i4) : String(t5);\nvar b4 = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 };\nvar S3 = (e5) => e5 ? e5 + \"-\" : \"\";\nvar k5 = (e5, t5, r5) => e5.replace(/([+-])?((?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[Ee][+-]?\\d+)?)?(\\$|--)([$\\w-]+)/g, (e6, n5, i4, o5, l7) => \"$\" == o5 == !!i4 ? e6 : (n5 || \"--\" == o5 ? \"calc(\" : \"\") + \"var(--\" + (\"$\" === o5 ? S3(t5) + (l7.includes(\"$\") ? \"\" : S3(r5)) + l7.replace(/\\$/g, \"-\") : l7) + \")\" + (n5 || \"--\" == o5 ? \"*\" + (n5 || \"\") + (i4 || \"1\") + \")\" : \"\"));\nvar y4 = /\\s*,\\s*(?![^()]*\\))/;\nvar B4 = Object.prototype.toString;\nvar $4 = (e5, t5, r5, n5, i4) => {\n  let o5, l7, s5;\n  const a7 = (e6, t6, r6) => {\n    let c5, g6;\n    const p6 = (e7) => {\n      for (c5 in e7) {\n        const R7 = 64 === c5.charCodeAt(0), z5 = R7 && Array.isArray(e7[c5]) ? e7[c5] : [e7[c5]];\n        for (g6 of z5) {\n          const e8 = /[A-Z]/.test($5 = c5) ? $5 : $5.replace(/-[^]/g, (e9) => e9[1].toUpperCase()), z6 = \"object\" == typeof g6 && g6 && g6.toString === B4 && (!n5.utils[e8] || !t6.length);\n          if (e8 in n5.utils && !z6) {\n            const t7 = n5.utils[e8];\n            if (t7 !== l7) {\n              l7 = t7, p6(t7(g6)), l7 = null;\n              continue;\n            }\n          } else if (e8 in u3) {\n            const t7 = u3[e8];\n            if (t7 !== s5) {\n              s5 = t7, p6(t7(g6)), s5 = null;\n              continue;\n            }\n          }\n          if (R7 && (b6 = c5.slice(1) in n5.media ? \"@media \" + n5.media[c5.slice(1)] : c5, c5 = b6.replace(/\\(\\s*([\\w-]+)\\s*(=|<|<=|>|>=)\\s*([\\w-]+)\\s*(?:(<|<=|>|>=)\\s*([\\w-]+)\\s*)?\\)/g, (e9, t7, r7, n6, i5, o6) => {\n            const l8 = h4.test(t7), s6 = 0.0625 * (l8 ? -1 : 1), [a8, c6] = l8 ? [n6, t7] : [t7, n6];\n            return \"(\" + (\"=\" === r7[0] ? \"\" : \">\" === r7[0] === l8 ? \"max-\" : \"min-\") + a8 + \":\" + (\"=\" !== r7[0] && 1 === r7.length ? c6.replace(h4, (e10, t8, n7) => Number(t8) + s6 * (\">\" === r7 ? 1 : -1) + n7) : c6) + (i5 ? \") and (\" + (\">\" === i5[0] ? \"min-\" : \"max-\") + a8 + \":\" + (1 === i5.length ? o6.replace(h4, (e10, t8, r8) => Number(t8) + s6 * (\">\" === i5 ? -1 : 1) + r8) : o6) : \"\") + \")\";\n          })), z6) {\n            const e9 = R7 ? r6.concat(c5) : [...r6], n6 = R7 ? [...t6] : f3(t6, c5.split(y4));\n            void 0 !== o5 && i4(x4(...o5)), o5 = void 0, a7(g6, n6, e9);\n          } else\n            void 0 === o5 && (o5 = [[], t6, r6]), c5 = R7 || 36 !== c5.charCodeAt(0) ? c5 : `--${S3(n5.prefix)}${c5.slice(1).replace(/\\$/g, \"-\")}`, g6 = z6 ? g6 : \"number\" == typeof g6 ? g6 && e8 in I2 ? String(g6) + \"px\" : String(g6) : k5(m4(e8, null == g6 ? \"\" : g6), n5.prefix, n5.themeMap[e8]), o5[0].push(`${R7 ? `${c5} ` : `${d4(c5)}:`}${g6}`);\n        }\n      }\n      var b6, $5;\n    };\n    p6(e6), void 0 !== o5 && i4(x4(...o5)), o5 = void 0;\n  };\n  a7(e5, t5, r5);\n};\nvar x4 = (e5, t5, r5) => `${r5.map((e6) => `${e6}{`).join(\"\")}${t5.length ? `${t5.join(\",\")}{` : \"\"}${e5.join(\";\")}${t5.length ? \"}\" : \"\"}${Array(r5.length ? r5.length + 1 : 0).join(\"}\")}`;\nvar I2 = { animationDelay: 1, animationDuration: 1, backgroundSize: 1, blockSize: 1, border: 1, borderBlock: 1, borderBlockEnd: 1, borderBlockEndWidth: 1, borderBlockStart: 1, borderBlockStartWidth: 1, borderBlockWidth: 1, borderBottom: 1, borderBottomLeftRadius: 1, borderBottomRightRadius: 1, borderBottomWidth: 1, borderEndEndRadius: 1, borderEndStartRadius: 1, borderInlineEnd: 1, borderInlineEndWidth: 1, borderInlineStart: 1, borderInlineStartWidth: 1, borderInlineWidth: 1, borderLeft: 1, borderLeftWidth: 1, borderRadius: 1, borderRight: 1, borderRightWidth: 1, borderSpacing: 1, borderStartEndRadius: 1, borderStartStartRadius: 1, borderTop: 1, borderTopLeftRadius: 1, borderTopRightRadius: 1, borderTopWidth: 1, borderWidth: 1, bottom: 1, columnGap: 1, columnRule: 1, columnRuleWidth: 1, columnWidth: 1, containIntrinsicSize: 1, flexBasis: 1, fontSize: 1, gap: 1, gridAutoColumns: 1, gridAutoRows: 1, gridTemplateColumns: 1, gridTemplateRows: 1, height: 1, inlineSize: 1, inset: 1, insetBlock: 1, insetBlockEnd: 1, insetBlockStart: 1, insetInline: 1, insetInlineEnd: 1, insetInlineStart: 1, left: 1, letterSpacing: 1, margin: 1, marginBlock: 1, marginBlockEnd: 1, marginBlockStart: 1, marginBottom: 1, marginInline: 1, marginInlineEnd: 1, marginInlineStart: 1, marginLeft: 1, marginRight: 1, marginTop: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, offsetDistance: 1, offsetRotate: 1, outline: 1, outlineOffset: 1, outlineWidth: 1, overflowClipMargin: 1, padding: 1, paddingBlock: 1, paddingBlockEnd: 1, paddingBlockStart: 1, paddingBottom: 1, paddingInline: 1, paddingInlineEnd: 1, paddingInlineStart: 1, paddingLeft: 1, paddingRight: 1, paddingTop: 1, perspective: 1, right: 1, rowGap: 1, scrollMargin: 1, scrollMarginBlock: 1, scrollMarginBlockEnd: 1, scrollMarginBlockStart: 1, scrollMarginBottom: 1, scrollMarginInline: 1, scrollMarginInlineEnd: 1, scrollMarginInlineStart: 1, scrollMarginLeft: 1, scrollMarginRight: 1, scrollMarginTop: 1, scrollPadding: 1, scrollPaddingBlock: 1, scrollPaddingBlockEnd: 1, scrollPaddingBlockStart: 1, scrollPaddingBottom: 1, scrollPaddingInline: 1, scrollPaddingInlineEnd: 1, scrollPaddingInlineStart: 1, scrollPaddingLeft: 1, scrollPaddingRight: 1, scrollPaddingTop: 1, shapeMargin: 1, textDecoration: 1, textDecorationThickness: 1, textIndent: 1, textUnderlineOffset: 1, top: 1, transitionDelay: 1, transitionDuration: 1, verticalAlign: 1, width: 1, wordSpacing: 1 };\nvar R6 = (e5) => String.fromCharCode(e5 + (e5 > 25 ? 39 : 97));\nvar z4 = (e5) => ((e6) => {\n  let t5, r5 = \"\";\n  for (t5 = Math.abs(e6); t5 > 52; t5 = t5 / 52 | 0)\n    r5 = R6(t5 % 52) + r5;\n  return R6(t5 % 52) + r5;\n})(((e6, t5) => {\n  let r5 = t5.length;\n  for (; r5; )\n    e6 = 33 * e6 ^ t5.charCodeAt(--r5);\n  return e6;\n})(5381, JSON.stringify(e5)) >>> 0);\nvar W4 = [\"themed\", \"global\", \"styled\", \"onevar\", \"resonevar\", \"allvar\", \"inline\"];\nvar j3 = (e5) => {\n  if (e5.href && !e5.href.startsWith(location.origin))\n    return false;\n  try {\n    return !!e5.cssRules;\n  } catch (e6) {\n    return false;\n  }\n};\nvar E4 = (e5) => {\n  let t5;\n  const r5 = () => {\n    const { cssRules: e6 } = t5.sheet;\n    return [].map.call(e6, (r6, n6) => {\n      const { cssText: i4 } = r6;\n      let o5 = \"\";\n      if (i4.startsWith(\"--sxs\"))\n        return \"\";\n      if (e6[n6 - 1] && (o5 = e6[n6 - 1].cssText).startsWith(\"--sxs\")) {\n        if (!r6.cssRules.length)\n          return \"\";\n        for (const e7 in t5.rules)\n          if (t5.rules[e7].group === r6)\n            return `--sxs{--sxs:${[...t5.rules[e7].cache].join(\" \")}}${i4}`;\n        return r6.cssRules.length ? `${o5}${i4}` : \"\";\n      }\n      return i4;\n    }).join(\"\");\n  }, n5 = () => {\n    if (t5) {\n      const { rules: e6, sheet: r6 } = t5;\n      if (!r6.deleteRule) {\n        for (; 3 === Object(Object(r6.cssRules)[0]).type; )\n          r6.cssRules.splice(0, 1);\n        r6.cssRules = [];\n      }\n      for (const t6 in e6)\n        delete e6[t6];\n    }\n    const i4 = Object(e5).styleSheets || [];\n    for (const e6 of i4)\n      if (j3(e6)) {\n        for (let i5 = 0, o6 = e6.cssRules; o6[i5]; ++i5) {\n          const l8 = Object(o6[i5]);\n          if (1 !== l8.type)\n            continue;\n          const s5 = Object(o6[i5 + 1]);\n          if (4 !== s5.type)\n            continue;\n          ++i5;\n          const { cssText: a7 } = l8;\n          if (!a7.startsWith(\"--sxs\"))\n            continue;\n          const c5 = a7.slice(14, -3).trim().split(/\\s+/), d6 = W4[c5[0]];\n          d6 && (t5 || (t5 = { sheet: e6, reset: n5, rules: {}, toString: r5 }), t5.rules[d6] = { group: s5, index: i5, cache: new Set(c5) });\n        }\n        if (t5)\n          break;\n      }\n    if (!t5) {\n      const i5 = (e6, t6) => ({ type: t6, cssRules: [], insertRule(e7, t7) {\n        this.cssRules.splice(t7, 0, i5(e7, { import: 3, undefined: 1 }[(e7.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));\n      }, get cssText() {\n        return \"@media{}\" === e6 ? `@media{${[].map.call(this.cssRules, (e7) => e7.cssText).join(\"\")}}` : e6;\n      } });\n      t5 = { sheet: e5 ? (e5.head || e5).appendChild(document.createElement(\"style\")).sheet : i5(\"\", \"text/css\"), rules: {}, reset: n5, toString: r5 };\n    }\n    const { sheet: o5, rules: l7 } = t5;\n    for (let e6 = W4.length - 1; e6 >= 0; --e6) {\n      const t6 = W4[e6];\n      if (!l7[t6]) {\n        const r6 = W4[e6 + 1], n6 = l7[r6] ? l7[r6].index : o5.cssRules.length;\n        o5.insertRule(\"@media{}\", n6), o5.insertRule(`--sxs{--sxs:${e6}}`, n6), l7[t6] = { group: o5.cssRules[n6 + 1], index: n6, cache: /* @__PURE__ */ new Set([e6]) };\n      }\n      v4(l7[t6]);\n    }\n  };\n  return n5(), t5;\n};\nvar v4 = (e5) => {\n  const t5 = e5.group;\n  let r5 = t5.cssRules.length;\n  e5.apply = (e6) => {\n    try {\n      t5.insertRule(e6, r5), ++r5;\n    } catch (e7) {\n    }\n  };\n};\nvar T4 = Symbol();\nvar w5 = o3();\nvar M2 = (e5, t5) => w5(e5, () => (...r5) => {\n  let n5 = { type: null, composers: /* @__PURE__ */ new Set() };\n  for (const t6 of r5)\n    if (null != t6)\n      if (t6[l5]) {\n        null == n5.type && (n5.type = t6[l5].type);\n        for (const e6 of t6[l5].composers)\n          n5.composers.add(e6);\n      } else\n        t6.constructor !== Object || t6.$$typeof ? null == n5.type && (n5.type = t6) : n5.composers.add(C5(t6, e5));\n  return null == n5.type && (n5.type = \"span\"), n5.composers.size || n5.composers.add([\"PJLV\", {}, [], [], {}, []]), P3(e5, n5, t5);\n});\nvar C5 = ({ variants: e5, compoundVariants: t5, defaultVariants: r5, ...n5 }, i4) => {\n  const o5 = `${S3(i4.prefix)}c-${z4(n5)}`, l7 = [], s5 = [], d6 = /* @__PURE__ */ Object.create(null), g6 = [];\n  for (const e6 in r5)\n    d6[e6] = String(r5[e6]);\n  if (\"object\" == typeof e5 && e5)\n    for (const t6 in e5) {\n      p6 = d6, u5 = t6, c3.call(p6, u5) || (d6[t6] = \"undefined\");\n      const r6 = e5[t6];\n      for (const e6 in r6) {\n        const n6 = { [t6]: String(e6) };\n        \"undefined\" === String(e6) && g6.push(t6);\n        const i5 = r6[e6], o6 = [n6, i5, !a5(i5)];\n        l7.push(o6);\n      }\n    }\n  var p6, u5;\n  if (\"object\" == typeof t5 && t5)\n    for (const e6 of t5) {\n      let { css: t6, ...r6 } = e6;\n      t6 = \"object\" == typeof t6 && t6 || {};\n      for (const e7 in r6)\n        r6[e7] = String(r6[e7]);\n      const n6 = [r6, t6, !a5(t6)];\n      s5.push(n6);\n    }\n  return [o5, n5, l7, s5, d6, g6];\n};\nvar P3 = (e5, t5, r5) => {\n  const [n5, i4, o5, a7] = L4(t5.composers), c5 = \"function\" == typeof t5.type || t5.type.$$typeof ? ((e6) => {\n    function t6() {\n      for (let r6 = 0; r6 < t6[T4].length; r6++) {\n        const [n6, i5] = t6[T4][r6];\n        e6.rules[n6].apply(i5);\n      }\n      return t6[T4] = [], null;\n    }\n    return t6[T4] = [], t6.rules = {}, W4.forEach((e7) => t6.rules[e7] = { apply: (r6) => t6[T4].push([e7, r6]) }), t6;\n  })(r5) : null, d6 = (c5 || r5).rules, g6 = `.${n5}${i4.length > 1 ? `:where(.${i4.slice(1).join(\".\")})` : \"\"}`, p6 = (l7) => {\n    l7 = \"object\" == typeof l7 && l7 || A5;\n    const { css: s5, ...p7 } = l7, u5 = {};\n    for (const e6 in o5)\n      if (delete p7[e6], e6 in l7) {\n        let t6 = l7[e6];\n        \"object\" == typeof t6 && t6 ? u5[e6] = { \"@initial\": o5[e6], ...t6 } : (t6 = String(t6), u5[e6] = \"undefined\" !== t6 || a7.has(e6) ? t6 : o5[e6]);\n      } else\n        u5[e6] = o5[e6];\n    const h6 = /* @__PURE__ */ new Set([...i4]);\n    for (const [n6, i5, o6, l8] of t5.composers) {\n      r5.rules.styled.cache.has(n6) || (r5.rules.styled.cache.add(n6), $4(i5, [`.${n6}`], [], e5, (e6) => {\n        d6.styled.apply(e6);\n      }));\n      const t6 = O5(o6, u5, e5.media), s6 = O5(l8, u5, e5.media, true);\n      for (const i6 of t6)\n        if (void 0 !== i6)\n          for (const [t7, o7, l9] of i6) {\n            const i7 = `${n6}-${z4(o7)}-${t7}`;\n            h6.add(i7);\n            const s7 = (l9 ? r5.rules.resonevar : r5.rules.onevar).cache, a8 = l9 ? d6.resonevar : d6.onevar;\n            s7.has(i7) || (s7.add(i7), $4(o7, [`.${i7}`], [], e5, (e6) => {\n              a8.apply(e6);\n            }));\n          }\n      for (const t7 of s6)\n        if (void 0 !== t7)\n          for (const [i6, o7] of t7) {\n            const t8 = `${n6}-${z4(o7)}-${i6}`;\n            h6.add(t8), r5.rules.allvar.cache.has(t8) || (r5.rules.allvar.cache.add(t8), $4(o7, [`.${t8}`], [], e5, (e6) => {\n              d6.allvar.apply(e6);\n            }));\n          }\n    }\n    if (\"object\" == typeof s5 && s5) {\n      const t6 = `${n5}-i${z4(s5)}-css`;\n      h6.add(t6), r5.rules.inline.cache.has(t6) || (r5.rules.inline.cache.add(t6), $4(s5, [`.${t6}`], [], e5, (e6) => {\n        d6.inline.apply(e6);\n      }));\n    }\n    for (const e6 of String(l7.className || \"\").trim().split(/\\s+/))\n      e6 && h6.add(e6);\n    const f5 = p7.className = [...h6].join(\" \");\n    return { type: t5.type, className: f5, selector: g6, props: p7, toString: () => f5, deferredInjector: c5 };\n  };\n  return s3(p6, { className: n5, selector: g6, [l5]: t5, toString: () => (r5.rules.styled.cache.has(n5) || p6(), n5) });\n};\nvar L4 = (e5) => {\n  let t5 = \"\";\n  const r5 = [], n5 = {}, i4 = [];\n  for (const [o5, , , , l7, s5] of e5) {\n    \"\" === t5 && (t5 = o5), r5.push(o5), i4.push(...s5);\n    for (const e6 in l7) {\n      const t6 = l7[e6];\n      (void 0 === n5[e6] || \"undefined\" !== t6 || s5.includes(t6)) && (n5[e6] = t6);\n    }\n  }\n  return [t5, r5, n5, new Set(i4)];\n};\nvar O5 = (e5, t5, r5, n5) => {\n  const i4 = [];\n  e:\n    for (let [o5, l7, s5] of e5) {\n      if (s5)\n        continue;\n      let e6, a7 = 0, c5 = false;\n      for (e6 in o5) {\n        const n6 = o5[e6];\n        let i5 = t5[e6];\n        if (i5 !== n6) {\n          if (\"object\" != typeof i5 || !i5)\n            continue e;\n          {\n            let e7, t6, o6 = 0;\n            for (const l8 in i5) {\n              if (n6 === String(i5[l8])) {\n                if (\"@initial\" !== l8) {\n                  const e8 = l8.slice(1);\n                  (t6 = t6 || []).push(e8 in r5 ? r5[e8] : l8.replace(/^@media ?/, \"\")), c5 = true;\n                }\n                a7 += o6, e7 = true;\n              }\n              ++o6;\n            }\n            if (t6 && t6.length && (l7 = { [\"@media \" + t6.join(\", \")]: l7 }), !e7)\n              continue e;\n          }\n        }\n      }\n      (i4[a7] = i4[a7] || []).push([n5 ? \"cv\" : `${e6}-${o5[e6]}`, l7, c5]);\n    }\n  return i4;\n};\nvar A5 = {};\nvar N3 = o3();\nvar D5 = (e5, t5) => N3(e5, () => (...r5) => {\n  const n5 = () => {\n    for (let n6 of r5) {\n      n6 = \"object\" == typeof n6 && n6 || {};\n      let r6 = z4(n6);\n      if (!t5.rules.global.cache.has(r6)) {\n        if (t5.rules.global.cache.add(r6), \"@import\" in n6) {\n          let e6 = [].indexOf.call(t5.sheet.cssRules, t5.rules.themed.group) - 1;\n          for (let r7 of [].concat(n6[\"@import\"]))\n            r7 = r7.includes('\"') || r7.includes(\"'\") ? r7 : `\"${r7}\"`, t5.sheet.insertRule(`@import ${r7};`, e6++);\n          delete n6[\"@import\"];\n        }\n        $4(n6, [], [], e5, (e6) => {\n          t5.rules.global.apply(e6);\n        });\n      }\n    }\n    return \"\";\n  };\n  return s3(n5, { toString: n5 });\n});\nvar H4 = o3();\nvar V6 = (e5, t5) => H4(e5, () => (r5) => {\n  const n5 = `${S3(e5.prefix)}k-${z4(r5)}`, i4 = () => {\n    if (!t5.rules.global.cache.has(n5)) {\n      t5.rules.global.cache.add(n5);\n      const i5 = [];\n      $4(r5, [], [], e5, (e6) => i5.push(e6));\n      const o5 = `@keyframes ${n5}{${i5.join(\"\")}}`;\n      t5.rules.global.apply(o5);\n    }\n    return n5;\n  };\n  return s3(i4, { get name() {\n    return i4();\n  }, toString: i4 });\n});\nvar G4 = class {\n  constructor(e5, t5, r5, n5) {\n    this.token = null == e5 ? \"\" : String(e5), this.value = null == t5 ? \"\" : String(t5), this.scale = null == r5 ? \"\" : String(r5), this.prefix = null == n5 ? \"\" : String(n5);\n  }\n  get computedValue() {\n    return \"var(\" + this.variable + \")\";\n  }\n  get variable() {\n    return \"--\" + S3(this.prefix) + S3(this.scale) + this.token;\n  }\n  toString() {\n    return this.computedValue;\n  }\n};\nvar F4 = o3();\nvar J2 = (e5, t5) => F4(e5, () => (r5, n5) => {\n  n5 = \"object\" == typeof r5 && r5 || Object(n5);\n  const i4 = `.${r5 = (r5 = \"string\" == typeof r5 ? r5 : \"\") || `${S3(e5.prefix)}t-${z4(n5)}`}`, o5 = {}, l7 = [];\n  for (const t6 in n5) {\n    o5[t6] = {};\n    for (const r6 in n5[t6]) {\n      const i5 = `--${S3(e5.prefix)}${t6}-${r6}`, s6 = k5(String(n5[t6][r6]), e5.prefix, t6);\n      o5[t6][r6] = new G4(r6, s6, t6, e5.prefix), l7.push(`${i5}:${s6}`);\n    }\n  }\n  const s5 = () => {\n    if (l7.length && !t5.rules.themed.cache.has(r5)) {\n      t5.rules.themed.cache.add(r5);\n      const i5 = `${n5 === e5.theme ? \":root,\" : \"\"}.${r5}{${l7.join(\";\")}}`;\n      t5.rules.themed.apply(i5);\n    }\n    return r5;\n  };\n  return { ...o5, get className() {\n    return s5();\n  }, selector: i4, toString: s5 };\n});\nvar U3 = o3();\nvar X2;\nvar Y2 = o3();\nvar q3 = (e5) => {\n  const t5 = ((e6) => {\n    let t6 = false;\n    const r5 = U3(e6, (e7) => {\n      t6 = true;\n      const r6 = \"prefix\" in (e7 = \"object\" == typeof e7 && e7 || {}) ? String(e7.prefix) : \"\", i4 = \"object\" == typeof e7.media && e7.media || {}, o5 = \"object\" == typeof e7.root ? e7.root || null : globalThis.document || null, l7 = \"object\" == typeof e7.theme && e7.theme || {}, s5 = { prefix: r6, media: i4, theme: l7, themeMap: \"object\" == typeof e7.themeMap && e7.themeMap || { ...n3 }, utils: \"object\" == typeof e7.utils && e7.utils || {} }, a7 = E4(o5), c5 = { css: M2(s5, a7), globalCss: D5(s5, a7), keyframes: V6(s5, a7), createTheme: J2(s5, a7), reset() {\n        a7.reset(), c5.theme.toString();\n      }, theme: {}, sheet: a7, config: s5, prefix: r6, getCssText: a7.toString, toString: a7.toString };\n      return String(c5.theme = c5.createTheme(l7)), c5;\n    });\n    return t6 || r5.reset(), r5;\n  })(e5);\n  return t5.styled = (({ config: e6, sheet: t6 }) => Y2(e6, () => {\n    const r5 = M2(e6, t6);\n    return (...e7) => {\n      const t7 = r5(...e7), n5 = t7[l5].type, i4 = import_react31.default.forwardRef((e8, r6) => {\n        const i5 = e8 && e8.as || n5, { props: o5, deferredInjector: l7 } = t7(e8);\n        return delete o5.as, o5.ref = r6, l7 ? import_react31.default.createElement(import_react31.default.Fragment, null, import_react31.default.createElement(i5, o5), import_react31.default.createElement(l7, null)) : import_react31.default.createElement(i5, o5);\n      });\n      return i4.className = t7.className, i4.displayName = `Styled.${n5.displayName || n5.name || n5}`, i4.selector = t7.selector, i4.toString = () => t7.selector, i4[l5] = t7[l5], i4;\n    };\n  }))(t5), t5;\n};\nvar K4 = () => X2 || (X2 = q3());\nvar re2 = (...e5) => K4().styled(...e5);\n\n// src/components/Tldraw/styles/stitches.config.ts\nvar { styled, createTheme } = q3({\n  themeMap: {\n    ...n3\n  },\n  theme: {\n    colors: {\n      bounds: \"rgba(65, 132, 244, 1.000)\",\n      boundsBg: \"rgba(65, 132, 244, 0.05)\",\n      hover: \"#ececec\",\n      overlay: \"rgba(0, 0, 0, 0.15)\",\n      overlayContrast: \"rgba(255, 255, 255, 0.15)\",\n      panel: \"#fefefe\",\n      panelContrast: \"#ffffff\",\n      selected: \"rgba(66, 133, 244, 1.000)\",\n      selectedContrast: \"#fefefe\",\n      text: \"#333333\",\n      tooltip: \"#1d1d1d\",\n      tooltipContrast: \"#ffffff\",\n      warn: \"rgba(255, 100, 100, 1)\",\n      canvas: \"rgb(248, 249, 250)\"\n    },\n    shadows: {\n      2: \"0px 1px 1px rgba(0, 0, 0, 0.14)\",\n      3: \"0px 2px 3px rgba(0, 0, 0, 0.14)\",\n      4: \"0px 4px 5px -1px rgba(0, 0, 0, 0.14)\",\n      8: \"0px 12px 17px rgba(0, 0, 0, 0.14)\",\n      12: \"0px 12px 17px rgba(0, 0, 0, 0.14)\",\n      24: \"0px 24px 38px rgba(0, 0, 0, 0.14)\",\n      key: \"1px 1px rgba(0,0,0,1)\",\n      panel: `0px 0px 16px -1px rgba(0, 0, 0, 0.05), \n        0px 0px 16px -8px rgba(0, 0, 0, 0.05), \n        0px 0px 16px -12px rgba(0, 0, 0, 0.12),\n        0px 0px 2px 0px rgba(0, 0, 0, 0.08)`\n    },\n    space: {\n      0: \"2px\",\n      1: \"3px\",\n      2: \"4px\",\n      3: \"8px\",\n      4: \"12px\",\n      5: \"16px\",\n      6: \"32px\",\n      7: \"48px\"\n    },\n    fontSizes: {\n      0: \"10px\",\n      1: \"12px\",\n      2: \"13px\",\n      3: \"16px\",\n      4: \"18px\"\n    },\n    fonts: {\n      ui: '\"Recursive\", system-ui, sans-serif',\n      body: '\"Recursive\", system-ui, sans-serif',\n      mono: '\"Recursive Mono\", monospace'\n    },\n    fontWeights: {},\n    lineHeights: {},\n    letterSpacings: {},\n    sizes: {},\n    borderWidths: {\n      0: \"$1\"\n    },\n    borderStyles: {},\n    radii: {\n      0: \"2px\",\n      1: \"4px\",\n      2: \"8px\",\n      3: \"12px\",\n      4: \"16px\"\n    },\n    zIndices: {},\n    transitions: {}\n  },\n  media: {\n    micro: \"(max-width: 370px)\",\n    sm: \"(min-width: 640px)\",\n    md: \"(min-width: 768px)\",\n    lg: \"(min-width: 1024px)\"\n  },\n  utils: {\n    zStrokeWidth: () => (value) => {\n      if (Array.isArray(value)) {\n        return {\n          strokeWidth: `calc(${value[0]}px / var(--camera-zoom))`\n        };\n      }\n      return {\n        strokeWidth: `calc(${value}px / var(--camera-zoom))`\n      };\n    }\n  }\n});\n\n// src/components/Tldraw/components/Primitives/Divider/Divider.tsx\nvar Divider = styled(\"hr\", {\n  height: 0,\n  paddingTop: 1,\n  width: \"calc(100%+8px)\",\n  backgroundColor: \"$hover\",\n  border: \"none\",\n  margin: \"$2 -4px\"\n});\n\n// src/components/Tldraw/components/Primitives/MenuContent/MenuContent.ts\nvar MenuContent = styled(\"div\", {\n  position: \"relative\",\n  overflow: \"hidden\",\n  userSelect: \"none\",\n  display: \"flex\",\n  flexDirection: \"column\",\n  zIndex: 99997,\n  minWidth: 180,\n  pointerEvents: \"all\",\n  backgroundColor: \"$panel\",\n  border: \"1px solid $panelContrast\",\n  boxShadow: \"$panel\",\n  padding: \"$2 $2\",\n  borderRadius: \"$3\",\n  font: \"$ui\",\n  maxHeight: \"100vh\",\n  overflowY: \"auto\",\n  overflowX: \"hidden\",\n  \"&::webkit-scrollbar\": {\n    display: \"none\"\n  },\n  \"-ms-overflow-style\": \"none\",\n  scrollbarWidth: \"none\",\n  variants: {\n    size: {\n      small: {\n        minWidth: 72\n      }\n    },\n    overflow: {\n      true: {\n        maxHeight: \"60vh\"\n      }\n    }\n  }\n});\n\n// node_modules/.pnpm/@radix-ui+react-dropdown-menu@2.0.5_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-dropdown-menu/dist/index.mjs\nvar import_react33 = require(\"react\");\nvar $d08ef79370b62062$var$DROPDOWN_MENU_NAME = \"DropdownMenu\";\nvar [$d08ef79370b62062$var$createDropdownMenuContext, $d08ef79370b62062$export$c0623cd925aeb687] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d08ef79370b62062$var$DROPDOWN_MENU_NAME, [\n  $6cc32821e9371a1c$export$4027731b685e72eb\n]);\nvar $d08ef79370b62062$var$useMenuScope = $6cc32821e9371a1c$export$4027731b685e72eb();\nvar [$d08ef79370b62062$var$DropdownMenuProvider, $d08ef79370b62062$var$useDropdownMenuContext] = $d08ef79370b62062$var$createDropdownMenuContext($d08ef79370b62062$var$DROPDOWN_MENU_NAME);\nvar $d08ef79370b62062$export$e44a253a59704894 = (props) => {\n  const { __scopeDropdownMenu, children, dir, open: openProp, defaultOpen, onOpenChange, modal = true } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  const triggerRef = (0, import_react33.useRef)(null);\n  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange\n  });\n  return /* @__PURE__ */ (0, import_react33.createElement)($d08ef79370b62062$var$DropdownMenuProvider, {\n    scope: __scopeDropdownMenu,\n    triggerId: $1746a345f3d73bb7$export$f680877a34711e37(),\n    triggerRef,\n    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),\n    open,\n    onOpenChange: setOpen,\n    onOpenToggle: (0, import_react33.useCallback)(\n      () => setOpen(\n        (prevOpen) => !prevOpen\n      ),\n      [\n        setOpen\n      ]\n    ),\n    modal\n  }, /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$be92b6f5f03c0fe9, _extends({}, menuScope, {\n    open,\n    onOpenChange: setOpen,\n    dir,\n    modal\n  }), children));\n};\nvar $d08ef79370b62062$var$TRIGGER_NAME = \"DropdownMenuTrigger\";\nvar $d08ef79370b62062$export$d2469213b3befba9 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;\n  const context = $d08ef79370b62062$var$useDropdownMenuContext($d08ef79370b62062$var$TRIGGER_NAME, __scopeDropdownMenu);\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$b688253958b8dfe7, _extends({\n    asChild: true\n  }, menuScope), /* @__PURE__ */ (0, import_react33.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({\n    type: \"button\",\n    id: context.triggerId,\n    \"aria-haspopup\": \"menu\",\n    \"aria-expanded\": context.open,\n    \"aria-controls\": context.open ? context.contentId : void 0,\n    \"data-state\": context.open ? \"open\" : \"closed\",\n    \"data-disabled\": disabled ? \"\" : void 0,\n    disabled\n  }, triggerProps, {\n    ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, context.triggerRef),\n    onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, (event) => {\n      if (!disabled && event.button === 0 && event.ctrlKey === false) {\n        context.onOpenToggle();\n        if (!context.open)\n          event.preventDefault();\n      }\n    }),\n    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {\n      if (disabled)\n        return;\n      if ([\n        \"Enter\",\n        \" \"\n      ].includes(event.key))\n        context.onOpenToggle();\n      if (event.key === \"ArrowDown\")\n        context.onOpenChange(true);\n      if ([\n        \"Enter\",\n        \" \",\n        \"ArrowDown\"\n      ].includes(event.key))\n        event.preventDefault();\n    })\n  })));\n});\nvar $d08ef79370b62062$export$cd369b4d4d54efc9 = (props) => {\n  const { __scopeDropdownMenu, ...portalProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$602eac185826482c, _extends({}, menuScope, portalProps));\n};\nvar $d08ef79370b62062$var$CONTENT_NAME = \"DropdownMenuContent\";\nvar $d08ef79370b62062$export$6e76d93a37c01248 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...contentProps } = props;\n  const context = $d08ef79370b62062$var$useDropdownMenuContext($d08ef79370b62062$var$CONTENT_NAME, __scopeDropdownMenu);\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  const hasInteractedOutsideRef = (0, import_react33.useRef)(false);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$7c6e2c02157bb7d2, _extends({\n    id: context.contentId,\n    \"aria-labelledby\": context.triggerId\n  }, menuScope, contentProps, {\n    ref: forwardedRef,\n    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {\n      var _context$triggerRef$c;\n      if (!hasInteractedOutsideRef.current)\n        (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();\n      hasInteractedOutsideRef.current = false;\n      event.preventDefault();\n    }),\n    onInteractOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onInteractOutside, (event) => {\n      const originalEvent = event.detail.originalEvent;\n      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;\n      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;\n      if (!context.modal || isRightClick)\n        hasInteractedOutsideRef.current = true;\n    }),\n    style: {\n      ...props.style,\n      \"--radix-dropdown-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-dropdown-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-dropdown-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-dropdown-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-dropdown-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    }\n  }));\n});\nvar $d08ef79370b62062$export$ed97964d1871885d = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...itemProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$6d08773d2e66f8f2, _extends({}, menuScope, itemProps, {\n    ref: forwardedRef\n  }));\n});\nvar $d08ef79370b62062$export$53a69729da201fa9 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...checkboxItemProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$16ce288f89fa631c, _extends({}, menuScope, checkboxItemProps, {\n    ref: forwardedRef\n  }));\n});\nvar $d08ef79370b62062$export$3323ad73d55f587e = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...radioGroupProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$a98f0dcb43a68a25, _extends({}, menuScope, radioGroupProps, {\n    ref: forwardedRef\n  }));\n});\nvar $d08ef79370b62062$export$e4f69b41b1637536 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...radioItemProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$371ab307eab489c0, _extends({}, menuScope, radioItemProps, {\n    ref: forwardedRef\n  }));\n});\nvar $d08ef79370b62062$export$42355ae145153fb6 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$c3468e2714d175fa, _extends({}, menuScope, itemIndicatorProps, {\n    ref: forwardedRef\n  }));\n});\nvar $d08ef79370b62062$export$da160178fd3bc7e9 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...separatorProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$1ff3c3f08ae963c0, _extends({}, menuScope, separatorProps, {\n    ref: forwardedRef\n  }));\n});\nvar $d08ef79370b62062$export$34b8980744021ec5 = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...arrowProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$21b07c8f274aebd5, _extends({}, menuScope, arrowProps, {\n    ref: forwardedRef\n  }));\n});\nvar $d08ef79370b62062$export$2f307d81a64f5442 = (props) => {\n  const { __scopeDropdownMenu, children, open: openProp, onOpenChange, defaultOpen } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange\n  });\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$d7a01e11500dfb6f, _extends({}, menuScope, {\n    open,\n    onOpenChange: setOpen\n  }), children);\n};\nvar $d08ef79370b62062$export$21dcb7ec56f874cf = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...subTriggerProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$2ea8a7a591ac5eac, _extends({}, menuScope, subTriggerProps, {\n    ref: forwardedRef\n  }));\n});\nvar $d08ef79370b62062$export$f34ec8bc2482cc5f = /* @__PURE__ */ (0, import_react33.forwardRef)((props, forwardedRef) => {\n  const { __scopeDropdownMenu, ...subContentProps } = props;\n  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);\n  return /* @__PURE__ */ (0, import_react33.createElement)($6cc32821e9371a1c$export$6d4de93b380beddf, _extends({}, menuScope, subContentProps, {\n    ref: forwardedRef,\n    style: {\n      ...props.style,\n      \"--radix-dropdown-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-dropdown-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-dropdown-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-dropdown-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-dropdown-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    }\n  }));\n});\nvar $d08ef79370b62062$export$be92b6f5f03c0fe9 = $d08ef79370b62062$export$e44a253a59704894;\nvar $d08ef79370b62062$export$41fb9f06171c75f4 = $d08ef79370b62062$export$d2469213b3befba9;\nvar $d08ef79370b62062$export$602eac185826482c = $d08ef79370b62062$export$cd369b4d4d54efc9;\nvar $d08ef79370b62062$export$7c6e2c02157bb7d2 = $d08ef79370b62062$export$6e76d93a37c01248;\nvar $d08ef79370b62062$export$6d08773d2e66f8f2 = $d08ef79370b62062$export$ed97964d1871885d;\nvar $d08ef79370b62062$export$16ce288f89fa631c = $d08ef79370b62062$export$53a69729da201fa9;\nvar $d08ef79370b62062$export$a98f0dcb43a68a25 = $d08ef79370b62062$export$3323ad73d55f587e;\nvar $d08ef79370b62062$export$371ab307eab489c0 = $d08ef79370b62062$export$e4f69b41b1637536;\nvar $d08ef79370b62062$export$c3468e2714d175fa = $d08ef79370b62062$export$42355ae145153fb6;\nvar $d08ef79370b62062$export$1ff3c3f08ae963c0 = $d08ef79370b62062$export$da160178fd3bc7e9;\nvar $d08ef79370b62062$export$21b07c8f274aebd5 = $d08ef79370b62062$export$34b8980744021ec5;\nvar $d08ef79370b62062$export$d7a01e11500dfb6f = $d08ef79370b62062$export$2f307d81a64f5442;\nvar $d08ef79370b62062$export$2ea8a7a591ac5eac = $d08ef79370b62062$export$21dcb7ec56f874cf;\nvar $d08ef79370b62062$export$6d4de93b380beddf = $d08ef79370b62062$export$f34ec8bc2482cc5f;\n\n// src/components/Tldraw/components/Primitives/RowButton/RowButton.tsx\nvar React9 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/components/Primitives/Kbd/Kbd.tsx\nvar import_jsx_runtime2 = require(\"react/jsx-runtime\");\nvar commandKey = () => C3.isDarwin() ? \"\\u2318\" : \"Ctrl\";\nfunction Kbd({ variant, children }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(StyledKbd, { variant, children: children.split(\"\").map((k7, index2) => {\n    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"span\", { children: k7.replace(\"#\", commandKey()) }, index2);\n  }) });\n}\nvar StyledKbd = styled(\"kbd\", {\n  marginLeft: \"$3\",\n  textShadow: \"$2\",\n  textAlign: \"center\",\n  fontSize: \"$0\",\n  fontFamily: \"$ui\",\n  color: \"$text\",\n  background: \"none\",\n  fontWeight: 400,\n  gap: \"$1\",\n  display: \"flex\",\n  alignItems: \"center\",\n  \"& > span\": {\n    padding: \"$0\",\n    borderRadius: \"$0\",\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\"\n  },\n  variants: {\n    variant: {\n      tooltip: {\n        \"& > span\": {\n          color: \"$tooltipContrast\",\n          background: \"$overlayContrast\",\n          boxShadow: \"$key\",\n          width: \"20px\",\n          height: \"20px\"\n        }\n      },\n      menu: {}\n    }\n  }\n});\n\n// src/components/Tldraw/components/Primitives/SmallIcon/SmallIcon.tsx\nvar SmallIcon = styled(\"div\", {\n  height: \"100%\",\n  borderRadius: \"4px\",\n  marginRight: \"1px\",\n  width: \"fit-content\",\n  display: \"grid\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  outline: \"none\",\n  border: \"none\",\n  pointerEvents: \"all\",\n  cursor: \"pointer\",\n  color: \"currentColor\",\n  \"& svg\": {\n    height: 16,\n    width: 16,\n    strokeWidth: 1\n  },\n  \"& > *\": {\n    gridRow: 1,\n    gridColumn: 1\n  }\n});\n\n// src/components/Tldraw/components/breakpoints.tsx\nvar breakpoints = {\n  \"@initial\": \"mobile\",\n  \"@micro\": \"micro\",\n  \"@sm\": \"small\",\n  \"@md\": \"medium\",\n  \"@lg\": \"large\"\n};\n\n// src/components/Tldraw/components/Primitives/RowButton/RowButton.tsx\nvar import_jsx_runtime3 = require(\"react/jsx-runtime\");\nvar RowButton = React9.forwardRef(\n  ({ onClick, isActive = false, isWarning = false, hasIndicator = false, hasArrow = false, disabled = false, variant, kbd, children, ...rest }, reference) => {\n    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(\n      StyledRowButton,\n      {\n        ref: reference,\n        bp: breakpoints,\n        isWarning,\n        isActive,\n        disabled,\n        onClick,\n        variant,\n        ...rest,\n        children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(StyledRowButtonInner, { children: [\n          children,\n          kbd ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Kbd, { variant: \"menu\", children: kbd }) : void 0,\n          hasIndicator && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)($d08ef79370b62062$export$c3468e2714d175fa, { dir: \"ltr\", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(SmallIcon, { children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(CheckIcon, {}) }) }),\n          hasArrow && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(SmallIcon, { children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(ChevronRightIcon, {}) })\n        ] })\n      }\n    );\n  }\n);\nvar StyledRowButtonInner = styled(\"div\", {\n  height: \"100%\",\n  width: \"100%\",\n  backgroundColor: \"$panel\",\n  borderRadius: \"$2\",\n  display: \"flex\",\n  gap: \"$1\",\n  flexDirection: \"row\",\n  alignItems: \"center\",\n  padding: \"0 $3\",\n  justifyContent: \"space-between\",\n  border: \"1px solid transparent\",\n  \"& svg\": {\n    position: \"relative\",\n    stroke: \"$overlay\",\n    strokeWidth: 1,\n    zIndex: 1\n  },\n  [`& > ${SmallIcon}`]: {\n    paddingLeft: \"$3\"\n  }\n});\nvar StyledRowButton = styled(\"button\", {\n  position: \"relative\",\n  width: \"100%\",\n  background: \"none\",\n  border: \"none\",\n  cursor: \"pointer\",\n  height: 32,\n  minHeight: 32,\n  outline: \"none\",\n  color: \"$text\",\n  fontFamily: \"$ui\",\n  fontWeight: 400,\n  fontSize: \"$1\",\n  borderRadius: 4,\n  userSelect: \"none\",\n  margin: 0,\n  padding: \"0 0\",\n  \"&[data-disabled]\": {\n    opacity: 0.3\n  },\n  \"&:disabled\": {\n    opacity: 0.3\n  },\n  [`&:focus:not(:disabled) ${StyledRowButtonInner}`]: {\n    backgroundColor: \"$hover\"\n  },\n  \"& a\": {\n    textDecoration: \"none\",\n    color: \"$text\"\n  },\n  variants: {\n    bp: {\n      mobile: {},\n      small: {}\n    },\n    variant: {\n      styleMenu: {\n        margin: \"$1 0 $1 0\"\n      },\n      wide: {\n        gridColumn: \"1 / span 4\"\n      }\n    },\n    size: {\n      icon: {\n        padding: \"4px \",\n        width: \"auto\"\n      }\n    },\n    isWarning: {\n      true: {\n        color: \"$warn\"\n      }\n    },\n    isActive: {\n      true: {\n        backgroundColor: \"$hover\"\n      },\n      false: {}\n    }\n  }\n});\n\n// src/components/Tldraw/components/Primitives/ToolButton/ToolButton.tsx\nvar React15 = __toESM(require(\"react\"));\n\n// node_modules/.pnpm/@radix-ui+react-tooltip@1.0.6_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-tooltip/dist/index.mjs\nvar import_react35 = require(\"react\");\n\n// node_modules/.pnpm/@radix-ui+react-visually-hidden@1.0.3_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-visually-hidden/dist/index.mjs\nvar import_react34 = require(\"react\");\nvar $ea1ef594cf570d83$export$439d29a4e110a164 = /* @__PURE__ */ (0, import_react34.forwardRef)((props, forwardedRef) => {\n  return /* @__PURE__ */ (0, import_react34.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({}, props, {\n    ref: forwardedRef,\n    style: {\n      // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss\n      position: \"absolute\",\n      border: 0,\n      width: 1,\n      height: 1,\n      padding: 0,\n      margin: -1,\n      overflow: \"hidden\",\n      clip: \"rect(0, 0, 0, 0)\",\n      whiteSpace: \"nowrap\",\n      wordWrap: \"normal\",\n      ...props.style\n    }\n  }));\n});\nvar $ea1ef594cf570d83$export$be92b6f5f03c0fe9 = $ea1ef594cf570d83$export$439d29a4e110a164;\n\n// node_modules/.pnpm/@radix-ui+react-tooltip@1.0.6_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-tooltip/dist/index.mjs\nvar [$a093c7e1ec25a057$var$createTooltipContext, $a093c7e1ec25a057$export$1c540a2224f0d865] = $c512c27ab02ef895$export$50c7b4e9d9f19c1(\"Tooltip\", [\n  $cf1ac5d9fe0e8206$export$722aac194ae923\n]);\nvar $a093c7e1ec25a057$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();\nvar $a093c7e1ec25a057$var$PROVIDER_NAME = \"TooltipProvider\";\nvar $a093c7e1ec25a057$var$DEFAULT_DELAY_DURATION = 700;\nvar $a093c7e1ec25a057$var$TOOLTIP_OPEN = \"tooltip.open\";\nvar [$a093c7e1ec25a057$var$TooltipProviderContextProvider, $a093c7e1ec25a057$var$useTooltipProviderContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$PROVIDER_NAME);\nvar $a093c7e1ec25a057$export$f78649fb9ca566b8 = (props) => {\n  const { __scopeTooltip, delayDuration = $a093c7e1ec25a057$var$DEFAULT_DELAY_DURATION, skipDelayDuration = 300, disableHoverableContent = false, children } = props;\n  const [isOpenDelayed, setIsOpenDelayed] = (0, import_react35.useState)(true);\n  const isPointerInTransitRef = (0, import_react35.useRef)(false);\n  const skipDelayTimerRef = (0, import_react35.useRef)(0);\n  (0, import_react35.useEffect)(() => {\n    const skipDelayTimer = skipDelayTimerRef.current;\n    return () => window.clearTimeout(skipDelayTimer);\n  }, []);\n  return /* @__PURE__ */ (0, import_react35.createElement)($a093c7e1ec25a057$var$TooltipProviderContextProvider, {\n    scope: __scopeTooltip,\n    isOpenDelayed,\n    delayDuration,\n    onOpen: (0, import_react35.useCallback)(() => {\n      window.clearTimeout(skipDelayTimerRef.current);\n      setIsOpenDelayed(false);\n    }, []),\n    onClose: (0, import_react35.useCallback)(() => {\n      window.clearTimeout(skipDelayTimerRef.current);\n      skipDelayTimerRef.current = window.setTimeout(\n        () => setIsOpenDelayed(true),\n        skipDelayDuration\n      );\n    }, [\n      skipDelayDuration\n    ]),\n    isPointerInTransitRef,\n    onPointerInTransitChange: (0, import_react35.useCallback)((inTransit) => {\n      isPointerInTransitRef.current = inTransit;\n    }, []),\n    disableHoverableContent\n  }, children);\n};\nvar $a093c7e1ec25a057$var$TOOLTIP_NAME = \"Tooltip\";\nvar [$a093c7e1ec25a057$var$TooltipContextProvider, $a093c7e1ec25a057$var$useTooltipContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$TOOLTIP_NAME);\nvar $a093c7e1ec25a057$export$28c660c63b792dea = (props) => {\n  const { __scopeTooltip, children, open: openProp, defaultOpen = false, onOpenChange, disableHoverableContent: disableHoverableContentProp, delayDuration: delayDurationProp } = props;\n  const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$TOOLTIP_NAME, props.__scopeTooltip);\n  const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);\n  const [trigger, setTrigger] = (0, import_react35.useState)(null);\n  const contentId = $1746a345f3d73bb7$export$f680877a34711e37();\n  const openTimerRef = (0, import_react35.useRef)(0);\n  const disableHoverableContent = disableHoverableContentProp !== null && disableHoverableContentProp !== void 0 ? disableHoverableContentProp : providerContext.disableHoverableContent;\n  const delayDuration = delayDurationProp !== null && delayDurationProp !== void 0 ? delayDurationProp : providerContext.delayDuration;\n  const wasOpenDelayedRef = (0, import_react35.useRef)(false);\n  const [open1 = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: (open) => {\n      if (open) {\n        providerContext.onOpen();\n        document.dispatchEvent(new CustomEvent($a093c7e1ec25a057$var$TOOLTIP_OPEN));\n      } else\n        providerContext.onClose();\n      onOpenChange === null || onOpenChange === void 0 || onOpenChange(open);\n    }\n  });\n  const stateAttribute = (0, import_react35.useMemo)(() => {\n    return open1 ? wasOpenDelayedRef.current ? \"delayed-open\" : \"instant-open\" : \"closed\";\n  }, [\n    open1\n  ]);\n  const handleOpen = (0, import_react35.useCallback)(() => {\n    window.clearTimeout(openTimerRef.current);\n    wasOpenDelayedRef.current = false;\n    setOpen(true);\n  }, [\n    setOpen\n  ]);\n  const handleClose = (0, import_react35.useCallback)(() => {\n    window.clearTimeout(openTimerRef.current);\n    setOpen(false);\n  }, [\n    setOpen\n  ]);\n  const handleDelayedOpen = (0, import_react35.useCallback)(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = window.setTimeout(() => {\n      wasOpenDelayedRef.current = true;\n      setOpen(true);\n    }, delayDuration);\n  }, [\n    delayDuration,\n    setOpen\n  ]);\n  (0, import_react35.useEffect)(() => {\n    return () => window.clearTimeout(openTimerRef.current);\n  }, []);\n  return /* @__PURE__ */ (0, import_react35.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ (0, import_react35.createElement)($a093c7e1ec25a057$var$TooltipContextProvider, {\n    scope: __scopeTooltip,\n    contentId,\n    open: open1,\n    stateAttribute,\n    trigger,\n    onTriggerChange: setTrigger,\n    onTriggerEnter: (0, import_react35.useCallback)(() => {\n      if (providerContext.isOpenDelayed)\n        handleDelayedOpen();\n      else\n        handleOpen();\n    }, [\n      providerContext.isOpenDelayed,\n      handleDelayedOpen,\n      handleOpen\n    ]),\n    onTriggerLeave: (0, import_react35.useCallback)(() => {\n      if (disableHoverableContent)\n        handleClose();\n      else\n        window.clearTimeout(openTimerRef.current);\n    }, [\n      handleClose,\n      disableHoverableContent\n    ]),\n    onOpen: handleOpen,\n    onClose: handleClose,\n    disableHoverableContent\n  }, children));\n};\nvar $a093c7e1ec25a057$var$TRIGGER_NAME = \"TooltipTrigger\";\nvar $a093c7e1ec25a057$export$8c610744efcf8a1d = /* @__PURE__ */ (0, import_react35.forwardRef)((props, forwardedRef) => {\n  const { __scopeTooltip, ...triggerProps } = props;\n  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$TRIGGER_NAME, __scopeTooltip);\n  const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$TRIGGER_NAME, __scopeTooltip);\n  const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);\n  const ref = (0, import_react35.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref, context.onTriggerChange);\n  const isPointerDownRef = (0, import_react35.useRef)(false);\n  const hasPointerMoveOpenedRef = (0, import_react35.useRef)(false);\n  const handlePointerUp = (0, import_react35.useCallback)(\n    () => isPointerDownRef.current = false,\n    []\n  );\n  (0, import_react35.useEffect)(() => {\n    return () => document.removeEventListener(\"pointerup\", handlePointerUp);\n  }, [\n    handlePointerUp\n  ]);\n  return /* @__PURE__ */ (0, import_react35.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({\n    asChild: true\n  }, popperScope), /* @__PURE__ */ (0, import_react35.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({\n    // We purposefully avoid adding `type=button` here because tooltip triggers are also\n    // commonly anchors and the anchor `type` attribute signifies MIME type.\n    \"aria-describedby\": context.open ? context.contentId : void 0,\n    \"data-state\": context.stateAttribute\n  }, triggerProps, {\n    ref: composedRefs,\n    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, (event) => {\n      if (event.pointerType === \"touch\")\n        return;\n      if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {\n        context.onTriggerEnter();\n        hasPointerMoveOpenedRef.current = true;\n      }\n    }),\n    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, () => {\n      context.onTriggerLeave();\n      hasPointerMoveOpenedRef.current = false;\n    }),\n    onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, () => {\n      isPointerDownRef.current = true;\n      document.addEventListener(\"pointerup\", handlePointerUp, {\n        once: true\n      });\n    }),\n    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, () => {\n      if (!isPointerDownRef.current)\n        context.onOpen();\n    }),\n    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, context.onClose),\n    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onClose)\n  })));\n});\nvar $a093c7e1ec25a057$var$PORTAL_NAME = \"TooltipPortal\";\nvar [$a093c7e1ec25a057$var$PortalProvider, $a093c7e1ec25a057$var$usePortalContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$PORTAL_NAME, {\n  forceMount: void 0\n});\nvar $a093c7e1ec25a057$var$CONTENT_NAME = \"TooltipContent\";\nvar $a093c7e1ec25a057$export$e9003e2be37ec060 = /* @__PURE__ */ (0, import_react35.forwardRef)((props, forwardedRef) => {\n  const portalContext = $a093c7e1ec25a057$var$usePortalContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);\n  const { forceMount = portalContext.forceMount, side = \"top\", ...contentProps } = props;\n  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);\n  return /* @__PURE__ */ (0, import_react35.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {\n    present: forceMount || context.open\n  }, context.disableHoverableContent ? /* @__PURE__ */ (0, import_react35.createElement)($a093c7e1ec25a057$var$TooltipContentImpl, _extends({\n    side\n  }, contentProps, {\n    ref: forwardedRef\n  })) : /* @__PURE__ */ (0, import_react35.createElement)($a093c7e1ec25a057$var$TooltipContentHoverable, _extends({\n    side\n  }, contentProps, {\n    ref: forwardedRef\n  })));\n});\nvar $a093c7e1ec25a057$var$TooltipContentHoverable = /* @__PURE__ */ (0, import_react35.forwardRef)((props, forwardedRef) => {\n  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);\n  const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);\n  const ref = (0, import_react35.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);\n  const [pointerGraceArea, setPointerGraceArea] = (0, import_react35.useState)(null);\n  const { trigger, onClose } = context;\n  const content = ref.current;\n  const { onPointerInTransitChange } = providerContext;\n  const handleRemoveGraceArea = (0, import_react35.useCallback)(() => {\n    setPointerGraceArea(null);\n    onPointerInTransitChange(false);\n  }, [\n    onPointerInTransitChange\n  ]);\n  const handleCreateGraceArea = (0, import_react35.useCallback)((event, hoverTarget) => {\n    const currentTarget = event.currentTarget;\n    const exitPoint = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    const exitSide = $a093c7e1ec25a057$var$getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());\n    const paddedExitPoints = $a093c7e1ec25a057$var$getPaddedExitPoints(exitPoint, exitSide);\n    const hoverTargetPoints = $a093c7e1ec25a057$var$getPointsFromRect(hoverTarget.getBoundingClientRect());\n    const graceArea = $a093c7e1ec25a057$var$getHull([\n      ...paddedExitPoints,\n      ...hoverTargetPoints\n    ]);\n    setPointerGraceArea(graceArea);\n    onPointerInTransitChange(true);\n  }, [\n    onPointerInTransitChange\n  ]);\n  (0, import_react35.useEffect)(() => {\n    return () => handleRemoveGraceArea();\n  }, [\n    handleRemoveGraceArea\n  ]);\n  (0, import_react35.useEffect)(() => {\n    if (trigger && content) {\n      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);\n      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);\n      trigger.addEventListener(\"pointerleave\", handleTriggerLeave);\n      content.addEventListener(\"pointerleave\", handleContentLeave);\n      return () => {\n        trigger.removeEventListener(\"pointerleave\", handleTriggerLeave);\n        content.removeEventListener(\"pointerleave\", handleContentLeave);\n      };\n    }\n  }, [\n    trigger,\n    content,\n    handleCreateGraceArea,\n    handleRemoveGraceArea\n  ]);\n  (0, import_react35.useEffect)(() => {\n    if (pointerGraceArea) {\n      const handleTrackPointerGrace = (event) => {\n        const target = event.target;\n        const pointerPosition = {\n          x: event.clientX,\n          y: event.clientY\n        };\n        const hasEnteredTarget = (trigger === null || trigger === void 0 ? void 0 : trigger.contains(target)) || (content === null || content === void 0 ? void 0 : content.contains(target));\n        const isPointerOutsideGraceArea = !$a093c7e1ec25a057$var$isPointInPolygon(pointerPosition, pointerGraceArea);\n        if (hasEnteredTarget)\n          handleRemoveGraceArea();\n        else if (isPointerOutsideGraceArea) {\n          handleRemoveGraceArea();\n          onClose();\n        }\n      };\n      document.addEventListener(\"pointermove\", handleTrackPointerGrace);\n      return () => document.removeEventListener(\"pointermove\", handleTrackPointerGrace);\n    }\n  }, [\n    trigger,\n    content,\n    pointerGraceArea,\n    onClose,\n    handleRemoveGraceArea\n  ]);\n  return /* @__PURE__ */ (0, import_react35.createElement)($a093c7e1ec25a057$var$TooltipContentImpl, _extends({}, props, {\n    ref: composedRefs\n  }));\n});\nvar [$a093c7e1ec25a057$var$VisuallyHiddenContentContextProvider, $a093c7e1ec25a057$var$useVisuallyHiddenContentContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$TOOLTIP_NAME, {\n  isInside: false\n});\nvar $a093c7e1ec25a057$var$TooltipContentImpl = /* @__PURE__ */ (0, import_react35.forwardRef)((props, forwardedRef) => {\n  const { __scopeTooltip, children, \"aria-label\": ariaLabel, onEscapeKeyDown, onPointerDownOutside, ...contentProps } = props;\n  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, __scopeTooltip);\n  const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);\n  const { onClose } = context;\n  (0, import_react35.useEffect)(() => {\n    document.addEventListener($a093c7e1ec25a057$var$TOOLTIP_OPEN, onClose);\n    return () => document.removeEventListener($a093c7e1ec25a057$var$TOOLTIP_OPEN, onClose);\n  }, [\n    onClose\n  ]);\n  (0, import_react35.useEffect)(() => {\n    if (context.trigger) {\n      const handleScroll2 = (event) => {\n        const target = event.target;\n        if (target !== null && target !== void 0 && target.contains(context.trigger))\n          onClose();\n      };\n      window.addEventListener(\"scroll\", handleScroll2, {\n        capture: true\n      });\n      return () => window.removeEventListener(\"scroll\", handleScroll2, {\n        capture: true\n      });\n    }\n  }, [\n    context.trigger,\n    onClose\n  ]);\n  return /* @__PURE__ */ (0, import_react35.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, {\n    asChild: true,\n    disableOutsidePointerEvents: false,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside: (event) => event.preventDefault(),\n    onDismiss: onClose\n  }, /* @__PURE__ */ (0, import_react35.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({\n    \"data-state\": context.stateAttribute\n  }, popperScope, contentProps, {\n    ref: forwardedRef,\n    style: {\n      ...contentProps.style,\n      \"--radix-tooltip-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-tooltip-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-tooltip-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-tooltip-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-tooltip-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    }\n  }), /* @__PURE__ */ (0, import_react35.createElement)($5e63c961fc1ce211$export$d9f1ccf0bdb05d45, null, children), /* @__PURE__ */ (0, import_react35.createElement)($a093c7e1ec25a057$var$VisuallyHiddenContentContextProvider, {\n    scope: __scopeTooltip,\n    isInside: true\n  }, /* @__PURE__ */ (0, import_react35.createElement)($ea1ef594cf570d83$export$be92b6f5f03c0fe9, {\n    id: context.contentId,\n    role: \"tooltip\"\n  }, ariaLabel || children))));\n});\nvar $a093c7e1ec25a057$var$ARROW_NAME = \"TooltipArrow\";\nvar $a093c7e1ec25a057$export$c27ee0ad710f7559 = /* @__PURE__ */ (0, import_react35.forwardRef)((props, forwardedRef) => {\n  const { __scopeTooltip, ...arrowProps } = props;\n  const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);\n  const visuallyHiddenContentContext = $a093c7e1ec25a057$var$useVisuallyHiddenContentContext($a093c7e1ec25a057$var$ARROW_NAME, __scopeTooltip);\n  return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ (0, import_react35.createElement)($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends({}, popperScope, arrowProps, {\n    ref: forwardedRef\n  }));\n});\nfunction $a093c7e1ec25a057$var$getExitSideFromRect(point, rect) {\n  const top2 = Math.abs(rect.top - point.y);\n  const bottom = Math.abs(rect.bottom - point.y);\n  const right = Math.abs(rect.right - point.x);\n  const left = Math.abs(rect.left - point.x);\n  switch (Math.min(top2, bottom, right, left)) {\n    case left:\n      return \"left\";\n    case right:\n      return \"right\";\n    case top2:\n      return \"top\";\n    case bottom:\n      return \"bottom\";\n    default:\n      throw new Error(\"unreachable\");\n  }\n}\nfunction $a093c7e1ec25a057$var$getPaddedExitPoints(exitPoint, exitSide, padding = 5) {\n  const paddedExitPoints = [];\n  switch (exitSide) {\n    case \"top\":\n      paddedExitPoints.push({\n        x: exitPoint.x - padding,\n        y: exitPoint.y + padding\n      }, {\n        x: exitPoint.x + padding,\n        y: exitPoint.y + padding\n      });\n      break;\n    case \"bottom\":\n      paddedExitPoints.push({\n        x: exitPoint.x - padding,\n        y: exitPoint.y - padding\n      }, {\n        x: exitPoint.x + padding,\n        y: exitPoint.y - padding\n      });\n      break;\n    case \"left\":\n      paddedExitPoints.push({\n        x: exitPoint.x + padding,\n        y: exitPoint.y - padding\n      }, {\n        x: exitPoint.x + padding,\n        y: exitPoint.y + padding\n      });\n      break;\n    case \"right\":\n      paddedExitPoints.push({\n        x: exitPoint.x - padding,\n        y: exitPoint.y - padding\n      }, {\n        x: exitPoint.x - padding,\n        y: exitPoint.y + padding\n      });\n      break;\n  }\n  return paddedExitPoints;\n}\nfunction $a093c7e1ec25a057$var$getPointsFromRect(rect) {\n  const { top: top2, right, bottom, left } = rect;\n  return [\n    {\n      x: left,\n      y: top2\n    },\n    {\n      x: right,\n      y: top2\n    },\n    {\n      x: right,\n      y: bottom\n    },\n    {\n      x: left,\n      y: bottom\n    }\n  ];\n}\nfunction $a093c7e1ec25a057$var$isPointInPolygon(point, polygon) {\n  const { x: x5, y: y6 } = point;\n  let inside = false;\n  for (let i4 = 0, j4 = polygon.length - 1; i4 < polygon.length; j4 = i4++) {\n    const xi = polygon[i4].x;\n    const yi = polygon[i4].y;\n    const xj = polygon[j4].x;\n    const yj = polygon[j4].y;\n    const intersect = yi > y6 !== yj > y6 && x5 < (xj - xi) * (y6 - yi) / (yj - yi) + xi;\n    if (intersect)\n      inside = !inside;\n  }\n  return inside;\n}\nfunction $a093c7e1ec25a057$var$getHull(points) {\n  const newPoints = points.slice();\n  newPoints.sort((a7, b6) => {\n    if (a7.x < b6.x)\n      return -1;\n    else if (a7.x > b6.x)\n      return 1;\n    else if (a7.y < b6.y)\n      return -1;\n    else if (a7.y > b6.y)\n      return 1;\n    else\n      return 0;\n  });\n  return $a093c7e1ec25a057$var$getHullPresorted(newPoints);\n}\nfunction $a093c7e1ec25a057$var$getHullPresorted(points) {\n  if (points.length <= 1)\n    return points.slice();\n  const upperHull = [];\n  for (let i4 = 0; i4 < points.length; i4++) {\n    const p6 = points[i4];\n    while (upperHull.length >= 2) {\n      const q4 = upperHull[upperHull.length - 1];\n      const r5 = upperHull[upperHull.length - 2];\n      if ((q4.x - r5.x) * (p6.y - r5.y) >= (q4.y - r5.y) * (p6.x - r5.x))\n        upperHull.pop();\n      else\n        break;\n    }\n    upperHull.push(p6);\n  }\n  upperHull.pop();\n  const lowerHull = [];\n  for (let i1 = points.length - 1; i1 >= 0; i1--) {\n    const p6 = points[i1];\n    while (lowerHull.length >= 2) {\n      const q4 = lowerHull[lowerHull.length - 1];\n      const r5 = lowerHull[lowerHull.length - 2];\n      if ((q4.x - r5.x) * (p6.y - r5.y) >= (q4.y - r5.y) * (p6.x - r5.x))\n        lowerHull.pop();\n      else\n        break;\n    }\n    lowerHull.push(p6);\n  }\n  lowerHull.pop();\n  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y)\n    return upperHull;\n  else\n    return upperHull.concat(lowerHull);\n}\nvar $a093c7e1ec25a057$export$2881499e37b75b9a = $a093c7e1ec25a057$export$f78649fb9ca566b8;\nvar $a093c7e1ec25a057$export$be92b6f5f03c0fe9 = $a093c7e1ec25a057$export$28c660c63b792dea;\nvar $a093c7e1ec25a057$export$41fb9f06171c75f4 = $a093c7e1ec25a057$export$8c610744efcf8a1d;\nvar $a093c7e1ec25a057$export$7c6e2c02157bb7d2 = $a093c7e1ec25a057$export$e9003e2be37ec060;\nvar $a093c7e1ec25a057$export$21b07c8f274aebd5 = $a093c7e1ec25a057$export$c27ee0ad710f7559;\n\n// src/components/Tldraw/components/Primitives/Tooltip/Tooltip.tsx\nvar import_jsx_runtime4 = require(\"react/jsx-runtime\");\nfunction Tooltip({ children, label, kbd: kbdProperty, id, side = \"top\" }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"span\", { id, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)($a093c7e1ec25a057$export$2881499e37b75b9a, { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)($a093c7e1ec25a057$export$be92b6f5f03c0fe9, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)($a093c7e1ec25a057$export$41fb9f06171c75f4, { dir: \"ltr\", asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"span\", { children }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(StyledContent, { dir: \"ltr\", side, sideOffset: 8, children: [\n      label,\n      kbdProperty ? /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Kbd, { variant: \"tooltip\", children: kbdProperty }) : null,\n      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(StyledArrow, {})\n    ] })\n  ] }) }) });\n}\nvar StyledContent = styled($a093c7e1ec25a057$export$7c6e2c02157bb7d2, {\n  borderRadius: 3,\n  padding: \"$3 $3 $3 $3\",\n  fontSize: \"$1\",\n  backgroundColor: \"$tooltip\",\n  color: \"$tooltipContrast\",\n  boxShadow: \"$3\",\n  display: \"flex\",\n  alignItems: \"center\",\n  fontFamily: \"$ui\",\n  userSelect: \"none\"\n});\nvar StyledArrow = styled($a093c7e1ec25a057$export$21b07c8f274aebd5, {\n  fill: \"$tooltip\",\n  margin: \"0 8px\"\n});\n\n// src/components/Tldraw/hooks/useFileSystem.ts\nvar React10 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/hooks/useFileSystemHandlers.ts\nvar React11 = __toESM(require(\"react\"));\nfunction useFileSystemHandlers() {\n  const app = useTldrawApp();\n  const onOpenMedia = React11.useCallback(\n    (event) => {\n      if (event !== void 0 && app.callbacks.onOpenMedia !== void 0)\n        event.preventDefault();\n      app.callbacks.onOpenMedia?.(app);\n    },\n    [app]\n  );\n  return {\n    onOpenMedia\n  };\n}\n\n// src/components/Tldraw/hooks/useKeyboardShortcuts.tsx\nvar React12 = __toESM(require(\"react\"));\n\n// node_modules/.pnpm/react-hotkeys-hook@4.4.0_react-dom@18.2.0_react@18.2.0/node_modules/react-hotkeys-hook/dist/react-hotkeys-hook.esm.js\nvar import_react36 = require(\"react\");\nvar import_jsx_runtime5 = require(\"react/jsx-runtime\");\nfunction _extends2() {\n  _extends2 = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i4 = 1; i4 < arguments.length; i4++) {\n      var source = arguments[i4];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends2.apply(this, arguments);\n}\nvar reservedModifierKeywords = [\"shift\", \"alt\", \"meta\", \"mod\", \"ctrl\"];\nvar mappedKeys = {\n  esc: \"escape\",\n  \"return\": \"enter\",\n  \".\": \"period\",\n  \",\": \"comma\",\n  \"-\": \"slash\",\n  \" \": \"space\",\n  \"`\": \"backquote\",\n  \"#\": \"backslash\",\n  \"+\": \"bracketright\",\n  ShiftLeft: \"shift\",\n  ShiftRight: \"shift\",\n  AltLeft: \"alt\",\n  AltRight: \"alt\",\n  MetaLeft: \"meta\",\n  MetaRight: \"meta\",\n  OSLeft: \"meta\",\n  OSRight: \"meta\",\n  ControlLeft: \"ctrl\",\n  ControlRight: \"ctrl\"\n};\nfunction mapKey(key) {\n  return (mappedKeys[key] || key).trim().toLowerCase().replace(/key|digit|numpad|arrow/, \"\");\n}\nfunction isHotkeyModifier(key) {\n  return reservedModifierKeywords.includes(key);\n}\nfunction parseKeysHookInput(keys, splitKey) {\n  if (splitKey === void 0) {\n    splitKey = \",\";\n  }\n  return keys.split(splitKey);\n}\nfunction parseHotkey(hotkey, combinationKey, description) {\n  if (combinationKey === void 0) {\n    combinationKey = \"+\";\n  }\n  var keys = hotkey.toLocaleLowerCase().split(combinationKey).map(function(k7) {\n    return mapKey(k7);\n  });\n  var modifiers = {\n    alt: keys.includes(\"alt\"),\n    ctrl: keys.includes(\"ctrl\") || keys.includes(\"control\"),\n    shift: keys.includes(\"shift\"),\n    meta: keys.includes(\"meta\"),\n    mod: keys.includes(\"mod\")\n  };\n  var singleCharKeys = keys.filter(function(k7) {\n    return !reservedModifierKeywords.includes(k7);\n  });\n  return _extends2({}, modifiers, {\n    keys: singleCharKeys,\n    description\n  });\n}\n(function() {\n  if (typeof document !== \"undefined\") {\n    document.addEventListener(\"keydown\", function(e5) {\n      if (e5.key === void 0) {\n        return;\n      }\n      pushToCurrentlyPressedKeys([mapKey(e5.key), mapKey(e5.code)]);\n    });\n    document.addEventListener(\"keyup\", function(e5) {\n      if (e5.key === void 0) {\n        return;\n      }\n      removeFromCurrentlyPressedKeys([mapKey(e5.key), mapKey(e5.code)]);\n    });\n  }\n  if (typeof window !== \"undefined\") {\n    window.addEventListener(\"blur\", function() {\n      currentlyPressedKeys.clear();\n    });\n  }\n})();\nvar currentlyPressedKeys = /* @__PURE__ */ new Set();\nfunction isHotkeyPressed(key, splitKey) {\n  if (splitKey === void 0) {\n    splitKey = \",\";\n  }\n  var hotkeyArray = Array.isArray(key) ? key : key.split(splitKey);\n  return hotkeyArray.every(function(hotkey) {\n    return currentlyPressedKeys.has(hotkey.trim().toLowerCase());\n  });\n}\nfunction pushToCurrentlyPressedKeys(key) {\n  var hotkeyArray = Array.isArray(key) ? key : [key];\n  if (currentlyPressedKeys.has(\"meta\")) {\n    currentlyPressedKeys.forEach(function(key2) {\n      return !isHotkeyModifier(key2) && currentlyPressedKeys[\"delete\"](key2.toLowerCase());\n    });\n  }\n  hotkeyArray.forEach(function(hotkey) {\n    return currentlyPressedKeys.add(hotkey.toLowerCase());\n  });\n}\nfunction removeFromCurrentlyPressedKeys(key) {\n  var hotkeyArray = Array.isArray(key) ? key : [key];\n  if (key === \"meta\") {\n    currentlyPressedKeys.clear();\n  } else {\n    hotkeyArray.forEach(function(hotkey) {\n      return currentlyPressedKeys[\"delete\"](hotkey.toLowerCase());\n    });\n  }\n}\nfunction maybePreventDefault(e5, hotkey, preventDefault2) {\n  if (typeof preventDefault2 === \"function\" && preventDefault2(e5, hotkey) || preventDefault2 === true) {\n    e5.preventDefault();\n  }\n}\nfunction isHotkeyEnabled(e5, hotkey, enabled) {\n  if (typeof enabled === \"function\") {\n    return enabled(e5, hotkey);\n  }\n  return enabled === true || enabled === void 0;\n}\nfunction isKeyboardEventTriggeredByInput(ev) {\n  return isHotkeyEnabledOnTag(ev, [\"input\", \"textarea\", \"select\"]);\n}\nfunction isHotkeyEnabledOnTag(_ref, enabledOnTags) {\n  var target = _ref.target;\n  if (enabledOnTags === void 0) {\n    enabledOnTags = false;\n  }\n  var targetTagName = target && target.tagName;\n  if (enabledOnTags instanceof Array) {\n    return Boolean(targetTagName && enabledOnTags && enabledOnTags.some(function(tag) {\n      return tag.toLowerCase() === targetTagName.toLowerCase();\n    }));\n  }\n  return Boolean(targetTagName && enabledOnTags && enabledOnTags === true);\n}\nfunction isScopeActive(activeScopes, scopes) {\n  if (activeScopes.length === 0 && scopes) {\n    console.warn('A hotkey has the \"scopes\" option set, however no active scopes were found. If you want to use the global scopes feature, you need to wrap your app in a <HotkeysProvider>');\n    return true;\n  }\n  if (!scopes) {\n    return true;\n  }\n  return activeScopes.some(function(scope) {\n    return scopes.includes(scope);\n  }) || activeScopes.includes(\"*\");\n}\nvar isHotkeyMatchingKeyboardEvent = function isHotkeyMatchingKeyboardEvent2(e5, hotkey, ignoreModifiers) {\n  if (ignoreModifiers === void 0) {\n    ignoreModifiers = false;\n  }\n  var alt = hotkey.alt, meta = hotkey.meta, mod = hotkey.mod, shift = hotkey.shift, ctrl = hotkey.ctrl, keys = hotkey.keys;\n  var pressedKeyUppercase = e5.key, code = e5.code, ctrlKey = e5.ctrlKey, metaKey = e5.metaKey, shiftKey = e5.shiftKey, altKey = e5.altKey;\n  var keyCode = mapKey(code);\n  var pressedKey = pressedKeyUppercase.toLowerCase();\n  if (!ignoreModifiers) {\n    if (alt === !altKey && pressedKey !== \"alt\") {\n      return false;\n    }\n    if (shift === !shiftKey && pressedKey !== \"shift\") {\n      return false;\n    }\n    if (mod) {\n      if (!metaKey && !ctrlKey) {\n        return false;\n      }\n    } else {\n      if (meta === !metaKey && pressedKey !== \"meta\" && pressedKey !== \"os\") {\n        return false;\n      }\n      if (ctrl === !ctrlKey && pressedKey !== \"ctrl\" && pressedKey !== \"control\") {\n        return false;\n      }\n    }\n  }\n  if (keys && keys.length === 1 && (keys.includes(pressedKey) || keys.includes(keyCode))) {\n    return true;\n  } else if (keys) {\n    return isHotkeyPressed(keys);\n  } else if (!keys) {\n    return true;\n  }\n  return false;\n};\nvar BoundHotkeysProxyProvider = /* @__PURE__ */ (0, import_react36.createContext)(void 0);\nvar useBoundHotkeysProxy = function useBoundHotkeysProxy2() {\n  return (0, import_react36.useContext)(BoundHotkeysProxyProvider);\n};\nfunction deepEqual2(x5, y6) {\n  return x5 && y6 && typeof x5 === \"object\" && typeof y6 === \"object\" ? Object.keys(x5).length === Object.keys(y6).length && //@ts-ignore\n  Object.keys(x5).reduce(function(isEqual, key) {\n    return isEqual && deepEqual2(x5[key], y6[key]);\n  }, true) : x5 === y6;\n}\nvar HotkeysContext = /* @__PURE__ */ (0, import_react36.createContext)({\n  hotkeys: [],\n  enabledScopes: [],\n  toggleScope: function toggleScope() {\n  },\n  enableScope: function enableScope() {\n  },\n  disableScope: function disableScope() {\n  }\n});\nvar useHotkeysContext = function useHotkeysContext2() {\n  return (0, import_react36.useContext)(HotkeysContext);\n};\nfunction useDeepEqualMemo(value) {\n  var ref = (0, import_react36.useRef)(void 0);\n  if (!deepEqual2(ref.current, value)) {\n    ref.current = value;\n  }\n  return ref.current;\n}\nvar stopPropagation = function stopPropagation2(e5) {\n  e5.stopPropagation();\n  e5.preventDefault();\n  e5.stopImmediatePropagation();\n};\nvar useSafeLayoutEffect = typeof window !== \"undefined\" ? import_react36.useLayoutEffect : import_react36.useEffect;\nfunction useHotkeys(keys, callback, options, dependencies) {\n  var ref = (0, import_react36.useRef)(null);\n  var hasTriggeredRef = (0, import_react36.useRef)(false);\n  var _options = !(options instanceof Array) ? options : !(dependencies instanceof Array) ? dependencies : void 0;\n  var _keys = keys instanceof Array ? keys.join(_options == null ? void 0 : _options.splitKey) : keys;\n  var _deps = options instanceof Array ? options : dependencies instanceof Array ? dependencies : void 0;\n  var memoisedCB = (0, import_react36.useCallback)(callback, _deps != null ? _deps : []);\n  var cbRef = (0, import_react36.useRef)(memoisedCB);\n  if (_deps) {\n    cbRef.current = memoisedCB;\n  } else {\n    cbRef.current = callback;\n  }\n  var memoisedOptions = useDeepEqualMemo(_options);\n  var _useHotkeysContext = useHotkeysContext(), enabledScopes = _useHotkeysContext.enabledScopes;\n  var proxy = useBoundHotkeysProxy();\n  useSafeLayoutEffect(function() {\n    if ((memoisedOptions == null ? void 0 : memoisedOptions.enabled) === false || !isScopeActive(enabledScopes, memoisedOptions == null ? void 0 : memoisedOptions.scopes)) {\n      return;\n    }\n    var listener = function listener2(e5, isKeyUp) {\n      var _e$target;\n      if (isKeyUp === void 0) {\n        isKeyUp = false;\n      }\n      if (isKeyboardEventTriggeredByInput(e5) && !isHotkeyEnabledOnTag(e5, memoisedOptions == null ? void 0 : memoisedOptions.enableOnFormTags)) {\n        return;\n      }\n      if (memoisedOptions != null && memoisedOptions.ignoreEventWhen != null && memoisedOptions.ignoreEventWhen(e5)) {\n        return;\n      }\n      if (ref.current !== null && document.activeElement !== ref.current && !ref.current.contains(document.activeElement)) {\n        stopPropagation(e5);\n        return;\n      }\n      if ((_e$target = e5.target) != null && _e$target.isContentEditable && !(memoisedOptions != null && memoisedOptions.enableOnContentEditable)) {\n        return;\n      }\n      parseKeysHookInput(_keys, memoisedOptions == null ? void 0 : memoisedOptions.splitKey).forEach(function(key) {\n        var _hotkey$keys;\n        var hotkey = parseHotkey(key, memoisedOptions == null ? void 0 : memoisedOptions.combinationKey);\n        if (isHotkeyMatchingKeyboardEvent(e5, hotkey, memoisedOptions == null ? void 0 : memoisedOptions.ignoreModifiers) || (_hotkey$keys = hotkey.keys) != null && _hotkey$keys.includes(\"*\")) {\n          if (isKeyUp && hasTriggeredRef.current) {\n            return;\n          }\n          maybePreventDefault(e5, hotkey, memoisedOptions == null ? void 0 : memoisedOptions.preventDefault);\n          if (!isHotkeyEnabled(e5, hotkey, memoisedOptions == null ? void 0 : memoisedOptions.enabled)) {\n            stopPropagation(e5);\n            return;\n          }\n          cbRef.current(e5, hotkey);\n          if (!isKeyUp) {\n            hasTriggeredRef.current = true;\n          }\n        }\n      });\n    };\n    var handleKeyDown = function handleKeyDown2(event) {\n      if (event.key === void 0) {\n        return;\n      }\n      pushToCurrentlyPressedKeys(mapKey(event.code));\n      if ((memoisedOptions == null ? void 0 : memoisedOptions.keydown) === void 0 && (memoisedOptions == null ? void 0 : memoisedOptions.keyup) !== true || memoisedOptions != null && memoisedOptions.keydown) {\n        listener(event);\n      }\n    };\n    var handleKeyUp = function handleKeyUp2(event) {\n      if (event.key === void 0) {\n        return;\n      }\n      removeFromCurrentlyPressedKeys(mapKey(event.code));\n      hasTriggeredRef.current = false;\n      if (memoisedOptions != null && memoisedOptions.keyup) {\n        listener(event, true);\n      }\n    };\n    var domNode = ref.current || (_options == null ? void 0 : _options.document) || document;\n    domNode.addEventListener(\"keyup\", handleKeyUp);\n    domNode.addEventListener(\"keydown\", handleKeyDown);\n    if (proxy) {\n      parseKeysHookInput(_keys, memoisedOptions == null ? void 0 : memoisedOptions.splitKey).forEach(function(key) {\n        return proxy.addHotkey(parseHotkey(key, memoisedOptions == null ? void 0 : memoisedOptions.combinationKey, memoisedOptions == null ? void 0 : memoisedOptions.description));\n      });\n    }\n    return function() {\n      domNode.removeEventListener(\"keyup\", handleKeyUp);\n      domNode.removeEventListener(\"keydown\", handleKeyDown);\n      if (proxy) {\n        parseKeysHookInput(_keys, memoisedOptions == null ? void 0 : memoisedOptions.splitKey).forEach(function(key) {\n          return proxy.removeHotkey(parseHotkey(key, memoisedOptions == null ? void 0 : memoisedOptions.combinationKey, memoisedOptions == null ? void 0 : memoisedOptions.description));\n        });\n      }\n    };\n  }, [_keys, memoisedOptions, enabledScopes]);\n  return ref;\n}\n\n// src/components/Tldraw/types.ts\nvar TDEventHandler = class {\n  onPinchStart;\n  onPinchEnd;\n  onPinch;\n  onKeyDown;\n  onKeyUp;\n  onPointerMove;\n  onPointerUp;\n  onPan;\n  onZoom;\n  onPointerDown;\n  onPointCanvas;\n  onDoubleClickCanvas;\n  onRightPointCanvas;\n  onDragCanvas;\n  onReleaseCanvas;\n  onPointShape;\n  onDoubleClickShape;\n  onRightPointShape;\n  onDragShape;\n  onHoverShape;\n  onUnhoverShape;\n  onReleaseShape;\n  onPointBounds;\n  onDoubleClickBounds;\n  onRightPointBounds;\n  onDragBounds;\n  onHoverBounds;\n  onUnhoverBounds;\n  onReleaseBounds;\n  onPointBoundsHandle;\n  onDoubleClickBoundsHandle;\n  onRightPointBoundsHandle;\n  onDragBoundsHandle;\n  onHoverBoundsHandle;\n  onUnhoverBoundsHandle;\n  onReleaseBoundsHandle;\n  onPointHandle;\n  onDoubleClickHandle;\n  onRightPointHandle;\n  onDragHandle;\n  onHoverHandle;\n  onUnhoverHandle;\n  onReleaseHandle;\n  onShapeBlur;\n  onShapeClone;\n};\nvar SizeStyle = /* @__PURE__ */ ((SizeStyle2) => {\n  SizeStyle2[\"Large\"] = \"large\";\n  SizeStyle2[\"Medium\"] = \"medium\";\n  SizeStyle2[\"Small\"] = \"small\";\n  return SizeStyle2;\n})(SizeStyle || {});\nvar DashStyle = /* @__PURE__ */ ((DashStyle2) => {\n  DashStyle2[\"Dashed\"] = \"dashed\";\n  DashStyle2[\"Dotted\"] = \"dotted\";\n  DashStyle2[\"Draw\"] = \"draw\";\n  DashStyle2[\"Solid\"] = \"solid\";\n  return DashStyle2;\n})(DashStyle || {});\nvar AlignStyle = /* @__PURE__ */ ((AlignStyle2) => {\n  AlignStyle2[\"End\"] = \"end\";\n  AlignStyle2[\"Justify\"] = \"justify\";\n  AlignStyle2[\"Middle\"] = \"middle\";\n  AlignStyle2[\"Start\"] = \"start\";\n  return AlignStyle2;\n})(AlignStyle || {});\nvar FontStyle = /* @__PURE__ */ ((FontStyle2) => {\n  FontStyle2[\"Mono\"] = \"mono\";\n  FontStyle2[\"Sans\"] = \"sans\";\n  FontStyle2[\"Script\"] = \"script\";\n  FontStyle2[\"Serif\"] = \"serif\";\n  return FontStyle2;\n})(FontStyle || {});\nvar TDExportBackground = /* @__PURE__ */ ((TDExportBackground2) => {\n  TDExportBackground2[\"Auto\"] = \"auto\";\n  TDExportBackground2[\"Dark\"] = \"dark\";\n  TDExportBackground2[\"Light\"] = \"light\";\n  TDExportBackground2[\"Transparent\"] = \"transparent\";\n  return TDExportBackground2;\n})(TDExportBackground || {});\n\n// src/components/Tldraw/state/shapes/StickyUtil/constants.ts\nvar STICKY_TEXT_AREA_CLASS_NAME = \"tl-sticky-edit-text-area\";\n\n// src/components/Tldraw/hooks/useKeyboardShortcuts.tsx\nfunction useKeyboardShortcuts(reference) {\n  const app = useTldrawApp();\n  const hotKeySetting = {};\n  const canHandleEvent = React12.useCallback(\n    (ignoreMenus = false) => {\n      const containerElement = reference.current;\n      if (!app.isMouseInBound)\n        return false;\n      if (document.activeElement?.classList?.contains(STICKY_TEXT_AREA_CLASS_NAME))\n        return false;\n      if (ignoreMenus && (app.isMenuOpen || app.settings.keepStyleMenuOpen))\n        return true;\n      return containerElement !== null && (document.activeElement === containerElement || containerElement.contains(document.activeElement));\n    },\n    [reference, app]\n  );\n  React12.useEffect(() => {\n    if (!app)\n      return;\n    const handleCut = (event) => {\n      if (!canHandleEvent(true))\n        return;\n      if (app.readOnly) {\n        app.copy(void 0, event);\n        return;\n      }\n      app.cut(void 0, event);\n    };\n    const handleCopy = (event) => {\n      if (!canHandleEvent(true))\n        return;\n      app.copy(void 0, event);\n    };\n    const handlePaste = (event) => {\n      if (!canHandleEvent(true))\n        return;\n      if (app.readOnly)\n        return;\n      void app.paste(void 0, event);\n    };\n    reference.current?.addEventListener(\"cut\", handleCut);\n    reference.current?.addEventListener(\"copy\", handleCopy);\n    reference.current?.addEventListener(\"paste\", handlePaste);\n    return () => {\n      reference.current?.removeEventListener(\"cut\", handleCut);\n      reference.current?.removeEventListener(\"copy\", handleCopy);\n      reference.current?.removeEventListener(\"paste\", handlePaste);\n    };\n  }, [app]);\n  useHotkeys(\n    \"v,1\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.selectTool(\"select\");\n    },\n    hotKeySetting,\n    [app, reference.current]\n  ).current = reference.current;\n  useHotkeys(\n    \"d,p,2\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.selectTool(\"draw\" /* Draw */);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"e,3\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.selectTool(\"erase\");\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"r,4\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.selectTool(\"rectangle\" /* Rectangle */);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"o,5\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.selectTool(\"ellipse\" /* Ellipse */);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"g,6\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.selectTool(\"triangle\" /* Triangle */);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"l,7\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.selectTool(\"line\" /* Line */);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"a,8\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.selectTool(\"arrow\" /* Arrow */);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"t,9\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.selectTool(\"text\" /* Text */);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"s,0\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.selectTool(\"sticky\" /* Sticky */);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"ctrl+.,\\u2318+.\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.toggleFocusMode();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"ctrl+shift+g,\\u2318+shift+g\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.toggleGrid();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  const { onOpenMedia } = useFileSystemHandlers();\n  useHotkeys(\n    \"ctrl+u,\\u2318+u\",\n    (event) => {\n      if (!canHandleEvent())\n        return;\n      onOpenMedia(event);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"\\u2318+z,ctrl+z\",\n    (event) => {\n      event?.preventDefault();\n      event?.stopPropagation();\n      if (!canHandleEvent(true))\n        return;\n      if (app.session === void 0) {\n        app.undo();\n      } else {\n        app.cancelSession();\n      }\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"ctrl+shift+z,\\u2318+shift+z\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      if (app.session === void 0) {\n        app.redo();\n      } else {\n        app.cancelSession();\n      }\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"\\u2318+u,ctrl+u\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.undoSelect();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"ctrl+shift-u,\\u2318+shift+u\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.redoSelect();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"ctrl+=,\\u2318+=,ctrl+num_add,\\u2318+num_add\",\n    (event) => {\n      if (!canHandleEvent(true))\n        return;\n      app.zoomIn();\n      event?.preventDefault();\n      event?.stopPropagation();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"ctrl+-,\\u2318+-,ctrl+num_subtract,\\u2318+num_subtract\",\n    (event) => {\n      if (!canHandleEvent(true))\n        return;\n      app.zoomOut();\n      event?.preventDefault();\n      event?.stopPropagation();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+0,ctrl+numpad_0,\\u2318+numpad_0\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.resetZoom();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+1\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.zoomToFit();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+2\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.zoomToSelection();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"ctrl+d,\\u2318+d\",\n    (event) => {\n      if (!canHandleEvent())\n        return;\n      app.duplicate();\n      event?.preventDefault();\n      event?.stopPropagation();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+h\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.flipHorizontal();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+v\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.flipVertical();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"escape\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.cancel();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"backspace,del\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.delete();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"\\u2318+a,ctrl+a\",\n    (event) => {\n      if (!canHandleEvent(true))\n        return;\n      event.preventDefault();\n      app.selectAll();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"up\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.nudge([0, -1], false);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"right\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.nudge([1, 0], false);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"down\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.nudge([0, 1], false);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"left\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.nudge([-1, 0], false);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+up\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.nudge([0, -1], true);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+right\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.nudge([1, 0], true);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+down\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.nudge([0, 1], true);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+left\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.nudge([-1, 0], true);\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"\\u2318+shift+l,ctrl+shift+l\",\n    () => {\n      if (!canHandleEvent())\n        return;\n      app.toggleLocked();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"\\u2318+g,ctrl+g\",\n    (event) => {\n      if (!canHandleEvent())\n        return;\n      event?.preventDefault();\n      event?.stopPropagation();\n      app.group();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"\\u2318+shift+g,ctrl+shift+g\",\n    (event) => {\n      if (!canHandleEvent())\n        return;\n      event?.preventDefault();\n      event?.stopPropagation();\n      app.ungroup();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"[\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.moveBackward();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"]\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.moveForward();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+[\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.moveToBack();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"shift+]\",\n    () => {\n      if (!canHandleEvent(true))\n        return;\n      app.moveToFront();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"ctrl+shift+backspace,\\u2318+shift+backspace\",\n    (event) => {\n      if (!canHandleEvent())\n        return;\n      if (app.settings.isDebugMode) {\n        app.resetDocument();\n      }\n      event?.preventDefault();\n      event?.stopPropagation();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"alt+command+l,alt+ctrl+l\",\n    (event) => {\n      if (!canHandleEvent(true))\n        return;\n      app.style({ textAlign: \"start\" /* Start */ });\n      event?.preventDefault();\n      event?.stopPropagation();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"alt+command+t,alt+ctrl+t\",\n    (event) => {\n      if (!canHandleEvent(true))\n        return;\n      app.style({ textAlign: \"middle\" /* Middle */ });\n      event?.preventDefault();\n      event?.stopPropagation();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n  useHotkeys(\n    \"alt+command+r,alt+ctrl+r\",\n    (event) => {\n      if (!canHandleEvent(true))\n        return;\n      app.style({ textAlign: \"end\" /* End */ });\n      event?.preventDefault();\n      event?.stopPropagation();\n    },\n    hotKeySetting,\n    [app]\n  ).current = reference.current;\n}\n\n// src/components/Tldraw/hooks/useTldrawApp.tsx\nvar React13 = __toESM(require(\"react\"));\nvar TldrawContext = React13.createContext({});\nvar useForceUpdate = () => {\n  const [_state, setState] = React13.useState(0);\n  React13.useEffect(() => setState(1));\n};\nfunction useTldrawApp() {\n  const context = React13.useContext(TldrawContext);\n  return context;\n}\nvar ContainerContext = React13.createContext({});\nfunction useContainer() {\n  const context = React13.useContext(ContainerContext);\n  useForceUpdate();\n  return context;\n}\n\n// src/components/Tldraw/hooks/useDialog.ts\nvar React14 = __toESM(require(\"react\"));\nvar AlertDialogContext = React14.createContext({});\nvar useDialog = () => {\n  const context = React14.useContext(AlertDialogContext);\n  if (!context)\n    throw new Error(\"useCtx must be inside a Provider with a value\");\n  return context;\n};\n\n// src/components/Tldraw/components/Primitives/ToolButton/ToolButton.tsx\nvar import_jsx_runtime6 = require(\"react/jsx-runtime\");\nvar ToolButton = React15.forwardRef(\n  ({ onSelect, onClick, onDoubleClick, variant, children, isToolLocked = false, disabled = false, isActive = false, onKeyDown, id, ...rest }, reference) => {\n    return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(\n      StyledToolButton,\n      {\n        ref: reference,\n        isActive,\n        variant,\n        onClick,\n        disabled,\n        onPointerDown: onSelect,\n        onDoubleClick,\n        onKeyDown,\n        bp: breakpoints,\n        id,\n        ...rest,\n        children: [\n          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(StyledToolButtonInner, { children }),\n          isToolLocked && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(ToolLockIndicator, {})\n        ]\n      }\n    );\n  }\n);\nfunction ToolButtonWithTooltip({ label, kbd, isLocked, ...rest }) {\n  const app = useTldrawApp();\n  const handleDoubleClick = React15.useCallback(() => {\n    app.toggleToolLock();\n  }, []);\n  const handleKeyDown = React15.useCallback((e5) => {\n    if (e5.key === \" \" && app.isForcePanning) {\n      e5.preventDefault();\n    }\n  }, []);\n  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Tooltip, { label: label[0].toUpperCase() + label.slice(1), kbd, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(ToolButton, { ...rest, variant: \"primary\", isToolLocked: isLocked && rest.isActive, onDoubleClick: handleDoubleClick, onKeyDown: handleKeyDown }) });\n}\nvar StyledToolButtonInner = styled(\"div\", {\n  position: \"relative\",\n  height: \"100%\",\n  width: \"100%\",\n  backgroundColor: \"$panel\",\n  borderRadius: \"$2\",\n  margin: \"0\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  fontFamily: \"$ui\",\n  color: \"inherit\",\n  userSelect: \"none\",\n  boxSizing: \"border-box\",\n  border: \"1px solid transparent\",\n  \"-webkit-tap-highlight-color\": \"transparent\",\n  \"tap-highlight-color\": \"transparent\"\n});\nvar StyledToolButton = styled(\"button\", {\n  position: \"relative\",\n  color: \"$text\",\n  fontSize: \"$0\",\n  background: \"none\",\n  margin: \"0\",\n  padding: \"$2\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  outline: \"none\",\n  cursor: \"pointer\",\n  pointerEvents: \"all\",\n  height: \"40px\",\n  width: \"40px\",\n  border: \"1px solid $panel\",\n  \"-webkit-tap-highlight-color\": \"transparent\",\n  \"tap-highlight-color\": \"transparent\",\n  [`&:disabled ${StyledToolButtonInner}`]: {\n    opacity: 0.618\n  },\n  variants: {\n    variant: {\n      primary: {\n        marginTop: \"0\"\n      },\n      icon: {\n        [`& ${StyledToolButtonInner}`]: {\n          display: \"grid\",\n          \"& > *\": {\n            gridRow: 1,\n            gridColumn: 1\n          }\n        }\n      },\n      text: {\n        width: \"auto\",\n        [`& ${StyledToolButtonInner}`]: {\n          fontSize: \"$1\",\n          padding: \"0 $3\",\n          gap: \"$3\"\n        }\n      },\n      circle: {\n        padding: 0,\n        height: 32,\n        width: 32,\n        border: \"none\",\n        [`& ${StyledToolButtonInner}`]: {\n          border: \"1px solid $panelContrast\",\n          borderRadius: \"100%\",\n          boxShadow: \"$panel\"\n        },\n        [`& ${StyledToolButtonInner} > svg`]: {\n          width: 14,\n          height: 14\n        }\n      }\n    },\n    isActive: {\n      true: {},\n      false: {}\n    },\n    bp: {\n      mobile: {\n        padding: 0\n      },\n      small: {}\n    }\n  },\n  compoundVariants: [\n    {\n      variant: \"primary\",\n      bp: \"mobile\",\n      css: {\n        height: 40,\n        width: 36,\n        [`& ${StyledToolButtonInner} > svg`]: {\n          width: 16,\n          height: 16\n        }\n      }\n    },\n    {\n      variant: \"primary\",\n      bp: \"small\",\n      css: {\n        height: \"44px\",\n        width: \"44px\",\n        [`& ${StyledToolButtonInner} > svg`]: {\n          width: 20,\n          height: 20\n        }\n      }\n    },\n    {\n      isActive: true,\n      css: {\n        [`${StyledToolButtonInner}`]: {\n          backgroundColor: \"$selected\",\n          color: \"$selectedContrast\"\n        }\n      }\n    },\n    {\n      isActive: false,\n      bp: \"small\",\n      css: {\n        [`&:hover:not(:disabled) ${StyledToolButtonInner}`]: {\n          backgroundColor: \"$hover\"\n        },\n        [`&:focus:not(:disabled) ${StyledToolButtonInner}`]: {\n          backgroundColor: \"$hover\"\n        }\n      }\n    }\n  ]\n});\nvar ToolLockIndicator = styled(\"div\", {\n  position: \"absolute\",\n  width: 10,\n  height: 10,\n  backgroundColor: \"$selected\",\n  borderRadius: \"100%\",\n  bottom: -2,\n  border: \"2px solid $panel\",\n  zIndex: 100\n});\n\n// src/components/Tldraw/components/ContextMenu/ContextMenu.tsx\nvar import_jsx_runtime7 = require(\"react/jsx-runtime\");\nvar numberOfSelectedIdsSelector = (s5) => {\n  return s5.document.pageStates[s5.appState.currentPageId].selectedIds.length;\n};\nvar isDebugModeSelector = (s5) => {\n  return s5.settings.isDebugMode;\n};\nvar hasGroupSelectedSelector = (s5) => {\n  return s5.document.pageStates[s5.appState.currentPageId].selectedIds.some((id) => s5.document.pages[s5.appState.currentPageId].shapes[id].children !== void 0);\n};\nvar preventDefault = (e5) => e5.stopPropagation();\nvar _ContextMenu = ({ onBlur, children }) => {\n  const container = useContainer();\n  return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)($1b0217ee4a91d156$export$be92b6f5f03c0fe9, { dir: \"ltr\", children: [\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$41fb9f06171c75f4, { dir: \"ltr\", children }),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$602eac185826482c, { container: container.current, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$7c6e2c02157bb7d2, { onEscapeKeyDown: preventDefault, tabIndex: -1, onBlur, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(MenuContent, { id: \"TD-ContextMenu\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(InnerMenu, {}) }) }) })\n  ] });\n};\nvar InnerMenu = React16.memo(function InnerMenu2() {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const numberOfSelectedIds = app.useStore(numberOfSelectedIdsSelector);\n  const isDebugMode = app.useStore(isDebugModeSelector);\n  const hasGroupSelected = app.useStore(hasGroupSelectedSelector);\n  const handleFlipHorizontal = React16.useCallback(() => {\n    app.flipHorizontal();\n  }, [app]);\n  const handleFlipVertical = React16.useCallback(() => {\n    app.flipVertical();\n  }, [app]);\n  const handleDuplicate = React16.useCallback(() => {\n    app.duplicate();\n  }, [app]);\n  const handleLock = React16.useCallback(() => {\n    app.toggleLocked();\n  }, [app]);\n  const handleGroup = React16.useCallback(() => {\n    app.group();\n  }, [app]);\n  const handleMoveToBack = React16.useCallback(() => {\n    app.moveToBack();\n  }, [app]);\n  const handleMoveBackward = React16.useCallback(() => {\n    app.moveBackward();\n  }, [app]);\n  const handleMoveForward = React16.useCallback(() => {\n    app.moveForward();\n  }, [app]);\n  const handleMoveToFront = React16.useCallback(() => {\n    app.moveToFront();\n  }, [app]);\n  const handleDelete = React16.useCallback(() => {\n    app.delete();\n  }, [app]);\n  const handleCut = React16.useCallback(() => {\n    app.cut();\n  }, [app]);\n  const handleCopy = React16.useCallback(() => {\n    app.copy();\n  }, [app]);\n  const handlePaste = React16.useCallback(() => {\n    app.paste();\n  }, [app]);\n  const handleCopySVG = React16.useCallback(() => {\n    app.copyImage(\"svg\" /* SVG */, { scale: 1, quality: 1, transparentBackground: false });\n  }, [app]);\n  const handleCopyPNG = React16.useCallback(() => {\n    app.copyImage(\"png\" /* PNG */, { scale: 2, quality: 1, transparentBackground: true });\n  }, [app]);\n  const handleUndo = React16.useCallback(() => {\n    app.undo();\n  }, [app]);\n  const handleRedo = React16.useCallback(() => {\n    app.redo();\n  }, [app]);\n  const handleExportPNG = React16.useCallback(async () => {\n    app.exportImage(\"png\" /* PNG */, { scale: 2, quality: 1 });\n  }, [app]);\n  const handleExportJPG = React16.useCallback(async () => {\n    app.exportImage(\"jpeg\" /* JPG */, { scale: 2, quality: 1 });\n  }, [app]);\n  const handleExportWEBP = React16.useCallback(async () => {\n    app.exportImage(\"webp\" /* WEBP */, { scale: 2, quality: 1 });\n  }, [app]);\n  const handleExportSVG = React16.useCallback(async () => {\n    app.exportImage(\"svg\" /* SVG */, { scale: 1, quality: 1 });\n  }, [app]);\n  const handleCopyJSON = React16.useCallback(async () => {\n    app.copyJson();\n  }, [app]);\n  const handleExportJSON = React16.useCallback(async () => {\n    app.exportJson();\n  }, [app]);\n  const hasSelection = numberOfSelectedIds > 0;\n  const hasTwoOrMore = numberOfSelectedIds > 1;\n  const hasThreeOrMore = numberOfSelectedIds > 2;\n  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, { children: hasSelection ? /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleDuplicate, kbd: \"#D\", id: \"TD-ContextMenu-Duplicate\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"duplicate\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleFlipHorizontal, kbd: \"\\u21E7H\", id: \"TD-ContextMenu-Flip_Horizontal\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"flip.horizontal\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleFlipVertical, kbd: \"\\u21E7V\", id: \"TD-ContextMenu-Flip_Vertical\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"flip.vertical\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(CMRowButton, { onClick: handleLock, kbd: \"#\\u21E7L\", id: \"TD-ContextMenu- Lock_Unlock\", children: [\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"lock\" }),\n      \" / \",\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"unlock\" })\n    ] }),\n    (hasTwoOrMore || hasGroupSelected) && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Divider, {}),\n    hasTwoOrMore && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleGroup, kbd: \"#G\", id: \"TD-ContextMenu-Group\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"group\" }) }),\n    hasGroupSelected && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleGroup, kbd: \"#G\", id: \"TD-ContextMenu-Ungroup\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"ungroup\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Divider, {}),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(ContextMenuSubMenu, { label: intl.formatMessage({ id: \"move\" }), id: \"TD-ContextMenu-Move\", children: [\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleMoveToFront, kbd: \"\\u21E7]\", id: \"TD-ContextMenu-Move-To_Front\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"to.front\" }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleMoveForward, kbd: \"]\", id: \"TD-ContextMenu-Move-Forward\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"forward\" }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleMoveBackward, kbd: \"[\", id: \"TD-ContextMenu-Move-Backward\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"backward\" }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleMoveToBack, kbd: \"\\u21E7[\", id: \"TD-ContextMenu-Move-To_Back\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"back\" }) })\n    ] }),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(MoveToPageMenu, {}),\n    hasTwoOrMore && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AlignDistributeSubMenu, { hasTwoOrMore, hasThreeOrMore }),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Divider, {}),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleCut, kbd: \"#X\", id: \"TD-ContextMenu-Cut\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"cut\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleCopy, kbd: \"#C\", id: \"TD-ContextMenu-Copy\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"copy\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handlePaste, kbd: \"#V\", id: \"TD-ContextMenu-Paste\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"paste\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Divider, {}),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(ContextMenuSubMenu, { label: `${intl.formatMessage({ id: \"copy.as\" })}...`, size: \"small\", id: \"TD-ContextMenu-Copy-As\", children: [\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleCopySVG, id: \"TD-ContextMenu-Copy-as-SVG\", children: \"SVG\" }),\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleCopyPNG, id: \"TD-ContextMenu-Copy-As-PNG\", children: \"PNG\" }),\n      isDebugMode && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleCopyJSON, id: \"TD-ContextMenu-Copy_as_JSON\", children: \"JSON\" })\n    ] }),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(ContextMenuSubMenu, { label: `${intl.formatMessage({ id: \"export.as\" })}...`, size: \"small\", id: \"TD-ContextMenu-Export\", children: [\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleExportSVG, id: \"TD-ContextMenu-Export-SVG\", children: \"SVG\" }),\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleExportPNG, id: \"TD-ContextMenu-Export-PNG\", children: \"PNG\" }),\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleExportJPG, id: \"TD-ContextMenu-Export-JPG\", children: \"JPG\" }),\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleExportWEBP, id: \"TD-ContextMenu-Export-WEBP\", children: \"WEBP\" }),\n      isDebugMode && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleExportJSON, id: \"TD-ContextMenu-Export-JSON\", children: \"JSON\" })\n    ] }),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Divider, {}),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleDelete, kbd: \"\\u232B\", id: \"TD-ContextMenu-Delete\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"delete\" }) })\n  ] }) : /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handlePaste, kbd: \"#V\", id: \"TD-ContextMenu-Paste\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"paste\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleUndo, kbd: \"#Z\", id: \"TD-ContextMenu-Undo\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"undo\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { onClick: handleRedo, kbd: \"#\\u21E7Z\", id: \"TD-ContextMenu-Redo\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"redo\" }) })\n  ] }) });\n});\nfunction AlignDistributeSubMenu({ hasThreeOrMore }) {\n  const app = useTldrawApp();\n  const alignTop = React16.useCallback(() => {\n    app.align(\"top\" /* Top */);\n  }, [app]);\n  const alignCenterVertical = React16.useCallback(() => {\n    app.align(\"centerVertical\" /* CenterVertical */);\n  }, [app]);\n  const alignBottom = React16.useCallback(() => {\n    app.align(\"bottom\" /* Bottom */);\n  }, [app]);\n  const stretchVertically = React16.useCallback(() => {\n    app.stretch(\"vertical\" /* Vertical */);\n  }, [app]);\n  const distributeVertically = React16.useCallback(() => {\n    app.distribute(\"vertical\" /* Vertical */);\n  }, [app]);\n  const alignLeft = React16.useCallback(() => {\n    app.align(\"left\" /* Left */);\n  }, [app]);\n  const alignCenterHorizontal = React16.useCallback(() => {\n    app.align(\"centerHorizontal\" /* CenterHorizontal */);\n  }, [app]);\n  const alignRight = React16.useCallback(() => {\n    app.align(\"right\" /* Right */);\n  }, [app]);\n  const stretchHorizontally = React16.useCallback(() => {\n    app.stretch(\"horizontal\" /* Horizontal */);\n  }, [app]);\n  const distributeHorizontally = React16.useCallback(() => {\n    app.distribute(\"horizontal\" /* Horizontal */);\n  }, [app]);\n  const container = useContainer();\n  return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)($1b0217ee4a91d156$export$d7a01e11500dfb6f, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMSubTriggerButton, { id: \"TD-ContextMenu-Align-Distribute-Trigger\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"align.distribute\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$602eac185826482c, { container: container.current, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$6d4de93b380beddf, { asChild: true, sideOffset: 4, alignOffset: -2, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(StyledGridContent, { numberOfSelected: hasThreeOrMore ? \"threeOrMore\" : \"twoOrMore\", children: [\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: alignLeft, id: \"TD-ContextMenu-Align_Distribute-AlignLeft\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AlignLeftIcon, {}) }),\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: alignCenterHorizontal, id: \"TD-ContextMenu-Align_Distribute-AlignCenterHorizontal\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AlignCenterHorizontallyIcon, {}) }),\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: alignRight, id: \"TD-ContextMenu-Align_Distribute-AlignRight\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AlignRightIcon, {}) }),\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: stretchHorizontally, id: \"TD-ContextMenu-Align_Distribute-StretchHorizontal\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(StretchHorizontallyIcon, {}) }),\n      hasThreeOrMore && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: distributeHorizontally, id: \"TD-ContextMenu-Align_Distribute-SpaceEvenlyHorizontal\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(SpaceEvenlyHorizontallyIcon, {}) }),\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: alignTop, id: \"TD-ContextMenu-Align_Distribute-AlignTop\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AlignTopIcon, {}) }),\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: alignCenterVertical, id: \"TD-ContextMenu-Align_Distribute-AlignCenterVertical\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AlignCenterVerticallyIcon, {}) }),\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: alignBottom, id: \"TD-ContextMenu-Align_Distribute-AlignBottom\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(AlignBottomIcon, {}) }),\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: stretchVertically, id: \"TD-ContextMenu-Align_Distribute-StretchVertical\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(StretchVerticallyIcon, {}) }),\n      hasThreeOrMore && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMIconButton, { onClick: distributeVertically, id: \"TD-ContextMenu-Align_Distribute-SpaceEvenlyVertical\", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(SpaceEvenlyVerticallyIcon, {}) }),\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMArrow, { offset: 13 })\n    ] }) }) })\n  ] });\n}\nvar StyledGridContent = styled(MenuContent, {\n  display: \"grid\",\n  variants: {\n    numberOfSelected: {\n      threeOrMore: {\n        gridTemplateColumns: \"repeat(5, auto)\"\n      },\n      twoOrMore: {\n        gridTemplateColumns: \"repeat(4, auto)\"\n      }\n    }\n  }\n});\nvar currentPageIdSelector = (s5) => s5.appState.currentPageId;\nvar documentPagesSelector = (s5) => s5.document.pages;\nfunction MoveToPageMenu() {\n  const app = useTldrawApp();\n  const currentPageId = app.useStore(currentPageIdSelector);\n  const documentPages = app.useStore(documentPagesSelector);\n  const sorted = Object.values(documentPages).sort((a7, b6) => (a7.childIndex || 0) - (b6.childIndex || 0)).filter((a7) => a7.id !== currentPageId);\n  const container = useContainer();\n  if (sorted.length === 0)\n    return null;\n  return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)($1b0217ee4a91d156$export$d7a01e11500dfb6f, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMSubTriggerButton, { children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FormattedMessage, { id: \"move.to.page\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$602eac185826482c, { container: container.current, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$6d4de93b380beddf, { sideOffset: 4, alignOffset: -2, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(MenuContent, { children: [\n      sorted.map(({ id, name }, index2) => /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMRowButton, { disabled: id === currentPageId, onClick: () => app.moveToPage(id), children: name || `Page ${index2}` }, id)),\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMArrow, { offset: 13 })\n    ] }) }) })\n  ] });\n}\nfunction ContextMenuSubMenu({ children, label, size, id }) {\n  const container = useContainer();\n  return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)($1b0217ee4a91d156$export$d7a01e11500dfb6f, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMSubTriggerButton, { children: label }),\n    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$602eac185826482c, { container: container.current, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$6d4de93b380beddf, { sideOffset: 4, alignOffset: -2, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(MenuContent, { size, children: [\n      children,\n      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CMArrow, { offset: 13 })\n    ] }) }) })\n  ] });\n}\nvar CMArrow = styled($1b0217ee4a91d156$export$f47d0a58228a61e2, {\n  fill: \"$panel\"\n});\nfunction CMIconButton({ onSelect, ...rest }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$16a26dc176a49100, { dir: \"ltr\", onSelect, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(ToolButton, { ...rest }) });\n}\nvar CMRowButton = ({ id, ...rest }) => {\n  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$16a26dc176a49100, { asChild: true, id, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(RowButton, { ...rest }) });\n};\nvar CMSubTriggerButton = ({ id, ...rest }) => {\n  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)($1b0217ee4a91d156$export$2ea8a7a591ac5eac, { asChild: true, id, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(RowButton, { hasArrow: true, ...rest }) });\n};\nvar ContextMenu = React16.memo(_ContextMenu);\n\n// src/components/Tldraw/components/Primitives/IconButton/IconButton.tsx\nvar IconButton = styled(\"button\", {\n  position: \"relative\",\n  height: \"32px\",\n  width: \"32px\",\n  backgroundColor: \"$panel\",\n  borderRadius: \"4px\",\n  padding: \"0\",\n  margin: \"0\",\n  outline: \"none\",\n  border: \"none\",\n  pointerEvents: \"all\",\n  fontSize: \"$0\",\n  color: \"$text\",\n  cursor: \"pointer\",\n  display: \"grid\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  \"& > *\": {\n    gridRow: 1,\n    gridColumn: 1\n  },\n  \"&:disabled\": {\n    opacity: \"0.5\"\n  },\n  \"& > span\": {\n    width: \"100%\",\n    height: \"100%\",\n    display: \"flex\",\n    alignItems: \"center\"\n  },\n  variants: {\n    bp: {\n      mobile: {\n        backgroundColor: \"transparent\"\n      },\n      small: {\n        \"&:hover:not(:disabled)\": {\n          backgroundColor: \"$hover\"\n        }\n      }\n    },\n    size: {\n      small: {\n        height: 32,\n        width: 32,\n        \"& svg:nth-of-type(1)\": {\n          height: \"16px\",\n          width: \"16px\"\n        }\n      },\n      medium: {\n        height: 44,\n        width: 44,\n        \"& svg:nth-of-type(1)\": {\n          height: \"18px\",\n          width: \"18px\"\n        }\n      },\n      large: {\n        height: 44,\n        width: 44,\n        \"& svg:nth-of-type(1)\": {\n          height: \"20px\",\n          width: \"20px\"\n        }\n      }\n    },\n    isActive: {\n      true: {\n        color: \"$selected\"\n      }\n    }\n  }\n});\n\n// src/components/Tldraw/components/FocusButton/FocusButton.tsx\nvar import_jsx_runtime8 = require(\"react/jsx-runtime\");\nfunction FocusButton({ onSelect }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(StyledButtonContainer, { children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(IconButton, { onClick: onSelect, children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(DotFilledIcon, {}) }) });\n}\nvar StyledButtonContainer = styled(\"div\", {\n  opacity: 1,\n  zIndex: 100,\n  backgroundColor: \"transparent\",\n  \"& svg\": {\n    color: \"$text\"\n  },\n  \"&:hover svg\": {\n    color: \"$text\"\n  }\n});\n\n// src/components/Tldraw/components/Loading/Loading.tsx\nvar import_jsx_runtime9 = require(\"react/jsx-runtime\");\nvar loadingSelector = (s5) => s5.appState.isLoading;\nfunction Loading() {\n  const app = useTldrawApp();\n  const isLoading = app.useStore(loadingSelector);\n  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(StyledLoadingPanelContainer, { hidden: !isLoading, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(FormattedMessage, { id: \"loading\", values: { dots: \"...\" } }) });\n}\nvar StyledLoadingPanelContainer = styled(\"div\", {\n  position: \"absolute\",\n  top: 0,\n  left: \"50%\",\n  transform: `translate(-50%, 0)`,\n  borderBottomLeftRadius: \"12px\",\n  borderBottomRightRadius: \"12px\",\n  padding: \"8px 16px\",\n  fontFamily: \"var(--fonts-ui)\",\n  fontSize: \"var(--fontSizes-1)\",\n  boxShadow: \"var(--shadows-panel)\",\n  backgroundColor: \"white\",\n  zIndex: 200,\n  pointerEvents: \"none\",\n  \"& > div > *\": {\n    pointerEvents: \"all\"\n  },\n  variants: {\n    transform: {\n      hidden: {\n        transform: `translate(-50%, 100%)`\n      },\n      visible: {\n        transform: `translate(-50%, 0%)`\n      }\n    }\n  }\n});\n\n// node_modules/.pnpm/@radix-ui+react-alert-dialog@1.0.4_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-alert-dialog/dist/index.mjs\nvar import_react38 = require(\"react\");\n\n// node_modules/.pnpm/@radix-ui+react-dialog@1.0.4_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-dialog/dist/index.mjs\nvar import_react37 = require(\"react\");\nvar $5d3850c4d0b4e6c7$var$DIALOG_NAME = \"Dialog\";\nvar [$5d3850c4d0b4e6c7$var$createDialogContext, $5d3850c4d0b4e6c7$export$cc702773b8ea3e41] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($5d3850c4d0b4e6c7$var$DIALOG_NAME);\nvar [$5d3850c4d0b4e6c7$var$DialogProvider, $5d3850c4d0b4e6c7$var$useDialogContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$DIALOG_NAME);\nvar $5d3850c4d0b4e6c7$export$3ddf2d174ce01153 = (props) => {\n  const { __scopeDialog, children, open: openProp, defaultOpen, onOpenChange, modal = true } = props;\n  const triggerRef = (0, import_react37.useRef)(null);\n  const contentRef = (0, import_react37.useRef)(null);\n  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange\n  });\n  return /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$DialogProvider, {\n    scope: __scopeDialog,\n    triggerRef,\n    contentRef,\n    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),\n    titleId: $1746a345f3d73bb7$export$f680877a34711e37(),\n    descriptionId: $1746a345f3d73bb7$export$f680877a34711e37(),\n    open,\n    onOpenChange: setOpen,\n    onOpenToggle: (0, import_react37.useCallback)(\n      () => setOpen(\n        (prevOpen) => !prevOpen\n      ),\n      [\n        setOpen\n      ]\n    ),\n    modal\n  }, children);\n};\nvar $5d3850c4d0b4e6c7$var$TRIGGER_NAME = \"DialogTrigger\";\nvar $5d3850c4d0b4e6c7$export$2e1e1122cf0cba88 = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {\n  const { __scopeDialog, ...triggerProps } = props;\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$TRIGGER_NAME, __scopeDialog);\n  const composedTriggerRef = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.triggerRef);\n  return /* @__PURE__ */ (0, import_react37.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({\n    type: \"button\",\n    \"aria-haspopup\": \"dialog\",\n    \"aria-expanded\": context.open,\n    \"aria-controls\": context.contentId,\n    \"data-state\": $5d3850c4d0b4e6c7$var$getState(context.open)\n  }, triggerProps, {\n    ref: composedTriggerRef,\n    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onOpenToggle)\n  }));\n});\nvar $5d3850c4d0b4e6c7$var$PORTAL_NAME = \"DialogPortal\";\nvar [$5d3850c4d0b4e6c7$var$PortalProvider, $5d3850c4d0b4e6c7$var$usePortalContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, {\n  forceMount: void 0\n});\nvar $5d3850c4d0b4e6c7$export$dad7c95542bacce0 = (props) => {\n  const { __scopeDialog, forceMount, children, container } = props;\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, __scopeDialog);\n  return /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$PortalProvider, {\n    scope: __scopeDialog,\n    forceMount\n  }, import_react37.Children.map(\n    children,\n    (child) => /* @__PURE__ */ (0, import_react37.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {\n      present: forceMount || context.open\n    }, /* @__PURE__ */ (0, import_react37.createElement)($f1701beae083dbae$export$602eac185826482c, {\n      asChild: true,\n      container\n    }, child))\n  ));\n};\nvar $5d3850c4d0b4e6c7$var$OVERLAY_NAME = \"DialogOverlay\";\nvar $5d3850c4d0b4e6c7$export$bd1d06c79be19e17 = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {\n  const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, props.__scopeDialog);\n  const { forceMount = portalContext.forceMount, ...overlayProps } = props;\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, props.__scopeDialog);\n  return context.modal ? /* @__PURE__ */ (0, import_react37.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {\n    present: forceMount || context.open\n  }, /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$DialogOverlayImpl, _extends({}, overlayProps, {\n    ref: forwardedRef\n  }))) : null;\n});\nvar $5d3850c4d0b4e6c7$var$DialogOverlayImpl = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {\n  const { __scopeDialog, ...overlayProps } = props;\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, __scopeDialog);\n  return (\n    // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`\n    // ie. when `Overlay` and `Content` are siblings\n    /* @__PURE__ */ (0, import_react37.createElement)(Combination_default, {\n      as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,\n      allowPinchZoom: true,\n      shards: [\n        context.contentRef\n      ]\n    }, /* @__PURE__ */ (0, import_react37.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({\n      \"data-state\": $5d3850c4d0b4e6c7$var$getState(context.open)\n    }, overlayProps, {\n      ref: forwardedRef,\n      style: {\n        pointerEvents: \"auto\",\n        ...overlayProps.style\n      }\n    })))\n  );\n});\nvar $5d3850c4d0b4e6c7$var$CONTENT_NAME = \"DialogContent\";\nvar $5d3850c4d0b4e6c7$export$b6d9565de1e068cf = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {\n  const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);\n  const { forceMount = portalContext.forceMount, ...contentProps } = props;\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);\n  return /* @__PURE__ */ (0, import_react37.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {\n    present: forceMount || context.open\n  }, context.modal ? /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$DialogContentModal, _extends({}, contentProps, {\n    ref: forwardedRef\n  })) : /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$DialogContentNonModal, _extends({}, contentProps, {\n    ref: forwardedRef\n  })));\n});\nvar $5d3850c4d0b4e6c7$var$DialogContentModal = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);\n  const contentRef = (0, import_react37.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.contentRef, contentRef);\n  (0, import_react37.useEffect)(() => {\n    const content = contentRef.current;\n    if (content)\n      return hideOthers(content);\n  }, []);\n  return /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends({}, props, {\n    ref: composedRefs,\n    trapFocus: context.open,\n    disableOutsidePointerEvents: true,\n    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {\n      var _context$triggerRef$c;\n      event.preventDefault();\n      (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();\n    }),\n    onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownOutside, (event) => {\n      const originalEvent = event.detail.originalEvent;\n      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;\n      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;\n      if (isRightClick)\n        event.preventDefault();\n    }),\n    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(\n      props.onFocusOutside,\n      (event) => event.preventDefault()\n    )\n  }));\n});\nvar $5d3850c4d0b4e6c7$var$DialogContentNonModal = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);\n  const hasInteractedOutsideRef = (0, import_react37.useRef)(false);\n  const hasPointerDownOutsideRef = (0, import_react37.useRef)(false);\n  return /* @__PURE__ */ (0, import_react37.createElement)($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends({}, props, {\n    ref: forwardedRef,\n    trapFocus: false,\n    disableOutsidePointerEvents: false,\n    onCloseAutoFocus: (event) => {\n      var _props$onCloseAutoFoc;\n      (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);\n      if (!event.defaultPrevented) {\n        var _context$triggerRef$c2;\n        if (!hasInteractedOutsideRef.current)\n          (_context$triggerRef$c2 = context.triggerRef.current) === null || _context$triggerRef$c2 === void 0 || _context$triggerRef$c2.focus();\n        event.preventDefault();\n      }\n      hasInteractedOutsideRef.current = false;\n      hasPointerDownOutsideRef.current = false;\n    },\n    onInteractOutside: (event) => {\n      var _props$onInteractOuts, _context$triggerRef$c3;\n      (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);\n      if (!event.defaultPrevented) {\n        hasInteractedOutsideRef.current = true;\n        if (event.detail.originalEvent.type === \"pointerdown\")\n          hasPointerDownOutsideRef.current = true;\n      }\n      const target = event.target;\n      const targetIsTrigger = (_context$triggerRef$c3 = context.triggerRef.current) === null || _context$triggerRef$c3 === void 0 ? void 0 : _context$triggerRef$c3.contains(target);\n      if (targetIsTrigger)\n        event.preventDefault();\n      if (event.detail.originalEvent.type === \"focusin\" && hasPointerDownOutsideRef.current)\n        event.preventDefault();\n    }\n  }));\n});\nvar $5d3850c4d0b4e6c7$var$DialogContentImpl = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {\n  const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, __scopeDialog);\n  const contentRef = (0, import_react37.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);\n  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();\n  return /* @__PURE__ */ (0, import_react37.createElement)(import_react37.Fragment, null, /* @__PURE__ */ (0, import_react37.createElement)($d3863c46a17e8a28$export$20e40289641fbbb6, {\n    asChild: true,\n    loop: true,\n    trapped: trapFocus,\n    onMountAutoFocus: onOpenAutoFocus,\n    onUnmountAutoFocus: onCloseAutoFocus\n  }, /* @__PURE__ */ (0, import_react37.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, _extends({\n    role: \"dialog\",\n    id: context.contentId,\n    \"aria-describedby\": context.descriptionId,\n    \"aria-labelledby\": context.titleId,\n    \"data-state\": $5d3850c4d0b4e6c7$var$getState(context.open)\n  }, contentProps, {\n    ref: composedRefs,\n    onDismiss: () => context.onOpenChange(false)\n  }))), false);\n});\nvar $5d3850c4d0b4e6c7$var$TITLE_NAME = \"DialogTitle\";\nvar $5d3850c4d0b4e6c7$var$DESCRIPTION_NAME = \"DialogDescription\";\nvar $5d3850c4d0b4e6c7$export$94e94c2ec2c954d5 = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {\n  const { __scopeDialog, ...descriptionProps } = props;\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$DESCRIPTION_NAME, __scopeDialog);\n  return /* @__PURE__ */ (0, import_react37.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.p, _extends({\n    id: context.descriptionId\n  }, descriptionProps, {\n    ref: forwardedRef\n  }));\n});\nvar $5d3850c4d0b4e6c7$var$CLOSE_NAME = \"DialogClose\";\nvar $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac = /* @__PURE__ */ (0, import_react37.forwardRef)((props, forwardedRef) => {\n  const { __scopeDialog, ...closeProps } = props;\n  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CLOSE_NAME, __scopeDialog);\n  return /* @__PURE__ */ (0, import_react37.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({\n    type: \"button\"\n  }, closeProps, {\n    ref: forwardedRef,\n    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(\n      props.onClick,\n      () => context.onOpenChange(false)\n    )\n  }));\n});\nfunction $5d3850c4d0b4e6c7$var$getState(open) {\n  return open ? \"open\" : \"closed\";\n}\nvar $5d3850c4d0b4e6c7$var$TITLE_WARNING_NAME = \"DialogTitleWarning\";\nvar [$5d3850c4d0b4e6c7$export$69b62a49393917d6, $5d3850c4d0b4e6c7$var$useWarningContext] = $c512c27ab02ef895$export$fd42f52fd3ae1109($5d3850c4d0b4e6c7$var$TITLE_WARNING_NAME, {\n  contentName: $5d3850c4d0b4e6c7$var$CONTENT_NAME,\n  titleName: $5d3850c4d0b4e6c7$var$TITLE_NAME,\n  docsSlug: \"dialog\"\n});\nvar $5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9 = $5d3850c4d0b4e6c7$export$3ddf2d174ce01153;\nvar $5d3850c4d0b4e6c7$export$41fb9f06171c75f4 = $5d3850c4d0b4e6c7$export$2e1e1122cf0cba88;\nvar $5d3850c4d0b4e6c7$export$602eac185826482c = $5d3850c4d0b4e6c7$export$dad7c95542bacce0;\nvar $5d3850c4d0b4e6c7$export$c6fdb837b070b4ff = $5d3850c4d0b4e6c7$export$bd1d06c79be19e17;\nvar $5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2 = $5d3850c4d0b4e6c7$export$b6d9565de1e068cf;\nvar $5d3850c4d0b4e6c7$export$393edc798c47379d = $5d3850c4d0b4e6c7$export$94e94c2ec2c954d5;\nvar $5d3850c4d0b4e6c7$export$f39c2d165cd861fe = $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac;\n\n// node_modules/.pnpm/@radix-ui+react-alert-dialog@1.0.4_@types+react-dom@18.2.4_@types+react@18.2.7_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-alert-dialog/dist/index.mjs\nvar $905f4ae918aab1aa$var$ROOT_NAME = \"AlertDialog\";\nvar [$905f4ae918aab1aa$var$createAlertDialogContext, $905f4ae918aab1aa$export$b8891880751c2c5b] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($905f4ae918aab1aa$var$ROOT_NAME, [\n  $5d3850c4d0b4e6c7$export$cc702773b8ea3e41\n]);\nvar $905f4ae918aab1aa$var$useDialogScope = $5d3850c4d0b4e6c7$export$cc702773b8ea3e41();\nvar $905f4ae918aab1aa$export$de466dd8317b0b75 = (props) => {\n  const { __scopeAlertDialog, ...alertDialogProps } = props;\n  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);\n  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9, _extends({}, dialogScope, alertDialogProps, {\n    modal: true\n  }));\n};\nvar $905f4ae918aab1aa$export$6edd7a623ef0f40b = /* @__PURE__ */ (0, import_react38.forwardRef)((props, forwardedRef) => {\n  const { __scopeAlertDialog, ...triggerProps } = props;\n  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);\n  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$41fb9f06171c75f4, _extends({}, dialogScope, triggerProps, {\n    ref: forwardedRef\n  }));\n});\nvar $905f4ae918aab1aa$export$660f2bfdb986706c = (props) => {\n  const { __scopeAlertDialog, ...portalProps } = props;\n  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);\n  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$602eac185826482c, _extends({}, dialogScope, portalProps));\n};\nvar $905f4ae918aab1aa$export$a707a4895ce23256 = /* @__PURE__ */ (0, import_react38.forwardRef)((props, forwardedRef) => {\n  const { __scopeAlertDialog, ...overlayProps } = props;\n  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);\n  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$c6fdb837b070b4ff, _extends({}, dialogScope, overlayProps, {\n    ref: forwardedRef\n  }));\n});\nvar $905f4ae918aab1aa$var$CONTENT_NAME = \"AlertDialogContent\";\nvar [$905f4ae918aab1aa$var$AlertDialogContentProvider, $905f4ae918aab1aa$var$useAlertDialogContentContext] = $905f4ae918aab1aa$var$createAlertDialogContext($905f4ae918aab1aa$var$CONTENT_NAME);\nvar $905f4ae918aab1aa$export$94e6af45f0af4efd = /* @__PURE__ */ (0, import_react38.forwardRef)((props, forwardedRef) => {\n  const { __scopeAlertDialog, children, ...contentProps } = props;\n  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);\n  const contentRef = (0, import_react38.useRef)(null);\n  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);\n  const cancelRef = (0, import_react38.useRef)(null);\n  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$69b62a49393917d6, {\n    contentName: $905f4ae918aab1aa$var$CONTENT_NAME,\n    titleName: $905f4ae918aab1aa$var$TITLE_NAME,\n    docsSlug: \"alert-dialog\"\n  }, /* @__PURE__ */ (0, import_react38.createElement)($905f4ae918aab1aa$var$AlertDialogContentProvider, {\n    scope: __scopeAlertDialog,\n    cancelRef\n  }, /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2, _extends({\n    role: \"alertdialog\"\n  }, dialogScope, contentProps, {\n    ref: composedRefs,\n    onOpenAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(contentProps.onOpenAutoFocus, (event) => {\n      var _cancelRef$current;\n      event.preventDefault();\n      (_cancelRef$current = cancelRef.current) === null || _cancelRef$current === void 0 || _cancelRef$current.focus({\n        preventScroll: true\n      });\n    }),\n    onPointerDownOutside: (event) => event.preventDefault(),\n    onInteractOutside: (event) => event.preventDefault()\n  }), /* @__PURE__ */ (0, import_react38.createElement)($5e63c961fc1ce211$export$d9f1ccf0bdb05d45, null, children), false)));\n});\nvar $905f4ae918aab1aa$var$TITLE_NAME = \"AlertDialogTitle\";\nvar $905f4ae918aab1aa$export$a23b55cde55ad9a5 = /* @__PURE__ */ (0, import_react38.forwardRef)((props, forwardedRef) => {\n  const { __scopeAlertDialog, ...descriptionProps } = props;\n  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);\n  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$393edc798c47379d, _extends({}, dialogScope, descriptionProps, {\n    ref: forwardedRef\n  }));\n});\nvar $905f4ae918aab1aa$export$b454f818c58ee85d = /* @__PURE__ */ (0, import_react38.forwardRef)((props, forwardedRef) => {\n  const { __scopeAlertDialog, ...actionProps } = props;\n  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);\n  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$f39c2d165cd861fe, _extends({}, dialogScope, actionProps, {\n    ref: forwardedRef\n  }));\n});\nvar $905f4ae918aab1aa$var$CANCEL_NAME = \"AlertDialogCancel\";\nvar $905f4ae918aab1aa$export$2f67a923571aaea0 = /* @__PURE__ */ (0, import_react38.forwardRef)((props, forwardedRef) => {\n  const { __scopeAlertDialog, ...cancelProps } = props;\n  const { cancelRef } = $905f4ae918aab1aa$var$useAlertDialogContentContext($905f4ae918aab1aa$var$CANCEL_NAME, __scopeAlertDialog);\n  const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);\n  const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, cancelRef);\n  return /* @__PURE__ */ (0, import_react38.createElement)($5d3850c4d0b4e6c7$export$f39c2d165cd861fe, _extends({}, dialogScope, cancelProps, {\n    ref\n  }));\n});\nvar $905f4ae918aab1aa$export$be92b6f5f03c0fe9 = $905f4ae918aab1aa$export$de466dd8317b0b75;\nvar $905f4ae918aab1aa$export$41fb9f06171c75f4 = $905f4ae918aab1aa$export$6edd7a623ef0f40b;\nvar $905f4ae918aab1aa$export$602eac185826482c = $905f4ae918aab1aa$export$660f2bfdb986706c;\nvar $905f4ae918aab1aa$export$c6fdb837b070b4ff = $905f4ae918aab1aa$export$a707a4895ce23256;\nvar $905f4ae918aab1aa$export$7c6e2c02157bb7d2 = $905f4ae918aab1aa$export$94e6af45f0af4efd;\nvar $905f4ae918aab1aa$export$e19cd5f9376f8cee = $905f4ae918aab1aa$export$b454f818c58ee85d;\nvar $905f4ae918aab1aa$export$848c9b7ead0df967 = $905f4ae918aab1aa$export$2f67a923571aaea0;\nvar $905f4ae918aab1aa$export$393edc798c47379d = $905f4ae918aab1aa$export$a23b55cde55ad9a5;\n\n// src/components/Tldraw/components/Primitives/AlertDialog/AlertDialog.tsx\nvar import_jsx_runtime10 = require(\"react/jsx-runtime\");\nfunction Content({ children, onClose, container }) {\n  const handleKeyDown = (event) => {\n    switch (event.key) {\n      case \"Escape\": {\n        onClose?.();\n        break;\n      }\n    }\n  };\n  return /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)($905f4ae918aab1aa$export$602eac185826482c, { container, children: [\n    /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(StyledOverlay, {}),\n    /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(StyledContent2, { onKeyDown: handleKeyDown, children })\n  ] });\n}\nvar StyledDescription = styled($905f4ae918aab1aa$export$393edc798c47379d, {\n  marginBottom: 20,\n  color: \"$text\",\n  fontSize: \"$2\",\n  lineHeight: 1.5,\n  textAlign: \"center\",\n  maxWidth: \"62%\",\n  minWidth: 0,\n  alignSelf: \"center\"\n});\nvar AlertDialogRoot = $905f4ae918aab1aa$export$be92b6f5f03c0fe9;\nvar AlertDialogContent = Content;\nvar AlertDialogDescription = StyledDescription;\nvar AlertDialogAction = $905f4ae918aab1aa$export$e19cd5f9376f8cee;\nvar AlertDialogCancel = $905f4ae918aab1aa$export$848c9b7ead0df967;\nvar AlertDialog = ({ container }) => {\n  const { setDialogState, dialogState, onCancel, onNo, onYes } = useDialog();\n  const intl = useIntl();\n  const descriptions = {\n    saveFirstTime: intl.formatMessage({ id: \"dialog.save.firsttime\" }),\n    saveAgain: intl.formatMessage({ id: \"dialog.save.again\" })\n  };\n  return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(AlertDialogRoot, { open: dialogState !== null, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(AlertDialogContent, { onClose: () => setDialogState(null), container, children: [\n    dialogState && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(AlertDialogDescription, { children: descriptions[dialogState] }),\n    /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(\n      \"div\",\n      {\n        style: {\n          width: \"100%\",\n          gap: \"$6\",\n          display: \"flex\",\n          justifyContent: \"space-between\"\n        },\n        children: [\n          onCancel != void 0 && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(AlertDialogCancel, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(\n            Button,\n            {\n              css: { color: \"$text\" },\n              onClick: () => {\n                onCancel();\n                setDialogState(null);\n              },\n              children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(FormattedMessage, { id: \"dialog.cancel\" })\n            }\n          ) }),\n          /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(\"div\", { style: { flexShrink: 0 }, children: [\n            onNo != void 0 && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(AlertDialogAction, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(\n              Button,\n              {\n                onClick: () => {\n                  onNo();\n                  setDialogState(null);\n                },\n                children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(FormattedMessage, { id: \"dialog.no\" })\n              }\n            ) }),\n            onYes != void 0 && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(AlertDialogAction, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(\n              Button,\n              {\n                css: { backgroundColor: \"#2F80ED\", color: \"White\" },\n                onClick: () => {\n                  onYes();\n                  setDialogState(null);\n                },\n                children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(FormattedMessage, { id: \"dialog.yes\" })\n              }\n            ) })\n          ] })\n        ]\n      }\n    )\n  ] }) });\n};\nvar StyledOverlay = styled($905f4ae918aab1aa$export$c6fdb837b070b4ff, {\n  position: \"fixed\",\n  inset: 0,\n  backgroundColor: \"rgba(0, 0, 0, .15)\",\n  pointerEvents: \"all\"\n});\nvar StyledDialogOverlay = styled($905f4ae918aab1aa$export$c6fdb837b070b4ff, {\n  backgroundColor: \"rgba(0, 0, 0, .15)\",\n  position: \"absolute\",\n  pointerEvents: \"all\",\n  inset: 0\n});\nvar StyledContent2 = styled($905f4ae918aab1aa$export$7c6e2c02157bb7d2, {\n  position: \"fixed\",\n  font: \"$ui\",\n  top: \"50%\",\n  left: \"50%\",\n  transform: \"translate(-50%, -50%)\",\n  width: \"max-content\",\n  padding: \"$3\",\n  pointerEvents: \"all\",\n  backgroundColor: \"$panel\",\n  borderRadius: \"$3\",\n  display: \"flex\",\n  flexDirection: \"column\",\n  justifyContent: \"center\",\n  fontFamily: \"$ui\",\n  border: \"1px solid $panelContrast\",\n  boxShadow: \"$panel\"\n});\nvar Button = styled(\"button\", {\n  all: \"unset\",\n  display: \"inline-flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  borderRadius: \"$2\",\n  padding: \"0 15px\",\n  fontSize: \"$1\",\n  lineHeight: 1,\n  fontWeight: \"normal\",\n  height: 36,\n  color: \"$text\",\n  cursor: \"pointer\",\n  minWidth: 48\n});\n\n// src/components/Tldraw/components/ToolsPanel/ToolsPanel.tsx\nvar React22 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/components/ToolsPanel/ActionButton.tsx\nvar React17 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/components/Primitives/DropdownMenu/DMItem.tsx\nvar import_jsx_runtime11 = require(\"react/jsx-runtime\");\nfunction DMItem({ onSelect, id, ...rest }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)($d08ef79370b62062$export$6d08773d2e66f8f2, { dir: \"ltr\", asChild: true, onSelect, id, children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(RowButton, { ...rest }) });\n}\n\n// src/components/Tldraw/components/preventEvent.ts\nvar preventEvent = (e5) => e5.preventDefault();\n\n// src/components/Tldraw/components/Primitives/DropdownMenu/DMCheckboxItem.tsx\nvar import_jsx_runtime12 = require(\"react/jsx-runtime\");\nfunction DMCheckboxItem({ checked, disabled = false, variant, onCheckedChange, kbd, id, children }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)($d08ef79370b62062$export$16ce288f89fa631c, { dir: \"ltr\", onSelect: preventEvent, onCheckedChange, checked, disabled, asChild: true, id, children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(RowButton, { kbd, variant, hasIndicator: true, children }) });\n}\n\n// src/components/Tldraw/components/stopPropagation.ts\nvar stopPropagation3 = (e5) => e5.stopPropagation();\n\n// src/components/Tldraw/components/Primitives/DropdownMenu/DMContent.tsx\nvar import_jsx_runtime13 = require(\"react/jsx-runtime\");\nfunction DMContent({ sideOffset = 4, alignOffset = 0, children, align, variant, id, overflow = false, side = \"bottom\" }) {\n  const container = useContainer();\n  return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)($d08ef79370b62062$export$602eac185826482c, { container: container.current, dir: \"ltr\", children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)($d08ef79370b62062$export$7c6e2c02157bb7d2, { align, alignOffset, sideOffset, onEscapeKeyDown: stopPropagation3, asChild: true, id, side, children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(StyledContent3, { variant, overflow, children }) }) });\n}\nvar StyledContent3 = styled(MenuContent, {\n  width: \"fit-content\",\n  height: \"fit-content\",\n  minWidth: 0,\n  maxHeight: \"100vh\",\n  overflowY: \"auto\",\n  overflowX: \"hidden\",\n  \"&::webkit-scrollbar\": {\n    display: \"none\"\n  },\n  \"-ms-overflow-style\": \"none\",\n  scrollbarWidth: \"none\",\n  variants: {\n    variant: {\n      horizontal: {\n        flexDirection: \"row\"\n      },\n      menu: {\n        minWidth: 128\n      }\n    },\n    overflow: {\n      true: {\n        maxHeight: \"60vh\"\n      }\n    }\n  }\n});\n\n// src/components/Tldraw/components/Primitives/DropdownMenu/DMDivider.tsx\nvar DMDivider = styled($d08ef79370b62062$export$1ff3c3f08ae963c0, {\n  backgroundColor: \"$hover\",\n  height: 1,\n  marginTop: \"$2\",\n  marginRight: \"-$2\",\n  marginBottom: \"$2\",\n  marginLeft: \"-$2\"\n});\n\n// src/components/Tldraw/components/Primitives/DropdownMenu/DMRadioItem.tsx\nvar DMRadioItem = styled($d08ef79370b62062$export$371ab307eab489c0, {\n  height: \"32px\",\n  width: \"32px\",\n  backgroundColor: \"$panel\",\n  borderRadius: \"4px\",\n  padding: \"0\",\n  margin: \"0\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  outline: \"none\",\n  border: \"none\",\n  pointerEvents: \"all\",\n  cursor: \"pointer\",\n  variants: {\n    isActive: {\n      true: {\n        backgroundColor: \"$selected\",\n        color: \"white\"\n      },\n      false: {}\n    },\n    bp: {\n      mobile: {},\n      small: {}\n    }\n  },\n  compoundVariants: [\n    {\n      isActive: false,\n      bp: \"small\",\n      css: {\n        \"&:focus\": {\n          backgroundColor: \"$hover\"\n        },\n        \"&:hover:not(:disabled)\": {\n          backgroundColor: \"$hover\"\n        }\n      }\n    }\n  ]\n});\n\n// src/components/Tldraw/components/Primitives/DropdownMenu/DMSubMenu.tsx\nvar import_jsx_runtime14 = require(\"react/jsx-runtime\");\nfunction DMSubMenu({ children, size, overflow = false, disabled = false, label, id }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)($d08ef79370b62062$export$d7a01e11500dfb6f, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime14.jsx)($d08ef79370b62062$export$2ea8a7a591ac5eac, { dir: \"ltr\", asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(RowButton, { disabled, hasArrow: true, children: label }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime14.jsx)($d08ef79370b62062$export$6d4de93b380beddf, { asChild: true, sideOffset: 4, alignOffset: -4, children: /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)(MenuContent, { size, overflow, children: [\n      children,\n      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)($d08ef79370b62062$export$21b07c8f274aebd5, { offset: 13 })\n    ] }) })\n  ] }, id);\n}\n\n// src/components/Tldraw/components/Primitives/DropdownMenu/DMTriggerIcon.tsx\nvar import_jsx_runtime15 = require(\"react/jsx-runtime\");\nfunction DMTriggerIcon({ id, children, ...rest }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { asChild: true, id, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ToolButton, { ...rest, children }) });\n}\n\n// src/components/Tldraw/components/ToolsPanel/ActionButton.tsx\nvar import_jsx_runtime16 = require(\"react/jsx-runtime\");\nvar dockPositionState = (s5) => s5.settings.dockPosition;\nvar selectedShapesCountSelector = (s5) => s5.document.pageStates[s5.appState.currentPageId].selectedIds.length;\nvar isAllLockedSelector = (s5) => {\n  const page = s5.document.pages[s5.appState.currentPageId];\n  const { selectedIds } = s5.document.pageStates[s5.appState.currentPageId];\n  return selectedIds.every((id) => page.shapes[id].isLocked);\n};\nvar isAllAspectLockedSelector = (s5) => {\n  const page = s5.document.pages[s5.appState.currentPageId];\n  const { selectedIds } = s5.document.pageStates[s5.appState.currentPageId];\n  return selectedIds.every((id) => page.shapes[id].isAspectRatioLocked);\n};\nvar isAllGroupedSelector = (s5) => {\n  const page = s5.document.pages[s5.appState.currentPageId];\n  const selectedShapes = s5.document.pageStates[s5.appState.currentPageId].selectedIds.map((id) => page.shapes[id]);\n  return selectedShapes.every(\n    (shape) => shape.children !== void 0 || shape.parentId === selectedShapes[0].parentId && selectedShapes[0].parentId !== s5.appState.currentPageId\n  );\n};\nvar hasSelectionSelector = (s5) => {\n  const { selectedIds } = s5.document.pageStates[s5.appState.currentPageId];\n  return selectedIds.length > 0;\n};\nvar hasMultipleSelectionSelector = (s5) => {\n  const { selectedIds } = s5.document.pageStates[s5.appState.currentPageId];\n  return selectedIds.length > 1;\n};\nfunction ActionButton() {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const isAllLocked = app.useStore(isAllLockedSelector);\n  const isAllAspectLocked = app.useStore(isAllAspectLockedSelector);\n  const isAllGrouped = app.useStore(isAllGroupedSelector);\n  const hasSelection = app.useStore(hasSelectionSelector);\n  const hasMultipleSelection = app.useStore(hasMultipleSelectionSelector);\n  const selectedShapesCount = app.useStore(selectedShapesCountSelector);\n  const dockPosition = app.useStore(dockPositionState);\n  const hasTwoOrMore = selectedShapesCount > 1;\n  const hasThreeOrMore = selectedShapesCount > 2;\n  const handleRotate = React17.useCallback(() => {\n    app.rotate();\n  }, [app]);\n  const handleDuplicate = React17.useCallback(() => {\n    app.duplicate();\n  }, [app]);\n  const handleToggleLocked = React17.useCallback(() => {\n    app.toggleLocked();\n  }, [app]);\n  const handleToggleAspectRatio = React17.useCallback(() => {\n    app.toggleAspectRatioLocked();\n  }, [app]);\n  const handleGroup = React17.useCallback(() => {\n    app.group();\n  }, [app]);\n  const handleMoveToBack = React17.useCallback(() => {\n    app.moveToBack();\n  }, [app]);\n  const handleMoveBackward = React17.useCallback(() => {\n    app.moveBackward();\n  }, [app]);\n  const handleMoveForward = React17.useCallback(() => {\n    app.moveForward();\n  }, [app]);\n  const handleMoveToFront = React17.useCallback(() => {\n    app.moveToFront();\n  }, [app]);\n  const handleResetAngle = React17.useCallback(() => {\n    app.setShapeProps({ rotation: 0 });\n  }, [app]);\n  const alignTop = React17.useCallback(() => {\n    app.align(\"top\" /* Top */);\n  }, [app]);\n  const alignCenterVertical = React17.useCallback(() => {\n    app.align(\"centerVertical\" /* CenterVertical */);\n  }, [app]);\n  const alignBottom = React17.useCallback(() => {\n    app.align(\"bottom\" /* Bottom */);\n  }, [app]);\n  const stretchVertically = React17.useCallback(() => {\n    app.stretch(\"vertical\" /* Vertical */);\n  }, [app]);\n  const distributeVertically = React17.useCallback(() => {\n    app.distribute(\"vertical\" /* Vertical */);\n  }, [app]);\n  const alignLeft = React17.useCallback(() => {\n    app.align(\"left\" /* Left */);\n  }, [app]);\n  const alignCenterHorizontal = React17.useCallback(() => {\n    app.align(\"centerHorizontal\" /* CenterHorizontal */);\n  }, [app]);\n  const alignRight = React17.useCallback(() => {\n    app.align(\"right\" /* Right */);\n  }, [app]);\n  const stretchHorizontally = React17.useCallback(() => {\n    app.stretch(\"horizontal\" /* Horizontal */);\n  }, [app]);\n  const distributeHorizontally = React17.useCallback(() => {\n    app.distribute(\"horizontal\" /* Horizontal */);\n  }, [app]);\n  const handleMenuOpenChange = React17.useCallback(\n    (open) => {\n      app.setMenuOpen(open);\n    },\n    [app]\n  );\n  const contentSide = dockPosition === \"bottom\" || dockPosition === \"top\" ? \"top\" : dockPosition;\n  return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: \"ltr\", onOpenChange: handleMenuOpenChange, children: [\n    /* @__PURE__ */ (0, import_jsx_runtime16.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { dir: \"ltr\", asChild: true, id: \"TD-Tools-Dots\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { variant: \"circle\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(DotsHorizontalIcon, {}) }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(DMContent, { sideOffset: 16, side: contentSide, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(import_jsx_runtime16.Fragment, { children: [\n      /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(ButtonsRow, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: \"duplicate\" }), kbd: `#D`, id: \"TD-Tools-Copy\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleDuplicate, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(CopyIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: \"rotate\" }), id: \"TD-Tools-Rotate\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleRotate, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(RotateCounterClockwiseIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: isAllLocked ? \"unlock\" : \"lock\" }), kbd: `#L`, id: \"TD-Tools-Lock\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleToggleLocked, children: isAllLocked ? /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(LockClosedIcon, {}) : /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(LockOpen1Icon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(\n          Tooltip,\n          {\n            label: intl.formatMessage({\n              id: isAllAspectLocked ? \"unlock.aspect.ratio\" : \"lock.aspect.ratio\"\n            }),\n            id: \"TD-Tools-AspectRatio\",\n            children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleToggleAspectRatio, children: isAllAspectLocked ? /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AspectRatioIcon, {}) : /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(BoxIcon, {}) })\n          }\n        ),\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: \"group\" }), kbd: `#G`, id: \"TD-Tools-Group\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection || !isAllGrouped && !hasMultipleSelection, onClick: handleGroup, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(GroupIcon, {}) }) })\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(ButtonsRow, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: \"move.to.back\" }), kbd: `#\\u21E7[`, id: \"TD-Tools-PinBottom\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleMoveToBack, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(PinBottomIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: \"move.backward\" }), kbd: `#[`, id: \"TD-Tools-ArrowDown\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleMoveBackward, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ArrowDownIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: \"move.forward\" }), kbd: `#]`, id: \"TD-Tools-ArrowUp\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleMoveForward, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ArrowUpIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: \"move.to.front\" }), kbd: `#\\u21E7]`, id: \"TD-Tools-PinTop\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleMoveToFront, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(PinTopIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: \"reset.angle\" }), id: \"TD-Tools-ResetAngle\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasSelection, onClick: handleResetAngle, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AngleIcon, {}) }) })\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Divider, {}),\n      /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(ButtonsRow, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: \"align.left\" }), id: \"TD-Tools-AlignLeft\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: alignLeft, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AlignLeftIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: \"align.center.x\" }), id: \"TD-Tools-AlignCenterHorizontal\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: alignCenterHorizontal, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AlignCenterHorizontallyIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: \"align.right\" }), id: \"TD-Tools-AlignRight\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: alignRight, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AlignRightIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: \"stretch.x\" }), id: \"TD-Tools-StretchHorizontal\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: stretchHorizontally, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(StretchHorizontallyIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: \"distribute.x\" }), id: \"TD-Tools-SpaceEvenlyHorizontal\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasThreeOrMore, onClick: distributeHorizontally, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(SpaceEvenlyHorizontallyIcon, {}) }) })\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(ButtonsRow, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: \"align.top\" }), id: \"TD-Tools-AlignTop\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: alignTop, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AlignTopIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: \"align.center.y\" }), id: \"TD-Tools-AlignCenterVertical\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: alignCenterVertical, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AlignCenterVerticallyIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: \"align.bottom\" }), id: \"TD-Tools-AlignBottom\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: alignBottom, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AlignBottomIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: \"stretch.y\" }), id: \"TD-Tools-StretchVertical\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasTwoOrMore, onClick: stretchVertically, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(StretchVerticallyIcon, {}) }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Tooltip, { label: intl.formatMessage({ id: \"distribute.y\" }), id: \"TD-Tools-SpaceEvenlyVertical\", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ToolButton, { disabled: !hasThreeOrMore, onClick: distributeVertically, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(SpaceEvenlyVerticallyIcon, {}) }) })\n      ] })\n    ] }) })\n  ] });\n}\nvar ButtonsRow = styled(\"div\", {\n  position: \"relative\",\n  display: \"flex\",\n  width: \"100%\",\n  background: \"none\",\n  border: \"none\",\n  cursor: \"pointer\",\n  outline: \"none\",\n  alignItems: \"center\",\n  justifyContent: \"flex-start\",\n  padding: 0\n});\n\n// src/components/Tldraw/components/ToolsPanel/BackToContent.tsx\nvar React18 = __toESM(require(\"react\"));\nvar import_jsx_runtime17 = require(\"react/jsx-runtime\");\nvar isEmptyCanvasSelector = (s5) => {\n  return s5.appState.isEmptyCanvas && Object.keys(s5.document.pages[s5.appState.currentPageId].shapes).length > 0;\n};\nvar isDebugModeSelector2 = (s5) => s5.settings.isDebugMode;\nvar dockPositionState2 = (s5) => s5.settings.dockPosition;\nvar BackToContent = React18.memo(function BackToContent2() {\n  const app = useTldrawApp();\n  const isEmptyCanvas = app.useStore(isEmptyCanvasSelector);\n  const dockPosition = app.useStore(dockPositionState2);\n  const isDebugMode = app.useStore(isDebugModeSelector2);\n  const style = {\n    bottom: dockPosition === \"bottom\" && isDebugMode ? 120 : dockPosition === \"bottom\" ? 80 : isDebugMode ? 60 : 20,\n    left: \"50%\",\n    transform: \"translate(-50%,0)\"\n  };\n  if (!isEmptyCanvas)\n    return null;\n  return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(BackToContentContainer, { id: \"TD-Tools-Back_to_content\", style: { ...style }, children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(RowButton, { onClick: app.zoomToContent, children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(FormattedMessage, { id: \"zoom.to.content\" }) }) });\n});\nvar BackToContentContainer = styled(MenuContent, {\n  pointerEvents: \"all\",\n  width: \"fit-content\",\n  minWidth: 0,\n  position: \"fixed\",\n  bottom: 0\n});\n\n// src/components/Tldraw/components/ToolsPanel/DeleteButton.tsx\nvar React19 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/components/Primitives/icons/BoxIcon.tsx\nvar import_jsx_runtime18 = require(\"react/jsx-runtime\");\n\n// src/components/Tldraw/components/Primitives/icons/CircleIcon.tsx\nvar import_jsx_runtime19 = require(\"react/jsx-runtime\");\nfunction CircleIcon2(props) {\n  const { size = 16, ...rest } = props;\n  return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(\"svg\", { width: 24, height: 24, ...rest, children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(\"circle\", { cx: 12, cy: 12, r: size / 2 }) });\n}\n\n// src/components/Tldraw/components/Primitives/icons/DashDashedIcon.tsx\nvar import_jsx_runtime20 = require(\"react/jsx-runtime\");\nfunction DashDashedIcon() {\n  return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(\"svg\", { width: \"24\", height: \"24\", stroke: \"currentColor\", xmlns: \"http://www.w3.org/2000/svg\", children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(\"circle\", { cx: 12, cy: 12, r: 8, fill: \"none\", strokeWidth: 2.5, strokeLinecap: \"round\", strokeDasharray: 50.26548 * 0.1 }) });\n}\n\n// src/components/Tldraw/components/Primitives/icons/DashDottedIcon.tsx\nvar import_jsx_runtime21 = require(\"react/jsx-runtime\");\nvar dottedDasharray = `${50.26548 * 0.025} ${50.26548 * 0.1}`;\nfunction DashDottedIcon() {\n  return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(\"svg\", { width: \"24\", height: \"24\", stroke: \"currentColor\", xmlns: \"http://www.w3.org/2000/svg\", children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(\"circle\", { cx: 12, cy: 12, r: 8, fill: \"none\", strokeWidth: 2.5, strokeLinecap: \"round\", strokeDasharray: dottedDasharray }) });\n}\n\n// src/components/Tldraw/components/Primitives/icons/DashDrawIcon.tsx\nvar import_jsx_runtime22 = require(\"react/jsx-runtime\");\nfunction DashDrawIcon() {\n  return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(\"svg\", { width: \"24\", height: \"24\", viewBox: \"1 1.5 21 22\", fill: \"currentColor\", stroke: \"currentColor\", xmlns: \"http://www.w3.org/2000/svg\", children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(\n    \"path\",\n    {\n      d: \"M10.0162 19.2768C10.0162 19.2768 9.90679 19.2517 9.6879 19.2017C9.46275 19.1454 9.12816 19.0422 8.68413 18.8921C8.23384 18.7358 7.81482 18.545 7.42707 18.3199C7.03307 18.101 6.62343 17.7883 6.19816 17.3818C5.77289 16.9753 5.33511 16.3718 4.88482 15.5713C4.43453 14.7645 4.1531 13.8545 4.04053 12.8414C3.92795 11.822 4.04991 10.8464 4.40639 9.91451C4.76286 8.98266 5.39452 8.10084 6.30135 7.26906C7.21444 6.44353 8.29325 5.83377 9.5378 5.43976C10.7823 5.05202 11.833 4.92068 12.6898 5.04576C13.5466 5.16459 14.3878 5.43664 15.2133 5.86191C16.0388 6.28718 16.7768 6.8688 17.4272 7.60678C18.0714 8.34475 18.5404 9.21406 18.8344 10.2147C19.1283 11.2153 19.1721 12.2598 18.9657 13.348C18.7593 14.4299 18.2872 15.4337 17.5492 16.3593C16.8112 17.2849 15.9263 18.0072 14.8944 18.5263C13.8624 19.0391 12.9056 19.3174 12.0238 19.3612C11.142 19.405 10.2101 19.2705 9.22823 18.9578C8.24635 18.6451 7.35828 18.151 6.56402 17.4756C5.77601 16.8002 6.08871 16.8658 7.50212 17.6726C8.90927 18.4731 10.1444 18.8484 11.2076 18.7983C12.2645 18.7545 13.2965 18.4825 14.3034 17.9822C15.3102 17.4819 16.1264 16.8221 16.7518 16.0028C17.3772 15.1835 17.7681 14.3111 17.9244 13.3855C18.0808 12.4599 18.0401 11.5781 17.8025 10.74C17.5586 9.902 17.1739 9.15464 16.6486 8.49797C16.1233 7.8413 15.2289 7.27844 13.9656 6.80939C12.7086 6.34034 11.4203 6.20901 10.1007 6.41539C8.78732 6.61552 7.69599 7.06893 6.82669 7.77564C5.96363 8.48859 5.34761 9.26409 4.97863 10.1021C4.60964 10.9402 4.45329 11.8376 4.50958 12.7945C4.56586 13.7513 4.79101 14.6238 5.18501 15.4118C5.57276 16.1998 5.96363 16.8002 6.35764 17.2129C6.75164 17.6257 7.13313 17.9509 7.50212 18.1886C7.87736 18.4325 8.28074 18.642 8.71227 18.8171C9.15005 18.9922 9.47839 19.111 9.69728 19.1736C9.91617 19.2361 10.0256 19.2705 10.0256 19.2768H10.0162Z\",\n      strokeWidth: \"2\"\n    }\n  ) });\n}\n\n// src/components/Tldraw/components/Primitives/icons/DashSolidIcon.tsx\nvar import_jsx_runtime23 = require(\"react/jsx-runtime\");\nfunction DashSolidIcon() {\n  return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(\"svg\", { width: \"24\", height: \"24\", stroke: \"currentColor\", xmlns: \"http://www.w3.org/2000/svg\", children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(\"circle\", { cx: 12, cy: 12, r: 8, fill: \"none\", strokeWidth: 2, strokeLinecap: \"round\" }) });\n}\n\n// src/components/Tldraw/components/Primitives/icons/TrashIcon.tsx\nvar import_jsx_runtime24 = require(\"react/jsx-runtime\");\nfunction TrashIcon(props) {\n  return /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)(\"svg\", { width: 18, height: 18, viewBox: \"0 0 15 15\", fill: \"currentColor\", xmlns: \"http://www.w3.org/2000/svg\", ...props, children: [\n    /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(\"path\", { fillRule: \"evenodd\", clipRule: \"evenodd\", d: \"M2 4.656a.5.5 0 01.5-.5h9.7a.5.5 0 010 1H2.5a.5.5 0 01-.5-.5z\" }),\n    /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M6.272 3a.578.578 0 00-.578.578v.578h3.311v-.578A.578.578 0 008.428 3H6.272zm3.733 1.156v-.578A1.578 1.578 0 008.428 2H6.272a1.578 1.578 0 00-1.578 1.578v.578H3.578a.5.5 0 00-.5.5V12.2a1.578 1.578 0 001.577 1.578h5.39a1.578 1.578 0 001.577-1.578V4.656a.5.5 0 00-.5-.5h-1.117zm-5.927 1V12.2a.578.578 0 00.577.578h5.39a.578.578 0 00.577-.578V5.156H4.078z\"\n      }\n    ),\n    /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M6.272 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5zM8.428 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5z\"\n      }\n    )\n  ] });\n}\n\n// src/components/Tldraw/components/Primitives/icons/UndoIcon.tsx\nvar import_jsx_runtime25 = require(\"react/jsx-runtime\");\nfunction UndoIcon({ flipHorizontal, ...props }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(\n    \"svg\",\n    {\n      width: 24,\n      height: 24,\n      viewBox: \"0 0 15 15\",\n      fill: \"currentColor\",\n      xmlns: \"http://www.w3.org/2000/svg\",\n      style: {\n        transform: flipHorizontal ? \"scale(-1, 1)\" : \"scale(1, 1)\"\n      },\n      ...props,\n      children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(\"path\", { d: \"M10.6707 8.5081C10.6707 10.1923 9.3004 11.5625 7.61631 11.5625H6.5351C6.35593 11.5625 6.21074 11.4173 6.21074 11.2382V11.13C6.21074 10.9508 6.35591 10.8057 6.5351 10.8057H7.61631C8.88313 10.8057 9.91387 9.77492 9.91387 8.5081C9.91387 7.24128 8.88313 6.21054 7.61631 6.21054H5.62155L6.99534 7.58433C7.14289 7.73183 7.14289 7.97195 6.99534 8.11944C6.85216 8.26251 6.60298 8.2623 6.46013 8.11944L4.44045 6.09971C4.36898 6.02824 4.32959 5.93321 4.32959 5.8321C4.32959 5.73106 4.36898 5.63598 4.44045 5.56454L6.46024 3.54472C6.60309 3.40176 6.85248 3.40176 6.99535 3.54472C7.14291 3.69218 7.14291 3.93234 6.99535 4.07979L5.62156 5.45368H7.61631C9.3004 5.45368 10.6707 6.82393 10.6707 8.5081Z\" })\n    }\n  );\n}\n\n// src/components/Tldraw/components/Primitives/icons/SizeSmallIcon.tsx\nvar import_jsx_runtime26 = require(\"react/jsx-runtime\");\nfunction SizeSmallIcon(props) {\n  return /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(\"svg\", { width: 24, height: 24, viewBox: \"-2 -2 28 28\", fill: \"currentColor\", xmlns: \"http://www.w3.org/2000/svg\", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(\"path\", { d: \"M12.4239 4.62C13.3572 4.62 14.1572 4.73333 14.8239 4.96C15.4906 5.17333 15.9772 5.43333 16.2839 5.74C16.3639 5.82 16.4039 5.94 16.4039 6.1V8.86H14.0639C13.9172 8.86 13.8439 8.78666 13.8439 8.64V7.26C13.4306 7.12666 12.9572 7.06 12.4239 7.06C11.6506 7.06 11.0639 7.18 10.6639 7.42C10.2639 7.66 10.0639 8.04666 10.0639 8.58V9C10.0639 9.38666 10.1639 9.69333 10.3639 9.92C10.5772 10.1333 11.0306 10.3467 11.7239 10.56L13.6439 11.14C14.4706 11.38 15.1172 11.66 15.5839 11.98C16.0506 12.3 16.3772 12.68 16.5639 13.12C16.7639 13.5467 16.8639 14.0733 16.8639 14.7V15.62C16.8639 16.7933 16.4039 17.7133 15.4839 18.38C14.5639 19.0467 13.2839 19.38 11.6439 19.38C10.6706 19.38 9.79723 19.2867 9.0239 19.1C8.2639 18.9133 7.71056 18.6533 7.3639 18.32C7.3239 18.28 7.29056 18.24 7.2639 18.2C7.25056 18.1467 7.2439 18.06 7.2439 17.94V15.74H7.6239C8.2239 16.1533 8.85056 16.4533 9.5039 16.64C10.1572 16.8267 10.9306 16.92 11.8239 16.92C12.6506 16.92 13.2506 16.7867 13.6239 16.52C14.0106 16.2533 14.2039 15.9333 14.2039 15.56V14.88C14.2039 14.6667 14.1639 14.48 14.0839 14.32C14.0172 14.16 13.8706 14.0133 13.6439 13.88C13.4172 13.7467 13.0572 13.6067 12.5639 13.46L10.6639 12.88C9.7839 12.6133 9.11056 12.3 8.6439 11.94C8.17723 11.58 7.85056 11.18 7.6639 10.74C7.49056 10.3 7.4039 9.83333 7.4039 9.34V8.38C7.4039 7.64666 7.61056 7 8.0239 6.44C8.43723 5.88 9.01723 5.44 9.7639 5.12C10.5239 4.78666 11.4106 4.62 12.4239 4.62Z\" }) });\n}\n\n// src/components/Tldraw/components/Primitives/icons/SizeMediumIcon.tsx\nvar import_jsx_runtime27 = require(\"react/jsx-runtime\");\nfunction SizeMediumIcon(props) {\n  return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(\"svg\", { width: 24, height: 24, viewBox: \"-2 -2 28 28\", fill: \"currentColor\", xmlns: \"http://www.w3.org/2000/svg\", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(\"path\", { d: \"M8.16191 19H5.68191C5.53525 19 5.46191 18.9267 5.46191 18.78V5H8.76191C8.88191 5 8.97525 5.03333 9.04191 5.1C9.10858 5.15333 9.17525 5.27333 9.24191 5.46C9.72191 6.59333 10.1686 7.7 10.5819 8.78C11.0086 9.84667 11.4352 10.98 11.8619 12.18H12.1619C12.6019 10.9667 13.0352 9.79333 13.4619 8.66C13.8886 7.52667 14.3552 6.30667 14.8619 5H18.3219C18.4686 5 18.5419 5.07333 18.5419 5.22V19H16.0619C15.9152 19 15.8419 18.9267 15.8419 18.78V16.26C15.8419 15.5267 15.8486 14.8133 15.8619 14.12C15.8886 13.4267 15.9286 12.6867 15.9819 11.9C16.0486 11.1 16.1419 10.1933 16.2619 9.18H15.9019C15.4352 10.3533 14.9486 11.5667 14.4419 12.82C13.9486 14.06 13.4819 15.2333 13.0419 16.34H11.1019C11.0619 16.34 11.0152 16.3333 10.9619 16.32C10.9219 16.2933 10.8886 16.2467 10.8619 16.18C10.4619 15.18 10.0086 14.06 9.50191 12.82C9.00858 11.58 8.53525 10.3667 8.08191 9.18H7.70191C7.83525 10.18 7.93525 11.0733 8.00191 11.86C8.06858 12.6467 8.10858 13.3933 8.12191 14.1C8.14858 14.8067 8.16191 15.5267 8.16191 16.26V19Z\" }) });\n}\n\n// src/components/Tldraw/components/Primitives/icons/SizeLargeIcon.tsx\nvar import_jsx_runtime28 = require(\"react/jsx-runtime\");\nfunction SizeLargeIcon(props) {\n  return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(\"svg\", { width: 24, height: 24, viewBox: \"-2 -2 28 28\", fill: \"currentColor\", xmlns: \"http://www.w3.org/2000/svg\", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(\"path\", { d: \"M7.68191 19C7.53525 19 7.46191 18.9267 7.46191 18.78V5H10.1219C10.2686 5 10.3419 5.07333 10.3419 5.22V16.56H13.4419V15.02H15.7619C15.9086 15.02 15.9819 15.0933 15.9819 15.24V19H7.68191Z\" }) });\n}\n\n// src/components/Tldraw/components/Primitives/icons/EraserIcon.tsx\nvar import_jsx_runtime29 = require(\"react/jsx-runtime\");\nfunction EraserIcon() {\n  return /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)(\"svg\", { width: \"15\", height: \"15\", viewBox: \"0 0 15 15\", fill: \"none\", xmlns: \"http://www.w3.org/2000/svg\", children: [\n    /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(\n      \"path\",\n      {\n        d: \"M1.72838 9.33987L8.84935 2.34732C9.23874 1.96494 9.86279 1.96539 10.2516 2.34831L13.5636 5.60975C13.9655 6.00555 13.9607 6.65526 13.553 7.04507L8.13212 12.2278C7.94604 12.4057 7.69851 12.505 7.44107 12.505L6.06722 12.505L3.83772 12.505C3.5673 12.505 3.30842 12.3954 3.12009 12.2014L1.7114 10.7498C1.32837 10.3551 1.33596 9.72521 1.72838 9.33987Z\",\n        stroke: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(\"line\", { x1: \"6.01807\", y1: \"12.5\", x2: \"10.7959\", y2: \"12.5\", stroke: \"currentColor\", strokeLinecap: \"round\" }),\n    /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(\"line\", { x1: \"5.50834\", y1: \"5.74606\", x2: \"10.1984\", y2: \"10.4361\", stroke: \"currentColor\" })\n  ] });\n}\n\n// src/components/Tldraw/components/Primitives/icons/DiscordIcon.tsx\nvar import_jsx_runtime30 = require(\"react/jsx-runtime\");\n\n// src/components/Tldraw/components/Primitives/icons/LineIcon.tsx\nvar import_jsx_runtime31 = require(\"react/jsx-runtime\");\nfunction LineIcon() {\n  return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(\"svg\", { width: \"15\", height: \"15\", viewBox: \"0 0 15 15\", fill: \"currentColor\", xmlns: \"http://www.w3.org/2000/svg\", children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(\"path\", { d: \"M3.64645 11.3536C3.45118 11.1583 3.45118 10.8417 3.64645 10.6465L11.1464 3.14645C11.3417 2.95118 11.6583 2.95118 11.8536 3.14645C12.0488 3.34171 12.0488 3.65829 11.8536 3.85355L4.35355 11.3536C4.15829 11.5488 3.84171 11.5488 3.64645 11.3536Z\" }) });\n}\n\n// src/components/Tldraw/components/ToolsPanel/DeleteButton.tsx\nvar import_jsx_runtime32 = require(\"react/jsx-runtime\");\nfunction DeleteButton() {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const handleDelete = React19.useCallback(() => {\n    app.delete();\n  }, [app]);\n  const hasSelection = app.useStore((s5) => s5.appState.status === \"idle\" && s5.document.pageStates[s5.appState.currentPageId].selectedIds.length > 0);\n  return /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(Tooltip, { label: intl.formatMessage({ id: \"delete\" }), kbd: \"\\u232B\", id: \"TD-Delete\", children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(ToolButton, { variant: \"circle\", disabled: !hasSelection, onSelect: handleDelete, children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(TrashIcon, {}) }) });\n}\n\n// src/components/Tldraw/components/ToolsPanel/PrimaryTools.tsx\nvar React21 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/components/Primitives/Panel/Panel.tsx\nvar Panel = styled(\"div\", {\n  backgroundColor: \"$panel\",\n  display: \"flex\",\n  flexDirection: \"row\",\n  boxShadow: \"$panel\",\n  padding: \"$2\",\n  border: \"1px solid $panelContrast\",\n  gap: 0,\n  overflow: \"hidden\",\n  variants: {\n    side: {\n      center: {\n        borderRadius: 9\n      },\n      left: {\n        padding: 0,\n        borderTop: 0,\n        borderLeft: 0,\n        borderTopRightRadius: 0,\n        borderBottomRightRadius: 9,\n        borderBottomLeftRadius: 0\n      },\n      right: {\n        padding: 0,\n        borderTop: 0,\n        borderRight: 0,\n        borderTopLeftRadius: 0,\n        borderBottomLeftRadius: 9,\n        borderBottomRightRadius: 0\n      }\n    }\n  },\n  \"& hr\": {\n    height: 10,\n    width: \"100%\",\n    backgroundColor: \"red\",\n    border: \"none\"\n  }\n});\n\n// src/components/Tldraw/components/ToolsPanel/ShapesMenu.tsx\nvar React20 = __toESM(require(\"react\"));\nvar import_jsx_runtime33 = require(\"react/jsx-runtime\");\nvar shapeShapes = [\"rectangle\" /* Rectangle */, \"ellipse\" /* Ellipse */, \"triangle\" /* Triangle */, \"line\" /* Line */];\nvar shapeShapeIcons = {\n  [\"rectangle\" /* Rectangle */]: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(SquareIcon, {}),\n  [\"ellipse\" /* Ellipse */]: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(CircleIcon, {}),\n  [\"triangle\" /* Triangle */]: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(VercelLogoIcon, {}),\n  [\"line\" /* Line */]: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(LineIcon, {})\n};\nvar dockPositionState3 = (s5) => s5.settings.dockPosition;\nvar ShapesMenu = React20.memo(function ShapesMenu2({ activeTool, isToolLocked }) {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const dockPosition = app.useStore(dockPositionState3);\n  const [lastActiveTool, setLastActiveTool] = React20.useState(\"rectangle\" /* Rectangle */);\n  React20.useEffect(() => {\n    if (shapeShapes.includes(activeTool) && lastActiveTool !== activeTool) {\n      setLastActiveTool(activeTool);\n    }\n  }, [activeTool]);\n  const selectShapeTool = React20.useCallback(() => {\n    app.selectTool(lastActiveTool);\n  }, [activeTool, app]);\n  const handleDoubleClick = React20.useCallback(() => {\n    app.toggleToolLock();\n  }, [app]);\n  const handleKeyDown = React20.useCallback((e5) => {\n    if (e5.key === \" \" && app.shiftKey) {\n      e5.preventDefault();\n    }\n  }, []);\n  const isActive = shapeShapes.includes(activeTool);\n  const contentSide = dockPosition === \"bottom\" || dockPosition === \"top\" ? \"top\" : dockPosition;\n  const panelStyle = dockPosition === \"bottom\" || dockPosition === \"top\" ? \"row\" : \"column\";\n  return /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: \"ltr\", onOpenChange: selectShapeTool, children: [\n    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { dir: \"ltr\", asChild: true, id: \"TD-PrimaryTools-Shapes\", children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(\n      ToolButton,\n      {\n        disabled: isActive && app.shiftKey,\n        variant: \"primary\",\n        onDoubleClick: handleDoubleClick,\n        isToolLocked: isActive && isToolLocked,\n        isActive,\n        onKeyDown: handleKeyDown,\n        children: shapeShapeIcons[lastActiveTool]\n      }\n    ) }),\n    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)($d08ef79370b62062$export$7c6e2c02157bb7d2, { asChild: true, side: contentSide, sideOffset: 12, children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(Panel, { side: \"center\", style: { flexDirection: panelStyle }, children: shapeShapes.map((shape, index2) => /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(Tooltip, { label: intl.formatMessage({ id: shape }), kbd: (4 + index2).toString(), id: `TD-PrimaryTools-Shapes-${shape}`, children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)($d08ef79370b62062$export$6d08773d2e66f8f2, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(\n      ToolButton,\n      {\n        variant: \"primary\",\n        onClick: () => {\n          app.selectTool(shape);\n          setLastActiveTool(shape);\n        },\n        children: shapeShapeIcons[shape]\n      }\n    ) }) }, shape)) }) })\n  ] });\n});\n\n// src/components/Tldraw/components/ToolsPanel/PrimaryTools.tsx\nvar import_jsx_runtime34 = require(\"react/jsx-runtime\");\nvar activeToolSelector = (s5) => s5.appState.activeTool;\nvar toolLockedSelector = (s5) => s5.appState.isToolLocked;\nvar dockPositionState4 = (s5) => s5.settings.dockPosition;\nvar PrimaryTools = React21.memo(function PrimaryTools2() {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const activeTool = app.useStore(activeToolSelector);\n  const isToolLocked = app.useStore(toolLockedSelector);\n  const dockPosition = app.useStore(dockPositionState4);\n  const selectSelectTool = React21.useCallback(() => {\n    app.selectTool(\"select\");\n  }, [app]);\n  const selectEraseTool = React21.useCallback(() => {\n    app.selectTool(\"erase\");\n  }, [app]);\n  const selectDrawTool = React21.useCallback(() => {\n    app.selectTool(\"draw\" /* Draw */);\n  }, [app]);\n  const selectArrowTool = React21.useCallback(() => {\n    app.selectTool(\"arrow\" /* Arrow */);\n  }, [app]);\n  const selectTextTool = React21.useCallback(() => {\n    app.selectTool(\"text\" /* Text */);\n  }, [app]);\n  const selectStickyTool = React21.useCallback(() => {\n    app.selectTool(\"sticky\" /* Sticky */);\n  }, [app]);\n  const uploadMedias = React21.useCallback(async () => {\n    app.openAsset();\n  }, [app]);\n  const panelStyle = dockPosition === \"bottom\" || dockPosition === \"top\" ? \"row\" : \"column\";\n  return /* @__PURE__ */ (0, import_jsx_runtime34.jsxs)(StyledPanel, { side: \"center\", id: \"TD-PrimaryTools\", style: { flexDirection: panelStyle }, bp: breakpoints, children: [\n    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(\n      ToolButtonWithTooltip,\n      {\n        kbd: \"1\",\n        label: intl.formatMessage({ id: \"select\" }),\n        onClick: selectSelectTool,\n        isActive: activeTool === \"select\",\n        id: \"TD-PrimaryTools-CursorArrow\",\n        children: /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(CursorArrowIcon, {})\n      }\n    ),\n    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(\n      ToolButtonWithTooltip,\n      {\n        kbd: \"2\",\n        label: intl.formatMessage({ id: \"draw\" }),\n        onClick: selectDrawTool,\n        isActive: activeTool === \"draw\" /* Draw */,\n        id: \"TD-PrimaryTools-Pencil\",\n        children: /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(Pencil1Icon, {})\n      }\n    ),\n    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(\n      ToolButtonWithTooltip,\n      {\n        kbd: \"3\",\n        label: intl.formatMessage({ id: \"eraser\" }),\n        onClick: selectEraseTool,\n        isActive: activeTool === \"erase\",\n        id: \"TD-PrimaryTools-Eraser\",\n        children: /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(EraserIcon, {})\n      }\n    ),\n    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(ShapesMenu, { activeTool, isToolLocked }),\n    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(\n      ToolButtonWithTooltip,\n      {\n        kbd: \"8\",\n        label: intl.formatMessage({ id: \"arrow\" }),\n        onClick: selectArrowTool,\n        isLocked: isToolLocked,\n        isActive: activeTool === \"arrow\" /* Arrow */,\n        id: \"TD-PrimaryTools-ArrowTopRight\",\n        children: /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(ArrowTopRightIcon, {})\n      }\n    ),\n    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(\n      ToolButtonWithTooltip,\n      {\n        kbd: \"9\",\n        label: intl.formatMessage({ id: \"text\" }),\n        onClick: selectTextTool,\n        isLocked: isToolLocked,\n        isActive: activeTool === \"text\" /* Text */,\n        id: \"TD-PrimaryTools-Text\",\n        children: /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(TextIcon, {})\n      }\n    ),\n    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(\n      ToolButtonWithTooltip,\n      {\n        kbd: \"0\",\n        label: intl.formatMessage({ id: \"sticky\" }),\n        onClick: selectStickyTool,\n        isActive: activeTool === \"sticky\" /* Sticky */,\n        id: \"TD-PrimaryTools-Pencil2\",\n        children: /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(Pencil2Icon, {})\n      }\n    ),\n    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(ToolButtonWithTooltip, { label: intl.formatMessage({ id: \"image\" }), onClick: uploadMedias, id: \"TD-PrimaryTools-Image\", children: /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(ImageIcon, {}) })\n  ] });\n});\nvar StyledPanel = styled(Panel, {\n  variants: {\n    bp: {\n      mobile: {\n        padding: \"$0\",\n        borderRadius: \"10px\"\n      },\n      small: {\n        padding: \"$2\"\n      }\n    }\n  }\n});\n\n// src/components/Tldraw/components/ToolsPanel/StatusBar.tsx\nvar import_jsx_runtime35 = require(\"react/jsx-runtime\");\nvar statusSelector = (s5) => s5.appState.status;\nvar activeToolSelector2 = (s5) => s5.appState.activeTool;\nfunction StatusBar() {\n  const app = useTldrawApp();\n  const status = app.useStore(statusSelector);\n  const activeTool = app.useStore(activeToolSelector2);\n  return /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(StyledStatusBar, { bp: breakpoints, id: \"TD-StatusBar\", children: /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)(StyledSection, { children: [\n    activeTool,\n    \" | \",\n    status\n  ] }) });\n}\nvar StyledStatusBar = styled(\"div\", {\n  height: 40,\n  userSelect: \"none\",\n  borderTop: \"1px solid $panelContrast\",\n  gridArea: \"status\",\n  display: \"flex\",\n  color: \"$text\",\n  justifyContent: \"space-between\",\n  alignItems: \"center\",\n  backgroundColor: \"$panel\",\n  gap: 8,\n  fontFamily: \"$ui\",\n  fontSize: \"$0\",\n  padding: \"0 16px\",\n  variants: {\n    bp: {\n      small: {\n        fontSize: \"$1\"\n      }\n    }\n  }\n});\nvar StyledSection = styled(\"div\", {\n  whiteSpace: \"nowrap\",\n  overflow: \"hidden\"\n});\n\n// src/components/Tldraw/components/ToolsPanel/ToolsPanel.tsx\nvar import_jsx_runtime36 = require(\"react/jsx-runtime\");\nvar isDebugModeSelector3 = (s5) => s5.settings.isDebugMode;\nvar dockPositionState5 = (s5) => s5.settings.dockPosition;\nvar ToolsPanel = React22.memo(function ToolsPanel2({ onBlur }) {\n  const app = useTldrawApp();\n  const side = app.useStore(dockPositionState5);\n  const isDebugMode = app.useStore(isDebugModeSelector3);\n  return /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)(import_jsx_runtime36.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(StyledToolsPanelContainer, { side, onBlur, bp: breakpoints, debug: isDebugMode, children: /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)(StyledCenterWrap, { id: \"TD-Tools\", children: [\n      /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(BackToContent, {}),\n      /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)(StyledPrimaryTools, { orientation: side === \"bottom\" || side === \"top\" ? \"horizontal\" : \"vertical\", children: [\n        /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(ActionButton, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(PrimaryTools, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(DeleteButton, {})\n      ] })\n    ] }) }),\n    isDebugMode && /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(StyledStatusWrap, { children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(StatusBar, {}) })\n  ] });\n});\nvar StyledToolsPanelContainer = styled(\"div\", {\n  position: \"absolute\",\n  width: \"100%\",\n  minWidth: 0,\n  maxWidth: \"100%\",\n  height: 64,\n  gap: \"$4\",\n  display: \"flex\",\n  justifyContent: \"center\",\n  alignItems: \"center\",\n  zIndex: 200,\n  overflow: \"hidden\",\n  pointerEvents: \"none\",\n  \"& > div > *\": {\n    pointerEvents: \"all\"\n  },\n  variants: {\n    debug: {\n      true: {},\n      false: {}\n    },\n    bp: {\n      mobile: {},\n      small: {},\n      medium: {},\n      large: {}\n    },\n    side: {\n      top: {\n        width: \"100%\",\n        height: 64,\n        left: 0,\n        right: 0,\n        top: 45\n      },\n      right: { width: 64, height: \"100%\", top: 0, right: 0 },\n      bottom: {\n        width: \"100%\",\n        left: 0,\n        right: 0,\n        bottom: 4\n      },\n      left: { width: 64, height: \"100%\", left: 0 }\n    }\n  },\n  compoundVariants: [\n    {\n      side: \"top\",\n      bp: \"large\",\n      css: {\n        top: 0\n      }\n    },\n    {\n      side: \"bottom\",\n      debug: true,\n      css: {\n        bottom: 44\n      }\n    }\n  ]\n});\nvar StyledCenterWrap = styled(\"div\", {\n  display: \"flex\",\n  width: \"fit-content\",\n  height: \"fit-content\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  flexDirection: \"column\",\n  gap: \"$4\"\n});\nvar StyledStatusWrap = styled(\"div\", {\n  position: \"absolute\",\n  bottom: \"0px\",\n  left: \"0px\",\n  right: \"0px\",\n  height: \"40px\",\n  width: \"100%\",\n  maxWidth: \"100%\"\n});\nvar StyledPrimaryTools = styled(\"div\", {\n  position: \"relative\",\n  display: \"flex\",\n  alignItems: \"center\",\n  height: \"fit-content\",\n  gap: \"$3\",\n  variants: {\n    orientation: {\n      horizontal: {\n        flexDirection: \"row\"\n      },\n      vertical: {\n        flexDirection: \"column\"\n      }\n    }\n  }\n});\n\n// src/components/Tldraw/components/TopPanel/TopPanel.tsx\nvar React47 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/components/TopPanel/Menu/Menu.tsx\nvar React24 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/components/TopPanel/PreferencesMenu/PreferencesMenu.tsx\nvar React23 = __toESM(require(\"react\"));\nvar import_jsx_runtime37 = require(\"react/jsx-runtime\");\nvar settingsSelector = (s5) => s5.settings;\nvar DockPosition = [\"bottom\", \"left\", \"right\", \"top\"];\nfunction PreferencesMenu() {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const settings = app.useStore(settingsSelector);\n  const toggleDebugMode = React23.useCallback(() => {\n    app.setSetting(\"isDebugMode\", (v6) => !v6);\n  }, [app]);\n  const toggleFocusMode = React23.useCallback(() => {\n    app.setSetting(\"isFocusMode\", (v6) => !v6);\n  }, [app]);\n  const toggleGrid = React23.useCallback(() => {\n    app.setSetting(\"showGrid\", (v6) => !v6);\n  }, [app]);\n  const toggleKeepStyleMenuOpen = React23.useCallback(() => {\n    app.setSetting(\"keepStyleMenuOpen\", (v6) => !v6);\n  }, [app]);\n  const toggleCadSelectMode = React23.useCallback(() => {\n    app.setSetting(\"isCadSelectMode\", (v6) => !v6);\n  }, [app]);\n  const handleChangeDockPosition = React23.useCallback(\n    (position) => {\n      app.setSetting(\"dockPosition\", position);\n    },\n    [app]\n  );\n  const selectExportBackground = React23.useCallback(\n    (background) => {\n      app.setSetting(\"exportBackground\", background);\n    },\n    [app]\n  );\n  return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(DMSubMenu, { label: intl.formatMessage({ id: \"menu.preferences\" }), id: \"TD-MenuItem-Preferences\", children: [\n    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMCheckboxItem, { checked: settings.isFocusMode, onCheckedChange: toggleFocusMode, kbd: \"#.\", id: \"TD-MenuItem-Preferences-Focus_Mode\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"preferences.focus.mode\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMCheckboxItem, { checked: settings.isDebugMode, onCheckedChange: toggleDebugMode, id: \"TD-MenuItem-Preferences-Debug_Mode\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"preferences.debug.mode\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Divider, {}),\n    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMCheckboxItem, { checked: settings.showGrid, onCheckedChange: toggleGrid, kbd: \"#\\u21E7G\", id: \"TD-MenuItem-Preferences-Grid\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"preferences.show.grid\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMCheckboxItem, { checked: settings.isCadSelectMode, onCheckedChange: toggleCadSelectMode, id: \"TD-MenuItem-Preferences-Cad_Selection\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"preferences.use.cad.selection\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMCheckboxItem, { checked: settings.keepStyleMenuOpen, onCheckedChange: toggleKeepStyleMenuOpen, id: \"TD-MenuItem-Preferences-Style_menu\", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: \"preferences.keep.stylemenu.open\" }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMSubMenu, { label: intl.formatMessage({ id: \"dock.position\" }), children: DockPosition.map((position) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(\n      DMCheckboxItem,\n      {\n        checked: settings.dockPosition === position,\n        onCheckedChange: () => handleChangeDockPosition(position),\n        id: `TD-MenuItem-DockPosition-${position}`,\n        children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(StyledText, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: position }) })\n      },\n      position\n    )) }),\n    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DMSubMenu, { label: intl.formatMessage({ id: \"export.background\" }), children: Object.values(TDExportBackground).map((exportBackground) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(\n      DMCheckboxItem,\n      {\n        checked: settings.exportBackground === exportBackground,\n        onCheckedChange: () => selectExportBackground(exportBackground),\n        id: `TD-MenuItem-ExportBackground-${exportBackground}`,\n        children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(StyledText, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FormattedMessage, { id: exportBackground }) })\n      },\n      exportBackground\n    )) })\n  ] });\n}\nvar StyledText = styled(\"span\", {\n  textTransform: \"capitalize\"\n});\n\n// src/components/Tldraw/components/TopPanel/Menu/Menu.tsx\nvar import_jsx_runtime38 = require(\"react/jsx-runtime\");\nvar numberOfSelectedIdsSelector2 = (s5) => {\n  return s5.document.pageStates[s5.appState.currentPageId].selectedIds.length;\n};\nvar disableAssetsSelector = (s5) => {\n  return s5.appState.disableAssets;\n};\nvar Menu = React24.memo(function Menu2({ readOnly }) {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const [openDialog, setOpenDialog] = React24.useState(false);\n  const numberOfSelectedIds = app.useStore(numberOfSelectedIdsSelector2);\n  const disableAssets = app.useStore(disableAssetsSelector);\n  const [_3, setForce] = React24.useState(0);\n  React24.useEffect(() => setForce(1), []);\n  const handleDelete = React24.useCallback(() => {\n    app.delete();\n  }, [app]);\n  const handleCopySVG = React24.useCallback(() => {\n    app.copyImage(\"svg\" /* SVG */, { scale: 1, quality: 1, transparentBackground: false });\n  }, [app]);\n  const handleCopyPNG = React24.useCallback(() => {\n    app.copyImage(\"png\" /* PNG */, { scale: 2, quality: 1, transparentBackground: true });\n  }, [app]);\n  const handleExportPNG = React24.useCallback(async () => {\n    app.exportImage(\"png\" /* PNG */, { scale: 2, quality: 1 });\n  }, [app]);\n  const handleExportJPG = React24.useCallback(async () => {\n    app.exportImage(\"jpeg\" /* JPG */, { scale: 2, quality: 1 });\n  }, [app]);\n  const handleExportWEBP = React24.useCallback(async () => {\n    app.exportImage(\"webp\" /* WEBP */, { scale: 2, quality: 1 });\n  }, [app]);\n  const handleExportSVG = React24.useCallback(async () => {\n    app.exportImage(\"svg\" /* SVG */, { scale: 2, quality: 1 });\n  }, [app]);\n  const handleCopyJSON = React24.useCallback(async () => {\n    app.copyJson();\n  }, [app]);\n  const handleExportJSON = React24.useCallback(async () => {\n    app.exportJson();\n  }, [app]);\n  const handleCut = React24.useCallback(() => {\n    app.cut();\n  }, [app]);\n  const handleCopy = React24.useCallback(() => {\n    app.copy();\n  }, [app]);\n  const handlePaste = React24.useCallback(() => {\n    app.paste();\n  }, [app]);\n  const handleSelectAll = React24.useCallback(() => {\n    app.selectAll();\n  }, [app]);\n  const handleSelectNone = React24.useCallback(() => {\n    app.selectNone();\n  }, [app]);\n  const handleUploadMedia = React24.useCallback(() => {\n    app.openAsset();\n  }, [app]);\n  const handleZoomTo100 = React24.useCallback(() => {\n    app.zoomTo(1);\n  }, [app]);\n  const showFileMenu = app.callbacks.onExport;\n  const hasSelection = numberOfSelectedIds > 0;\n  return /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(import_jsx_runtime38.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: \"ltr\", children: [\n    /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMTriggerIcon, { id: \"TD-MenuIcon\", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(HamburgerMenuIcon, {}) }),\n    /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(DMContent, { variant: \"menu\", id: \"TD-Menu\", side: \"bottom\", align: \"start\", sideOffset: 4, alignOffset: 4, children: [\n      showFileMenu != void 0 && /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMSubMenu, { label: `${intl.formatMessage({ id: \"menu.file\" })}...`, id: \"TD-MenuItem-File\", children: !disableAssets && /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(import_jsx_runtime38.Fragment, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Divider, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onClick: handleUploadMedia, kbd: \"#U\", id: \"TD-MenuItem-File-Upload_Media\", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: \"upload.media\" }) })\n      ] }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(DMSubMenu, { label: `${intl.formatMessage({ id: \"menu.edit\" })}...`, id: \"TD-MenuItem-Edit\", children: [\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, onClick: app.undo, disabled: readOnly, kbd: \"#Z\", id: \"TD-MenuItem-Edit-Undo\", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: \"undo\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, onClick: app.redo, disabled: readOnly, kbd: \"#\\u21E7Z\", id: \"TD-MenuItem-Edit-Redo\", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: \"redo\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Divider, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, disabled: !hasSelection || readOnly, onClick: handleCut, kbd: \"#X\", id: \"TD-MenuItem-Edit-Cut\", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: \"cut\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, disabled: !hasSelection, onClick: handleCopy, kbd: \"#C\", id: \"TD-MenuItem-Edit-Copy\", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: \"copy\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, onClick: handlePaste, kbd: \"#V\", id: \"TD-MenuItem-Edit-Paste\", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: \"paste\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Divider, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(DMSubMenu, { label: `${intl.formatMessage({ id: \"copy.as\" })}...`, size: \"small\", id: \"TD-MenuItem-Copy-As\", children: [\n          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onClick: handleCopySVG, id: \"TD-MenuItem-Copy-as-SVG\", children: \"SVG\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onClick: handleCopyPNG, id: \"TD-MenuItem-Copy-As-PNG\", children: \"PNG\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onClick: handleCopyJSON, id: \"TD-MenuItem-Copy_as_JSON\", children: \"JSON\" })\n        ] }),\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(DMSubMenu, { label: `${intl.formatMessage({ id: \"export.as\" })}...`, size: \"small\", id: \"TD-MenuItem-Export\", children: [\n          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onClick: handleExportSVG, id: \"TD-MenuItem-Export-SVG\", children: \"SVG\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onClick: handleExportPNG, id: \"TD-MenuItem-Export-PNG\", children: \"PNG\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onClick: handleExportJPG, id: \"TD-MenuItem-Export-JPG\", children: \"JPG\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onClick: handleExportWEBP, id: \"TD-MenuItem-Export-WEBP\", children: \"WEBP\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onClick: handleExportJSON, id: \"TD-MenuItem-Export-JSON\", children: \"JSON\" })\n        ] }),\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Divider, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, onClick: handleSelectAll, kbd: \"#A\", id: \"TD-MenuItem-Select_All\", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: \"select.all\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, disabled: !hasSelection, onClick: handleSelectNone, id: \"TD-MenuItem-Select_None\", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: \"select.none\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Divider, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: handleDelete, disabled: !hasSelection, kbd: \"\\u232B\", id: \"TD-MenuItem-Delete\", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: \"delete\" }) })\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(DMSubMenu, { label: intl.formatMessage({ id: \"menu.view\" }), id: \"TD-MenuItem-Edit\", children: [\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomIn, kbd: \"#+\", id: \"TD-MenuItem-View-ZoomIn\", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: \"zoom.in\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomOut, kbd: \"#-\", id: \"TD-MenuItem-View-ZoomOut\", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: \"zoom.out\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(DMItem, { onSelect: preventEvent, onClick: handleZoomTo100, kbd: \"\\u21E7+0\", id: \"TD-MenuItem-View-ZoomTo100\", children: [\n          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: \"zoom.to\" }),\n          \" 100%\"\n        ] }),\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomToFit, kbd: \"\\u21E7+1\", id: \"TD-MenuItem-View-ZoomToFit\", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: \"zoom.to.fit\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomToSelection, kbd: \"\\u21E7+2\", id: \"TD-MenuItem-View-ZoomToSelection\", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FormattedMessage, { id: \"zoom.to.selection\" }) })\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Divider, {}),\n      /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(PreferencesMenu, {})\n    ] })\n  ] }) });\n});\n\n// src/components/Tldraw/components/TopPanel/PageMenu/PageMenu.tsx\nvar React27 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/components/TopPanel/PageOptionsDialog/PageOptionsDialog.tsx\nvar React26 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/components/Primitives/TextField/TextField.tsx\nvar React25 = __toESM(require(\"react\"));\nvar import_jsx_runtime39 = require(\"react/jsx-runtime\");\nvar TextField = React25.forwardRef(({ icon, ...rest }, reference) => {\n  return /* @__PURE__ */ (0, import_jsx_runtime39.jsxs)(StyledInputWrapper, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(StyledInput, { ...rest, ref: reference }),\n    icon == void 0 ? null : /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(StyledInputIcon, { children: icon })\n  ] });\n});\nvar StyledInputWrapper = styled(\"div\", {\n  position: \"relative\",\n  width: \"100%\",\n  height: \"min-content\"\n});\nvar StyledInput = styled(\"input\", {\n  color: \"$text\",\n  border: \"none\",\n  textAlign: \"left\",\n  width: \"100%\",\n  paddingLeft: \"$3\",\n  paddingRight: \"$6\",\n  backgroundColor: \"$background\",\n  height: \"32px\",\n  outline: \"none\",\n  fontFamily: \"$ui\",\n  fontSize: \"$1\",\n  \"&:focus\": {\n    backgroundColor: \"$hover\"\n  },\n  borderRadius: \"$2\"\n});\nvar StyledInputIcon = styled(SmallIcon, {\n  top: 0,\n  right: 0,\n  position: \"absolute\",\n  paddingLeft: \"$3\",\n  paddingRight: \"$3\",\n  pointerEvents: \"none\",\n  color: \"$text\"\n});\n\n// src/components/Tldraw/components/TopPanel/PageOptionsDialog/PageOptionsDialog.tsx\nvar import_jsx_runtime40 = require(\"react/jsx-runtime\");\nvar canDeleteSelector = (s5) => {\n  return Object.keys(s5.document.pages).length > 1;\n};\nfunction PageOptionsDialog({ page, onOpen, onClose }) {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const [isOpen, setIsOpen] = React26.useState(false);\n  const [pageName, setPageName] = React26.useState(page.name || \"Page\");\n  const canDelete = app.useStore(canDeleteSelector);\n  const rInput = React26.useRef(null);\n  const handleClose = React26.useCallback(() => {\n    setIsOpen(false);\n  }, []);\n  const handleDuplicate = React26.useCallback(() => {\n    app.duplicatePage(page.id);\n  }, [app]);\n  const handleDelete = React26.useCallback(() => {\n    if (window.confirm(`Are you sure you want to delete this page?`)) {\n      app.deletePage(page.id);\n    }\n  }, [app]);\n  const handleOpenChange = React26.useCallback(\n    (isOpen2) => {\n      setIsOpen(isOpen2);\n      if (isOpen2) {\n        onOpen?.();\n      }\n    },\n    [app]\n  );\n  function stopPropagation4(e5) {\n    e5.stopPropagation();\n  }\n  const rInitialName = React26.useRef(page.name || \"Page\");\n  const rCurrentName = React26.useRef(rInitialName.current);\n  const handleTextFieldChange = React26.useCallback((event) => {\n    const value = event.target.value.trimStart();\n    rCurrentName.current = value;\n    setPageName(value);\n  }, []);\n  const handleTextFieldKeyDown = React26.useCallback((e5) => {\n    switch (e5.key) {\n      case \"Enter\": {\n        if (rCurrentName.current === rInitialName.current) {\n          setIsOpen(false);\n        } else {\n          rInitialName.current = rCurrentName.current;\n          app.renamePage(page.id, rCurrentName.current.trim());\n          setIsOpen(false);\n        }\n        break;\n      }\n      case \"Escape\": {\n        if (rCurrentName.current === rInitialName.current) {\n          setIsOpen(false);\n          return;\n        }\n        rCurrentName.current = rInitialName.current;\n        setPageName(rInitialName.current);\n        requestAnimationFrame(() => {\n          const elm = rInput.current;\n          if (elm != void 0) {\n            elm.focus();\n            elm.setSelectionRange(0, elm.value.length);\n          }\n        });\n        break;\n      }\n    }\n  }, []);\n  const rWasOpen = React26.useRef(false);\n  React26.useEffect(() => {\n    if (isOpen) {\n      rWasOpen.current = true;\n      rInitialName.current = page.name || \"Page\";\n      rCurrentName.current = rInitialName.current;\n      requestAnimationFrame(() => {\n        const elm = rInput.current;\n        if (elm != void 0) {\n          elm.focus();\n          elm.setSelectionRange(0, elm.value.length);\n        }\n      });\n    } else if (rWasOpen.current) {\n      onClose?.();\n    }\n    return () => {\n      if (rCurrentName.current !== rInitialName.current) {\n        rInitialName.current = rCurrentName.current;\n        app.renamePage(page.id, rCurrentName.current);\n      }\n    };\n  }, [isOpen]);\n  const container = useContainer();\n  return /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)($905f4ae918aab1aa$export$be92b6f5f03c0fe9, { open: isOpen, onOpenChange: handleOpenChange, children: [\n    /* @__PURE__ */ (0, import_jsx_runtime40.jsx)($905f4ae918aab1aa$export$41fb9f06171c75f4, { asChild: true, \"data-shy\": \"true\", children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(IconButton, { bp: breakpoints, children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(SmallIcon, { children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(MixerVerticalIcon, {}) }) }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)($905f4ae918aab1aa$export$602eac185826482c, { container: container.current, children: [\n      /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(StyledDialogOverlay2, { onPointerDown: handleClose }),\n      /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)(StyledDialogContent, { dir: \"ltr\", onKeyDown: stopPropagation4, onKeyUp: stopPropagation4, children: [\n        /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(\n          TextField,\n          {\n            ref: rInput,\n            placeholder: intl.formatMessage({ id: \"page.name\" }),\n            value: pageName,\n            onChange: handleTextFieldChange,\n            onKeyDown: handleTextFieldKeyDown,\n            icon: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(Pencil1Icon, {})\n          }\n        ),\n        /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(Divider, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(DialogAction, { onSelect: handleDuplicate, children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(FormattedMessage, { id: \"duplicate\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(DialogAction, { disabled: !canDelete, onSelect: handleDelete, children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(FormattedMessage, { id: \"delete\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(Divider, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime40.jsx)($905f4ae918aab1aa$export$848c9b7ead0df967, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(RowButton, { children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(FormattedMessage, { id: \"cancel\" }) }) })\n      ] })\n    ] })\n  ] });\n}\nvar StyledDialogContent = styled($905f4ae918aab1aa$export$7c6e2c02157bb7d2, {\n  position: \"absolute\",\n  top: \"50%\",\n  left: \"50%\",\n  transform: \"translate(-50%, -50%)\",\n  minWidth: 240,\n  maxWidth: \"fit-content\",\n  maxHeight: \"85vh\",\n  marginTop: \"-5vh\",\n  pointerEvents: \"all\",\n  backgroundColor: \"$panel\",\n  padding: \"$1\",\n  borderRadius: \"$2\",\n  font: \"$ui\",\n  zIndex: 999999,\n  \"&:focus\": {\n    outline: \"none\"\n  }\n});\nvar StyledDialogOverlay2 = styled($905f4ae918aab1aa$export$c6fdb837b070b4ff, {\n  backgroundColor: \"rgba(0, 0, 0, .15)\",\n  position: \"absolute\",\n  pointerEvents: \"all\",\n  inset: 0,\n  zIndex: 999998\n});\nfunction DialogAction({ onSelect, ...rest }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime40.jsx)($905f4ae918aab1aa$export$e19cd5f9376f8cee, { asChild: true, onClick: onSelect, onSelect, children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(RowButton, { ...rest }) });\n}\n\n// src/components/Tldraw/components/TopPanel/PageMenu/PageMenu.tsx\nvar import_jsx_runtime41 = require(\"react/jsx-runtime\");\nvar sortedSelector = (s5) => Object.values(s5.document.pages).sort((a7, b6) => (a7.childIndex || 0) - (b6.childIndex || 0));\nvar currentPageNameSelector = (s5) => s5.document.pages[s5.appState.currentPageId].name;\nvar currentPageIdSelector2 = (s5) => s5.document.pages[s5.appState.currentPageId].id;\nfunction PageMenu() {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const rIsOpen = React27.useRef(false);\n  const [isOpen, setIsOpen] = React27.useState(false);\n  React27.useEffect(() => {\n    if (rIsOpen.current !== isOpen) {\n      rIsOpen.current = isOpen;\n    }\n  }, [isOpen]);\n  const handleClose = React27.useCallback(() => {\n    setIsOpen(false);\n  }, [setIsOpen]);\n  const handleOpenChange = React27.useCallback(\n    (isOpen2) => {\n      if (rIsOpen.current !== isOpen2) {\n        setIsOpen(isOpen2);\n      }\n    },\n    [setIsOpen]\n  );\n  const currentPageName = app.useStore(currentPageNameSelector);\n  return /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: \"ltr\", open: isOpen, onOpenChange: handleOpenChange, children: [\n    /* @__PURE__ */ (0, import_jsx_runtime41.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { dir: \"ltr\", asChild: true, id: \"TD-Page\", children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(ToolButton, { variant: \"text\", children: currentPageName || intl.formatMessage({ id: \"page\" }) }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(DMContent, { variant: \"menu\", align: \"start\", sideOffset: 4, children: isOpen && /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(PageMenuContent, { onClose: handleClose }) })\n  ] });\n}\nfunction PageMenuContent({ onClose }) {\n  const app = useTldrawApp();\n  const intl = useIntl();\n  const sortedPages = app.useStore(sortedSelector);\n  const currentPageId = app.useStore(currentPageIdSelector2);\n  const defaultPageName = intl.formatMessage({ id: \"page\" });\n  const handleCreatePage = React27.useCallback(() => {\n    const pageName = defaultPageName + \" \" + (Object.keys(app.document.pages).length + 1);\n    app.createPage(void 0, pageName);\n  }, [app]);\n  const handleChangePage = React27.useCallback(\n    (id) => {\n      onClose();\n      app.changePage(id);\n    },\n    [app]\n  );\n  const [dragId, setDragId] = React27.useState(null);\n  const [dropIndex, setDropIndex] = React27.useState(null);\n  const handleDragStart = React27.useCallback((event_) => {\n    setDragId(event_.currentTarget.id);\n    setDropIndex(sortedPages.findIndex((p6) => p6.id === event_.currentTarget.id));\n    event_.dataTransfer.effectAllowed = \"move\";\n  }, []);\n  const handleDrag = React27.useCallback(\n    (event_) => {\n      event_.preventDefault();\n      let dropIndex2 = sortedPages.findIndex((p6) => p6.id === event_.currentTarget.id);\n      const rect = event_.currentTarget.getBoundingClientRect();\n      const ny = (event_.clientY - rect.top) / rect.height;\n      dropIndex2 = ny < 0.5 ? dropIndex2 : dropIndex2 + 1;\n      setDropIndex(dropIndex2);\n    },\n    [dragId, sortedPages]\n  );\n  const handleDrop = React27.useCallback(() => {\n    if (dragId !== null && dropIndex !== null) {\n      app.movePage(dragId, dropIndex);\n    }\n    setDragId(null);\n    setDropIndex(null);\n  }, [dragId, dropIndex]);\n  return /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)(import_jsx_runtime41.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime41.jsx)($d08ef79370b62062$export$a98f0dcb43a68a25, { dir: \"ltr\", value: currentPageId, onValueChange: handleChangePage, children: sortedPages.map((page, index2) => /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)(ButtonWithOptions, { isDropAbove: index2 === dropIndex && index2 === 0, isDropBelow: dropIndex !== null && index2 === dropIndex - 1, children: [\n      /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(\n        $d08ef79370b62062$export$371ab307eab489c0,\n        {\n          title: page.name || defaultPageName,\n          value: page.id,\n          id: page.id,\n          asChild: true,\n          onDragOver: handleDrag,\n          onDragStart: handleDragStart,\n          onDrop: handleDrop,\n          draggable: true,\n          children: /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)(PageButton, { children: [\n            /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(\"span\", { id: page.id, children: page.name || defaultPageName }),\n            /* @__PURE__ */ (0, import_jsx_runtime41.jsx)($d08ef79370b62062$export$c3468e2714d175fa, { children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(SmallIcon, { children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(CheckIcon, {}) }) })\n          ] })\n        },\n        page.id\n      ),\n      /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(PageOptionsDialog, { page, onClose })\n    ] }, page.id)) }),\n    /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(Divider, {}),\n    /* @__PURE__ */ (0, import_jsx_runtime41.jsx)($d08ef79370b62062$export$6d08773d2e66f8f2, { onSelect: handleCreatePage, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)(RowButton, { children: [\n      /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(\"span\", { children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(FormattedMessage, { id: \"create.page\" }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(SmallIcon, { children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(PlusIcon, {}) })\n    ] }) })\n  ] });\n}\nvar ButtonWithOptions = styled(\"div\", {\n  position: \"relative\",\n  display: \"grid\",\n  gridTemplateColumns: \"1fr auto\",\n  gridAutoFlow: \"column\",\n  margin: 0,\n  '& > *[data-shy=\"true\"]': {\n    opacity: 0\n  },\n  '&:hover > *[data-shy=\"true\"]': {\n    opacity: 1\n  },\n  variants: {\n    isDropAbove: {\n      true: {\n        \"&::after\": {\n          content: \"\",\n          display: \"block\",\n          position: \"absolute\",\n          top: 0,\n          width: \"100%\",\n          height: \"1px\",\n          backgroundColor: \"$selected\",\n          zIndex: 999,\n          pointerEvents: \"none\"\n        }\n      }\n    },\n    isDropBelow: {\n      true: {\n        \"&::after\": {\n          content: \"\",\n          display: \"block\",\n          position: \"absolute\",\n          width: \"100%\",\n          height: \"1px\",\n          top: \"100%\",\n          backgroundColor: \"$selected\",\n          zIndex: 999,\n          pointerEvents: \"none\"\n        }\n      }\n    }\n  }\n});\nvar PageButton = styled(RowButton, {\n  minWidth: 128\n});\n\n// src/components/Tldraw/components/TopPanel/StyleMenu/StyleMenu.tsx\nvar React46 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/shared/getBoundsRectangle.ts\nfunction getBoundsRectangle(shape, boundsCache) {\n  const bounds = C3.getFromCache(boundsCache, shape, () => {\n    const [width, height] = shape.size;\n    return {\n      minX: 0,\n      maxX: width,\n      minY: 0,\n      maxY: height,\n      width,\n      height\n    };\n  });\n  return C3.translateBounds(bounds, shape.point);\n}\n\n// src/components/Tldraw/state/shapes/shared/getTextAlign.ts\nvar ALIGN_VALUES = {\n  [\"start\" /* Start */]: \"left\",\n  [\"middle\" /* Middle */]: \"center\",\n  [\"end\" /* End */]: \"right\",\n  [\"justify\" /* Justify */]: \"justify\"\n};\nfunction getTextAlign(alignStyle = \"start\" /* Start */) {\n  return ALIGN_VALUES[alignStyle];\n}\n\n// src/components/Tldraw/constants.ts\nvar LETTER_SPACING = \"0\";\nvar GRID_SIZE = 8;\nvar SVG_EXPORT_PADDING = 16;\nvar BINDING_DISTANCE = 16;\nvar CLONING_DISTANCE = 32;\nvar FIT_TO_SCREEN_PADDING = 128;\nvar SNAP_DISTANCE = 5;\nvar SLOW_SPEED = 10;\nvar GHOSTED_OPACITY = 0.3;\nvar DEAD_ZONE = 3;\nvar LABEL_POINT = [0.5, 0.5];\nvar PI2 = Math.PI * 2;\nvar EASINGS = {\n  linear: (t5) => t5,\n  easeInQuad: (t5) => t5 * t5,\n  easeOutQuad: (t5) => t5 * (2 - t5),\n  easeInOutQuad: (t5) => t5 < 0.5 ? 2 * t5 * t5 : -1 + (4 - 2 * t5) * t5,\n  easeInCubic: (t5) => t5 * t5 * t5,\n  easeOutCubic: (t5) => --t5 * t5 * t5 + 1,\n  easeInOutCubic: (t5) => t5 < 0.5 ? 4 * t5 * t5 * t5 : (t5 - 1) * (2 * t5 - 2) * (2 * t5 - 2) + 1,\n  easeInQuart: (t5) => t5 * t5 * t5 * t5,\n  easeOutQuart: (t5) => 1 - --t5 * t5 * t5 * t5,\n  easeInOutQuart: (t5) => t5 < 0.5 ? 8 * t5 * t5 * t5 * t5 : 1 - 8 * --t5 * t5 * t5 * t5,\n  easeInQuint: (t5) => t5 * t5 * t5 * t5 * t5,\n  easeOutQuint: (t5) => 1 + --t5 * t5 * t5 * t5 * t5,\n  easeInOutQuint: (t5) => t5 < 0.5 ? 16 * t5 * t5 * t5 * t5 * t5 : 1 + 16 * --t5 * t5 * t5 * t5 * t5,\n  easeInSine: (t5) => 1 - Math.cos(t5 * Math.PI / 2),\n  easeOutSine: (t5) => Math.sin(t5 * Math.PI / 2),\n  easeInOutSine: (t5) => -(Math.cos(Math.PI * t5) - 1) / 2,\n  easeInExpo: (t5) => t5 <= 0 ? 0 : Math.pow(2, 10 * t5 - 10),\n  easeOutExpo: (t5) => t5 >= 1 ? 1 : 1 - Math.pow(2, -10 * t5),\n  easeInOutExpo: (t5) => t5 <= 0 ? 0 : t5 >= 1 ? 1 : t5 < 0.5 ? Math.pow(2, 20 * t5 - 10) / 2 : (2 - Math.pow(2, -20 * t5 + 10)) / 2\n};\nvar isSafari = typeof Window === \"undefined\" ? false : /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\nvar isLinux = typeof Window === \"undefined\" ? false : /linux/i.test(navigator.userAgent);\nvar IMAGE_EXTENSIONS = [\".png\", \".svg\", \".jpg\", \".jpeg\", \".gif\"];\n\n// src/components/Tldraw/state/shapes/shared/getTextSize.ts\nvar melm;\nfunction getMeasurementDiv() {\n  document.querySelector(\"#__textLabelMeasure\")?.remove();\n  const pre = document.createElement(\"pre\");\n  pre.id = \"__textLabelMeasure\";\n  Object.assign(pre.style, {\n    whiteSpace: \"pre\",\n    width: \"auto\",\n    border: \"1px solid transparent\",\n    padding: \"4px\",\n    margin: \"0px\",\n    letterSpacing: LETTER_SPACING,\n    opacity: \"0\",\n    position: \"absolute\",\n    top: \"-500px\",\n    left: \"0px\",\n    zIndex: \"9999\",\n    pointerEvents: \"none\",\n    userSelect: \"none\",\n    alignmentBaseline: \"mathematical\",\n    dominantBaseline: \"mathematical\"\n  });\n  pre.tabIndex = -1;\n  document.body.appendChild(pre);\n  return pre;\n}\nif (typeof window !== \"undefined\") {\n  melm = getMeasurementDiv();\n}\nvar prevText = \"\";\nvar prevFont = \"\";\nvar prevSize = [0, 0];\nfunction clearPrevSize() {\n  prevText = \"\";\n}\nfunction getTextLabelSize(text, font) {\n  if (!text) {\n    return [16, 32];\n  }\n  if (!melm) {\n    return [10, 10];\n  }\n  if (!melm.parent)\n    document.body.appendChild(melm);\n  if (text === prevText && font === prevFont) {\n    return prevSize;\n  }\n  prevText = text;\n  prevFont = font;\n  melm.textContent = text;\n  melm.style.font = font;\n  const width = melm.offsetWidth || 1;\n  const height = melm.offsetHeight || 1;\n  prevSize = [width, height];\n  return prevSize;\n}\n\n// src/components/Tldraw/state/shapes/shared/getTextSvgElement.ts\nvar wordSeparator = new RegExp(`${[32, 160, 4961, 65792, 65793, 4153, 4241].map((c5) => String.fromCodePoint(c5)).join(\"|\")}`);\nfunction getTextSvgElement(text, fontSize, fontFamily, textAlign, width, wrap = false) {\n  const fontWeight = \"normal\";\n  const lineHeight = 1;\n  const letterSpacingPct = LETTER_SPACING;\n  const lines = breakText({\n    text,\n    wrap,\n    width,\n    fontSize,\n    fontWeight,\n    fontFamily,\n    fontStyle: \"normal\",\n    textAlign: \"left\",\n    letterSpacing: LETTER_SPACING,\n    lineHeight: 1\n  });\n  const textElm = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n  textElm.setAttribute(\"font-size\", fontSize + \"px\");\n  textElm.setAttribute(\"font-family\", fontFamily);\n  textElm.setAttribute(\"font-weight\", fontWeight);\n  textElm.setAttribute(\"line-height\", lineHeight * fontSize + \"px\");\n  textElm.setAttribute(\"letter-spacing\", letterSpacingPct);\n  textElm.setAttribute(\"text-align\", textAlign ?? \"left\");\n  textElm.setAttribute(\"dominant-baseline\", \"mathematical\");\n  textElm.setAttribute(\"alignment-baseline\", \"mathematical\");\n  const textLines = lines.map((line, i4) => {\n    const tspan = document.createElementNS(\"http://www.w3.org/2000/svg\", \"tspan\");\n    tspan.textContent = line + \"\\n\";\n    tspan.setAttribute(\"y\", lineHeight * fontSize * (i4 + 0.5) + \"px\");\n    textElm.appendChild(tspan);\n    return tspan;\n  });\n  switch (textAlign) {\n    case \"middle\" /* Middle */: {\n      textElm.setAttribute(\"text-align\", \"center\");\n      textElm.setAttribute(\"text-anchor\", \"middle\");\n      textLines.forEach((textElm2) => textElm2.setAttribute(\"x\", 4 + width / 2 + \"\"));\n      break;\n    }\n    case \"end\" /* End */: {\n      textElm.setAttribute(\"text-align\", \"right\");\n      textElm.setAttribute(\"text-anchor\", \"end\");\n      textLines.forEach((textElm2) => textElm2.setAttribute(\"x\", 4 + width + \"\"));\n      break;\n    }\n    default: {\n      textElm.setAttribute(\"text-align\", \"left\");\n      textElm.setAttribute(\"text-anchor\", \"start\");\n      textLines.forEach((textElm2) => textElm2.setAttribute(\"x\", \"4\"));\n    }\n  }\n  return textElm;\n}\nfunction breakText(opts) {\n  const textElm = document.createElement(\"div\");\n  textElm.style.setProperty(\"position\", \"absolute\");\n  textElm.style.setProperty(\"top\", \"-9999px\");\n  textElm.style.setProperty(\"left\", \"-9999px\");\n  textElm.style.setProperty(\"width\", opts.width + \"px\");\n  textElm.style.setProperty(\"height\", \"min-content\");\n  textElm.style.setProperty(\"font-size\", opts.fontSize + \"px\");\n  textElm.style.setProperty(\"font-family\", opts.fontFamily);\n  textElm.style.setProperty(\"font-weight\", opts.fontWeight);\n  textElm.style.setProperty(\"line-height\", opts.lineHeight * opts.fontSize + \"px\");\n  textElm.style.setProperty(\"letter-spacing\", opts.letterSpacing);\n  textElm.style.setProperty(\"text-align\", opts.textAlign);\n  document.body.appendChild(textElm);\n  const words = opts.text.split(wordSeparator).flatMap((word) => word.replace(\"\\n\", \" \\n\")).join(\" \").split(\" \");\n  textElm.innerText = words[0];\n  let prevHeight = textElm.offsetHeight;\n  let currentLine = [words[0]];\n  const lines = [currentLine];\n  for (let i4 = 1; i4 < words.length; i4++) {\n    const word = words[i4];\n    textElm.innerText += \" \" + word;\n    const newHeight = textElm.offsetHeight;\n    if (newHeight > prevHeight) {\n      prevHeight = newHeight;\n      currentLine = [];\n      lines.push(currentLine);\n    }\n    currentLine.push(word);\n  }\n  textElm.remove();\n  return lines.map((line) => line.join(\" \"));\n}\n\n// src/components/Tldraw/state/shapes/shared/LabelMask.tsx\nvar import_jsx_runtime42 = require(\"react/jsx-runtime\");\nfunction LabelMask({ id, bounds, labelSize, offset, scale = 1 }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(\"defs\", { children: /* @__PURE__ */ (0, import_jsx_runtime42.jsxs)(\"mask\", { id: id + \"_clip\", children: [\n    /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(\"rect\", { x: -100, y: -100, width: bounds.width + 200, height: bounds.height + 200, fill: \"white\" }),\n    /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(\n      \"rect\",\n      {\n        x: bounds.width / 2 - labelSize[0] / 2 * scale + (offset?.[0] || 0),\n        y: bounds.height / 2 - labelSize[1] / 2 * scale + (offset?.[1] || 0),\n        width: labelSize[0] * scale,\n        height: labelSize[1] * scale,\n        rx: 4 * scale,\n        ry: 4 * scale,\n        fill: \"black\",\n        opacity: Math.max(scale, 0.8)\n      }\n    )\n  ] }) });\n}\n\n// src/components/Tldraw/state/shapes/shared/PolygonUtils.ts\nvar PI22 = Math.PI * 2;\nvar _PolygonUtils = class {\n  static inwardEdgeNormal(edge) {\n    const delta = p.sub(edge[1], edge[0]);\n    const len = p.len2(delta);\n    return [-delta[0] / len, delta[1] / len];\n  }\n  static outwardEdgeNormal(edge) {\n    return p.neg(_PolygonUtils.inwardEdgeNormal(edge));\n  }\n  static isReflexVertex(polygon, index2) {\n    const len = polygon.length;\n    const v0 = polygon[(index2 + len - 1) % len];\n    const v1 = polygon[index2];\n    const v22 = polygon[(index2 + 1) % len];\n    if (_PolygonUtils.leftSide(v0, v22, v1) < 0)\n      return true;\n    return false;\n  }\n  static getEdges(vertices) {\n    return vertices.map((vert, i4) => [vert, vertices[(i4 + 1) % vertices.length]]);\n  }\n  // based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, A => \"line a\", B => \"line b\"\n  static edgesIntersection([A1, A22], [B1, B22]) {\n    const den = (B22[1] - B1[1]) * (A22[0] - A1[0]) - (B22[0] - B1[0]) * (A22[1] - A1[1]);\n    if (den == 0)\n      return null;\n    const ua = ((B22[0] - B1[0]) * (A1[1] - B1[1]) - (B22[1] - B1[1]) * (A1[0] - B1[0])) / den;\n    const ub = ((A22[0] - A1[0]) * (A1[1] - B1[1]) - (A22[1] - A1[1]) * (A1[0] - B1[0])) / den;\n    if (ua < 0 || ub < 0 || ua > 1 || ub > 1)\n      return null;\n    return [A1[0] + ua * (A22[0] - A1[0]), A1[1] + ua * (A22[1] - A1[1])];\n  }\n  static appendArc(polygon, center, radius, startVertex, endVertex, isPaddingBoundary = false) {\n    const vertices = [...polygon];\n    let startAngle = Math.atan2(startVertex[1] - center[1], startVertex[0] - center[0]);\n    let endAngle = Math.atan2(endVertex[1] - center[1], endVertex[0] - center[0]);\n    if (startAngle < 0)\n      startAngle += PI22;\n    if (endAngle < 0)\n      endAngle += PI22;\n    const arcSegmentCount = 5;\n    const angle = startAngle > endAngle ? startAngle - endAngle : startAngle + PI22 - endAngle;\n    const angle5 = (isPaddingBoundary ? -angle : PI22 - angle) / arcSegmentCount;\n    vertices.push(startVertex);\n    for (let i4 = 1; i4 < arcSegmentCount; ++i4) {\n      const angle2 = startAngle + angle5 * i4;\n      vertices.push([center[0] + Math.cos(angle2) * radius, center[1] + Math.sin(angle2) * radius]);\n    }\n    vertices.push(endVertex);\n    return vertices;\n  }\n  static createOffsetEdge(edge, offset) {\n    return edge.map((vert) => p.add(vert, offset));\n  }\n  static getOffsetPolygon(polygon, offset = 0) {\n    const edges = _PolygonUtils.getEdges(polygon);\n    const offsetEdges = edges.map((edge) => _PolygonUtils.createOffsetEdge(edge, p.mul(_PolygonUtils.outwardEdgeNormal(edge), offset)));\n    const vertices = [];\n    for (let i4 = 0; i4 < offsetEdges.length; i4++) {\n      const thisEdge = offsetEdges[i4];\n      const prevEdge = offsetEdges[(i4 + offsetEdges.length - 1) % offsetEdges.length];\n      const vertex = _PolygonUtils.edgesIntersection(prevEdge, thisEdge);\n      if (vertex)\n        vertices.push(vertex);\n      else {\n        _PolygonUtils.appendArc(vertices, edges[i4][0], offset, prevEdge[1], thisEdge[0], false);\n      }\n    }\n    return vertices;\n  }\n  static createPaddingPolygon(polygon, shapePadding = 0) {\n    const offsetEdges = polygon.map((edge) => _PolygonUtils.createOffsetEdge(edge, _PolygonUtils.inwardEdgeNormal(edge)));\n    const vertices = [];\n    for (let i4 = 0; i4 < offsetEdges.length; i4++) {\n      const thisEdge = offsetEdges[i4];\n      const prevEdge = offsetEdges[(i4 + offsetEdges.length - 1) % offsetEdges.length];\n      const vertex = _PolygonUtils.edgesIntersection(prevEdge, thisEdge);\n      if (vertex)\n        vertices.push(vertex);\n      else {\n        _PolygonUtils.appendArc(vertices, polygon[i4][0], shapePadding, prevEdge[1], thisEdge[0], true);\n      }\n    }\n    return vertices;\n  }\n};\nvar PolygonUtils = _PolygonUtils;\n// If the slope of line v1,v2 greater than the slope of v1,p then p is on the left side of v1,v2 and the return value is > 0.\n// If p is colinear with v1,v2 then return 0, otherwise return a value < 0.\n__publicField(PolygonUtils, \"leftSide\", p.isLeft);\nfunction getOffsetPolygon(points, offset) {\n  if (points.length < 3)\n    throw new Error(\"Polygon must have at least 3 points\");\n  const len = points.length;\n  return points.map((point, i4) => [point, points[(i4 + 1) % len]]).map(([A6, B5]) => {\n    const offsetVector = p.mul(p.per(p.uni(p.sub(B5, A6))), offset);\n    return [p.add(A6, offsetVector), p.add(B5, offsetVector)];\n  }).map((edge, i4, edges) => {\n    const intersection = ie2(edge, edges[(i4 + 1) % edges.length]);\n    if (intersection === void 0)\n      throw new Error(\"Expected an intersection\");\n    return intersection;\n  });\n}\n\n// src/components/Tldraw/state/shapes/shared/shape-styles.ts\nvar canvasLight = \"#fafafa\";\nvar canvasDark = \"#343d45\";\nvar colors = {\n  [\"white\" /* White */]: \"#f0f1f3\",\n  [\"lightGray\" /* LightGray */]: \"#c6cbd1\",\n  [\"gray\" /* Gray */]: \"#788492\",\n  [\"black\" /* Black */]: \"#1d1d1d\",\n  [\"green\" /* Green */]: \"#36b24d\",\n  [\"cyan\" /* Cyan */]: \"#0e98ad\",\n  [\"blue\" /* Blue */]: \"#1c7ed6\",\n  [\"indigo\" /* Indigo */]: \"#4263eb\",\n  [\"violet\" /* Violet */]: \"#7746f1\",\n  [\"red\" /* Red */]: \"#ff2133\",\n  [\"orange\" /* Orange */]: \"#ff9433\",\n  [\"yellow\" /* Yellow */]: \"#ffc936\"\n};\nvar stickyFills = {\n  light: {\n    ...Object.fromEntries(Object.entries(colors).map(([k7, v6]) => [k7, C3.lerpColor(v6, canvasLight, 0.45)])),\n    [\"white\" /* White */]: \"#ffffff\",\n    [\"black\" /* Black */]: \"#3d3d3d\"\n  },\n  dark: {\n    ...Object.fromEntries(Object.entries(colors).map(([k7, v6]) => [k7, C3.lerpColor(C3.lerpColor(v6, \"#999999\", 0.3), canvasDark, 0.4)])),\n    [\"white\" /* White */]: \"#1d1d1d\",\n    [\"black\" /* Black */]: \"#bbbbbb\"\n  }\n};\nvar strokes = {\n  light: {\n    ...colors,\n    [\"white\" /* White */]: \"#1d1d1d\"\n  },\n  dark: {\n    ...Object.fromEntries(Object.entries(colors).map(([k7, v6]) => [k7, C3.lerpColor(v6, canvasDark, 0.1)])),\n    [\"white\" /* White */]: \"#cecece\",\n    [\"black\" /* Black */]: \"#cecece\"\n  }\n};\nvar fills = {\n  light: {\n    ...Object.fromEntries(Object.entries(colors).map(([k7, v6]) => [k7, C3.lerpColor(v6, canvasLight, 0.82)])),\n    [\"white\" /* White */]: \"#fefefe\"\n  },\n  dark: {\n    ...Object.fromEntries(Object.entries(colors).map(([k7, v6]) => [k7, C3.lerpColor(v6, canvasDark, 0.82)])),\n    [\"white\" /* White */]: \"rgb(30,33,37)\",\n    [\"black\" /* Black */]: \"#1e1e1f\"\n  }\n};\nvar strokeWidths = {\n  [\"small\" /* Small */]: 2,\n  [\"medium\" /* Medium */]: 3.5,\n  [\"large\" /* Large */]: 5\n};\nvar fontSizes = {\n  [\"small\" /* Small */]: 28,\n  [\"medium\" /* Medium */]: 48,\n  [\"large\" /* Large */]: 96,\n  auto: \"auto\"\n};\nvar fontFaces = {\n  [\"script\" /* Script */]: '\"Caveat Brush\"',\n  [\"sans\" /* Sans */]: '\"Source Sans Pro\"',\n  [\"serif\" /* Serif */]: '\"Crimson Pro\"',\n  [\"mono\" /* Mono */]: '\"Source Code Pro\"'\n};\nvar fontSizeModifiers = {\n  [\"script\" /* Script */]: 1,\n  [\"sans\" /* Sans */]: 1,\n  [\"serif\" /* Serif */]: 1,\n  [\"mono\" /* Mono */]: 1\n};\nvar stickyFontSizes = {\n  [\"small\" /* Small */]: 24,\n  [\"medium\" /* Medium */]: 36,\n  [\"large\" /* Large */]: 48,\n  auto: \"auto\"\n};\nfunction getStrokeWidth(size) {\n  return strokeWidths[size];\n}\nfunction getFontSize(size, fontStyle = \"script\" /* Script */) {\n  return fontSizes[size] * fontSizeModifiers[fontStyle];\n}\nfunction getFontFace(font = \"script\" /* Script */) {\n  return fontFaces[font];\n}\nfunction getStickyFontSize(size) {\n  return stickyFontSizes[size];\n}\nfunction getFontStyle(style) {\n  const fontSize = getFontSize(style.size, style.font);\n  const tiddlywikiFontSetting = typeof $tw === \"undefined\" ? void 0 : $tw.wiki.getTiddlerText(\"$:/themes/tiddlywiki/vanilla/settings/fontfamily\");\n  const fontFace = tiddlywikiFontSetting ?? getFontFace(style.font);\n  const { scale = 1 } = style;\n  return `${fontSize * scale}px/1 ${fontFace}`;\n}\nfunction getStickyFontStyle(style) {\n  const fontSize = getStickyFontSize(style.size);\n  const fontFace = getFontFace(style.font);\n  const { scale = 1 } = style;\n  return `${fontSize * scale}px/1 ${fontFace}`;\n}\nfunction getStickyShapeStyle(style) {\n  const { color } = style;\n  const theme = \"light\";\n  const adjustedColor = color === \"white\" /* White */ || color === \"black\" /* Black */ ? \"yellow\" /* Yellow */ : color;\n  return {\n    fill: stickyFills[theme][adjustedColor],\n    stroke: strokes[theme][adjustedColor],\n    color: \"#0d0d0d\"\n  };\n}\nfunction getShapeStyle(style) {\n  const { color, size, isFilled } = style;\n  const strokeWidth = getStrokeWidth(size);\n  const theme = \"light\";\n  return {\n    stroke: strokes[theme][color],\n    fill: isFilled ? fills[theme][color] : \"none\",\n    strokeWidth\n  };\n}\nvar defaultStyle = {\n  color: \"black\" /* Black */,\n  size: \"small\" /* Small */,\n  isFilled: false,\n  dash: \"draw\" /* Draw */,\n  scale: 1\n};\nvar defaultTextStyle = {\n  ...defaultStyle,\n  font: \"script\" /* Script */,\n  textAlign: \"middle\" /* Middle */\n};\n\n// src/components/Tldraw/state/shapes/shared/TextAreaUtils.ts\nvar INDENT = \"  \";\nvar TextAreaUtils = class {\n  static insertTextFirefox(field, text) {\n    field.setRangeText(\n      text,\n      field.selectionStart || 0,\n      field.selectionEnd || 0,\n      \"end\"\n      // Without this, the cursor is either at the beginning or `text` remains selected\n    );\n    field.dispatchEvent(\n      new InputEvent(\"input\", {\n        data: text,\n        inputType: \"insertText\",\n        isComposing: false\n        // TODO: fix @types/jsdom, this shouldn't be required\n      })\n    );\n  }\n  /** Inserts `text` at the cursor’s position, replacing any selection, with **undo** support and by firing the `input` event. */\n  static insert(field, text) {\n    const document2 = field.ownerDocument;\n    const initialFocus = document2.activeElement;\n    if (initialFocus !== field) {\n      field.focus();\n    }\n    if (!document2.execCommand(\"insertText\", false, text)) {\n      TextAreaUtils.insertTextFirefox(field, text);\n    }\n    if (initialFocus === document2.body) {\n      field.blur();\n    } else if (initialFocus instanceof HTMLElement && initialFocus !== field) {\n      initialFocus.focus();\n    }\n  }\n  /** Replaces the entire content, equivalent to `field.value = text` but with **undo** support and by firing the `input` event. */\n  static set(field, text) {\n    field.select();\n    TextAreaUtils.insert(field, text);\n  }\n  /** Get the selected text in a field or an empty string if nothing is selected. */\n  static getSelection(field) {\n    const { selectionStart, selectionEnd } = field;\n    return field.value.slice(selectionStart || void 0, selectionEnd || void 0);\n  }\n  /** Adds the `wrappingText` before and after field’s selection (or cursor). If `endWrappingText` is provided, it will be used instead of `wrappingText` at on the right. */\n  static wrapSelection(field, wrap, wrapEnd) {\n    const { selectionStart, selectionEnd } = field;\n    const selection = TextAreaUtils.getSelection(field);\n    TextAreaUtils.insert(field, wrap + selection + (wrapEnd ?? wrap));\n    field.selectionStart = (selectionStart || 0) + wrap.length;\n    field.selectionEnd = (selectionEnd || 0) + wrap.length;\n  }\n  /** Finds and replaces strings and regex in the field’s value, like `field.value = field.value.replace()` but better */\n  static replace(field, searchValue, replacer) {\n    let drift = 0;\n    field.value.replace(searchValue, (...args) => {\n      const matchStart = drift + args[args.length - 2];\n      const matchLength = args[0].length;\n      field.selectionStart = matchStart;\n      field.selectionEnd = matchStart + matchLength;\n      const replacement = typeof replacer === \"string\" ? replacer : replacer(...args);\n      TextAreaUtils.insert(field, replacement);\n      field.selectionStart = matchStart;\n      drift += replacement.length - matchLength;\n      return replacement;\n    });\n  }\n  static findLineEnd(value, currentEnd) {\n    const lastLineStart = value.lastIndexOf(\"\\n\", currentEnd - 1) + 1;\n    if (value.charAt(lastLineStart) !== \"\t\") {\n      return currentEnd;\n    }\n    return lastLineStart + 1;\n  }\n  static indent(element) {\n    const { selectionStart, selectionEnd, value } = element;\n    const selectedContrast = value.slice(selectionStart, selectionEnd);\n    const lineBreakCount = /\\n/g.exec(selectedContrast)?.length;\n    if (lineBreakCount && lineBreakCount > 0) {\n      const firstLineStart = value.lastIndexOf(\"\\n\", selectionStart - 1) + 1;\n      const newSelection = element.value.slice(firstLineStart, selectionEnd - 1);\n      const indentedText = newSelection.replace(\n        /^|\\n/g,\n        // Match all line starts\n        `$&${INDENT}`\n      );\n      const replacementsCount = indentedText.length - newSelection.length;\n      element.setSelectionRange(firstLineStart, selectionEnd - 1);\n      TextAreaUtils.insert(element, indentedText);\n      element.setSelectionRange(selectionStart + 1, selectionEnd + replacementsCount);\n    } else {\n      TextAreaUtils.insert(element, INDENT);\n    }\n  }\n  // The first line should always be unindented\n  // The last line should only be unindented if the selection includes any characters after `\\n`\n  static unindent(element) {\n    const { selectionStart, selectionEnd, value } = element;\n    const firstLineStart = value.lastIndexOf(\"\\n\", selectionStart - 1) + 1;\n    const minimumSelectionEnd = TextAreaUtils.findLineEnd(value, selectionEnd);\n    const newSelection = element.value.slice(firstLineStart, minimumSelectionEnd);\n    const indentedText = newSelection.replace(/(^|\\n)(\\t| {1,2})/g, \"$1\");\n    const replacementsCount = newSelection.length - indentedText.length;\n    element.setSelectionRange(firstLineStart, minimumSelectionEnd);\n    TextAreaUtils.insert(element, indentedText);\n    const firstLineIndentation = /\\t| {1,2}/.exec(value.slice(firstLineStart, selectionStart));\n    const difference = firstLineIndentation ? firstLineIndentation[0].length : 0;\n    const newSelectionStart = selectionStart - difference;\n    element.setSelectionRange(selectionStart - difference, Math.max(newSelectionStart, selectionEnd - replacementsCount));\n  }\n};\n\n// src/components/Tldraw/state/shapes/shared/TextLabel.tsx\nvar React45 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/StateManager/copy.ts\nfunction deepCopy(target) {\n  if (target === null) {\n    return target;\n  }\n  if (target instanceof Date) {\n    return new Date(target.getTime());\n  }\n  if (typeof target === \"object\") {\n    if (typeof target[Symbol.iterator] === \"function\") {\n      const cp = [];\n      if (target.length > 0) {\n        for (const arrayMember of target) {\n          cp.push(deepCopy(arrayMember));\n        }\n      }\n      return cp;\n    } else {\n      const targetKeys = Object.keys(target);\n      const cp = {};\n      if (targetKeys.length > 0) {\n        for (const key of targetKeys) {\n          cp[key] = deepCopy(target[key]);\n        }\n      }\n      return cp;\n    }\n  }\n  return target;\n}\n\n// src/components/Tldraw/state/shapes/ArrowUtil/ArrowUtil.tsx\nvar React31 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/TDShapeUtil.tsx\nvar React28 = __toESM(require(\"react\"));\nvar TDShapeUtil = class extends _e2 {\n  canBind = false;\n  canEdit = false;\n  canClone = false;\n  isAspectRatioLocked = false;\n  hideResizeHandles = false;\n  bindingDistance = BINDING_DISTANCE;\n  hitTestPoint = (shape, point) => {\n    return C3.pointInBounds(point, this.getRotatedBounds(shape));\n  };\n  hitTestLineSegment = (shape, A6, B5) => {\n    const box = C3.getBoundsFromPoints([A6, B5]);\n    const bounds = this.getBounds(shape);\n    return C3.boundsContain(bounds, box) || shape.rotation ? S(A6, B5, C3.getRotatedCorners(this.getBounds(shape))).didIntersect : ce2(A6, B5, this.getBounds(shape)).length > 0;\n  };\n  create = (props) => {\n    this.refMap.set(props.id, React28.createRef());\n    return this.getShape(props);\n  };\n  getCenter = (shape) => {\n    return C3.getBoundsCenter(this.getBounds(shape));\n  };\n  getExpandedBounds = (shape) => {\n    return C3.expandBounds(this.getBounds(shape), this.bindingDistance);\n  };\n  getBindingPoint = (shape, fromShape, point, origin, direction, bindAnywhere) => {\n    const bounds = this.getBounds(shape);\n    const expandedBounds = this.getExpandedBounds(shape);\n    if (!C3.pointInBounds(point, expandedBounds))\n      return;\n    const intersections = se2(origin, direction, expandedBounds).filter((int) => int.didIntersect).map((int) => int.points[0]);\n    if (intersections.length === 0)\n      return;\n    const center = this.getCenter(shape);\n    const intersection = intersections.sort((a7, b6) => e.dist(b6, origin) - e.dist(a7, origin))[0];\n    const middlePoint = e.med(point, intersection);\n    let anchor;\n    let distance;\n    if (bindAnywhere) {\n      anchor = e.dist(point, center) < BINDING_DISTANCE / 2 ? center : point;\n      distance = 0;\n    } else {\n      if (e.distanceToLineSegment(point, middlePoint, center) < BINDING_DISTANCE / 2) {\n        anchor = center;\n      } else {\n        anchor = middlePoint;\n      }\n      if (C3.pointInBounds(point, bounds)) {\n        distance = this.bindingDistance;\n      } else {\n        distance = Math.max(\n          this.bindingDistance,\n          C3.getBoundsSides(bounds).map((side) => e.distanceToLineSegment(side[1][0], side[1][1], point)).sort((a7, b6) => a7 - b6)[0]\n        );\n      }\n    }\n    const bindingPoint = e.divV(e.sub(anchor, [expandedBounds.minX, expandedBounds.minY]), [expandedBounds.width, expandedBounds.height]);\n    return {\n      point: e.clampV(bindingPoint, 0, 1),\n      distance\n    };\n  };\n  mutate = (shape, props) => {\n    return props;\n  };\n  transform = (shape, bounds, info) => {\n    return { ...shape, point: [bounds.minX, bounds.minY] };\n  };\n  transformSingle = (shape, bounds, info) => {\n    return this.transform(shape, bounds, info);\n  };\n  updateChildren;\n  onChildrenChange;\n  onHandleChange;\n  onRightPointHandle;\n  onDoubleClickHandle;\n  onDoubleClickBoundsHandle;\n  onSessionComplete;\n  getSvgElement = (shape) => {\n    const elm = document.getElementById(shape.id + \"_svg\")?.cloneNode(true);\n    if (!elm)\n      return;\n    const hasLabel = shape.label?.trim()?.length ?? 0 > 0;\n    if (hasLabel) {\n      const s5 = shape;\n      const g6 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      const font = getFontStyle(shape.style);\n      const labelSize = getTextLabelSize(shape.label, font);\n      const fontSize = getFontSize(shape.style.size, shape.style.font) * (shape.style.scale ?? 1);\n      const fontFamily = getFontFace(shape.style.font).slice(1, -1);\n      const labelElm = getTextSvgElement(s5.label, fontSize, fontFamily, \"middle\" /* Middle */, labelSize[0], false);\n      const bounds = this.getBounds(shape);\n      labelElm.setAttribute(\"transform\", `translate(${bounds.width / 2 - labelSize[0] / 2}, ${bounds.height / 2 - labelSize[1] / 2})`);\n      labelElm.setAttribute(\"fill\", getShapeStyle(shape.style).stroke);\n      labelElm.setAttribute(\"transform-origin\", \"center center\");\n      g6.setAttribute(\"text-align\", \"center\");\n      g6.setAttribute(\"text-anchor\", \"middle\");\n      g6.appendChild(elm);\n      g6.appendChild(labelElm);\n      return g6;\n    }\n    return elm;\n  };\n};\n\n// src/components/Tldraw/state/shapes/ArrowUtil/arrowHelpers.ts\nfunction getArrowArcPath(start, end, circle, bend) {\n  return [\"M\", start[0], start[1], \"A\", circle[2], circle[2], 0, 0, bend < 0 ? 0 : 1, end[0], end[1]].join(\" \");\n}\nfunction getBendPoint(handles, bend) {\n  const { start, end } = handles;\n  const dist = p.dist(start.point, end.point);\n  const midPoint = p.med(start.point, end.point);\n  const bendDist = dist / 2 * bend;\n  const u5 = p.uni(p.vec(start.point, end.point));\n  const point = p.toFixed(Math.abs(bendDist) < 10 ? midPoint : p.add(midPoint, p.mul(p.per(u5), bendDist)));\n  return point;\n}\nfunction renderFreehandArrowShaft(id, style, start, end, decorationStart, decorationEnd) {\n  const getRandom = C3.rng(id);\n  const strokeWidth = getShapeStyle(style).strokeWidth;\n  const startPoint = decorationStart ? p.nudge(start, end, strokeWidth) : start;\n  const endPoint = decorationEnd ? p.nudge(end, start, strokeWidth) : end;\n  const stroke = _e([startPoint, endPoint], {\n    size: strokeWidth,\n    thinning: 0.618 + getRandom() * 0.2,\n    easing: EASINGS.easeOutQuad,\n    simulatePressure: true,\n    streamline: 0,\n    last: true\n  });\n  return C3.getSvgPathFromStroke(stroke);\n}\nfunction renderCurvedFreehandArrowShaft(id, style, start, end, decorationStart, decorationEnd, center, radius, length, easing) {\n  const getRandom = C3.rng(id);\n  const strokeWidth = getShapeStyle(style).strokeWidth;\n  const startPoint = decorationStart ? p.rotWith(start, center, strokeWidth / length) : start;\n  const endPoint = decorationEnd ? p.rotWith(end, center, -(strokeWidth / length)) : end;\n  const startAngle = p.angle(center, startPoint);\n  const endAngle = p.angle(center, endPoint);\n  const points = [];\n  const count = 8 + Math.floor(Math.abs(length) / 20 * 1 + getRandom() / 2);\n  for (let i4 = 0; i4 < count; i4++) {\n    const t5 = easing(i4 / count);\n    const angle = C3.lerpAngles(startAngle, endAngle, t5);\n    points.push(p.toFixed(p.nudgeAtAngle(center, angle, radius)));\n  }\n  const stroke = _e([startPoint, ...points, endPoint], {\n    size: 1 + strokeWidth,\n    thinning: 0.618 + getRandom() * 0.2,\n    easing: EASINGS.easeOutQuad,\n    simulatePressure: false,\n    streamline: 0,\n    last: true\n  });\n  return C3.getSvgPathFromStroke(stroke);\n}\nfunction getCtp(start, bend, end) {\n  return C3.circleFromThreePoints(start, end, bend);\n}\nfunction getCurvedArrowHeadPoints(A6, r1, C6, r22, sweep) {\n  const ints = le(A6, r1 * 0.618, C6, r22).points;\n  if (!ints) {\n    TLDR.warn(\"Could not find an intersection for the arrow head.\");\n    return { left: A6, right: A6 };\n  }\n  const int = sweep ? ints[0] : ints[1];\n  const left = int ? p.nudge(p.rotWith(int, A6, Math.PI / 6), A6, r1 * -0.382) : A6;\n  const right = int ? p.nudge(p.rotWith(int, A6, -Math.PI / 6), A6, r1 * -0.382) : A6;\n  return { left, right };\n}\nfunction getStraightArrowHeadPoints(A6, B5, r5) {\n  const ints = de2(A6, r5, A6, B5).points;\n  if (!ints) {\n    TLDR.warn(\"Could not find an intersection for the arrow head.\");\n    return { left: A6, right: A6 };\n  }\n  const int = ints[0];\n  const left = int ? p.rotWith(int, A6, Math.PI / 6) : A6;\n  const right = int ? p.rotWith(int, A6, -Math.PI / 6) : A6;\n  return { left, right };\n}\nfunction getCurvedArrowHeadPath(A6, r1, C6, r22, sweep) {\n  const { left, right } = getCurvedArrowHeadPoints(A6, r1, C6, r22, sweep);\n  return `M ${left} L ${A6} ${right}`;\n}\nfunction getStraightArrowHeadPath(A6, B5, r5) {\n  const { left, right } = getStraightArrowHeadPoints(A6, B5, r5);\n  return `M ${left} L ${A6} ${right}`;\n}\nfunction getArrowPath(style, start, bend, end, decorationStart, decorationEnd) {\n  const { strokeWidth } = getShapeStyle(style, false);\n  const arrowDist = p.dist(start, end);\n  const arrowHeadLength = Math.min(arrowDist / 3, strokeWidth * 8);\n  const path = [];\n  const isStraightLine = p.dist(bend, p.toFixed(p.med(start, end))) < 1;\n  if (isStraightLine) {\n    path.push(`M ${start} L ${end}`);\n    if (decorationStart) {\n      path.push(getStraightArrowHeadPath(start, end, arrowHeadLength));\n    }\n    if (decorationEnd) {\n      path.push(getStraightArrowHeadPath(end, start, arrowHeadLength));\n    }\n  } else {\n    const circle = getCtp(start, bend, end);\n    const center = [circle[0], circle[1]];\n    const radius = circle[2];\n    const length = getArcLength(center, radius, start, end);\n    path.push(`M ${start} A ${radius} ${radius} 0 0 ${length > 0 ? \"1\" : \"0\"} ${end}`);\n    if (decorationStart)\n      path.push(getCurvedArrowHeadPath(start, arrowHeadLength, center, radius, length < 0));\n    if (decorationEnd) {\n      path.push(getCurvedArrowHeadPath(end, arrowHeadLength, center, radius, length >= 0));\n    }\n  }\n  return path.join(\" \");\n}\nfunction getArcPoints(start, bend, end) {\n  if (p.dist2(bend, p.med(start, end)) <= 4)\n    return [start, end];\n  const points = [];\n  const circle = getCtp(start, bend, end);\n  const center = [circle[0], circle[1]];\n  const radius = circle[2];\n  const startAngle = p.angle(center, start);\n  const endAngle = p.angle(center, end);\n  for (let i4 = 0; i4 < 20; i4++) {\n    const t5 = i4 / 19;\n    const angle = C3.lerpAngles(startAngle, endAngle, t5);\n    points.push(p.nudgeAtAngle(center, angle, radius));\n  }\n  return points;\n}\nfunction isAngleBetween(a7, b6, c5) {\n  if (c5 === a7 || c5 === b6)\n    return true;\n  const PI24 = Math.PI * 2;\n  const AB = (b6 - a7 + PI24) % PI24;\n  const AC = (c5 - a7 + PI24) % PI24;\n  return AB <= Math.PI !== AC > AB;\n}\nfunction getArcLength(C6, r5, A6, B5) {\n  const sweep = C3.getSweep(C6, A6, B5);\n  return r5 * (2 * Math.PI) * (sweep / (2 * Math.PI));\n}\n\n// src/components/Tldraw/state/shapes/ArrowUtil/components/CurvedArrow.tsx.tsx\nvar React29 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/ArrowUtil/components/ArrowHead.tsx\nvar import_jsx_runtime43 = require(\"react/jsx-runtime\");\nfunction Arrowhead({ left, middle, right, stroke, strokeWidth }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime43.jsxs)(\"g\", { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(\"path\", { className: \"tl-stroke-hitarea\", d: `M ${left} L ${middle} ${right}` }),\n    /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(\n      \"path\",\n      {\n        d: `M ${left} L ${middle} ${right}`,\n        fill: \"none\",\n        stroke,\n        strokeWidth,\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        pointerEvents: \"none\"\n      }\n    )\n  ] });\n}\n\n// src/components/Tldraw/state/shapes/ArrowUtil/components/CurvedArrow.tsx.tsx\nvar import_jsx_runtime44 = require(\"react/jsx-runtime\");\nvar CurvedArrow = React29.memo(function CurvedArrow2({\n  id,\n  style,\n  start,\n  bend,\n  end,\n  arrowBend,\n  decorationStart,\n  decorationEnd,\n  isDraw\n}) {\n  const arrowDist = p.dist(start, end);\n  if (arrowDist < 2)\n    return null;\n  const styles = getShapeStyle(style);\n  const { strokeWidth } = styles;\n  const sw = 1 + strokeWidth * 1.618;\n  const circle = getCtp(start, bend, end);\n  const center = [circle[0], circle[1]];\n  const radius = circle[2];\n  const length = getArcLength(center, radius, start, end);\n  const getRandom = C3.rng(id);\n  const easing = EASINGS[getRandom() > 0 ? \"easeInOutSine\" : \"easeInOutCubic\"];\n  const path = isDraw ? renderCurvedFreehandArrowShaft(id, style, start, end, decorationStart, decorationEnd, center, radius, length, easing) : getArrowArcPath(start, end, circle, arrowBend);\n  const { strokeDasharray, strokeDashoffset } = C3.getPerfectDashProps(Math.abs(length), sw, style.dash, 2, false);\n  const arrowHeadLength = Math.min(arrowDist / 3, strokeWidth * 8);\n  const startArrowHead = decorationStart ? getCurvedArrowHeadPoints(start, arrowHeadLength, center, radius, length < 0) : null;\n  const endArrowHead = decorationEnd ? getCurvedArrowHeadPoints(end, arrowHeadLength, center, radius, length >= 0) : null;\n  return /* @__PURE__ */ (0, import_jsx_runtime44.jsxs)(import_jsx_runtime44.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(\"path\", { className: \"tl-stroke-hitarea\", d: path }),\n    /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(\n      \"path\",\n      {\n        d: path,\n        fill: isDraw ? styles.stroke : \"none\",\n        stroke: styles.stroke,\n        strokeWidth: isDraw ? 0 : sw,\n        strokeDasharray,\n        strokeDashoffset,\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        pointerEvents: \"none\"\n      }\n    ),\n    startArrowHead && /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(Arrowhead, { left: startArrowHead.left, middle: start, right: startArrowHead.right, stroke: styles.stroke, strokeWidth: sw }),\n    endArrowHead && /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(Arrowhead, { left: endArrowHead.left, middle: end, right: endArrowHead.right, stroke: styles.stroke, strokeWidth: sw })\n  ] });\n});\n\n// src/components/Tldraw/state/shapes/ArrowUtil/components/StraightArrow.tsx\nvar React30 = __toESM(require(\"react\"));\nvar import_jsx_runtime45 = require(\"react/jsx-runtime\");\nvar StraightArrow = React30.memo(function StraightArrow2({ id, style, start, end, decorationStart, decorationEnd, isDraw }) {\n  const arrowDist = p.dist(start, end);\n  if (arrowDist < 2)\n    return null;\n  const styles = getShapeStyle(style);\n  const { strokeWidth } = styles;\n  const sw = 1 + strokeWidth * 1.618;\n  const path = isDraw ? renderFreehandArrowShaft(id, style, start, end, decorationStart, decorationEnd) : \"M\" + p.toFixed(start) + \"L\" + p.toFixed(end);\n  const { strokeDasharray, strokeDashoffset } = C3.getPerfectDashProps(arrowDist, strokeWidth * 1.618, style.dash, 2, false);\n  const arrowHeadLength = Math.min(arrowDist / 3, strokeWidth * 8);\n  const startArrowHead = decorationStart ? getStraightArrowHeadPoints(start, end, arrowHeadLength) : null;\n  const endArrowHead = decorationEnd ? getStraightArrowHeadPoints(end, start, arrowHeadLength) : null;\n  return /* @__PURE__ */ (0, import_jsx_runtime45.jsxs)(import_jsx_runtime45.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(\"path\", { className: \"tl-stroke-hitarea\", d: path }),\n    /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(\n      \"path\",\n      {\n        d: path,\n        fill: styles.stroke,\n        stroke: styles.stroke,\n        strokeWidth: isDraw ? sw / 2 : sw,\n        strokeDasharray,\n        strokeDashoffset,\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        pointerEvents: \"stroke\"\n      }\n    ),\n    startArrowHead && /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(Arrowhead, { left: startArrowHead.left, middle: start, right: startArrowHead.right, stroke: styles.stroke, strokeWidth: sw }),\n    endArrowHead && /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(Arrowhead, { left: endArrowHead.left, middle: end, right: endArrowHead.right, stroke: styles.stroke, strokeWidth: sw })\n  ] });\n});\n\n// src/components/Tldraw/state/shapes/ArrowUtil/ArrowUtil.tsx\nvar import_jsx_runtime46 = require(\"react/jsx-runtime\");\nvar ArrowUtil = class extends TDShapeUtil {\n  type = \"arrow\" /* Arrow */;\n  hideBounds = true;\n  canEdit = true;\n  pathCache = /* @__PURE__ */ new WeakMap();\n  getShape = (props) => {\n    return {\n      id: \"id\",\n      type: \"arrow\" /* Arrow */,\n      name: \"Arrow\",\n      parentId: \"page\",\n      childIndex: 1,\n      point: [0, 0],\n      rotation: 0,\n      bend: 0,\n      handles: {\n        start: {\n          id: \"start\",\n          index: 0,\n          point: [0, 0],\n          canBind: true,\n          ...props.handles?.start\n        },\n        end: {\n          id: \"end\",\n          index: 1,\n          point: [1, 1],\n          canBind: true,\n          ...props.handles?.end\n        },\n        bend: {\n          id: \"bend\",\n          index: 2,\n          point: [0.5, 0.5],\n          ...props.handles?.bend\n        }\n      },\n      decorations: props.decorations ?? {\n        end: \"arrow\" /* Arrow */\n      },\n      style: {\n        ...defaultStyle,\n        isFilled: false,\n        ...props.style\n      },\n      label: \"\",\n      labelPoint: [0.5, 0.5],\n      ...props\n    };\n  };\n  Component = TDShapeUtil.Component(({ shape, isEditing, isGhost, meta, events, onShapeChange, onShapeBlur }, ref) => {\n    const {\n      id,\n      label = \"\",\n      handles: { start, bend, end },\n      decorations = {},\n      style\n    } = shape;\n    const hasLabel = label?.trim()?.length ?? 0 > 0;\n    const isStraightLine = e.dist(bend.point, e.toFixed(e.med(start.point, end.point))) < 1;\n    const font = getFontStyle(style);\n    const styles = getShapeStyle(style);\n    const labelSize = hasLabel || isEditing ? getTextLabelSize(label, font) : [0, 0];\n    const bounds = this.getBounds(shape);\n    const dist = React31.useMemo(() => {\n      const { start: start2, bend: bend2, end: end2 } = shape.handles;\n      if (isStraightLine)\n        return e.dist(start2.point, end2.point);\n      const circle = getCtp(start2.point, bend2.point, end2.point);\n      const center = circle.slice(0, 2);\n      const radius = circle[2];\n      const length = getArcLength(center, radius, start2.point, end2.point);\n      return Math.abs(length);\n    }, [shape.handles]);\n    const scale = Math.max(0.5, Math.min(1, Math.max(dist / (labelSize[1] + 128), dist / (labelSize[0] + 128))));\n    const offset = React31.useMemo(() => {\n      const bounds2 = this.getBounds(shape);\n      const offset2 = e.sub(shape.handles.bend.point, e.toFixed([bounds2.width / 2, bounds2.height / 2]));\n      return offset2;\n    }, [shape, scale]);\n    const handleLabelChange = React31.useCallback(\n      (label2) => {\n        onShapeChange?.({ id, label: label2 });\n      },\n      [onShapeChange]\n    );\n    const Component = isStraightLine ? StraightArrow : CurvedArrow;\n    return /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(FullWrapper, { ref, ...events, children: [\n      /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(\n        TextLabel,\n        {\n          font,\n          text: label,\n          color: styles.stroke,\n          offsetX: offset[0],\n          offsetY: offset[1],\n          scale,\n          isEditing,\n          onChange: handleLabelChange,\n          onBlur: onShapeBlur\n        }\n      ),\n      /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(te, { id: shape.id + \"_svg\", children: [\n        /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(\"defs\", { children: /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(\"mask\", { id: shape.id + \"_clip\", children: [\n          /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(\"rect\", { x: -100, y: -100, width: bounds.width + 200, height: bounds.height + 200, fill: \"white\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(\n            \"rect\",\n            {\n              x: bounds.width / 2 - labelSize[0] / 2 * scale + offset[0],\n              y: bounds.height / 2 - labelSize[1] / 2 * scale + offset[1],\n              width: labelSize[0] * scale,\n              height: labelSize[1] * scale,\n              rx: 4 * scale,\n              ry: 4 * scale,\n              fill: \"black\",\n              opacity: 1\n            }\n          )\n        ] }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(\"g\", { pointerEvents: \"none\", opacity: isGhost ? GHOSTED_OPACITY : 1, mask: hasLabel || isEditing ? `url(#${shape.id}_clip)` : ``, children: /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(\n          Component,\n          {\n            id,\n            style,\n            start: start.point,\n            end: end.point,\n            bend: bend.point,\n            arrowBend: shape.bend,\n            decorationStart: decorations?.start,\n            decorationEnd: decorations?.end,\n            isDraw: style.dash === \"draw\" /* Draw */\n          }\n        ) })\n      ] })\n    ] });\n  });\n  Indicator = TDShapeUtil.Indicator(({ shape, bounds }) => {\n    const {\n      style,\n      decorations,\n      label,\n      handles: { start, bend, end }\n    } = shape;\n    const hasLabel = label?.trim()?.length ?? 0 > 0;\n    const font = getFontStyle(style);\n    const labelSize = hasLabel ? getTextLabelSize(label, font) : [0, 0];\n    const isStraightLine = e.dist(bend.point, e.toFixed(e.med(start.point, end.point))) < 1;\n    const dist = React31.useMemo(() => {\n      const { start: start2, bend: bend2, end: end2 } = shape.handles;\n      if (isStraightLine)\n        return e.dist(start2.point, end2.point);\n      const circle = getCtp(start2.point, bend2.point, end2.point);\n      const center = circle.slice(0, 2);\n      const radius = circle[2];\n      const length = getArcLength(center, radius, start2.point, end2.point);\n      return Math.abs(length);\n    }, [shape.handles]);\n    const scale = Math.max(0.5, Math.min(1, Math.max(dist / (labelSize[1] + 128), dist / (labelSize[0] + 128))));\n    const offset = React31.useMemo(() => {\n      const bounds2 = this.getBounds(shape);\n      const offset2 = e.sub(shape.handles.bend.point, [bounds2.width / 2, bounds2.height / 2]);\n      return offset2;\n    }, [shape, scale]);\n    return /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(import_jsx_runtime46.Fragment, { children: [\n      hasLabel && /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(LabelMask, { id: shape.id, scale, offset, bounds, labelSize }),\n      /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(\n        \"path\",\n        {\n          d: getArrowPath(style, start.point, bend.point, end.point, decorations?.start, decorations?.end),\n          mask: hasLabel ? `url(#${shape.id}_clip)` : ``\n        }\n      ),\n      hasLabel && /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(\n        \"rect\",\n        {\n          x: bounds.width / 2 - labelSize[0] / 2 * scale + offset[0],\n          y: bounds.height / 2 - labelSize[1] / 2 * scale + offset[1],\n          width: labelSize[0] * scale,\n          height: labelSize[1] * scale,\n          rx: 4 * scale,\n          ry: 4 * scale,\n          fill: \"transparent\"\n        }\n      )\n    ] });\n  });\n  getBounds = (shape) => {\n    const bounds = C3.getFromCache(this.boundsCache, shape, () => {\n      const {\n        handles: { start, bend, end }\n      } = shape;\n      return C3.getBoundsFromPoints(getArcPoints(start.point, bend.point, end.point));\n    });\n    return C3.translateBounds(bounds, shape.point);\n  };\n  getRotatedBounds = (shape) => {\n    const {\n      handles: { start, bend, end }\n    } = shape;\n    let points = getArcPoints(start.point, bend.point, end.point);\n    const { minX, minY, maxX, maxY } = C3.getBoundsFromPoints(points);\n    if (shape.rotation !== 0) {\n      points = points.map((pt2) => e.rotWith(pt2, [(minX + maxX) / 2, (minY + maxY) / 2], shape.rotation || 0));\n    }\n    return C3.translateBounds(C3.getBoundsFromPoints(points), shape.point);\n  };\n  getCenter = (shape) => {\n    const { start, end } = shape.handles;\n    return e.add(shape.point, e.med(start.point, end.point));\n  };\n  shouldRender = (prev, next) => {\n    return next.decorations !== prev.decorations || next.handles !== prev.handles || next.style !== prev.style || next.label !== prev.label;\n  };\n  hitTestPoint = (shape, point) => {\n    const {\n      handles: { start, bend, end }\n    } = shape;\n    const pt2 = e.sub(point, shape.point);\n    const points = getArcPoints(start.point, bend.point, end.point);\n    for (let i4 = 1; i4 < points.length; i4++) {\n      if (e.distanceToLineSegment(points[i4 - 1], points[i4], pt2) < 1) {\n        return true;\n      }\n    }\n    return false;\n  };\n  hitTestLineSegment = (shape, A6, B5) => {\n    const {\n      handles: { start, bend, end }\n    } = shape;\n    const ptA = e.sub(A6, shape.point);\n    const ptB = e.sub(B5, shape.point);\n    const points = getArcPoints(start.point, bend.point, end.point);\n    for (let i4 = 1; i4 < points.length; i4++) {\n      if (B2(points[i4 - 1], points[i4], ptA, ptB).didIntersect) {\n        return true;\n      }\n    }\n    return false;\n  };\n  hitTestBounds = (shape, bounds) => {\n    const { start, end, bend } = shape.handles;\n    const sp = e.add(shape.point, start.point);\n    const ep = e.add(shape.point, end.point);\n    if (C3.pointInBounds(sp, bounds) || C3.pointInBounds(ep, bounds)) {\n      return true;\n    }\n    if (e.isEqual(e.med(start.point, end.point), bend.point)) {\n      return ce2(sp, ep, bounds).length > 0;\n    } else {\n      const [cx, cy, r5] = getCtp(start.point, bend.point, end.point);\n      const cp = e.add(shape.point, [cx, cy]);\n      return be(cp, r5, sp, ep, bounds).length > 0;\n    }\n  };\n  transform = (shape, bounds, { initialShape, scaleX, scaleY }) => {\n    const initialShapeBounds = this.getBounds(initialShape);\n    const handles = [\"start\", \"end\"];\n    const nextHandles = { ...initialShape.handles };\n    handles.forEach((handle) => {\n      if (handle === \"bend\")\n        return;\n      const [x5, y6] = nextHandles[handle].point;\n      const nw = x5 / initialShapeBounds.width;\n      const nh = y6 / initialShapeBounds.height;\n      nextHandles[handle] = {\n        ...nextHandles[handle],\n        point: [bounds.width * (scaleX < 0 ? 1 - nw : nw), bounds.height * (scaleY < 0 ? 1 - nh : nh)]\n      };\n    });\n    const nextBend = scaleX > 0 && scaleY < 0 || scaleX < 0 && scaleY > 0 ? -initialShape.bend : initialShape.bend;\n    const bendPoint = getBendPoint(nextHandles, nextBend);\n    nextHandles.bend.point = bendPoint;\n    return {\n      point: e.toFixed([bounds.minX, bounds.minY]),\n      handles: nextHandles,\n      bend: nextBend\n      // does this change?\n    };\n  };\n  onDoubleClickHandle = (shape, handle) => {\n    switch (handle) {\n      case \"bend\": {\n        return {\n          bend: 0,\n          handles: {\n            ...shape.handles,\n            bend: {\n              ...shape.handles.bend,\n              point: getBendPoint(shape.handles, shape.bend)\n            }\n          }\n        };\n      }\n      case \"start\": {\n        return {\n          decorations: {\n            ...shape.decorations,\n            start: shape.decorations?.start ? void 0 : \"arrow\" /* Arrow */\n          }\n        };\n      }\n      case \"end\": {\n        return {\n          decorations: {\n            ...shape.decorations,\n            end: shape.decorations?.end ? void 0 : \"arrow\" /* Arrow */\n          }\n        };\n      }\n    }\n    return this;\n  };\n  onHandleChange = (shape, handles) => {\n    let nextHandles = C3.deepMerge(shape.handles, handles);\n    let nextBend = shape.bend;\n    nextHandles = C3.deepMerge(nextHandles, {\n      start: {\n        point: e.toFixed(nextHandles.start.point)\n      },\n      end: {\n        point: e.toFixed(nextHandles.end.point)\n      }\n    });\n    if (e.isEqual(nextHandles.start.point, nextHandles.end.point))\n      return;\n    if (\"bend\" in handles) {\n      const { start, end, bend } = nextHandles;\n      const distance = e.dist(start.point, end.point);\n      const midPoint = e.med(start.point, end.point);\n      const angle = e.angle(start.point, end.point);\n      const u5 = e.uni(e.vec(start.point, end.point));\n      const ap = e.add(midPoint, e.mul(e.per(u5), distance));\n      const bp = e.sub(midPoint, e.mul(e.per(u5), distance));\n      const bendPoint = e.nearestPointOnLineSegment(ap, bp, bend.point, true);\n      const bendDist = e.dist(midPoint, bendPoint);\n      const realBend = bendDist / (distance / 2);\n      nextBend = C3.clamp(realBend, -0.99, 0.99);\n      const angleToBend = e.angle(start.point, bendPoint);\n      if (e.isEqual(midPoint, getBendPoint(nextHandles, nextBend))) {\n        nextBend = 0;\n      } else if (isAngleBetween(angle, angle + Math.PI, angleToBend)) {\n        nextBend *= -1;\n      }\n    }\n    const nextShape = {\n      point: shape.point,\n      bend: nextBend,\n      handles: {\n        ...nextHandles,\n        bend: {\n          ...nextHandles.bend,\n          point: getBendPoint(nextHandles, nextBend)\n        }\n      }\n    };\n    const topLeft = shape.point;\n    const nextBounds = this.getBounds({ ...nextShape });\n    const offset = e.sub([nextBounds.minX, nextBounds.minY], topLeft);\n    if (!e.isEqual(offset, [0, 0])) {\n      Object.values(nextShape.handles).forEach((handle) => {\n        handle.point = e.toFixed(e.sub(handle.point, offset));\n      });\n      nextShape.point = e.toFixed(e.add(nextShape.point, offset));\n    }\n    return nextShape;\n  };\n  getSvgElement = (shape) => {\n    const elm = document.getElementById(shape.id + \"_svg\")?.cloneNode(true);\n    if (!elm)\n      return;\n    const hasLabel = shape.label?.trim()?.length ?? 0 > 0;\n    if (hasLabel) {\n      const s5 = shape;\n      const g6 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      const font = getFontStyle(shape.style);\n      const labelSize = getTextLabelSize(shape.label, font);\n      const fontSize = getFontSize(shape.style.size, shape.style.font) * (shape.style.scale ?? 1);\n      const fontFamily = getFontFace(shape.style.font).slice(1, -1);\n      const labelElm = getTextSvgElement(s5.label, fontSize, fontFamily, \"start\" /* Start */, labelSize[0], false);\n      let dist;\n      const { start, bend, end } = shape.handles;\n      const isStraightLine = e.dist(bend.point, e.toFixed(e.med(start.point, end.point))) < 1;\n      if (isStraightLine) {\n        dist = e.dist(start.point, end.point);\n      } else {\n        const circle = getCtp(start.point, bend.point, end.point);\n        const center = circle.slice(0, 2);\n        const radius = circle[2];\n        const length = getArcLength(center, radius, start.point, end.point);\n        dist = Math.abs(length);\n      }\n      const scale = Math.max(0.5, Math.min(1, Math.max(dist / (labelSize[1] + 128), dist / (labelSize[0] + 128))));\n      const bounds = this.getBounds(shape);\n      const offset = e.sub(shape.handles.bend.point, [bounds.width / 2, bounds.height / 2]);\n      const x5 = bounds.width / 2 - labelSize[0] / 2 * scale + offset[0];\n      const y6 = bounds.height / 2 - labelSize[1] / 2 * scale + offset[1];\n      labelElm.setAttribute(\"transform\", `translate(${x5}, ${y6})`);\n      labelElm.setAttribute(\"fill\", getShapeStyle(shape.style).stroke);\n      labelElm.setAttribute(\"transform-origin\", \"center center\");\n      g6.setAttribute(\"text-align\", \"center\");\n      g6.setAttribute(\"text-anchor\", \"middle\");\n      g6.appendChild(elm);\n      g6.appendChild(labelElm);\n      return g6;\n    }\n    return elm;\n  };\n};\nvar FullWrapper = styled(\"div\", { width: \"100%\", height: \"100%\" });\n\n// src/components/Tldraw/state/shapes/DrawUtil/DrawUtil.tsx\nvar React32 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/DrawUtil/drawHelpers.ts\nvar simulatePressureSettings = {\n  easing: (t5) => Math.sin(t5 * Math.PI / 2),\n  simulatePressure: true\n};\nvar realPressureSettings = {\n  easing: (t5) => t5 * t5,\n  simulatePressure: false\n};\nfunction getFreehandOptions(shape) {\n  const styles = getShapeStyle(shape.style);\n  const options = {\n    size: 1 + styles.strokeWidth * 1.5,\n    thinning: 0.65,\n    streamline: 0.65,\n    smoothing: 0.65,\n    ...shape.points[1][2] === 0.5 ? simulatePressureSettings : realPressureSettings,\n    last: shape.isComplete\n  };\n  return options;\n}\nfunction getFillPath(shape) {\n  if (shape.points.length < 2)\n    return \"\";\n  return C3.getSvgPathFromStroke(me(shape.points, getFreehandOptions(shape)).map((pt2) => pt2.point));\n}\nfunction getDrawStrokePoints(shape, options) {\n  return me(shape.points, options);\n}\nfunction getDrawStrokePathTDSnapshot(shape) {\n  if (shape.points.length < 2)\n    return \"\";\n  const options = getFreehandOptions(shape);\n  const strokePoints = getDrawStrokePoints(shape, options);\n  const path = C3.getSvgPathFromStroke(ce(strokePoints, options));\n  return path;\n}\nfunction getSolidStrokePathTDSnapshot(shape) {\n  const { points } = shape;\n  if (points.length < 2)\n    return \"M 0 0 L 0 0\";\n  const options = getFreehandOptions(shape);\n  const strokePoints = getDrawStrokePoints(shape, options);\n  const last = points[points.length - 1];\n  if (!p.isEqual(strokePoints[0].point, last))\n    strokePoints.push({ point: last });\n  const path = C3.getSvgPathFromStrokePoints(strokePoints);\n  return path;\n}\n\n// src/components/Tldraw/state/shapes/DrawUtil/DrawUtil.tsx\nvar import_jsx_runtime47 = require(\"react/jsx-runtime\");\nvar DrawUtil = class extends TDShapeUtil {\n  type = \"draw\" /* Draw */;\n  pointsBoundsCache = /* @__PURE__ */ new WeakMap([]);\n  shapeBoundsCache = /* @__PURE__ */ new Map();\n  rotatedCache = /* @__PURE__ */ new WeakMap([]);\n  pointCache = {};\n  canClone = true;\n  getShape = (props) => {\n    return C3.deepMerge(\n      {\n        id: \"id\",\n        type: \"draw\" /* Draw */,\n        name: \"Draw\",\n        parentId: \"page\",\n        childIndex: 1,\n        point: [0, 0],\n        rotation: 0,\n        style: defaultStyle,\n        points: [],\n        isComplete: false\n      },\n      props\n    );\n  };\n  Component = TDShapeUtil.Component(({ shape, meta, isSelected, isGhost, events }, ref) => {\n    const { points, style, isComplete } = shape;\n    const polygonPathTDSnapshot = React32.useMemo(() => {\n      return getFillPath(shape);\n    }, [points, style.size]);\n    const pathTDSnapshot = React32.useMemo(() => {\n      return style.dash === \"draw\" /* Draw */ ? getDrawStrokePathTDSnapshot(shape) : getSolidStrokePathTDSnapshot(shape);\n    }, [points, style.size, style.dash, isComplete]);\n    const styles = getShapeStyle(style);\n    const { stroke, fill, strokeWidth } = styles;\n    const bounds = this.getBounds(shape);\n    const verySmall = bounds.width <= strokeWidth / 2 && bounds.height <= strokeWidth / 2;\n    if (verySmall) {\n      const sw2 = 1 + strokeWidth;\n      return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(te, { ref, id: shape.id + \"_svg\", ...events, children: /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(\"circle\", { r: sw2, fill: stroke, stroke, pointerEvents: \"all\", opacity: isGhost ? GHOSTED_OPACITY : 1 }) });\n    }\n    const shouldFill = style.isFilled && points.length > 3 && e.dist(points[0], points[points.length - 1]) < strokeWidth * 2;\n    if (shape.style.dash === \"draw\" /* Draw */) {\n      return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(te, { ref, id: shape.id + \"_svg\", ...events, children: /* @__PURE__ */ (0, import_jsx_runtime47.jsxs)(\"g\", { opacity: isGhost ? GHOSTED_OPACITY : 1, children: [\n        /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(\"path\", { className: shouldFill || isSelected ? \"tl-fill-hitarea\" : \"tl-stroke-hitarea\", d: pathTDSnapshot }),\n        shouldFill && /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(\"path\", { d: polygonPathTDSnapshot, stroke: \"none\", fill, strokeLinejoin: \"round\", strokeLinecap: \"round\", pointerEvents: \"none\" }),\n        /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(\n          \"path\",\n          {\n            d: pathTDSnapshot,\n            fill: stroke,\n            stroke,\n            strokeWidth: strokeWidth / 2,\n            strokeLinejoin: \"round\",\n            strokeLinecap: \"round\",\n            pointerEvents: \"none\"\n          }\n        )\n      ] }) });\n    }\n    const strokeDasharray = {\n      [\"draw\" /* Draw */]: \"none\",\n      [\"solid\" /* Solid */]: `none`,\n      [\"dotted\" /* Dotted */]: `0.1 ${strokeWidth * 4}`,\n      [\"dashed\" /* Dashed */]: `${strokeWidth * 4} ${strokeWidth * 4}`\n    }[style.dash];\n    const strokeDashoffset = {\n      [\"draw\" /* Draw */]: \"none\",\n      [\"solid\" /* Solid */]: `none`,\n      [\"dotted\" /* Dotted */]: `0`,\n      [\"dashed\" /* Dashed */]: `0`\n    }[style.dash];\n    const sw = 1 + strokeWidth * 1.5;\n    return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(te, { ref, id: shape.id + \"_svg\", ...events, children: /* @__PURE__ */ (0, import_jsx_runtime47.jsxs)(\"g\", { opacity: isGhost ? GHOSTED_OPACITY : 1, children: [\n      /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(\"path\", { className: shouldFill && isSelected ? \"tl-fill-hitarea\" : \"tl-stroke-hitarea\", d: pathTDSnapshot }),\n      /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(\n        \"path\",\n        {\n          d: pathTDSnapshot,\n          fill: shouldFill ? fill : \"none\",\n          stroke: \"none\",\n          strokeWidth: Math.min(4, strokeWidth * 2),\n          strokeLinejoin: \"round\",\n          strokeLinecap: \"round\",\n          pointerEvents: \"none\"\n        }\n      ),\n      /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(\n        \"path\",\n        {\n          d: pathTDSnapshot,\n          fill: \"none\",\n          stroke,\n          strokeWidth: sw,\n          strokeDasharray,\n          strokeDashoffset,\n          strokeLinejoin: \"round\",\n          strokeLinecap: \"round\",\n          pointerEvents: \"none\"\n        }\n      )\n    ] }) });\n  });\n  Indicator = TDShapeUtil.Indicator(({ shape }) => {\n    const { points } = shape;\n    const pathTDSnapshot = React32.useMemo(() => {\n      return getSolidStrokePathTDSnapshot(shape);\n    }, [points]);\n    const bounds = this.getBounds(shape);\n    const verySmall = bounds.width < 4 && bounds.height < 4;\n    if (verySmall) {\n      return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(\"circle\", { x: bounds.width / 2, y: bounds.height / 2, r: 1 });\n    }\n    return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(\"path\", { d: pathTDSnapshot });\n  });\n  transform = (shape, bounds, { initialShape, scaleX, scaleY }) => {\n    const initialShapeBounds = C3.getFromCache(this.boundsCache, initialShape, () => C3.getBoundsFromPoints(initialShape.points));\n    const points = initialShape.points.map(([x5, y6, r5]) => {\n      return [\n        bounds.width * (scaleX < 0 ? 1 - x5 / initialShapeBounds.width : x5 / initialShapeBounds.width),\n        bounds.height * (scaleY < 0 ? 1 - y6 / initialShapeBounds.height : y6 / initialShapeBounds.height),\n        r5\n      ];\n    });\n    const newBounds = C3.getBoundsFromPoints(shape.points);\n    const point = e.sub([bounds.minX, bounds.minY], [newBounds.minX, newBounds.minY]);\n    return {\n      points,\n      point\n    };\n  };\n  getBounds = (shape) => {\n    const pointsHaveChanged = !this.pointsBoundsCache.has(shape.points);\n    const pointHasChanged = !(this.pointCache[shape.id] === shape.point);\n    if (pointsHaveChanged) {\n      const bounds = C3.getBoundsFromPoints(shape.points);\n      this.pointsBoundsCache.set(shape.points, bounds);\n      this.shapeBoundsCache.set(shape.id, C3.translateBounds(bounds, shape.point));\n      this.pointCache[shape.id] = shape.point;\n    } else if (pointHasChanged && !pointsHaveChanged) {\n      this.pointCache[shape.id] = shape.point;\n      this.shapeBoundsCache.set(shape.id, C3.translateBounds(this.pointsBoundsCache.get(shape.points), shape.point));\n    }\n    return this.shapeBoundsCache.get(shape.id);\n  };\n  shouldRender = (prev, next) => {\n    return next.points !== prev.points || next.style !== prev.style || next.isComplete !== prev.isComplete;\n  };\n  hitTestPoint = (shape, point) => {\n    const ptA = e.sub(point, shape.point);\n    return C3.pointInPolyline(ptA, shape.points);\n  };\n  hitTestLineSegment = (shape, A6, B5) => {\n    const { points, point } = shape;\n    const ptA = e.sub(A6, point);\n    const ptB = e.sub(B5, point);\n    const bounds = this.getBounds(shape);\n    if (bounds.width < 8 && bounds.height < 8) {\n      return e.distanceToLineSegment(A6, B5, C3.getBoundsCenter(bounds)) < 5;\n    }\n    if (ce2(ptA, ptB, bounds)) {\n      for (let i4 = 1; i4 < points.length; i4++) {\n        if (B2(points[i4 - 1], points[i4], ptA, ptB).didIntersect) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  hitTestBounds = (shape, bounds) => {\n    if (!shape.rotation) {\n      const shapeBounds = this.getBounds(shape);\n      return C3.boundsContain(bounds, shapeBounds) || (C3.boundsContain(shapeBounds, bounds) || Te(shapeBounds, bounds).length > 0) && ye(C3.translateBounds(bounds, e.neg(shape.point)), shape.points).length > 0;\n    }\n    const rBounds = this.getRotatedBounds(shape);\n    const rotatedBounds = C3.getFromCache(this.rotatedCache, shape, () => {\n      const c5 = C3.getBoundsCenter(C3.getBoundsFromPoints(shape.points));\n      return shape.points.map((pt2) => e.rotWith(pt2, c5, shape.rotation || 0));\n    });\n    return C3.boundsContain(bounds, rBounds) || ye(C3.translateBounds(bounds, e.neg(shape.point)), rotatedBounds).length > 0;\n  };\n};\n\n// src/components/Tldraw/state/shapes/EllipseUtil/EllipseUtil.tsx\nvar React35 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/EllipseUtil/components/DashedEllipse.tsx\nvar React33 = __toESM(require(\"react\"));\nvar import_jsx_runtime48 = require(\"react/jsx-runtime\");\nvar DashedEllipse = React33.memo(function DashedEllipse2({ radius, style, isSelected }) {\n  const { stroke, strokeWidth, fill } = getShapeStyle(style);\n  const sw = 1 + strokeWidth * 1.618;\n  const rx = Math.max(0, radius[0] - sw / 2);\n  const ry = Math.max(0, radius[1] - sw / 2);\n  const perimeter = C3.perimeterOfEllipse(rx, ry);\n  const { strokeDasharray, strokeDashoffset } = C3.getPerfectDashProps(perimeter < 64 ? perimeter * 2 : perimeter, strokeWidth * 1.618, style.dash, 4);\n  return /* @__PURE__ */ (0, import_jsx_runtime48.jsxs)(import_jsx_runtime48.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(\"ellipse\", { className: style.isFilled || isSelected ? \"tl-fill-hitarea\" : \"tl-stroke-hitarea\", cx: radius[0], cy: radius[1], rx: radius[0], ry: radius[1] }),\n    /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(\n      \"ellipse\",\n      {\n        cx: radius[0],\n        cy: radius[1],\n        rx,\n        ry,\n        fill,\n        stroke,\n        strokeWidth: sw,\n        strokeDasharray,\n        strokeDashoffset,\n        pointerEvents: \"none\",\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\"\n      }\n    )\n  ] });\n});\n\n// src/components/Tldraw/state/shapes/EllipseUtil/components/DrawEllipse.tsx\nvar React34 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/EllipseUtil/ellipseHelpers.ts\nfunction getEllipseStrokePoints(id, radius, style) {\n  const { strokeWidth } = getShapeStyle(style);\n  const getRandom = C3.rng(id);\n  const rx = radius[0] + getRandom() * strokeWidth * 2;\n  const ry = radius[1] + getRandom() * strokeWidth * 2;\n  const perimeter = C3.perimeterOfEllipse(rx, ry);\n  const points = [];\n  const start = Math.PI + Math.PI * getRandom();\n  const extra = Math.abs(getRandom());\n  const count = Math.max(16, perimeter / 10);\n  for (let i4 = 0; i4 < count; i4++) {\n    const t5 = EASINGS.easeInOutSine(i4 / (count + 1));\n    const rads = start * 2 + Math.PI * (2 + extra) * t5;\n    const c5 = Math.cos(rads);\n    const s5 = Math.sin(rads);\n    points.push([rx * c5 + radius[0], ry * s5 + radius[1], t5 + 0.5 + getRandom() / 2]);\n  }\n  return me(points, {\n    size: 1 + strokeWidth * 2,\n    thinning: 0.618,\n    end: { taper: perimeter / 8 },\n    start: { taper: perimeter / 12 },\n    streamline: 0,\n    simulatePressure: true\n  });\n}\nfunction getEllipsePath(id, radius, style) {\n  const { strokeWidth } = getShapeStyle(style);\n  const getRandom = C3.rng(id);\n  const rx = radius[0] + getRandom() * strokeWidth * 2;\n  const ry = radius[1] + getRandom() * strokeWidth * 2;\n  const perimeter = C3.perimeterOfEllipse(rx, ry);\n  return C3.getSvgPathFromStroke(\n    ce(getEllipseStrokePoints(id, radius, style), {\n      size: 2 + strokeWidth * 2,\n      thinning: 0.618,\n      end: { taper: perimeter / 8 },\n      start: { taper: perimeter / 12 },\n      streamline: 0,\n      simulatePressure: true\n    })\n  );\n}\nfunction getEllipseIndicatorPath(id, radius, style) {\n  return C3.getSvgPathFromStrokePoints(getEllipseStrokePoints(id, radius, style));\n}\n\n// src/components/Tldraw/state/shapes/EllipseUtil/components/DrawEllipse.tsx\nvar import_jsx_runtime49 = require(\"react/jsx-runtime\");\nvar DrawEllipse = React34.memo(function DrawEllipse2({ id, radius, style, isSelected }) {\n  const { stroke, strokeWidth, fill } = getShapeStyle(style);\n  const innerPath = getEllipsePath(id, radius, style);\n  return /* @__PURE__ */ (0, import_jsx_runtime49.jsxs)(import_jsx_runtime49.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(\"ellipse\", { className: style.isFilled || isSelected ? \"tl-fill-hitarea\" : \"tl-stroke-hitarea\", cx: radius[0], cy: radius[1], rx: radius[0], ry: radius[1] }),\n    style.isFilled && /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(\"path\", { d: getEllipseIndicatorPath(id, radius, style), stroke: \"none\", fill, pointerEvents: \"none\" }),\n    /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(\"path\", { d: innerPath, fill: stroke, stroke, strokeWidth, pointerEvents: \"none\", strokeLinecap: \"round\", strokeLinejoin: \"round\" })\n  ] });\n});\n\n// src/components/Tldraw/state/shapes/EllipseUtil/EllipseUtil.tsx\nvar import_jsx_runtime50 = require(\"react/jsx-runtime\");\nvar EllipseUtil = class extends TDShapeUtil {\n  type = \"ellipse\" /* Ellipse */;\n  canBind = true;\n  canClone = true;\n  canEdit = true;\n  getShape = (props) => {\n    return C3.deepMerge(\n      {\n        id: \"id\",\n        type: \"ellipse\" /* Ellipse */,\n        name: \"Ellipse\",\n        parentId: \"page\",\n        childIndex: 1,\n        point: [0, 0],\n        radius: [1, 1],\n        rotation: 0,\n        style: defaultStyle,\n        label: \"\",\n        labelPoint: [0.5, 0.5]\n      },\n      props\n    );\n  };\n  Component = TDShapeUtil.Component(\n    ({ shape, isGhost, isSelected, isBinding, isEditing, meta, bounds, events, onShapeChange, onShapeBlur }, ref) => {\n      const { id, radius, style, label = \"\", labelPoint = LABEL_POINT } = shape;\n      const font = getFontStyle(shape.style);\n      const styles = getShapeStyle(style);\n      const strokeWidth = styles.strokeWidth;\n      const sw = 1 + strokeWidth * 1.618;\n      const rx = Math.max(0, radius[0] - sw / 2);\n      const ry = Math.max(0, radius[1] - sw / 2);\n      const Component = style.dash === \"draw\" /* Draw */ ? DrawEllipse : DashedEllipse;\n      const handleLabelChange = React35.useCallback((label2) => onShapeChange?.({ id, label: label2 }), [onShapeChange]);\n      return /* @__PURE__ */ (0, import_jsx_runtime50.jsxs)(FullWrapper2, { ref, ...events, children: [\n        /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(\n          TextLabel,\n          {\n            isEditing,\n            onChange: handleLabelChange,\n            onBlur: onShapeBlur,\n            font,\n            text: label,\n            color: styles.stroke,\n            offsetX: (labelPoint[0] - 0.5) * bounds.width,\n            offsetY: (labelPoint[1] - 0.5) * bounds.height\n          }\n        ),\n        /* @__PURE__ */ (0, import_jsx_runtime50.jsxs)(te, { id: shape.id + \"_svg\", opacity: isGhost ? GHOSTED_OPACITY : 1, children: [\n          isBinding && /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(\"ellipse\", { className: \"tl-binding-indicator\", cx: radius[0], cy: radius[1], rx, ry, strokeWidth: this.bindingDistance }),\n          /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(Component, { id, radius, style, isSelected })\n        ] })\n      ] });\n    }\n  );\n  Indicator = TDShapeUtil.Indicator(({ shape }) => {\n    const { id, radius, style } = shape;\n    const styles = getShapeStyle(style);\n    const strokeWidth = styles.strokeWidth;\n    const sw = 1 + strokeWidth * 1.618;\n    const rx = Math.max(0, radius[0] - sw / 2);\n    const ry = Math.max(0, radius[1] - sw / 2);\n    return style.dash === \"draw\" /* Draw */ ? /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(\"path\", { d: getEllipseIndicatorPath(id, radius, style) }) : /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(\"ellipse\", { cx: radius[0], cy: radius[1], rx, ry });\n  });\n  hitTestPoint = (shape, point) => {\n    return C3.pointInBounds(point, this.getRotatedBounds(shape)) && C3.pointInEllipse(point, this.getCenter(shape), shape.radius[0], shape.radius[1], shape.rotation || 0);\n  };\n  hitTestLineSegment = (shape, A6, B5) => {\n    return y(A6, B5, this.getCenter(shape), shape.radius[0], shape.radius[1], shape.rotation || 0).didIntersect;\n  };\n  getBounds = (shape) => {\n    return C3.getFromCache(this.boundsCache, shape, () => {\n      return C3.getRotatedEllipseBounds(shape.point[0], shape.point[1], shape.radius[0], shape.radius[1], 0);\n    });\n  };\n  getRotatedBounds = (shape) => {\n    return C3.getRotatedEllipseBounds(shape.point[0], shape.point[1], shape.radius[0], shape.radius[1], shape.rotation);\n  };\n  hitTestBounds = (shape, bounds) => {\n    const shapeBounds = this.getBounds(shape);\n    return C3.boundsContained(shapeBounds, bounds) || pe2(this.getCenter(shape), shape.radius[0], shape.radius[1], shape.rotation || 0, bounds).length > 0;\n  };\n  shouldRender = (prev, next) => {\n    return next.radius !== prev.radius || next.style !== prev.style || next.label !== prev.label;\n  };\n  getCenter = (shape) => {\n    return e.add(shape.point, shape.radius);\n  };\n  getBindingPoint = (shape, fromShape, point, origin, direction, bindAnywhere) => {\n    {\n      const expandedBounds = this.getExpandedBounds(shape);\n      const center = this.getCenter(shape);\n      let bindingPoint;\n      let distance;\n      if (!C3.pointInEllipse(point, center, shape.radius[0] + this.bindingDistance, shape.radius[1] + this.bindingDistance)) {\n        return;\n      }\n      if (bindAnywhere) {\n        if (e.dist(point, this.getCenter(shape)) < 12) {\n          bindingPoint = [0.5, 0.5];\n        } else {\n          bindingPoint = e.divV(e.sub(point, [expandedBounds.minX, expandedBounds.minY]), [expandedBounds.width, expandedBounds.height]);\n        }\n        distance = 0;\n      } else {\n        let intersection = F(origin, direction, center, shape.radius[0], shape.radius[1], shape.rotation || 0).points.sort(\n          (a7, b6) => e.dist(a7, origin) - e.dist(b6, origin)\n        )[0];\n        if (!intersection) {\n          intersection = y(point, center, center, shape.radius[0], shape.radius[1], shape.rotation || 0).points.sort(\n            (a7, b6) => e.dist(a7, point) - e.dist(b6, point)\n          )[0];\n        }\n        if (!intersection) {\n          return;\n        }\n        const anchor = e.med(point, intersection);\n        if (e.distanceToLineSegment(point, anchor, this.getCenter(shape)) < 12) {\n          bindingPoint = [0.5, 0.5];\n        } else {\n          bindingPoint = e.divV(e.sub(anchor, [expandedBounds.minX, expandedBounds.minY]), [expandedBounds.width, expandedBounds.height]);\n        }\n        if (C3.pointInEllipse(point, center, shape.radius[0], shape.radius[1], shape.rotation || 0)) {\n          distance = this.bindingDistance / 2;\n        } else {\n          const innerIntersection = y(point, center, center, shape.radius[0], shape.radius[1], shape.rotation || 0).points[0];\n          if (!innerIntersection)\n            return;\n          distance = Math.max(this.bindingDistance / 2, e.dist(point, innerIntersection));\n        }\n      }\n      return {\n        point: bindingPoint,\n        distance\n      };\n    }\n  };\n  transform = (shape, bounds, { scaleX, scaleY, initialShape }) => {\n    const { rotation = 0 } = initialShape;\n    return {\n      point: [bounds.minX, bounds.minY],\n      radius: [bounds.width / 2, bounds.height / 2],\n      rotation: scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? -(rotation || 0) : rotation || 0\n    };\n  };\n  transformSingle = (shape, bounds) => {\n    return {\n      point: e.toFixed([bounds.minX, bounds.minY]),\n      radius: e.div([bounds.width, bounds.height], 2)\n    };\n  };\n};\nvar FullWrapper2 = styled(\"div\", { width: \"100%\", height: \"100%\" });\n\n// src/components/Tldraw/state/shapes/GroupUtil/GroupUtil.tsx\nvar import_jsx_runtime51 = require(\"react/jsx-runtime\");\nvar GroupUtil = class extends TDShapeUtil {\n  type = \"group\" /* Group */;\n  canBind = true;\n  getShape = (props) => {\n    return C3.deepMerge(\n      {\n        id: \"id\",\n        type: \"group\" /* Group */,\n        name: \"Group\",\n        parentId: \"page\",\n        childIndex: 1,\n        point: [0, 0],\n        size: [100, 100],\n        rotation: 0,\n        children: [],\n        style: defaultStyle\n      },\n      props\n    );\n  };\n  Component = TDShapeUtil.Component(({ shape, isBinding, isGhost, isHovered, isSelected, events }, ref) => {\n    const { id, size } = shape;\n    const sw = 2;\n    const w7 = Math.max(0, size[0] - sw / 2);\n    const h6 = Math.max(0, size[1] - sw / 2);\n    const strokes2 = [\n      [[sw / 2, sw / 2], [w7, sw / 2], w7 - sw / 2],\n      [[w7, sw / 2], [w7, h6], h6 - sw / 2],\n      [[w7, h6], [sw / 2, h6], w7 - sw / 2],\n      [[sw / 2, h6], [sw / 2, sw / 2], h6 - sw / 2]\n    ];\n    const paths = strokes2.map(([start, end], i4) => {\n      return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(\"line\", { x1: start[0], y1: start[1], x2: end[0], y2: end[1] }, id + \"_\" + i4);\n    });\n    return /* @__PURE__ */ (0, import_jsx_runtime51.jsxs)(te, { ref, ...events, children: [\n      isBinding && /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(\"rect\", { className: \"tl-binding-indicator\", strokeWidth: this.bindingDistance }),\n      /* @__PURE__ */ (0, import_jsx_runtime51.jsxs)(\"g\", { opacity: isGhost ? GHOSTED_OPACITY : 1, children: [\n        /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(\"rect\", { x: 0, y: 0, width: size[0], height: size[1], fill: \"transparent\", pointerEvents: \"all\" }),\n        /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(ScaledLines, { stroke: \"black\" /* Black */, opacity: isHovered || isSelected ? 1 : 0, strokeLinecap: \"round\", pointerEvents: \"stroke\", children: paths })\n      ] })\n    ] });\n  });\n  Indicator = TDShapeUtil.Indicator(({ shape }) => {\n    const { id, size } = shape;\n    const sw = 2;\n    const w7 = Math.max(0, size[0] - sw / 2);\n    const h6 = Math.max(0, size[1] - sw / 2);\n    const strokes2 = [\n      [[sw / 2, sw / 2], [w7, sw / 2], w7 - sw / 2],\n      [[w7, sw / 2], [w7, h6], h6 - sw / 2],\n      [[w7, h6], [sw / 2, h6], w7 - sw / 2],\n      [[sw / 2, h6], [sw / 2, sw / 2], h6 - sw / 2]\n    ];\n    const paths = strokes2.map(([start, end], i4) => {\n      return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(\"line\", { x1: start[0], y1: start[1], x2: end[0], y2: end[1] }, id + \"_\" + i4);\n    });\n    return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(ScaledLines, { strokeLinecap: \"round\", pointerEvents: \"stroke\", children: paths });\n  });\n  getBounds = (shape) => {\n    return getBoundsRectangle(shape, this.boundsCache);\n  };\n  shouldRender = (prev, next) => {\n    return next.size !== prev.size || next.style !== prev.style;\n  };\n};\nvar ScaledLines = styled(\"g\", {\n  strokeWidth: \"calc(1.5px * var(--tl-scale))\",\n  strokeDasharray: `calc(1px * var(--tl-scale)), calc(3px * var(--tl-scale))`\n});\n\n// src/components/Tldraw/state/shapes/ImageUtil/ImageUtil.tsx\nvar React36 = __toESM(require(\"react\"));\nvar import_jsx_runtime52 = require(\"react/jsx-runtime\");\nvar ImageUtil = class extends TDShapeUtil {\n  type = \"image\" /* Image */;\n  canBind = true;\n  canClone = true;\n  isAspectRatioLocked = true;\n  showCloneHandles = false;\n  getShape = (props) => {\n    return C3.deepMerge(\n      {\n        id: \"image\",\n        type: \"image\" /* Image */,\n        name: \"Image\",\n        parentId: \"page\",\n        childIndex: 1,\n        point: [0, 0],\n        size: [1, 1],\n        rotation: 0,\n        style: { ...defaultStyle, isFilled: true },\n        assetId: \"assetId\"\n      },\n      props\n    );\n  };\n  Component = TDShapeUtil.Component(({ shape, asset = { src: \"\" }, isBinding, isGhost, meta, events, onShapeChange }, ref) => {\n    const { size, style } = shape;\n    const { bindingDistance } = this;\n    const rImage = React36.useRef(null);\n    const rWrapper = React36.useRef(null);\n    React36.useLayoutEffect(() => {\n      const wrapper = rWrapper.current;\n      if (!wrapper)\n        return;\n      const [width, height] = size;\n      wrapper.style.width = `${width}px`;\n      wrapper.style.height = `${height}px`;\n    }, [size]);\n    return /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)(Xs, { ref, ...events, children: [\n      isBinding && /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(\n        \"div\",\n        {\n          className: \"tl-binding-indicator\",\n          style: {\n            position: \"absolute\",\n            top: `calc(${-bindingDistance}px * var(--tl-zoom))`,\n            left: `calc(${-bindingDistance}px * var(--tl-zoom))`,\n            width: `calc(100% + ${bindingDistance * 2}px * var(--tl-zoom))`,\n            height: `calc(100% + ${bindingDistance * 2}px * var(--tl-zoom))`,\n            backgroundColor: \"var(--tl-selectFill)\"\n          }\n        }\n      ),\n      /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(\n        Wrapper,\n        {\n          ref: rWrapper,\n          isFilled: style.isFilled,\n          isGhost,\n          children: /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(ImageElement, { id: shape.id + \"_image\", ref: rImage, src: asset.src, alt: \"tl_image_asset\", draggable: false })\n        }\n      )\n    ] });\n  });\n  Indicator = TDShapeUtil.Indicator(({ shape }) => {\n    const {\n      size: [width, height]\n    } = shape;\n    return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(\"rect\", { x: 0, y: 0, rx: 2, ry: 2, width: Math.max(1, width), height: Math.max(1, height) });\n  });\n  getBounds = (shape) => {\n    return getBoundsRectangle(shape, this.boundsCache);\n  };\n  shouldRender = (prev, next) => {\n    return next.size !== prev.size || next.style !== prev.style;\n  };\n  transform = transformRectangle;\n  transformSingle = transformSingleRectangle;\n  getSvgElement = (shape) => {\n    const bounds = this.getBounds(shape);\n    const elm = document.createElementNS(\"http://www.w3.org/2000/svg\", \"image\");\n    elm.setAttribute(\"width\", `${bounds.width}`);\n    elm.setAttribute(\"height\", `${bounds.height}`);\n    elm.setAttribute(\"xmlns:xlink\", `http://www.w3.org/1999/xlink`);\n    return elm;\n  };\n};\nvar Wrapper = re2(\"div\", {\n  pointerEvents: \"all\",\n  position: \"relative\",\n  fontFamily: \"sans-serif\",\n  fontSize: \"2em\",\n  height: \"100%\",\n  width: \"100%\",\n  borderRadius: \"3px\",\n  perspective: \"800px\",\n  overflow: \"hidden\",\n  p: {\n    userSelect: \"none\"\n  },\n  img: {\n    userSelect: \"none\"\n  },\n  variants: {\n    isGhost: {\n      false: { opacity: 1 },\n      true: { transition: \"opacity .2s\", opacity: GHOSTED_OPACITY }\n    },\n    isFilled: {\n      true: {},\n      false: {}\n    }\n  },\n  compoundVariants: [\n    {\n      isFilled: true,\n      css: {\n        boxShadow: \"2px 3px 12px -2px rgba(0,0,0,.3), 1px 1px 4px rgba(0,0,0,.3), 1px 1px 2px rgba(0,0,0,.3)\"\n      }\n    },\n    {\n      isFilled: true,\n      css: {\n        boxShadow: \"2px 3px 12px -2px rgba(0,0,0,.2), 1px 1px 4px rgba(0,0,0,.16),  1px 1px 2px rgba(0,0,0,.16)\"\n      }\n    }\n  ]\n});\nvar ImageElement = re2(\"img\", {\n  position: \"absolute\",\n  top: 0,\n  left: 0,\n  width: \"100%\",\n  height: \"100%\",\n  maxWidth: \"100%\",\n  minWidth: \"100%\",\n  pointerEvents: \"none\",\n  objectFit: \"cover\",\n  userSelect: \"none\",\n  borderRadius: 2\n});\n\n// src/components/Tldraw/state/shapes/RectangleUtil/RectangleUtil.tsx\nvar React39 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/RectangleUtil/components/BindingIndicator.tsx\nvar import_jsx_runtime53 = require(\"react/jsx-runtime\");\nfunction BindingIndicator({ strokeWidth, size }) {\n  return /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(\n    \"rect\",\n    {\n      className: \"tl-binding-indicator\",\n      x: strokeWidth,\n      y: strokeWidth,\n      width: Math.max(0, size[0] - strokeWidth / 2),\n      height: Math.max(0, size[1] - strokeWidth / 2),\n      strokeWidth: BINDING_DISTANCE * 2\n    }\n  );\n}\n\n// src/components/Tldraw/state/shapes/RectangleUtil/components/DashedRectangle.tsx\nvar React37 = __toESM(require(\"react\"));\nvar import_jsx_runtime54 = require(\"react/jsx-runtime\");\nvar DashedRectangle = React37.memo(function DashedRectangle2({ id, style, size, isSelected }) {\n  const { stroke, strokeWidth, fill } = getShapeStyle(style);\n  const sw = 1 + strokeWidth * 1.618;\n  const w7 = Math.max(0, size[0] - sw / 2);\n  const h6 = Math.max(0, size[1] - sw / 2);\n  const strokes2 = [\n    [[sw / 2, sw / 2], [w7, sw / 2], w7 - sw / 2],\n    [[w7, sw / 2], [w7, h6], h6 - sw / 2],\n    [[w7, h6], [sw / 2, h6], w7 - sw / 2],\n    [[sw / 2, h6], [sw / 2, sw / 2], h6 - sw / 2]\n  ];\n  const paths = strokes2.map(([start, end, length], i4) => {\n    const { strokeDasharray, strokeDashoffset } = C3.getPerfectDashProps(length, strokeWidth * 1.618, style.dash);\n    return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(\"line\", { x1: start[0], y1: start[1], x2: end[0], y2: end[1], strokeDasharray, strokeDashoffset }, id + \"_\" + i4);\n  });\n  return /* @__PURE__ */ (0, import_jsx_runtime54.jsxs)(import_jsx_runtime54.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(\n      \"rect\",\n      {\n        className: isSelected || style.isFilled ? \"tl-fill-hitarea\" : \"tl-stroke-hitarea\",\n        x: sw / 2,\n        y: sw / 2,\n        width: w7,\n        height: h6,\n        strokeWidth: BINDING_DISTANCE\n      }\n    ),\n    style.isFilled && /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(\"rect\", { x: sw / 2, y: sw / 2, width: w7, height: h6, fill, pointerEvents: \"none\" }),\n    /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(\"g\", { pointerEvents: \"none\", stroke, strokeWidth: sw, strokeLinecap: \"round\", children: paths })\n  ] });\n});\n\n// src/components/Tldraw/state/shapes/RectangleUtil/components/DrawRectangle.tsx\nvar React38 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/RectangleUtil/rectangleHelpers.ts\nfunction getRectangleDrawPoints(id, style, size) {\n  const styles = getShapeStyle(style);\n  const getRandom = C3.rng(id);\n  const sw = styles.strokeWidth;\n  const w7 = Math.max(0, size[0]);\n  const h6 = Math.max(0, size[1]);\n  const offsets = Array.from({ length: 4 }).map(() => {\n    return [getRandom() * sw * 0.75, getRandom() * sw * 0.75];\n  });\n  const tl = p.add([sw / 2, sw / 2], offsets[0]);\n  const tr = p.add([w7 - sw / 2, sw / 2], offsets[1]);\n  const br = p.add([w7 - sw / 2, h6 - sw / 2], offsets[2]);\n  const bl = p.add([sw / 2, h6 - sw / 2], offsets[3]);\n  const rm = Math.round(Math.abs(getRandom() * 2 * 4));\n  const rx = Math.min(w7 / 4, sw * 2);\n  const ry = Math.min(h6 / 4, sw * 2);\n  const px = Math.max(8, Math.floor(w7 / 16));\n  const py = Math.max(8, Math.floor(h6 / 16));\n  const lines = C3.rotateArray(\n    [\n      p.pointsBetween(p.add(tl, [rx, 0]), p.sub(tr, [rx, 0]), px),\n      p.pointsBetween(p.add(tr, [0, ry]), p.sub(br, [0, ry]), py),\n      p.pointsBetween(p.sub(br, [rx, 0]), p.add(bl, [rx, 0]), px),\n      p.pointsBetween(p.sub(bl, [0, ry]), p.add(tl, [0, ry]), py)\n    ],\n    rm\n  );\n  const points = [...lines.flat(), ...lines[0]].slice(5, Math.floor((rm % 2 === 0 ? px : py) / -2) + 3);\n  return {\n    points\n  };\n}\nfunction getDrawStrokeInfo(id, style, size) {\n  const { points } = getRectangleDrawPoints(id, style, size);\n  const { strokeWidth } = getShapeStyle(style);\n  const options = {\n    size: strokeWidth,\n    thinning: 0.65,\n    streamline: 0.3,\n    smoothing: 1,\n    simulatePressure: false,\n    last: true\n  };\n  return { points, options };\n}\nfunction getRectanglePath(id, style, size) {\n  const { points, options } = getDrawStrokeInfo(id, style, size);\n  const stroke = _e(points, options);\n  return C3.getSvgPathFromStroke(stroke);\n}\nfunction getRectangleIndicatorPathTDSnapshot(id, style, size) {\n  const { points, options } = getDrawStrokeInfo(id, style, size);\n  return C3.getSvgPathFromStrokePoints(me(points, options));\n}\n\n// src/components/Tldraw/state/shapes/RectangleUtil/components/DrawRectangle.tsx\nvar import_jsx_runtime55 = require(\"react/jsx-runtime\");\nvar DrawRectangle = React38.memo(function DrawRectangle2({ id, style, size, isSelected }) {\n  const { isFilled } = style;\n  const { stroke, strokeWidth, fill } = getShapeStyle(style);\n  const pathTDSnapshot = getRectanglePath(id, style, size);\n  const innerPath = getRectangleIndicatorPathTDSnapshot(id, style, size);\n  return /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)(import_jsx_runtime55.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(\"path\", { className: style.isFilled || isSelected ? \"tl-fill-hitarea\" : \"tl-stroke-hitarea\", d: innerPath }),\n    isFilled && /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(\"path\", { d: innerPath, fill, pointerEvents: \"none\" }),\n    /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(\"path\", { d: pathTDSnapshot, fill: stroke, stroke, strokeWidth, pointerEvents: \"none\" })\n  ] });\n});\n\n// src/components/Tldraw/state/shapes/RectangleUtil/RectangleUtil.tsx\nvar import_jsx_runtime56 = require(\"react/jsx-runtime\");\nvar RectangleUtil = class extends TDShapeUtil {\n  type = \"rectangle\" /* Rectangle */;\n  canBind = true;\n  canClone = true;\n  canEdit = true;\n  getShape = (props) => {\n    return C3.deepMerge(\n      {\n        id: \"id\",\n        type: \"rectangle\" /* Rectangle */,\n        name: \"Rectangle\",\n        parentId: \"page\",\n        childIndex: 1,\n        point: [0, 0],\n        size: [1, 1],\n        rotation: 0,\n        style: defaultStyle,\n        label: \"\",\n        labelPoint: [0.5, 0.5]\n      },\n      props\n    );\n  };\n  Component = TDShapeUtil.Component(\n    ({ shape, isEditing, isBinding, isSelected, isGhost, meta, bounds, events, onShapeBlur, onShapeChange }, ref) => {\n      const { id, size, style, label = \"\", labelPoint = LABEL_POINT } = shape;\n      const font = getFontStyle(style);\n      const styles = getShapeStyle(style);\n      const Component = style.dash === \"draw\" /* Draw */ ? DrawRectangle : DashedRectangle;\n      const handleLabelChange = React39.useCallback((label2) => onShapeChange?.({ id, label: label2 }), [onShapeChange]);\n      return /* @__PURE__ */ (0, import_jsx_runtime56.jsxs)(FullWrapper3, { ref, ...events, children: [\n        /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(\n          TextLabel,\n          {\n            isEditing,\n            onChange: handleLabelChange,\n            onBlur: onShapeBlur,\n            font,\n            text: label,\n            color: styles.stroke,\n            offsetX: (labelPoint[0] - 0.5) * bounds.width,\n            offsetY: (labelPoint[1] - 0.5) * bounds.height\n          }\n        ),\n        /* @__PURE__ */ (0, import_jsx_runtime56.jsxs)(te, { id: shape.id + \"_svg\", opacity: isGhost ? GHOSTED_OPACITY : 1, children: [\n          isBinding && /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(BindingIndicator, { strokeWidth: styles.strokeWidth, size }),\n          /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(Component, { id, style, size, isSelected })\n        ] })\n      ] });\n    }\n  );\n  Indicator = TDShapeUtil.Indicator(({ shape }) => {\n    const { id, style, size } = shape;\n    const styles = getShapeStyle(style, false);\n    const sw = styles.strokeWidth;\n    if (style.dash === \"draw\" /* Draw */) {\n      return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(\"path\", { d: getRectangleIndicatorPathTDSnapshot(id, style, size) });\n    }\n    return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(\"rect\", { x: sw, y: sw, rx: 1, ry: 1, width: Math.max(1, size[0] - sw * 2), height: Math.max(1, size[1] - sw * 2) });\n  });\n  getBounds = (shape) => {\n    return getBoundsRectangle(shape, this.boundsCache);\n  };\n  shouldRender = (prev, next) => {\n    return next.size !== prev.size || next.style !== prev.style || next.label !== prev.label;\n  };\n  transform = transformRectangle;\n  transformSingle = transformSingleRectangle;\n};\nvar FullWrapper3 = styled(\"div\", { width: \"100%\", height: \"100%\" });\n\n// src/components/Tldraw/state/shapes/StickyUtil/StickyUtil.tsx\nvar React40 = __toESM(require(\"react\"));\nvar import_tw_react = __toESM(require_tw_react());\nvar import_jsx_runtime57 = require(\"react/jsx-runtime\");\nvar StickyUtil = class extends TDShapeUtil {\n  type = \"sticky\" /* Sticky */;\n  canBind = true;\n  canEdit = true;\n  canClone = true;\n  getShape = (props) => {\n    return C3.deepMerge(\n      {\n        id: \"id\",\n        type: \"sticky\" /* Sticky */,\n        name: \"Sticky\",\n        parentId: \"page\",\n        childIndex: 1,\n        point: [0, 0],\n        size: [300, 300],\n        text: \"\",\n        rotation: 0,\n        style: defaultTextStyle\n      },\n      props\n    );\n  };\n  Component = TDShapeUtil.Component(({ shape, meta, events, isGhost, isBinding, isEditing, onShapeBlur, onShapeChange }, reference) => {\n    const font = getStickyFontStyle(shape.style);\n    const { color, fill } = getStickyShapeStyle(shape.style);\n    const rContainer = React40.useRef(null);\n    const rTextArea = React40.useRef(null);\n    const rRenderedText = React40.useRef(null);\n    const rIsMounted = React40.useRef(false);\n    const handlePointerDown = React40.useCallback((event) => {\n      event.stopPropagation();\n    }, []);\n    const astNode = React40.useMemo(() => {\n      const childTree = $tw.wiki.parseText(\"text/vnd.tiddlywiki\", shape.text).tree;\n      return { type: \"tiddler\", children: childTree };\n    }, [shape.text]);\n    (0, import_tw_react.useWidget)(astNode, rRenderedText, { skip: isEditing });\n    const onChange = React40.useCallback(\n      (text) => {\n        onShapeChange?.({\n          id: shape.id,\n          type: shape.type,\n          text: TLDR.normalizeText(text)\n        });\n      },\n      [onShapeChange, shape.id, shape.type]\n    );\n    const handleTextChange = React40.useCallback(\n      (event) => {\n        onChange(event.currentTarget.value);\n      },\n      [onChange]\n    );\n    const handleKeyDown = React40.useCallback(\n      (event) => {\n        if (event.key === \"Escape\") {\n          event.preventDefault();\n          event.stopPropagation();\n          onShapeBlur?.();\n          return;\n        }\n        if (event.key === \"Tab\" && shape.text.length === 0) {\n          event.preventDefault();\n          return;\n        }\n        if (!(event.key === \"Meta\" || event.metaKey)) {\n          event.stopPropagation();\n        } else if (event.key === \"z\" && event.metaKey) {\n          if (event.shiftKey) {\n            document.execCommand(\"redo\", false);\n          } else {\n            document.execCommand(\"undo\", false);\n          }\n          event.stopPropagation();\n          event.preventDefault();\n          return;\n        }\n        if ((event.metaKey || event.ctrlKey) && event.key === \"=\") {\n          event.preventDefault();\n        }\n        if (event.key === \"Tab\") {\n          event.preventDefault();\n          if (event.shiftKey) {\n            TextAreaUtils.unindent(event.currentTarget);\n          } else {\n            TextAreaUtils.indent(event.currentTarget);\n          }\n          onShapeChange?.({ ...shape, text: TLDR.normalizeText(event.currentTarget.value) });\n        }\n      },\n      [shape, onShapeBlur, onShapeChange]\n    );\n    const handleBlur = React40.useCallback(\n      (event) => {\n        event.currentTarget.setSelectionRange(0, 0);\n        onShapeBlur?.();\n      },\n      [onShapeBlur]\n    );\n    const handleFocus = React40.useCallback(\n      (event) => {\n        if (!isEditing)\n          return;\n        if (!rIsMounted.current)\n          return;\n        event.currentTarget.select();\n      },\n      [isEditing]\n    );\n    React40.useEffect(() => {\n      if (isEditing) {\n        rIsMounted.current = true;\n        const elm = rTextArea.current;\n        elm.focus();\n        elm.select();\n      }\n    }, [isEditing]);\n    const style = {\n      font,\n      color,\n      textShadow: `0.5px 0.5px 2px rgba(255, 255, 255,.5)`\n    };\n    const getClickedTWElement = React40.useCallback((event) => {\n      const buttonOrLinkInWikiText = event.target.querySelectorAll(\"a,button\");\n      const clickedElement = Array.from(buttonOrLinkInWikiText).find((element) => {\n        const rect = element.getBoundingClientRect();\n        return event.clientX > rect.x && event.clientX < rect.x + rect.width && event.clientY > rect.y && event.clientY < rect.y + rect.height;\n      });\n      return clickedElement;\n    }, []);\n    const onPointerUp = React40.useCallback(\n      (event) => {\n        const clickedElement = getClickedTWElement(event);\n        if (clickedElement !== void 0) {\n          event.preventDefault();\n          event.stopPropagation();\n          const newClickEvent = new MouseEvent(\"click\", { ...event.nativeEvent });\n          clickedElement.dispatchEvent(newClickEvent);\n        }\n        events.onPointerUp(event);\n      },\n      [events, getClickedTWElement]\n    );\n    return /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(Xs, { ref: reference, ...events, onPointerUp, children: /* @__PURE__ */ (0, import_jsx_runtime57.jsxs)(StyledStickyContainer, { ref: rContainer, isGhost, style: { backgroundColor: fill, ...style }, children: [\n      isBinding && /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(\n        \"div\",\n        {\n          className: \"tl-binding-indicator\",\n          style: {\n            position: \"absolute\",\n            top: -this.bindingDistance,\n            left: -this.bindingDistance,\n            width: `calc(100% + ${this.bindingDistance * 2}px)`,\n            height: `calc(100% + ${this.bindingDistance * 2}px)`,\n            backgroundColor: \"var(--tl-selectFill)\"\n          }\n        }\n      ),\n      /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(StyledText2, { ref: rRenderedText, isEditing, alignment: shape.style.textAlign }),\n      isEditing && /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(\n        StyledTextArea,\n        {\n          className: STICKY_TEXT_AREA_CLASS_NAME,\n          ref: rTextArea,\n          onPointerDown: handlePointerDown,\n          value: shape.text,\n          onChange: handleTextChange,\n          onKeyDown: handleKeyDown,\n          onFocus: handleFocus,\n          onBlur: handleBlur,\n          tabIndex: -1,\n          autoComplete: \"false\",\n          autoCapitalize: \"false\",\n          autoCorrect: \"false\",\n          autoSave: \"false\",\n          autoFocus: true,\n          spellCheck: true,\n          alignment: shape.style.textAlign,\n          onContextMenu: stopPropagation3,\n          onCopy: stopPropagation3,\n          onPaste: stopPropagation3,\n          onCut: stopPropagation3\n        }\n      )\n    ] }) });\n  });\n  Indicator = TDShapeUtil.Indicator(({ shape }) => {\n    const {\n      size: [width, height]\n    } = shape;\n    return /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(\"rect\", { x: 0, y: 0, rx: 3, ry: 3, width: Math.max(1, width), height: Math.max(1, height) });\n  });\n  getBounds = (shape) => {\n    return getBoundsRectangle(shape, this.boundsCache);\n  };\n  shouldRender = (previous, next) => {\n    return next.size !== previous.size || next.style !== previous.style || next.text !== previous.text;\n  };\n  transform = transformRectangle;\n  transformSingle = transformSingleRectangle;\n  getSvgElement = (shape) => {\n    const bounds = this.getBounds(shape);\n    const style = getStickyShapeStyle(shape.style);\n    const fontSize = getStickyFontSize(shape.style.size) * (shape.style.scale ?? 1);\n    const fontFamily = getFontFace(shape.style.font).slice(1, -1);\n    const textAlign = shape.style.textAlign ?? \"start\" /* Start */;\n    const textElm = getTextSvgElement(shape.text, fontSize, fontFamily, textAlign, bounds.width - PADDING * 2, true);\n    textElm.setAttribute(\"fill\", style.color);\n    textElm.setAttribute(\"transform\", `translate(${PADDING}, ${PADDING})`);\n    const g6 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    const rect = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n    rect.setAttribute(\"width\", String(bounds.width));\n    rect.setAttribute(\"height\", String(bounds.height));\n    rect.setAttribute(\"fill\", style.fill);\n    rect.setAttribute(\"rx\", \"3\");\n    rect.setAttribute(\"ry\", \"3\");\n    g6.appendChild(rect);\n    g6.appendChild(textElm);\n    return g6;\n  };\n};\nvar PADDING = 16;\nvar StyledStickyContainer = styled(\"div\", {\n  pointerEvents: \"all\",\n  position: \"relative\",\n  backgroundColor: \"transparent\",\n  height: \"100%\",\n  width: \"100%\",\n  padding: `${PADDING}px`,\n  borderRadius: \"3px\",\n  perspective: \"800px\",\n  variants: {\n    isGhost: {\n      false: { opacity: 1 },\n      true: { transition: \"opacity .2s\", opacity: GHOSTED_OPACITY }\n    }\n  }\n});\nvar commonTextWrapping = {\n  whiteSpace: \"pre-wrap\",\n  overflowWrap: \"break-word\",\n  letterSpacing: LETTER_SPACING\n};\nvar StyledText2 = styled(\"div\", {\n  position: \"absolute\",\n  top: PADDING,\n  left: PADDING,\n  width: `calc(100% - ${PADDING * 2}px)`,\n  height: \"fit-content\",\n  font: \"inherit\",\n  pointerEvents: \"none\",\n  userSelect: \"none\",\n  variants: {\n    isEditing: {\n      true: {\n        opacity: 0\n      },\n      false: {\n        opacity: 1\n      }\n    },\n    alignment: {\n      [\"start\" /* Start */]: {\n        textAlign: \"left\"\n      },\n      [\"middle\" /* Middle */]: {\n        textAlign: \"center\"\n      },\n      [\"end\" /* End */]: {\n        textAlign: \"right\"\n      },\n      [\"justify\" /* Justify */]: {\n        textAlign: \"justify\"\n      }\n    }\n  },\n  ...commonTextWrapping\n});\nvar StyledTextArea = styled(\"textarea\", {\n  width: \"100%\",\n  height: \"100%\",\n  border: \"none\",\n  overflow: \"hidden\",\n  background: \"none\",\n  outline: \"none\",\n  textAlign: \"left\",\n  font: \"inherit\",\n  padding: 0,\n  color: \"#333\",\n  verticalAlign: \"top\",\n  resize: \"none\",\n  caretColor: \"black\",\n  ...commonTextWrapping,\n  variants: {\n    alignment: {\n      [\"start\" /* Start */]: {\n        textAlign: \"left\"\n      },\n      [\"middle\" /* Middle */]: {\n        textAlign: \"center\"\n      },\n      [\"end\" /* End */]: {\n        textAlign: \"right\"\n      },\n      [\"justify\" /* Justify */]: {\n        textAlign: \"justify\"\n      }\n    }\n  },\n  \"&:focus\": {\n    outline: \"none\",\n    border: \"none\"\n  }\n});\n\n// src/components/Tldraw/state/shapes/TextUtil/TextUtil.tsx\nvar React41 = __toESM(require(\"react\"));\nvar import_jsx_runtime58 = require(\"react/jsx-runtime\");\nvar TextUtil = class extends TDShapeUtil {\n  type = \"text\" /* Text */;\n  isAspectRatioLocked = true;\n  canEdit = true;\n  canBind = true;\n  canClone = true;\n  bindingDistance = BINDING_DISTANCE / 2;\n  getShape = (props) => {\n    return C3.deepMerge(\n      {\n        id: \"id\",\n        type: \"text\" /* Text */,\n        name: \"Text\",\n        parentId: \"page\",\n        childIndex: 1,\n        point: [0, 0],\n        rotation: 0,\n        text: \" \",\n        style: defaultTextStyle\n      },\n      props\n    );\n  };\n  texts = /* @__PURE__ */ new Map();\n  Component = TDShapeUtil.Component(({ shape, isBinding, isGhost, isEditing, onShapeBlur, onShapeChange, meta, events }, ref) => {\n    const { text, style } = shape;\n    const styles = getShapeStyle(style);\n    const font = getFontStyle(shape.style);\n    const rInput = React41.useRef(null);\n    const rIsMounted = React41.useRef(false);\n    const rEditedText = React41.useRef(text);\n    React41.useLayoutEffect(() => {\n      if (text !== rEditedText.current) {\n        let delta = [0, 0];\n        this.texts.set(shape.id, text);\n        const currentBounds = this.getBounds(shape);\n        const nextBounds = this.getBounds(shape);\n        switch (shape.style.textAlign) {\n          case \"start\" /* Start */: {\n            break;\n          }\n          case \"middle\" /* Middle */: {\n            delta = e.div([nextBounds.width - currentBounds.width, 0], 2);\n            break;\n          }\n          case \"end\" /* End */: {\n            delta = [nextBounds.width - currentBounds.width, 0];\n            break;\n          }\n        }\n        rEditedText.current = text;\n        onShapeChange?.({\n          ...shape,\n          id: shape.id,\n          point: e.sub(shape.point, delta),\n          text\n        });\n      }\n    }, [text]);\n    const handleChange = React41.useCallback(\n      (e5) => {\n        let delta = [0, 0];\n        const newText = TLDR.normalizeText(e5.currentTarget.value);\n        const currentBounds = this.getBounds(shape);\n        this.texts.set(shape.id, newText);\n        const nextBounds = this.getBounds({\n          ...shape,\n          text: newText\n        });\n        switch (shape.style.textAlign) {\n          case \"start\" /* Start */: {\n            break;\n          }\n          case \"middle\" /* Middle */: {\n            delta = e.div([nextBounds.width - currentBounds.width, 0], 2);\n            break;\n          }\n          case \"end\" /* End */: {\n            delta = [nextBounds.width - currentBounds.width, 0];\n            break;\n          }\n        }\n        rEditedText.current = newText;\n        onShapeChange?.({\n          ...shape,\n          id: shape.id,\n          point: e.sub(shape.point, delta),\n          text: newText\n        });\n      },\n      [shape.id, shape.point]\n    );\n    const handleKeyDown = React41.useCallback(\n      (e5) => {\n        if (e5.key === \"Escape\") {\n          e5.preventDefault();\n          e5.stopPropagation();\n          onShapeBlur?.();\n          return;\n        }\n        if (e5.key === \"Tab\" && shape.text.length === 0) {\n          e5.preventDefault();\n          return;\n        }\n        if (e5.key === \"Enter\" && (e5.metaKey || e5.ctrlKey)) {\n          e5.preventDefault();\n          e5.stopPropagation();\n          rInput.current.blur();\n          return;\n        }\n        if (!(e5.key === \"Meta\" || e5.metaKey)) {\n          e5.stopPropagation();\n        } else if (e5.key === \"z\" && e5.metaKey) {\n          if (e5.shiftKey) {\n            document.execCommand(\"redo\", false);\n          } else {\n            document.execCommand(\"undo\", false);\n          }\n          e5.stopPropagation();\n          e5.preventDefault();\n          return;\n        }\n        if ((e5.metaKey || e5.ctrlKey) && e5.key === \"=\") {\n          e5.preventDefault();\n        }\n        if (e5.key === \"Tab\") {\n          e5.preventDefault();\n          if (e5.shiftKey) {\n            TextAreaUtils.unindent(e5.currentTarget);\n          } else {\n            TextAreaUtils.indent(e5.currentTarget);\n          }\n          onShapeChange?.({ ...shape, text: TLDR.normalizeText(e5.currentTarget.value) });\n        }\n      },\n      [shape, onShapeChange]\n    );\n    const handleBlur = React41.useCallback((e5) => {\n      e5.currentTarget.setSelectionRange(0, 0);\n      onShapeBlur?.();\n    }, []);\n    const handleFocus = React41.useCallback(\n      (e5) => {\n        if (!isEditing)\n          return;\n        if (!rIsMounted.current)\n          return;\n        if (document.activeElement === e5.currentTarget) {\n          e5.currentTarget.select();\n        }\n      },\n      [isEditing]\n    );\n    const handlePointerDown = React41.useCallback(\n      (e5) => {\n        if (isEditing) {\n          e5.stopPropagation();\n        }\n      },\n      [isEditing]\n    );\n    const rWasEditing = React41.useRef(isEditing);\n    React41.useEffect(() => {\n      if (isEditing) {\n        rWasEditing.current = true;\n        this.texts.set(shape.id, text);\n        requestAnimationFrame(() => {\n          rIsMounted.current = true;\n          const elm = rInput.current;\n          if (elm) {\n            elm.focus();\n            elm.select();\n          }\n        });\n      } else if (rWasEditing.current) {\n        rWasEditing.current = false;\n        onShapeBlur?.();\n      }\n    }, [isEditing]);\n    return /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(Xs, { ref, ...events, children: /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(Wrapper2, { isGhost, isEditing, onPointerDown: handlePointerDown, children: /* @__PURE__ */ (0, import_jsx_runtime58.jsxs)(\n      InnerWrapper,\n      {\n        style: {\n          font,\n          color: styles.stroke,\n          textAlign: getTextAlign(style.textAlign)\n        },\n        children: [\n          isBinding && /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(\n            \"div\",\n            {\n              className: \"tl-binding-indicator\",\n              style: {\n                position: \"absolute\",\n                top: -this.bindingDistance,\n                left: -this.bindingDistance,\n                width: `calc(100% + ${this.bindingDistance * 2}px)`,\n                height: `calc(100% + ${this.bindingDistance * 2}px)`,\n                backgroundColor: \"var(--tl-selectFill)\"\n              }\n            }\n          ),\n          isEditing ? /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(\n            TextArea,\n            {\n              ref: rInput,\n              style: {\n                font,\n                color: styles.stroke\n              },\n              name: \"text\",\n              tabIndex: -1,\n              autoComplete: \"false\",\n              autoCapitalize: \"false\",\n              autoCorrect: \"false\",\n              autoSave: \"false\",\n              autoFocus: true,\n              placeholder: \"\",\n              spellCheck: \"true\",\n              wrap: \"off\",\n              dir: \"auto\",\n              datatype: \"wysiwyg\",\n              defaultValue: text,\n              color: styles.stroke,\n              onFocus: handleFocus,\n              onChange: handleChange,\n              onKeyDown: handleKeyDown,\n              onBlur: handleBlur,\n              onPointerDown: handlePointerDown,\n              onContextMenu: stopPropagation3,\n              onCopy: stopPropagation3,\n              onPaste: stopPropagation3,\n              onCut: stopPropagation3\n            }\n          ) : text,\n          \"\\u200B\"\n        ]\n      }\n    ) }) });\n  });\n  Indicator = TDShapeUtil.Indicator(({ shape }) => {\n    const { width, height } = this.getBounds(shape);\n    return /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(\"rect\", { x: 0, y: 0, width, height });\n  });\n  getBounds = (shape) => {\n    const bounds = C3.getFromCache(this.boundsCache, shape, () => {\n      if (!melm2) {\n        return { minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10 };\n      }\n      if (!melm2.parentNode)\n        document.body.appendChild(melm2);\n      melm2.style.font = getFontStyle(shape.style);\n      melm2.textContent = this.texts.get(shape.id) ?? shape.text;\n      const width = melm2.offsetWidth || 1;\n      const height = melm2.offsetHeight || 1;\n      return {\n        minX: 0,\n        maxX: width,\n        minY: 0,\n        maxY: height,\n        width,\n        height\n      };\n    });\n    return C3.translateBounds(bounds, shape.point);\n  };\n  shouldRender = (prev, next) => {\n    return next.text !== prev.text || next.style.scale !== prev.style.scale || next.style !== prev.style;\n  };\n  transform = (shape, bounds, { initialShape, scaleX, scaleY }) => {\n    const {\n      rotation = 0,\n      style: { scale = 1 }\n    } = initialShape;\n    const nextScale = scale * Math.abs(Math.min(scaleX, scaleY));\n    return {\n      point: [bounds.minX, bounds.minY],\n      rotation: scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? -(rotation || 0) : rotation,\n      style: {\n        ...initialShape.style,\n        scale: nextScale\n      }\n    };\n  };\n  transformSingle = (shape, bounds, { initialShape, scaleX, scaleY }) => {\n    const {\n      style: { scale = 1 }\n    } = initialShape;\n    return {\n      point: e.toFixed([bounds.minX, bounds.minY]),\n      style: {\n        ...initialShape.style,\n        scale: scale * Math.max(Math.abs(scaleY), Math.abs(scaleX))\n      }\n    };\n  };\n  onDoubleClickBoundsHandle = (shape) => {\n    const center = this.getCenter(shape);\n    const newCenter = this.getCenter({\n      ...shape,\n      style: {\n        ...shape.style,\n        scale: 1\n      }\n    });\n    return {\n      style: {\n        ...shape.style,\n        scale: 1\n      },\n      point: e.toFixed(e.add(shape.point, e.sub(center, newCenter)))\n    };\n  };\n  getSvgElement = (shape) => {\n    const bounds = this.getBounds(shape);\n    const style = getShapeStyle(shape.style);\n    const fontSize = getFontSize(shape.style.size, shape.style.font) * (shape.style.scale ?? 1);\n    const fontFamily = getFontFace(shape.style.font).slice(1, -1);\n    const textAlign = shape.style.textAlign ?? \"start\" /* Start */;\n    const textElm = getTextSvgElement(shape.text, fontSize, fontFamily, textAlign, bounds.width, false);\n    textElm.setAttribute(\"fill\", style.stroke);\n    return textElm;\n  };\n};\nvar melm2;\nfunction getMeasurementDiv2() {\n  document.querySelector(\"#__textMeasure\")?.remove();\n  const pre = document.createElement(\"pre\");\n  pre.id = \"__textMeasure\";\n  Object.assign(pre.style, {\n    whiteSpace: \"pre\",\n    width: \"auto\",\n    border: \"1px solid transparent\",\n    padding: \"4px\",\n    margin: \"0px\",\n    letterSpacing: LETTER_SPACING,\n    opacity: \"0\",\n    position: \"absolute\",\n    top: \"-500px\",\n    left: \"0px\",\n    zIndex: \"9999\",\n    pointerEvents: \"none\",\n    userSelect: \"none\",\n    alignmentBaseline: \"mathematical\",\n    dominantBaseline: \"mathematical\"\n  });\n  pre.tabIndex = -1;\n  document.body.appendChild(pre);\n  return pre;\n}\nif (typeof window !== \"undefined\") {\n  melm2 = getMeasurementDiv2();\n}\nvar Wrapper2 = styled(\"div\", {\n  width: \"100%\",\n  height: \"100%\",\n  variants: {\n    isGhost: {\n      false: { opacity: 1 },\n      true: { transition: \"opacity .2s\", opacity: GHOSTED_OPACITY }\n    },\n    isEditing: {\n      false: {\n        pointerEvents: \"all\",\n        userSelect: \"all\"\n      },\n      true: {\n        pointerEvents: \"none\",\n        userSelect: \"none\"\n      }\n    }\n  }\n});\nvar commonTextWrapping2 = {\n  whiteSpace: \"pre-wrap\",\n  overflowWrap: \"break-word\"\n};\nvar InnerWrapper = styled(\"div\", {\n  position: \"absolute\",\n  width: \"100%\",\n  height: \"100%\",\n  padding: \"4px\",\n  zIndex: 1,\n  minHeight: 1,\n  minWidth: 1,\n  lineHeight: 1,\n  letterSpacing: LETTER_SPACING,\n  outline: 0,\n  fontWeight: \"500\",\n  backfaceVisibility: \"hidden\",\n  userSelect: \"none\",\n  pointerEvents: \"none\",\n  WebkitUserSelect: \"none\",\n  WebkitTouchCallout: \"none\",\n  isEditing: {\n    false: {},\n    true: {\n      pointerEvents: \"all\",\n      background: \"$boundsBg\",\n      userSelect: \"text\",\n      WebkitUserSelect: \"text\"\n    }\n  },\n  ...commonTextWrapping2\n});\nvar TextArea = styled(\"textarea\", {\n  position: \"absolute\",\n  top: 0,\n  left: 0,\n  zIndex: 1,\n  width: \"100%\",\n  height: \"100%\",\n  border: \"none\",\n  padding: \"4px\",\n  resize: \"none\",\n  textAlign: \"inherit\",\n  minHeight: \"inherit\",\n  minWidth: \"inherit\",\n  lineHeight: \"inherit\",\n  letterSpacing: \"inherit\",\n  outline: 0,\n  fontWeight: \"inherit\",\n  overflow: \"hidden\",\n  backfaceVisibility: \"hidden\",\n  display: \"inline-block\",\n  pointerEvents: \"all\",\n  background: \"$boundsBg\",\n  userSelect: \"text\",\n  WebkitUserSelect: \"text\",\n  ...commonTextWrapping2,\n  \"&:focus\": {\n    outline: \"none\",\n    border: \"none\"\n  }\n});\n\n// src/components/Tldraw/state/shapes/TriangleUtil/TriangleUtil.tsx\nvar React44 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/TriangleUtil/components/DashedTriangle.tsx\nvar React42 = __toESM(require(\"react\"));\n\n// src/components/Tldraw/state/shapes/TriangleUtil/triangleHelpers.ts\nfunction getTrianglePoints(size, offset = 0, rotation = 0) {\n  const [w7, h6] = size;\n  let points = [\n    [w7 / 2, 0],\n    [w7, h6],\n    [0, h6]\n  ];\n  if (offset)\n    points = getOffsetPolygon(points, offset);\n  if (rotation)\n    points = points.map((pt2) => p.rotWith(pt2, [w7 / 2, h6 / 2], rotation));\n  return points;\n}\nfunction getTriangleCentroid(size) {\n  const [w7, h6] = size;\n  const points = [\n    [w7 / 2, 0],\n    [w7, h6],\n    [0, h6]\n  ];\n  return [(points[0][0] + points[1][0] + points[2][0]) / 3, (points[0][1] + points[1][1] + points[2][1]) / 3];\n}\nfunction getTriangleDrawPoints(id, size, strokeWidth) {\n  const [w7, h6] = size;\n  const getRandom = C3.rng(id);\n  const offsets = Array.from({ length: 3 }).map(() => {\n    return [getRandom() * strokeWidth * 0.75, getRandom() * strokeWidth * 0.75];\n  });\n  const corners = [p.add([w7 / 2, 0], offsets[0]), p.add([w7, h6], offsets[1]), p.add([0, h6], offsets[2])];\n  const rm = Math.round(Math.abs(getRandom() * 2 * 3));\n  const lines = C3.rotateArray(\n    [p.pointsBetween(corners[0], corners[1], 32), p.pointsBetween(corners[1], corners[2], 32), p.pointsBetween(corners[2], corners[0], 32)],\n    rm\n  );\n  const points = [...lines.flat(), ...lines[0]];\n  return {\n    points\n  };\n}\nfunction getDrawStrokeInfo2(id, size, style) {\n  const { strokeWidth } = getShapeStyle(style);\n  const { points } = getTriangleDrawPoints(id, size, strokeWidth);\n  const options = {\n    size: strokeWidth,\n    thinning: 0.65,\n    streamline: 0.3,\n    smoothing: 1,\n    simulatePressure: false,\n    last: true\n  };\n  return { points, options };\n}\nfunction getTrianglePath(id, size, style) {\n  const { points, options } = getDrawStrokeInfo2(id, size, style);\n  const stroke = _e(points, options);\n  return C3.getSvgPathFromStroke(stroke);\n}\nfunction getTriangleIndicatorPathTDSnapshot(id, size, style) {\n  const { points, options } = getDrawStrokeInfo2(id, size, style);\n  return C3.getSvgPathFromStrokePoints(me(points, options));\n}\n\n// src/components/Tldraw/state/shapes/TriangleUtil/components/DashedTriangle.tsx\nvar import_jsx_runtime59 = require(\"react/jsx-runtime\");\nvar DashedTriangle = React42.memo(function DashedTriangle2({ id, size, style, isSelected }) {\n  const { stroke, strokeWidth, fill } = getShapeStyle(style);\n  const sw = 1 + strokeWidth * 1.618;\n  const points = getTrianglePoints(size);\n  const sides = C3.pointsToLineSegments(points, true);\n  const paths = sides.map(([start, end], i4) => {\n    const { strokeDasharray, strokeDashoffset } = C3.getPerfectDashProps(p.dist(start, end), strokeWidth * 1.618, style.dash);\n    return /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(\n      \"line\",\n      {\n        x1: start[0],\n        y1: start[1],\n        x2: end[0],\n        y2: end[1],\n        stroke,\n        strokeWidth: sw,\n        strokeLinecap: \"round\",\n        strokeDasharray,\n        strokeDashoffset\n      },\n      id + \"_\" + i4\n    );\n  });\n  const bgPath = points.join(\",\");\n  return /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)(import_jsx_runtime59.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(\"polygon\", { className: style.isFilled || isSelected ? \"tl-fill-hitarea\" : \"tl-stroke-hitarea\", points: bgPath }),\n    style.isFilled && /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(\"polygon\", { fill, points: bgPath, pointerEvents: \"none\" }),\n    /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(\"g\", { pointerEvents: \"stroke\", children: paths })\n  ] });\n});\n\n// src/components/Tldraw/state/shapes/TriangleUtil/components/DrawTriangle.tsx\nvar React43 = __toESM(require(\"react\"));\nvar import_jsx_runtime60 = require(\"react/jsx-runtime\");\nvar DrawTriangle = React43.memo(function DrawTriangle2({ id, size, style, isSelected }) {\n  const { stroke, strokeWidth, fill } = getShapeStyle(style);\n  const pathTDSnapshot = getTrianglePath(id, size, style);\n  const indicatorPath = getTriangleIndicatorPathTDSnapshot(id, size, style);\n  return /* @__PURE__ */ (0, import_jsx_runtime60.jsxs)(import_jsx_runtime60.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(\"path\", { className: style.isFilled || isSelected ? \"tl-fill-hitarea\" : \"tl-stroke-hitarea\", d: indicatorPath }),\n    style.isFilled && /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(\"path\", { d: indicatorPath, fill, pointerEvents: \"none\" }),\n    /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(\"path\", { d: pathTDSnapshot, fill: stroke, stroke, strokeWidth, pointerEvents: \"none\" })\n  ] });\n});\n\n// src/components/Tldraw/state/shapes/TriangleUtil/components/TriangleBindingIndicator.tsx\nvar import_jsx_runtime61 = require(\"react/jsx-runtime\");\nfunction TriangleBindingIndicator({ size }) {\n  const trianglePoints = getTrianglePoints(size).join(\",\");\n  return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(\"polygon\", { className: \"tl-binding-indicator\", points: trianglePoints, strokeWidth: BINDING_DISTANCE * 2 });\n}\n\n// src/components/Tldraw/state/shapes/TriangleUtil/TriangleUtil.tsx\nvar import_jsx_runtime62 = require(\"react/jsx-runtime\");\nvar TriangleUtil = class extends TDShapeUtil {\n  type = \"triangle\" /* Triangle */;\n  canBind = true;\n  canClone = true;\n  canEdit = true;\n  getShape = (props) => {\n    return C3.deepMerge(\n      {\n        id: \"id\",\n        type: \"triangle\" /* Triangle */,\n        name: \"Triangle\",\n        parentId: \"page\",\n        childIndex: 1,\n        point: [0, 0],\n        size: [1, 1],\n        rotation: 0,\n        style: defaultStyle,\n        label: \"\",\n        labelPoint: [0.5, 0.5]\n      },\n      props\n    );\n  };\n  Component = TDShapeUtil.Component(\n    ({ shape, bounds, isBinding, isEditing, isSelected, isGhost, meta, events, onShapeChange, onShapeBlur }, ref) => {\n      const { id, label = \"\", size, style, labelPoint = LABEL_POINT } = shape;\n      const font = getFontStyle(style);\n      const styles = getShapeStyle(style);\n      const Component = style.dash === \"draw\" /* Draw */ ? DrawTriangle : DashedTriangle;\n      const handleLabelChange = React44.useCallback((label2) => onShapeChange?.({ id, label: label2 }), [onShapeChange]);\n      const offsetY = React44.useMemo(() => {\n        const center = p.div(size, 2);\n        const centroid = getTriangleCentroid(size);\n        return (centroid[1] - center[1]) * 0.72;\n      }, [size]);\n      return /* @__PURE__ */ (0, import_jsx_runtime62.jsxs)(FullWrapper4, { ref, ...events, children: [\n        /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(\n          TextLabel,\n          {\n            font,\n            text: label,\n            color: styles.stroke,\n            offsetX: (labelPoint[0] - 0.5) * bounds.width,\n            offsetY: offsetY + (labelPoint[1] - 0.5) * bounds.height,\n            isEditing,\n            onChange: handleLabelChange,\n            onBlur: onShapeBlur\n          }\n        ),\n        /* @__PURE__ */ (0, import_jsx_runtime62.jsxs)(te, { id: shape.id + \"_svg\", opacity: isGhost ? GHOSTED_OPACITY : 1, children: [\n          isBinding && /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(TriangleBindingIndicator, { size }),\n          /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Component, { id, style, size, isSelected })\n        ] })\n      ] });\n    }\n  );\n  Indicator = TDShapeUtil.Indicator(({ shape }) => {\n    const { size } = shape;\n    return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(\"polygon\", { points: getTrianglePoints(size).join(\",\") });\n  });\n  getPoints(shape) {\n    const {\n      rotation = 0,\n      point: [x5, y6],\n      size: [w7, h6]\n    } = shape;\n    return [\n      [x5 + w7 / 2, y6],\n      [x5, y6 + h6],\n      [x5 + w7, y6 + h6]\n    ].map((pt2) => p.rotWith(pt2, this.getCenter(shape), rotation));\n  }\n  shouldRender = (prev, next) => {\n    return next.size !== prev.size || next.style !== prev.style || next.label !== prev.label;\n  };\n  getBounds = (shape) => {\n    return getBoundsRectangle(shape, this.boundsCache);\n  };\n  getExpandedBounds = (shape) => {\n    return C3.getBoundsFromPoints(getTrianglePoints(shape.size, this.bindingDistance).map((pt2) => p.add(pt2, shape.point)));\n  };\n  hitTestLineSegment = (shape, A6, B5) => {\n    return S(A6, B5, this.getPoints(shape)).didIntersect;\n  };\n  hitTestBounds = (shape, bounds) => {\n    return C3.boundsContained(this.getBounds(shape), bounds) || Se(bounds, this.getPoints(shape)).length > 0;\n  };\n  getBindingPoint = (shape, fromShape, point, origin, direction, bindAnywhere) => {\n    const expandedBounds = this.getExpandedBounds(shape);\n    if (!C3.pointInBounds(point, expandedBounds))\n      return;\n    const points = getTrianglePoints(shape.size).map((pt2) => p.add(pt2, shape.point));\n    const expandedPoints = getTrianglePoints(shape.size, this.bindingDistance).map((pt2) => p.add(pt2, shape.point));\n    const closestDistanceToEdge = C3.pointsToLineSegments(points, true).map(([a7, b6]) => p.distanceToLineSegment(a7, b6, point)).sort((a7, b6) => a7 - b6)[0];\n    if (!(C3.pointInPolygon(point, expandedPoints) || closestDistanceToEdge < this.bindingDistance))\n      return;\n    const intersections = C3.pointsToLineSegments([...expandedPoints, expandedPoints[0]]).map((segment) => x(origin, direction, segment[0], segment[1])).filter((intersection2) => intersection2.didIntersect).flatMap((intersection2) => intersection2.points);\n    if (intersections.length === 0)\n      return;\n    const center = p.add(getTriangleCentroid(shape.size), shape.point);\n    const intersection = intersections.sort((a7, b6) => p.dist(b6, origin) - p.dist(a7, origin))[0];\n    const middlePoint = p.med(point, intersection);\n    let anchor;\n    let distance;\n    if (bindAnywhere) {\n      anchor = p.dist(point, center) < BINDING_DISTANCE / 2 ? center : point;\n      distance = 0;\n    } else {\n      if (p.distanceToLineSegment(point, middlePoint, center) < BINDING_DISTANCE / 2) {\n        anchor = center;\n      } else {\n        anchor = middlePoint;\n      }\n      if (C3.pointInPolygon(point, points)) {\n        distance = this.bindingDistance;\n      } else {\n        distance = Math.max(this.bindingDistance, closestDistanceToEdge);\n      }\n    }\n    const bindingPoint = p.divV(p.sub(anchor, [expandedBounds.minX, expandedBounds.minY]), [expandedBounds.width, expandedBounds.height]);\n    return {\n      point: p.clampV(bindingPoint, 0, 1),\n      distance\n    };\n  };\n  transform = transformRectangle;\n  transformSingle = transformSingleRectangle;\n};\nvar FullWrapper4 = styled(\"div\", { width: \"100%\", height: \"100%\" });\n\n// src/components/Tldraw/state/shapes/index.ts\nvar Rectangle = new RectangleUtil();\nvar Triangle = new TriangleUtil();\nvar Ellipse = new EllipseUtil();\nvar Draw = new DrawUtil();\nvar Arrow = new ArrowUtil();\nvar Text = new TextUtil();\nvar Group = new GroupUtil();\nvar Sticky = new StickyUtil();\nvar Image2 = new ImageUtil();\nvar shapeUtils = {\n  [\"rectangle\" /* Rectangle */]: Rectangle,\n  [\"triangle\" /* Triangle */]: Triangle,\n  [\"ellipse\" /* Ellipse */]: Ellipse,\n  [\"draw\" /* Draw */]: Draw,\n  [\"arrow\" /* Arrow */]: Arrow,\n  [\"text\" /* Text */]: Text,\n  [\"group\" /* Group */]: Group,\n  [\"sticky\" /* Sticky */]: Sticky,\n  [\"image\" /* Image */]: Image2\n};\nvar getShapeUtil = (shape) => {\n  if (typeof shape === \"string\")\n    return shapeUtils[shape];\n  return shapeUtils[shape.type];\n};\n\n// src/components/Tldraw/state/TLDR.ts\nvar isDevelopment = true;\nvar _TLDR = class {\n  static getShapeUtil(shape) {\n    if (shape === void 0) {\n      debugger;\n      throw new Error(`shape is undefined in getShapeUtil`);\n    }\n    return getShapeUtil(shape);\n  }\n  static getSelectedShapes(data, pageId) {\n    const page = _TLDR.getPage(data, pageId);\n    const selectedIds = _TLDR.getSelectedIds(data, pageId);\n    return selectedIds.map((id) => page.shapes[id]);\n  }\n  static screenToWorld(data, point) {\n    const camera = _TLDR.getPageState(data, data.appState.currentPageId).camera;\n    return e.sub(e.div(point, camera.zoom), camera.point);\n  }\n  static getCameraZoom(zoom) {\n    return C3.clamp(zoom, 0.1, 5);\n  }\n  static getPage(data, pageId) {\n    return data.document.pages[pageId];\n  }\n  static getPageState(data, pageId) {\n    return data.document.pageStates[pageId];\n  }\n  static getSelectedIds(data, pageId) {\n    return _TLDR.getPageState(data, pageId).selectedIds;\n  }\n  static getShapes(data, pageId) {\n    return Object.values(_TLDR.getPage(data, pageId).shapes);\n  }\n  static getCamera(data, pageId) {\n    return _TLDR.getPageState(data, pageId).camera;\n  }\n  static getShape(data, shapeId, pageId) {\n    return _TLDR.getPage(data, pageId).shapes[shapeId];\n  }\n  static getCenter(shape) {\n    return _TLDR.getShapeUtil(shape).getCenter(shape);\n  }\n  static getBounds(shape) {\n    return _TLDR.getShapeUtil(shape).getBounds(shape);\n  }\n  static getRotatedBounds(shape) {\n    return _TLDR.getShapeUtil(shape).getRotatedBounds(shape);\n  }\n  static getSelectedBounds(data) {\n    return C3.getCommonBounds(_TLDR.getSelectedShapes(data, data.appState.currentPageId).map((shape) => _TLDR.getShapeUtil(shape).getBounds(shape)));\n  }\n  static getParentId(data, id, pageId) {\n    return _TLDR.getShape(data, id, pageId).parentId;\n  }\n  // static getPointedId(data: TDSnapshot, id: string, pageId: string): string {\n  //   const page = TLDR.getPage(data, pageId)\n  //   const pageState = TLDR.getPageState(data, data.appState.currentPageId)\n  //   const shape = TLDR.getShape(data, id, pageId)\n  //   if (!shape) return id\n  //   return shape.parentId === pageState.currentParentId || shape.parentId === page.id\n  //     ? id\n  //     : TLDR.getPointedId(data, shape.parentId, pageId)\n  // }\n  // static getDrilledPointedId(data: TDSnapshot, id: string, pageId: string): string {\n  //   const shape = TLDR.getShape(data, id, pageId)\n  //   const { currentPageId } = data.appState\n  //   const { currentParentId, pointedId } = TLDR.getPageState(data, data.appState.currentPageId)\n  //   return shape.parentId === currentPageId ||\n  //     shape.parentId === pointedId ||\n  //     shape.parentId === currentParentId\n  //     ? id\n  //     : TLDR.getDrilledPointedId(data, shape.parentId, pageId)\n  // }\n  // static getTopParentId(data: TDSnapshot, id: string, pageId: string): string {\n  //   const page = TLDR.getPage(data, pageId)\n  //   const pageState = TLDR.getPageState(data, pageId)\n  //   const shape = TLDR.getShape(data, id, pageId)\n  //   if (shape.parentId === shape.id) {\n  //     throw Error(`Shape has the same id as its parent! ${shape.id}`)\n  //   }\n  //   return shape.parentId === page.id || shape.parentId === pageState.currentParentId\n  //     ? id\n  //     : TLDR.getTopParentId(data, shape.parentId, pageId)\n  // }\n  // Get an array of a shape id and its descendant shapes' ids\n  static getDocumentBranch(data, id, pageId) {\n    const shape = _TLDR.getShape(data, id, pageId);\n    if (shape.children === void 0)\n      return [id];\n    return [id, ...shape.children.flatMap((childId) => _TLDR.getDocumentBranch(data, childId, pageId))];\n  }\n  static getSelectedBranchSnapshot(data, pageId, function_) {\n    const page = _TLDR.getPage(data, pageId);\n    const copies = _TLDR.getSelectedIds(data, pageId).flatMap((id) => _TLDR.getDocumentBranch(data, id, pageId).map((id2) => page.shapes[id2])).filter((shape) => !shape.isLocked).map(C3.deepClone);\n    if (function_ !== void 0) {\n      return copies.map((shape) => ({ id: shape.id, ...function_(shape) }));\n    }\n    return copies;\n  }\n  static getSelectedShapeSnapshot(data, pageId, function_) {\n    const copies = _TLDR.getSelectedShapes(data, pageId).filter((shape) => !shape.isLocked).map(C3.deepClone);\n    if (function_ !== void 0) {\n      return copies.map((shape) => ({ id: shape.id, ...function_(shape) }));\n    }\n    return copies;\n  }\n  // For a given array of shape ids, an array of all other shapes that may be affected by a mutation to it.\n  // Use this to decide which shapes to clone as before / after for a command.\n  static getAllEffectedShapeIds(data, ids, pageId) {\n    const page = _TLDR.getPage(data, pageId);\n    const visited = new Set(ids);\n    ids.forEach((id) => {\n      const shape = page.shapes[id];\n      function collectDescendants(shape2) {\n        if (shape2.children === void 0)\n          return;\n        shape2.children.filter((childId) => !visited.has(childId)).forEach((childId) => {\n          visited.add(childId);\n          collectDescendants(page.shapes[childId]);\n        });\n      }\n      collectDescendants(shape);\n      function collectAscendants(shape2) {\n        const parentId = shape2.parentId;\n        if (parentId === page.id)\n          return;\n        if (visited.has(parentId))\n          return;\n        visited.add(parentId);\n        collectAscendants(page.shapes[parentId]);\n      }\n      collectAscendants(shape);\n      visited.forEach((id2) => {\n        Object.values(page.bindings).filter((binding) => binding.fromId === id2 || binding.toId === id2).forEach((binding) => visited.add(binding.fromId === id2 ? binding.toId : binding.fromId));\n      });\n    });\n    return [...visited.values()];\n  }\n  static getLinkedShapeIds(data, pageId, direction, includeArrows = true) {\n    const selectedIds = _TLDR.getSelectedIds(data, pageId);\n    const page = _TLDR.getPage(data, pageId);\n    const linkedIds = new Set(selectedIds);\n    const checkedIds = /* @__PURE__ */ new Set();\n    const idsToCheck = [...selectedIds];\n    const arrows = new Set(\n      Object.values(page.shapes).filter((shape) => {\n        return shape.type === \"arrow\" /* Arrow */ && (shape.handles.start.bindingId || shape.handles?.end.bindingId);\n      })\n    );\n    while (idsToCheck.length > 0) {\n      const id = idsToCheck.pop();\n      if (!(id && arrows.size > 0))\n        break;\n      if (checkedIds.has(id))\n        continue;\n      checkedIds.add(id);\n      arrows.forEach((arrow2) => {\n        const {\n          handles: {\n            start: { bindingId: startBindingId },\n            end: { bindingId: endBindingId }\n          }\n        } = arrow2;\n        const startBinding = startBindingId ? page.bindings[startBindingId] : null;\n        const endBinding = endBindingId ? page.bindings[endBindingId] : null;\n        let hit = false;\n        if (startBinding != void 0 && startBinding.toId === id) {\n          if (direction === \"center\") {\n            hit = true;\n          } else if (arrow2.decorations?.start && endBinding != void 0) {\n            hit = direction === \"left\";\n          } else {\n            hit = direction === \"right\";\n          }\n          if (hit) {\n            if (includeArrows)\n              linkedIds.add(arrow2.id);\n            linkedIds.add(id);\n            if (endBinding != void 0) {\n              linkedIds.add(endBinding.toId);\n              idsToCheck.push(endBinding.toId);\n            }\n          }\n        } else if (endBinding != void 0 && endBinding.toId === id) {\n          if (direction === \"center\") {\n            hit = true;\n          } else if (arrow2.decorations?.end && startBinding != void 0) {\n            hit = direction === \"left\";\n          } else {\n            hit = direction === \"right\";\n          }\n          if (hit) {\n            if (includeArrows)\n              linkedIds.add(arrow2.id);\n            linkedIds.add(id);\n            if (startBinding != void 0) {\n              linkedIds.add(startBinding.toId);\n              idsToCheck.push(startBinding.toId);\n            }\n          }\n        }\n        if ((startBinding == void 0 || linkedIds.has(startBinding.toId)) && (endBinding == void 0 || linkedIds.has(endBinding.toId))) {\n          arrows.delete(arrow2);\n        }\n      });\n    }\n    return [...linkedIds.values()];\n  }\n  static getChildIndexAbove(data, id, pageId) {\n    const page = data.document.pages[pageId];\n    const shape = page.shapes[id];\n    let siblings;\n    if (shape.parentId === page.id) {\n      siblings = Object.values(page.shapes).filter((shape2) => shape2.parentId === page.id).sort((a7, b6) => a7.childIndex - b6.childIndex);\n    } else {\n      const parent = page.shapes[shape.parentId];\n      if (parent.children == void 0)\n        throw new Error(\"No children in parent!\");\n      siblings = parent.children.map((childId) => page.shapes[childId]).sort((a7, b6) => a7.childIndex - b6.childIndex);\n    }\n    const index2 = siblings.indexOf(shape);\n    const nextSibling = siblings[index2 + 1];\n    if (!nextSibling)\n      return shape.childIndex + 1;\n    return nextSibling.childIndex;\n  }\n  /* -------------------------------------------------- */\n  /*                      Mutations                     */\n  /* -------------------------------------------------- */\n  static getBeforeShape(shape, change) {\n    return Object.fromEntries(Object.keys(change).map((k7) => [k7, shape[k7]]));\n  }\n  static mutateShapes(data, ids, function_, pageId, forceChildrenTraversal = false) {\n    const beforeShapes = {};\n    const afterShapes = {};\n    ids.forEach((id, index2) => {\n      const shape = _TLDR.getShape(data, id, pageId);\n      if (shape.isLocked)\n        return;\n      if (shape?.type === \"group\" && (ids.length === 1 || forceChildrenTraversal)) {\n        shape.children.forEach((id2, index_) => {\n          const shape2 = _TLDR.getShape(data, id2, pageId);\n          if (shape2.isLocked)\n            return;\n          const change2 = function_(shape2, index_);\n          if (change2 != void 0) {\n            beforeShapes[id2] = _TLDR.getBeforeShape(shape2, change2);\n            afterShapes[id2] = change2;\n          }\n        });\n      }\n      const change = function_(shape, index2);\n      if (change != void 0) {\n        beforeShapes[id] = _TLDR.getBeforeShape(shape, change);\n        afterShapes[id] = change;\n      }\n    });\n    const dataWithMutations = C3.deepMerge(data, {\n      document: {\n        pages: {\n          [data.appState.currentPageId]: {\n            shapes: afterShapes\n          }\n        }\n      }\n    });\n    return {\n      before: beforeShapes,\n      after: afterShapes,\n      data: dataWithMutations\n    };\n  }\n  static createShapes(data, shapes, pageId) {\n    const before = {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: {\n              ...Object.fromEntries(\n                shapes.flatMap((shape) => {\n                  const results = [[shape.id, void 0]];\n                  if (shape.parentId !== pageId) {\n                    const parent = _TLDR.getShape(data, shape.parentId, pageId);\n                    if (parent.children == void 0)\n                      throw new Error(\"No children in parent!\");\n                    results.push([parent.id, { children: parent.children }]);\n                  }\n                  return results;\n                })\n              )\n            }\n          }\n        }\n      }\n    };\n    const after = {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: {\n              shapes: {\n                ...Object.fromEntries(\n                  shapes.flatMap((shape) => {\n                    const results = [[shape.id, shape]];\n                    if (shape.parentId !== pageId) {\n                      const parent = _TLDR.getShape(data, shape.parentId, pageId);\n                      if (parent.children == void 0)\n                        throw new Error(\"No children in parent!\");\n                      results.push([parent.id, { children: [...parent.children, shape.id] }]);\n                    }\n                    return results;\n                  })\n                )\n              }\n            }\n          }\n        }\n      }\n    };\n    return {\n      before,\n      after\n    };\n  }\n  static deleteShapes(data, shapes, pageId) {\n    pageId = pageId || data.appState.currentPageId;\n    const page = _TLDR.getPage(data, pageId);\n    const shapeIds = typeof shapes[0] === \"string\" ? shapes : shapes.map((shape) => shape.id);\n    const before = {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: {\n              // These are the shapes that we're going to delete\n              ...Object.fromEntries(\n                shapeIds.flatMap((id) => {\n                  const shape = page.shapes[id];\n                  const results = [[shape.id, shape]];\n                  if (shape.parentId !== pageId) {\n                    const parent = page.shapes[shape.parentId];\n                    if (parent.children == void 0)\n                      throw new Error(\"No children in parent!\");\n                    results.push([parent.id, { children: parent.children }]);\n                  }\n                  return results;\n                })\n              )\n            },\n            bindings: {\n              // These are the bindings that we're going to delete\n              ...Object.fromEntries(\n                Object.values(page.bindings).filter((binding) => {\n                  return shapeIds.includes(binding.fromId) || shapeIds.includes(binding.toId);\n                }).map((binding) => {\n                  return [binding.id, binding];\n                })\n              )\n            }\n          }\n        }\n      }\n    };\n    const after = {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: {\n              ...Object.fromEntries(\n                shapeIds.flatMap((id) => {\n                  const shape = page.shapes[id];\n                  const results = [[shape.id, void 0]];\n                  if (shape.parentId !== page.id) {\n                    const parent = page.shapes[shape.parentId];\n                    if (parent.children == void 0)\n                      throw new Error(\"No children in parent!\");\n                    results.push([parent.id, { children: parent.children.filter((id2) => id2 !== shape.id) }]);\n                  }\n                  return results;\n                })\n              )\n            }\n          }\n        }\n      }\n    };\n    return {\n      before,\n      after\n    };\n  }\n  static onSessionComplete(shape) {\n    const delta = _TLDR.getShapeUtil(shape).onSessionComplete?.(shape);\n    if (delta == void 0)\n      return shape;\n    return { ...shape, ...delta };\n  }\n  static onChildrenChange(data, shape, pageId) {\n    if (shape.children == void 0)\n      return;\n    const delta = _TLDR.getShapeUtil(shape).onChildrenChange?.(\n      shape,\n      shape.children.map((id) => _TLDR.getShape(data, id, pageId))\n    );\n    if (delta == void 0)\n      return shape;\n    return { ...shape, ...delta };\n  }\n  static updateArrowBindings(page, arrowShape) {\n    const result = {\n      start: deepCopy(arrowShape.handles.start),\n      end: deepCopy(arrowShape.handles.end)\n    };\n    let start = {\n      isBound: false,\n      handle: arrowShape.handles.start,\n      point: e.add(arrowShape.handles.start.point, arrowShape.point)\n    };\n    let end = {\n      isBound: false,\n      handle: arrowShape.handles.end,\n      point: e.add(arrowShape.handles.end.point, arrowShape.point)\n    };\n    if (arrowShape.handles.start.bindingId) {\n      const hasDecoration = arrowShape.decorations?.start !== void 0;\n      const handle = arrowShape.handles.start;\n      const binding = page.bindings[arrowShape.handles.start.bindingId];\n      if (!binding)\n        throw new Error(\"Could not find a binding to match the start handle's bindingId: \" + arrowShape.handles.start.bindingId);\n      const target = page.shapes[binding.toId];\n      const util = _TLDR.getShapeUtil(target);\n      const bounds = util.getBounds(target);\n      const expandedBounds = util.getExpandedBounds(target);\n      const intersectBounds = hasDecoration ? C3.expandBounds(bounds, binding.distance) : bounds;\n      const { minX, minY, width, height } = expandedBounds;\n      const anchorPoint = e.add([minX, minY], e.mulV([width, height], e.rotWith(binding.point, [0.5, 0.5], target.rotation || 0)));\n      start = {\n        isBound: true,\n        hasDecoration,\n        binding,\n        handle,\n        point: anchorPoint,\n        util,\n        target,\n        bounds,\n        expandedBounds,\n        intersectBounds,\n        center: util.getCenter(target)\n      };\n    }\n    if (arrowShape.handles.end.bindingId) {\n      const hasDecoration = arrowShape.decorations?.end !== void 0;\n      const handle = arrowShape.handles.end;\n      const binding = page.bindings[arrowShape.handles.end.bindingId];\n      if (!binding)\n        throw new Error(\"Could not find a binding to match the end handle's bindingId\");\n      const target = page.shapes[binding.toId];\n      const util = _TLDR.getShapeUtil(target);\n      const bounds = util.getBounds(target);\n      const expandedBounds = util.getExpandedBounds(target);\n      const intersectBounds = hasDecoration ? C3.expandBounds(bounds, binding.distance) : bounds;\n      const { minX, minY, width, height } = expandedBounds;\n      const anchorPoint = e.add([minX, minY], e.mulV([width, height], e.rotWith(binding.point, [0.5, 0.5], target.rotation || 0)));\n      end = {\n        isBound: true,\n        hasDecoration,\n        binding,\n        handle,\n        point: anchorPoint,\n        util,\n        target,\n        bounds,\n        expandedBounds,\n        intersectBounds,\n        center: util.getCenter(target)\n      };\n    }\n    for (const ID of [\"end\", \"start\"]) {\n      const A6 = ID === \"start\" ? start : end;\n      const B5 = ID === \"start\" ? end : start;\n      if (A6.isBound) {\n        if (A6.binding.distance) {\n          const direction = e.uni(e.sub(A6.point, B5.point));\n          switch (A6.target.type) {\n            case \"ellipse\" /* Ellipse */: {\n              const hits = F(\n                B5.point,\n                direction,\n                A6.center,\n                A6.target.radius[0] + (A6.hasDecoration ? A6.binding.distance : 0),\n                A6.target.radius[1] + (A6.hasDecoration ? A6.binding.distance : 0),\n                A6.target.rotation || 0\n              ).points.sort((a7, b6) => e.dist(a7, B5.point) - e.dist(b6, B5.point));\n              if (hits[0] !== void 0) {\n                result[ID].point = e.toFixed(e.sub(hits[0], arrowShape.point));\n              }\n              break;\n            }\n            case \"triangle\" /* Triangle */: {\n              const targetPoint = A6.target.point;\n              const points = getTrianglePoints(A6.target.size, A6.hasDecoration ? BINDING_DISTANCE : 0, A6.target.rotation).map((pt2) => e.add(pt2, targetPoint));\n              const hits = C3.pointsToLineSegments(points, true).map(([p0, p1]) => x(B5.point, direction, p0, p1)).filter((intersection) => intersection.didIntersect).flatMap((intersection) => intersection.points).sort((a7, b6) => e.dist(a7, B5.point) - e.dist(b6, B5.point));\n              if (hits[0] !== void 0) {\n                result[ID].point = e.toFixed(e.sub(hits[0], arrowShape.point));\n              }\n              break;\n            }\n            default: {\n              const hits = se2(B5.point, direction, A6.intersectBounds, A6.target.rotation).filter((int) => int.didIntersect).map((int) => int.points[0]).sort((a7, b6) => e.dist(a7, B5.point) - e.dist(b6, B5.point));\n              if (!hits[0])\n                continue;\n              let bHit;\n              if (B5.isBound) {\n                const bHits = se2(B5.point, direction, B5.intersectBounds, B5.target.rotation).filter((int) => int.didIntersect).map((int) => int.points[0]).sort((a7, b6) => e.dist(a7, B5.point) - e.dist(b6, B5.point));\n                bHit = bHits[0];\n              }\n              if (B5.isBound && (hits.length < 2 || bHit != void 0 && hits[0] && Math.ceil(e.dist(hits[0], bHit)) < BINDING_DISTANCE * 2.5 || C3.boundsContain(A6.expandedBounds, B5.expandedBounds) || C3.boundsCollide(A6.expandedBounds, B5.expandedBounds))) {\n                const shortArrowDirection = e.uni(e.sub(B5.point, A6.point));\n                const shortArrowHits = se2(A6.point, shortArrowDirection, A6.bounds, A6.target.rotation).filter((int) => int.didIntersect).map((int) => int.points[0]);\n                if (!shortArrowHits[0])\n                  continue;\n                result[ID].point = e.toFixed(e.sub(shortArrowHits[0], arrowShape.point));\n                result[ID === \"start\" ? \"end\" : \"start\"].point = e.toFixed(\n                  e.add(\n                    e.sub(shortArrowHits[0], arrowShape.point),\n                    e.mul(\n                      shortArrowDirection,\n                      Math.min(e.dist(shortArrowHits[0], B5.point), BINDING_DISTANCE * 2.5 * (C3.boundsContain(B5.bounds, A6.intersectBounds) ? -1 : 1))\n                    )\n                  )\n                );\n              } else if (!B5.isBound && (hits[0] && e.dist(hits[0], B5.point) < BINDING_DISTANCE * 2.5 || C3.pointInBounds(B5.point, A6.intersectBounds))) {\n                const shortArrowDirection = e.uni(e.sub(A6.center, B5.point));\n                return _TLDR.getShapeUtil(arrowShape).onHandleChange?.(arrowShape, {\n                  [ID]: {\n                    ...arrowShape.handles[ID],\n                    point: e.toFixed(e.add(e.sub(B5.point, arrowShape.point), e.mul(shortArrowDirection, BINDING_DISTANCE * 2.5)))\n                  }\n                });\n              } else if (hits[0]) {\n                result[ID].point = e.toFixed(e.sub(hits[0], arrowShape.point));\n              }\n            }\n          }\n        } else {\n          result[ID].point = e.sub(A6.point, arrowShape.point);\n        }\n      }\n    }\n    return _TLDR.getShapeUtil(arrowShape).onHandleChange?.(arrowShape, result);\n  }\n  static transform(shape, bounds, info) {\n    const delta = _TLDR.getShapeUtil(shape).transform(shape, bounds, info);\n    if (!delta)\n      return shape;\n    return { ...shape, ...delta };\n  }\n  static transformSingle(shape, bounds, info) {\n    const delta = _TLDR.getShapeUtil(shape).transformSingle(shape, bounds, info);\n    if (delta == void 0)\n      return shape;\n    return { ...shape, ...delta };\n  }\n  /**\n   * Rotate a shape around an origin point.\n   * @param shape a shape.\n   * @param center the shape's center in page space.\n   * @param origin the page point to rotate around.\n   * @param rotation the amount to rotate the shape.\n   */\n  static getRotatedShapeMutation(shape, center, origin, delta) {\n    const relativeCenter = e.sub(center, shape.point);\n    const rotatedCenter = e.rotWith(center, origin, delta);\n    const nextPoint = e.toFixed(e.sub(rotatedCenter, relativeCenter));\n    if (shape.handles !== void 0) {\n      const change = this.getShapeUtil(shape).onHandleChange?.(\n        // Base the change on a shape with the next point\n        { ...shape, point: nextPoint },\n        Object.fromEntries(\n          Object.entries(shape.handles).map(([handleId, handle]) => {\n            const point = e.toFixed(e.rotWith(handle.point, relativeCenter, delta));\n            return [handleId, { ...handle, point }];\n          })\n        )\n      );\n      return change;\n    }\n    const nextRotation = C3.clampRadians((shape.rotation || 0) + delta);\n    return {\n      point: nextPoint,\n      rotation: nextRotation\n    };\n  }\n  /* -------------------------------------------------- */\n  /*                       Parents                      */\n  /* -------------------------------------------------- */\n  static updateParents(data, pageId, changedShapeIds) {\n    const page = _TLDR.getPage(data, pageId);\n    if (changedShapeIds.length === 0)\n      return;\n    const { shapes } = _TLDR.getPage(data, pageId);\n    const parentToUpdateIds = [...new Set(changedShapeIds.map((id) => shapes[id].parentId).values())].filter((id) => id !== page.id);\n    for (const parentId of parentToUpdateIds) {\n      const parent = shapes[parentId];\n      if (parent.children == void 0) {\n        throw new Error(\"A shape is parented to a shape without a children array.\");\n      }\n      _TLDR.onChildrenChange(data, parent, pageId);\n    }\n    _TLDR.updateParents(data, pageId, parentToUpdateIds);\n  }\n  /* -------------------------------------------------- */\n  /*                      Bindings                      */\n  /* -------------------------------------------------- */\n  static getBinding(data, id, pageId) {\n    return _TLDR.getPage(data, pageId).bindings[id];\n  }\n  static getBindings(data, pageId) {\n    const page = _TLDR.getPage(data, pageId);\n    return Object.values(page.bindings);\n  }\n  static getBindableShapeIds(data) {\n    return _TLDR.getShapes(data, data.appState.currentPageId).filter((shape) => _TLDR.getShapeUtil(shape).canBind).sort((a7, b6) => b6.childIndex - a7.childIndex).map((shape) => shape.id);\n  }\n  static getBindingsWithShapeIds(data, ids, pageId) {\n    return [\n      ...new Set(\n        _TLDR.getBindings(data, pageId).filter((binding) => {\n          return ids.includes(binding.toId) || ids.includes(binding.fromId);\n        })\n      ).values()\n    ];\n  }\n  static getRelatedBindings(data, ids, pageId) {\n    const changedShapeIds = new Set(ids);\n    const page = _TLDR.getPage(data, pageId);\n    const bindingsArray = Object.values(page.bindings);\n    const bindingsToUpdate = new Set(bindingsArray.filter((binding) => changedShapeIds.has(binding.toId) || changedShapeIds.has(binding.fromId)));\n    let previousSize = bindingsToUpdate.size;\n    let delta = -1;\n    while (delta !== 0) {\n      bindingsToUpdate.forEach((binding) => {\n        const fromId = binding.fromId;\n        for (const otherBinding of bindingsArray) {\n          if (otherBinding.fromId === fromId) {\n            bindingsToUpdate.add(otherBinding);\n          }\n          if (otherBinding.toId === fromId) {\n            bindingsToUpdate.add(otherBinding);\n          }\n        }\n      });\n      delta = bindingsToUpdate.size - previousSize;\n      previousSize = bindingsToUpdate.size;\n    }\n    return [...bindingsToUpdate.values()];\n  }\n  static normalizeText(text) {\n    return text.replace(_TLDR.fixNewLines, \"\\n\").split(\"\\n\").map((x5) => x5 || \" \").join(\"\\n\");\n  }\n  /* -------------------------------------------------- */\n  /*                     Assertions                     */\n  /* -------------------------------------------------- */\n  static assertShapeHasProperty(shape, property) {\n    if (shape[property] === void 0) {\n      throw new Error();\n    }\n  }\n  static warn(e5) {\n    if (isDevelopment) {\n      console.warn(e5);\n    }\n  }\n  static error(e5) {\n    if (isDevelopment) {\n      console.error(e5);\n    }\n  }\n  /* -------------------------------------------------- */\n  /*                       Export                       */\n  /* -------------------------------------------------- */\n  static getSvgString(svg, scale = 1) {\n    const clone = svg.cloneNode(true);\n    svg.setAttribute(\"width\", +svg.getAttribute(\"width\") * scale + \"\");\n    svg.setAttribute(\"height\", +svg.getAttribute(\"height\") * scale + \"\");\n    return new XMLSerializer().serializeToString(clone).replaceAll(\"&#10;      \", \"\").replaceAll(/((\\s|\")\\d*\\.\\d{2})(\\d*)(\\b|\"|\\))/g, \"$1\");\n  }\n  static getSvgAsDataUrl(svg, scale = 1) {\n    const svgString = _TLDR.getSvgString(svg, scale);\n    const base64SVG = window.btoa(unescape(svgString));\n    return `data:image/svg+xml;base64,${base64SVG}`;\n  }\n  static async getImageForSvg(svg, type = \"png\" /* PNG */, options = {}) {\n    const { scale = 2, quality = 1 } = options;\n    const svgString = _TLDR.getSvgString(svg, scale);\n    const width = +svg.getAttribute(\"width\");\n    const height = +svg.getAttribute(\"height\");\n    if (!svgString)\n      return;\n    const canvas = await new Promise((resolve) => {\n      const image = new Image();\n      image.crossOrigin = \"anonymous\";\n      const base64SVG = window.btoa(unescape(encodeURIComponent(svgString)));\n      const dataUrl = `data:image/svg+xml;base64,${base64SVG}`;\n      image.onload = () => {\n        const canvas2 = document.createElement(\"canvas\");\n        const context = canvas2.getContext(\"2d\");\n        canvas2.width = width;\n        canvas2.height = height;\n        context.drawImage(image, 0, 0, width, height);\n        URL.revokeObjectURL(dataUrl);\n        resolve(canvas2);\n      };\n      image.onerror = () => {\n        console.warn(\"Could not convert that SVG to an image.\");\n      };\n      image.src = dataUrl;\n    });\n    const blob = await new Promise((resolve) => canvas.toBlob((blob2) => resolve(blob2), \"image/\" + type, quality));\n    return blob;\n  }\n};\nvar TLDR = _TLDR;\n__publicField(TLDR, \"copyStringToClipboard\", (string) => {\n  try {\n    if (navigator.clipboard) {\n      navigator.clipboard.write([\n        new ClipboardItem({\n          \"text/plain\": new Blob([string], { type: \"text/plain\" })\n        })\n      ]);\n    }\n  } catch {\n    const textarea = document.createElement(\"textarea\");\n    textarea.setAttribute(\"position\", \"fixed\");\n    textarea.setAttribute(\"top\", \"0\");\n    textarea.setAttribute(\"readonly\", \"true\");\n    textarea.setAttribute(\"contenteditable\", \"true\");\n    textarea.style.position = \"fixed\";\n    textarea.value = string;\n    document.body.appendChild(textarea);\n    textarea.focus();\n    textarea.select();\n    try {\n      const range = document.createRange();\n      range.selectNodeContents(textarea);\n      const sel = window.getSelection();\n      if (sel != void 0) {\n        sel.removeAllRanges();\n        sel.addRange(range);\n        textarea.setSelectionRange(0, textarea.value.length);\n      }\n      document.execCommand(\"copy\");\n    } catch {\n      null;\n    } finally {\n      textarea.remove();\n    }\n  }\n});\n/* -------------------------------------------------- */\n/*                       Groups                       */\n/* -------------------------------------------------- */\n__publicField(TLDR, \"flattenShape\", (data, shape) => {\n  return [\n    shape,\n    ...(shape.children ?? []).map((childId) => _TLDR.getShape(data, childId, data.appState.currentPageId)).sort((a7, b6) => a7.childIndex - b6.childIndex).flatMap((shape2) => _TLDR.flattenShape(data, shape2))\n  ];\n});\n__publicField(TLDR, \"flattenPage\", (data, pageId) => {\n  return Object.values(data.document.pages[pageId].shapes).sort((a7, b6) => a7.childIndex - b6.childIndex).reduce((accumulator, shape) => [...accumulator, ..._TLDR.flattenShape(data, shape)], []);\n});\n__publicField(TLDR, \"getTopChildIndex\", (data, pageId) => {\n  const shapes = _TLDR.getShapes(data, pageId);\n  return shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === pageId).sort((a7, b6) => b6.childIndex - a7.childIndex)[0].childIndex + 1;\n});\n/* -------------------------------------------------- */\n/*                        Text                        */\n/* -------------------------------------------------- */\n__publicField(TLDR, \"fixNewLines\", /\\r?\\n|\\r/g);\n\n// src/components/Tldraw/state/shapes/shared/TextLabel.tsx\nvar import_jsx_runtime63 = require(\"react/jsx-runtime\");\nvar TextLabel = React45.memo(function TextLabel2({\n  font,\n  text,\n  color,\n  offsetX = 0,\n  offsetY = 0,\n  scale = 1,\n  isEditing = false,\n  onBlur,\n  onChange\n}) {\n  const rInput = React45.useRef(null);\n  const rIsMounted = React45.useRef(false);\n  const handleChange = React45.useCallback(\n    (e5) => {\n      onChange(TLDR.normalizeText(e5.currentTarget.value));\n    },\n    [onChange]\n  );\n  const handleKeyDown = React45.useCallback(\n    (e5) => {\n      if (e5.key === \"Escape\") {\n        e5.preventDefault();\n        e5.stopPropagation();\n        onBlur?.();\n        return;\n      }\n      if (e5.key === \"Tab\" && text.length === 0) {\n        e5.preventDefault();\n        return;\n      }\n      if (!(e5.key === \"Meta\" || e5.metaKey)) {\n        e5.stopPropagation();\n      } else if (e5.key === \"z\" && e5.metaKey) {\n        if (e5.shiftKey) {\n          document.execCommand(\"redo\", false);\n        } else {\n          document.execCommand(\"undo\", false);\n        }\n        e5.stopPropagation();\n        e5.preventDefault();\n        return;\n      }\n      if ((e5.metaKey || e5.ctrlKey) && e5.key === \"=\") {\n        e5.preventDefault();\n      }\n      if (e5.key === \"Tab\") {\n        e5.preventDefault();\n        if (e5.shiftKey) {\n          TextAreaUtils.unindent(e5.currentTarget);\n        } else {\n          TextAreaUtils.indent(e5.currentTarget);\n        }\n        onChange?.(TLDR.normalizeText(e5.currentTarget.value));\n      }\n    },\n    [onChange]\n  );\n  const handleBlur = React45.useCallback(\n    (e5) => {\n      e5.currentTarget.setSelectionRange(0, 0);\n      onBlur?.();\n    },\n    [onBlur]\n  );\n  const handleFocus = React45.useCallback(\n    (e5) => {\n      if (!isEditing)\n        return;\n      if (!rIsMounted.current)\n        return;\n      if (document.activeElement === e5.currentTarget) {\n        e5.currentTarget.select();\n      }\n    },\n    [isEditing]\n  );\n  const handlePointerDown = React45.useCallback(\n    (e5) => {\n      if (isEditing) {\n        e5.stopPropagation();\n      }\n    },\n    [isEditing]\n  );\n  const rWasEditing = React45.useRef(isEditing);\n  React45.useEffect(() => {\n    if (isEditing) {\n      rWasEditing.current = true;\n      requestAnimationFrame(() => {\n        rIsMounted.current = true;\n        const elm = rInput.current;\n        if (elm) {\n          elm.focus();\n          elm.select();\n        }\n      });\n    } else if (rWasEditing.current) {\n      onBlur?.();\n      rWasEditing.current = false;\n    }\n  }, [isEditing, onBlur]);\n  const rInnerWrapper = React45.useRef(null);\n  React45.useLayoutEffect(() => {\n    const elm = rInnerWrapper.current;\n    if (!elm)\n      return;\n    const size = getTextLabelSize(text, font);\n    elm.style.transform = `scale(${scale}, ${scale}) translate(${offsetX}px, ${offsetY}px)`;\n    elm.style.width = size[0] + 1 + \"px\";\n    elm.style.height = size[1] + 1 + \"px\";\n  }, [text, font, offsetY, offsetX, scale]);\n  return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(TextWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)(\n    InnerWrapper2,\n    {\n      ref: rInnerWrapper,\n      hasText: !!text,\n      isEditing,\n      style: {\n        font,\n        color\n      },\n      children: [\n        isEditing ? /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(\n          TextArea2,\n          {\n            ref: rInput,\n            style: {\n              font,\n              color\n            },\n            name: \"text\",\n            tabIndex: -1,\n            autoComplete: \"false\",\n            autoCapitalize: \"false\",\n            autoCorrect: \"false\",\n            autoSave: \"false\",\n            autoFocus: true,\n            placeholder: \"\",\n            spellCheck: \"true\",\n            wrap: \"off\",\n            dir: \"auto\",\n            datatype: \"wysiwyg\",\n            defaultValue: text,\n            color,\n            onFocus: handleFocus,\n            onChange: handleChange,\n            onKeyDown: handleKeyDown,\n            onBlur: handleBlur,\n            onPointerDown: handlePointerDown,\n            onContextMenu: stopPropagation3,\n            onCopy: stopPropagation3,\n            onPaste: stopPropagation3,\n            onCut: stopPropagation3\n          }\n        ) : text,\n        \"\\u200B\"\n      ]\n    }\n  ) });\n});\nvar TextWrapper = styled(\"div\", {\n  position: \"absolute\",\n  top: 0,\n  left: 0,\n  width: \"100%\",\n  height: \"100%\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  pointerEvents: \"none\",\n  userSelect: \"none\",\n  variants: {\n    isGhost: {\n      false: { opacity: 1 },\n      true: { transition: \"opacity .2s\", opacity: GHOSTED_OPACITY }\n    }\n  }\n});\nvar commonTextWrapping3 = {\n  whiteSpace: \"pre-wrap\",\n  overflowWrap: \"break-word\",\n  letterSpacing: LETTER_SPACING\n};\nvar InnerWrapper2 = styled(\"div\", {\n  position: \"absolute\",\n  padding: \"4px\",\n  zIndex: 1,\n  minHeight: 1,\n  minWidth: 1,\n  lineHeight: 1,\n  outline: 0,\n  fontWeight: \"500\",\n  textAlign: \"center\",\n  backfaceVisibility: \"hidden\",\n  userSelect: \"none\",\n  WebkitUserSelect: \"none\",\n  WebkitTouchCallout: \"none\",\n  variants: {\n    hasText: {\n      false: {\n        pointerEvents: \"none\"\n      },\n      true: {\n        pointerEvents: \"all\"\n      }\n    },\n    isEditing: {\n      false: {\n        userSelect: \"none\"\n      },\n      true: {\n        background: \"$boundsBg\",\n        userSelect: \"text\",\n        WebkitUserSelect: \"text\"\n      }\n    }\n  },\n  ...commonTextWrapping3\n});\nvar TextArea2 = styled(\"textarea\", {\n  position: \"absolute\",\n  top: 0,\n  left: 0,\n  zIndex: 1,\n  width: \"100%\",\n  height: \"100%\",\n  border: \"none\",\n  padding: \"4px\",\n  resize: \"none\",\n  textAlign: \"inherit\",\n  minHeight: \"inherit\",\n  minWidth: \"inherit\",\n  lineHeight: \"inherit\",\n  outline: 0,\n  fontWeight: \"inherit\",\n  overflow: \"hidden\",\n  backfaceVisibility: \"hidden\",\n  display: \"inline-block\",\n  pointerEvents: \"all\",\n  background: \"$boundsBg\",\n  userSelect: \"text\",\n  WebkitUserSelect: \"text\",\n  fontSmooth: \"always\",\n  WebkitFontSmoothing: \"subpixel-antialiased\",\n  MozOsxFontSmoothing: \"auto\",\n  ...commonTextWrapping3,\n  \"&:focus\": {\n    outline: \"none\",\n    border: \"none\"\n  }\n});\n\n// src/components/Tldraw/state/shapes/shared/transformRectangle.ts\nfunction transformRectangle(shape, bounds, { initialShape, transformOrigin, scaleX, scaleY }) {\n  if (shape.rotation || initialShape.isAspectRatioLocked) {\n    const size = p.toFixed(p.mul(initialShape.size, Math.min(Math.abs(scaleX), Math.abs(scaleY))));\n    const point = p.toFixed([\n      bounds.minX + (bounds.width - shape.size[0]) * (scaleX < 0 ? 1 - transformOrigin[0] : transformOrigin[0]),\n      bounds.minY + (bounds.height - shape.size[1]) * (scaleY < 0 ? 1 - transformOrigin[1] : transformOrigin[1])\n    ]);\n    const rotation = scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? initialShape.rotation ? -initialShape.rotation : 0 : initialShape.rotation;\n    return {\n      size,\n      point,\n      rotation\n    };\n  } else {\n    return {\n      point: p.toFixed([bounds.minX, bounds.minY]),\n      size: p.toFixed([bounds.width, bounds.height])\n    };\n  }\n}\n\n// src/components/Tldraw/state/shapes/shared/transformSingleRectangle.ts\nfunction transformSingleRectangle(shape, bounds) {\n  return {\n    size: p.toFixed([bounds.width, bounds.height]),\n    point: p.toFixed([bounds.minX, bounds.minY])\n  };\n}\n\n// src/components/Tldraw/components/TopPanel/StyleMenu/StyleMenu.tsx\nvar import_jsx_runtime64 = require(\"react/jsx-runtime\");\nvar currentStyleSelector = (s5) => s5.appState.currentStyle;\nvar selectedIdsSelector = (s5) => s5.document.pageStates[s5.appState.currentPageId].selectedIds;\nvar STYLE_KEYS = Object.keys(defaultTextStyle);\nvar DASH_ICONS = {\n  [\"draw\" /* Draw */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(DashDrawIcon, {}),\n  [\"solid\" /* Solid */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(DashSolidIcon, {}),\n  [\"dashed\" /* Dashed */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(DashDashedIcon, {}),\n  [\"dotted\" /* Dotted */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(DashDottedIcon, {})\n};\nvar SIZE_ICONS = {\n  [\"small\" /* Small */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(SizeSmallIcon, {}),\n  [\"medium\" /* Medium */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(SizeMediumIcon, {}),\n  [\"large\" /* Large */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(SizeLargeIcon, {})\n};\nvar ALIGN_ICONS = {\n  [\"start\" /* Start */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(TextAlignLeftIcon, {}),\n  [\"middle\" /* Middle */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(TextAlignCenterIcon, {}),\n  [\"end\" /* End */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(TextAlignRightIcon, {}),\n  [\"justify\" /* Justify */]: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(TextAlignJustifyIcon, {})\n};\nvar themeSelector = (s5) => \"light\";\nvar keepOpenSelector = (s5) => s5.settings.keepStyleMenuOpen;\nvar optionsSelector = (s5) => {\n  const { activeTool, currentPageId: pageId } = s5.appState;\n  switch (activeTool) {\n    case \"select\": {\n      const page = s5.document.pages[pageId];\n      let hasText = false;\n      let hasLabel = false;\n      for (const id of s5.document.pageStates[pageId].selectedIds) {\n        if (\"text\" in page.shapes[id])\n          hasText = true;\n        if (\"label\" in page.shapes[id])\n          hasLabel = true;\n      }\n      return hasText ? \"text\" : hasLabel ? \"label\" : \"\";\n    }\n    case \"text\" /* Text */: {\n      return \"text\";\n    }\n    case \"rectangle\" /* Rectangle */: {\n      return \"label\";\n    }\n    case \"ellipse\" /* Ellipse */: {\n      return \"label\";\n    }\n    case \"triangle\" /* Triangle */: {\n      return \"label\";\n    }\n    case \"arrow\" /* Arrow */: {\n      return \"label\";\n    }\n    case \"line\" /* Line */: {\n      return \"label\";\n    }\n  }\n  return false;\n};\nvar StyleMenu = React46.memo(function ColorMenu() {\n  const app = useTldrawApp();\n  const theme = app.useStore(themeSelector);\n  const keepOpen = app.useStore(keepOpenSelector);\n  const options = app.useStore(optionsSelector);\n  const currentStyle = app.useStore(currentStyleSelector);\n  const selectedIds = app.useStore(selectedIdsSelector);\n  const [displayedStyle, setDisplayedStyle] = React46.useState(currentStyle);\n  const rDisplayedStyle = React46.useRef(currentStyle);\n  React46.useEffect(() => {\n    const {\n      appState: { currentStyle: currentStyle2 },\n      page,\n      selectedIds: selectedIds2\n    } = app;\n    let commonStyle = {};\n    if (selectedIds2.length <= 0) {\n      commonStyle = currentStyle2;\n    } else {\n      const overrides = /* @__PURE__ */ new Set([]);\n      app.selectedIds.map((id) => page.shapes[id]).forEach((shape) => {\n        STYLE_KEYS.forEach((key) => {\n          if (overrides.has(key))\n            return;\n          if (commonStyle[key] === void 0) {\n            commonStyle[key] = shape.style[key];\n          } else {\n            if (commonStyle[key] === shape.style[key])\n              return;\n            commonStyle[key] = shape.style[key];\n            overrides.add(key);\n          }\n        });\n      });\n    }\n    if (JSON.stringify(commonStyle) !== JSON.stringify(rDisplayedStyle.current)) {\n      rDisplayedStyle.current = commonStyle;\n      setDisplayedStyle(commonStyle);\n    }\n  }, [currentStyle, selectedIds]);\n  const handleToggleKeepOpen = React46.useCallback((checked) => {\n    app.setSetting(\"keepStyleMenuOpen\", checked);\n  }, []);\n  const handleToggleFilled = React46.useCallback((checked) => {\n    app.style({ isFilled: checked });\n  }, []);\n  const handleDashChange = React46.useCallback((value) => {\n    app.style({ dash: value });\n  }, []);\n  const handleSizeChange = React46.useCallback((value) => {\n    app.style({ size: value });\n  }, []);\n  const handleFontChange = React46.useCallback((value) => {\n    app.style({ font: value });\n  }, []);\n  const handleTextAlignChange = React46.useCallback((value) => {\n    app.style({ textAlign: value });\n  }, []);\n  const handleMenuOpenChange = React46.useCallback(\n    (open) => {\n      app.setMenuOpen(open);\n    },\n    [app]\n  );\n  return /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: \"ltr\", onOpenChange: handleMenuOpenChange, open: keepOpen ? true : void 0, modal: false, children: [\n    /* @__PURE__ */ (0, import_jsx_runtime64.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { asChild: true, id: \"TD-Styles\", children: /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(ToolButton, { variant: \"text\", children: [\n      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: \"styles\" }),\n      /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(\n        OverlapIcons,\n        {\n          style: {\n            color: strokes[theme][displayedStyle.color]\n          },\n          children: [\n            displayedStyle.isFilled && /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(CircleIcon2, { size: 16, stroke: \"none\", fill: fills[theme][displayedStyle.color] }),\n            DASH_ICONS[displayedStyle.dash]\n          ]\n        }\n      )\n    ] }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(DMContent, { id: \"language-menu\", side: \"bottom\", align: \"end\", sideOffset: 4, alignOffset: 4, children: [\n      /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(StyledRow, { variant: \"tall\", id: \"TD-Styles-Color-Container\", children: [\n        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(\"span\", { children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: \"style.menu.color\" }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(ColorGrid, { children: Object.keys(strokes.light).map((style) => /* @__PURE__ */ (0, import_jsx_runtime64.jsx)($d08ef79370b62062$export$6d08773d2e66f8f2, { onSelect: preventEvent, asChild: true, id: `TD-Styles-Color-Swatch-${style}`, children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(ToolButton, { variant: \"icon\", isActive: displayedStyle.color === style, onClick: () => app.style({ color: style }), children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(\n          CircleIcon2,\n          {\n            size: 18,\n            strokeWidth: 2.5,\n            fill: displayedStyle.isFilled ? fills[theme][style] : \"transparent\",\n            stroke: strokes.light[style]\n          }\n        ) }) }, style)) })\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(DMCheckboxItem, { variant: \"styleMenu\", checked: !!displayedStyle.isFilled, onCheckedChange: handleToggleFilled, id: \"TD-Styles-Fill\", children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: \"style.menu.fill\" }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(StyledRow, { id: \"TD-Styles-Dash-Container\", children: [\n        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: \"style.menu.dash\" }),\n        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(StyledGroup, { dir: \"ltr\", value: displayedStyle.dash, onValueChange: handleDashChange, children: Object.values(DashStyle).map((style) => /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(\n          DMRadioItem,\n          {\n            isActive: style === displayedStyle.dash,\n            value: style,\n            onSelect: preventEvent,\n            bp: breakpoints,\n            id: `TD-Styles-Dash-${style}`,\n            children: DASH_ICONS[style]\n          },\n          style\n        )) })\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(StyledRow, { id: \"TD-Styles-Size-Container\", children: [\n        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: \"style.menu.size\" }),\n        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(StyledGroup, { dir: \"ltr\", value: displayedStyle.size, onValueChange: handleSizeChange, children: Object.values(SizeStyle).map((sizeStyle) => /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(\n          DMRadioItem,\n          {\n            isActive: sizeStyle === displayedStyle.size,\n            value: sizeStyle,\n            onSelect: preventEvent,\n            bp: breakpoints,\n            id: `TD-Styles-Dash-${sizeStyle}`,\n            children: SIZE_ICONS[sizeStyle]\n          },\n          sizeStyle\n        )) })\n      ] }),\n      (options === \"text\" || options === \"label\") && /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(import_jsx_runtime64.Fragment, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(Divider, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(StyledRow, { id: \"TD-Styles-Font-Container\", children: [\n          /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: \"style.menu.font\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(StyledGroup, { dir: \"ltr\", value: displayedStyle.font, onValueChange: handleFontChange, children: Object.values(FontStyle).map((fontStyle) => /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(\n            DMRadioItem,\n            {\n              isActive: fontStyle === displayedStyle.font,\n              value: fontStyle,\n              onSelect: preventEvent,\n              bp: breakpoints,\n              id: `TD-Styles-Font-${fontStyle}`,\n              children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FontIcon, { fontStyle, children: \"Aa\" })\n            },\n            fontStyle\n          )) })\n        ] }),\n        options === \"text\" && /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(StyledRow, { id: \"TD-Styles-Align-Container\", children: [\n          /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: \"style.menu.align\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(StyledGroup, { dir: \"ltr\", value: displayedStyle.textAlign, onValueChange: handleTextAlignChange, children: Object.values(AlignStyle).map((style) => /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(\n            DMRadioItem,\n            {\n              isActive: style === displayedStyle.textAlign,\n              value: style,\n              onSelect: preventEvent,\n              bp: breakpoints,\n              id: `TD-Styles-Align-${style}`,\n              children: ALIGN_ICONS[style]\n            },\n            style\n          )) })\n        ] })\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(Divider, {}),\n      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(DMCheckboxItem, { variant: \"styleMenu\", checked: keepOpen, onCheckedChange: handleToggleKeepOpen, id: \"TD-Styles-Keep-Open\", children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(FormattedMessage, { id: \"style.menu.keep.open\" }) })\n    ] })\n  ] });\n});\nvar ColorGrid = styled(\"div\", {\n  display: \"grid\",\n  gridTemplateColumns: \"repeat(4, auto)\",\n  gap: 0\n});\nvar StyledRow = styled(\"div\", {\n  position: \"relative\",\n  width: \"100%\",\n  background: \"none\",\n  border: \"none\",\n  cursor: \"pointer\",\n  minHeight: \"32px\",\n  outline: \"none\",\n  color: \"$text\",\n  fontFamily: \"$ui\",\n  fontWeight: 400,\n  fontSize: \"$1\",\n  padding: \"$2 0 $2 $3\",\n  borderRadius: 4,\n  userSelect: \"none\",\n  margin: 0,\n  display: \"flex\",\n  gap: \"$3\",\n  flexDirection: \"row\",\n  alignItems: \"center\",\n  justifyContent: \"space-between\",\n  variants: {\n    variant: {\n      tall: {\n        alignItems: \"flex-start\",\n        padding: \"0 0 0 $3\",\n        \"& > span\": {\n          paddingTop: \"$4\"\n        }\n      }\n    }\n  }\n});\nvar StyledGroup = styled($d08ef79370b62062$export$3323ad73d55f587e, {\n  display: \"flex\",\n  flexDirection: \"row\",\n  gap: \"$1\"\n});\nvar OverlapIcons = styled(\"div\", {\n  display: \"grid\",\n  \"& > *\": {\n    gridColumn: 1,\n    gridRow: 1\n  }\n});\nvar FontIcon = styled(\"div\", {\n  width: 32,\n  height: 32,\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  fontSize: \"$3\",\n  variants: {\n    fontStyle: {\n      [\"script\" /* Script */]: {\n        fontFamily: \"Caveat Brush\"\n      },\n      [\"sans\" /* Sans */]: {\n        fontFamily: \"Recursive\"\n      },\n      [\"serif\" /* Serif */]: {\n        fontFamily: \"Georgia\"\n      },\n      [\"mono\" /* Mono */]: {\n        fontFamily: \"Recursive Mono\"\n      }\n    }\n  }\n});\n\n// src/components/Tldraw/components/TopPanel/ZoomMenu/ZoomMenu.tsx\nvar import_jsx_runtime65 = require(\"react/jsx-runtime\");\nvar zoomSelector = (s5) => s5.document.pageStates[s5.appState.currentPageId].camera.zoom;\nvar ZoomMenu = function ZoomMenu2() {\n  const app = useTldrawApp();\n  const zoom = app.useStore(zoomSelector);\n  return /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: \"ltr\", children: [\n    /* @__PURE__ */ (0, import_jsx_runtime65.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { dir: \"ltr\", asChild: true, id: \"TD-Zoom\", children: /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(FixedWidthToolButton, { onDoubleClick: app.resetZoom, variant: \"text\", children: [\n      Math.round(zoom * 100),\n      \"%\"\n    ] }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(DMContent, { align: \"end\", children: [\n      /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomIn, kbd: \"#+\", id: \"TD-Zoom-Zoom_In\", children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(FormattedMessage, { id: \"zoom.in\" }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomOut, kbd: \"#\\u2212\", id: \"TD-Zoom-Zoom_Out\", children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(FormattedMessage, { id: \"zoom.out\" }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(DMItem, { onSelect: preventEvent, onClick: app.resetZoom, kbd: \"\\u21E70\", id: \"TD-Zoom-Zoom_To_100%\", children: [\n        /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(FormattedMessage, { id: \"zoom.to\" }),\n        \" 100%\"\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomToFit, kbd: \"\\u21E71\", id: \"TD-Zoom-To_Fit\", children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(FormattedMessage, { id: \"zoom.to.fit\" }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(DMItem, { onSelect: preventEvent, onClick: app.zoomToSelection, kbd: \"\\u21E72\", id: \"TD-Zoom-To_Selection\", children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(FormattedMessage, { id: \"zoom.to.selection\" }) })\n    ] })\n  ] });\n};\nvar FixedWidthToolButton = styled(ToolButton, {\n  minWidth: 56\n});\n\n// src/components/Tldraw/components/TopPanel/TopPanel.tsx\nvar import_jsx_runtime66 = require(\"react/jsx-runtime\");\nfunction _TopPanel({ readOnly, showPages, showMenu, showStyles, showZoom }) {\n  const app = useTldrawApp();\n  return /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(StyledTopPanel, { children: [\n    (showMenu || showPages) && /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(Panel, { side: \"left\", id: \"TD-MenuPanel\", children: [\n      showMenu && /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(Menu, { readOnly }),\n      showPages && /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(PageMenu, {})\n    ] }),\n    /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(StyledSpacer, {}),\n    (showStyles || showZoom) && /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(Panel, { side: \"right\", children: [\n      readOnly ? /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(ReadOnlyLabel, { children: \"Read Only\" }) : /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(import_jsx_runtime66.Fragment, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(ToolButton, { children: /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(UndoIcon, { onClick: app.undo }) }),\n        /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(ToolButton, { children: /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(UndoIcon, { onClick: app.redo, flipHorizontal: true }) })\n      ] }),\n      showZoom && /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(ZoomMenu, {}),\n      showStyles && !readOnly && /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(StyleMenu, {})\n    ] })\n  ] });\n}\nvar StyledTopPanel = styled(\"div\", {\n  width: \"100%\",\n  position: \"absolute\",\n  top: 0,\n  left: 0,\n  right: 0,\n  display: \"flex\",\n  flexDirection: \"row\",\n  pointerEvents: \"none\",\n  \"& > *\": {\n    pointerEvents: \"all\"\n  }\n});\nvar StyledSpacer = styled(\"div\", {\n  flexGrow: 2,\n  pointerEvents: \"none\"\n});\nvar ReadOnlyLabel = styled(\"div\", {\n  width: \"100%\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  fontFamily: \"$ui\",\n  fontSize: \"$1\",\n  paddingLeft: \"$4\",\n  paddingRight: \"$1\",\n  userSelect: \"none\"\n});\nvar TopPanel = React47.memo(_TopPanel);\n\n// src/components/Tldraw/hooks/useCursor.ts\nvar import_react40 = __toESM(require(\"react\"));\nfunction useCursor(reference) {\n  import_react40.default.useEffect(() => {\n    let isPointing = false;\n    let isSpacePanning = false;\n    const elm = reference.current;\n    if (elm == void 0)\n      return;\n    const onKeyDown = (e5) => {\n      if (e5.key === \" \" && !isSpacePanning) {\n        isSpacePanning = true;\n        if (isPointing) {\n          elm.setAttribute(\"style\", \"cursor: grabbing !important\");\n        } else {\n          elm.setAttribute(\"style\", \"cursor: grab !important\");\n        }\n      }\n    };\n    const onKeyUp = (e5) => {\n      if (e5.key === \" \") {\n        isSpacePanning = false;\n        elm.setAttribute(\"style\", \"cursor: initial\");\n      }\n    };\n    const onPointerDown = (e5) => {\n      isPointing = true;\n      if (e5.button === 1) {\n        elm.setAttribute(\"style\", \"cursor: grabbing !important\");\n      }\n      if (e5.button === 0 && isSpacePanning) {\n        elm.setAttribute(\"style\", \"cursor: grabbing !important\");\n      }\n    };\n    const onPointerUp = () => {\n      isPointing = false;\n      if (isSpacePanning) {\n        elm.setAttribute(\"style\", \"cursor: grab !important\");\n      } else {\n        elm.setAttribute(\"style\", \"cursor: initial\");\n      }\n    };\n    elm.addEventListener(\"keydown\", onKeyDown);\n    elm.addEventListener(\"keyup\", onKeyUp);\n    elm.addEventListener(\"pointerdown\", onPointerDown);\n    elm.addEventListener(\"pointerup\", onPointerUp);\n    return () => {\n      elm.removeEventListener(\"keydown\", onKeyDown);\n      elm.removeEventListener(\"keyup\", onKeyUp);\n      elm.removeEventListener(\"pointerdown\", onPointerDown);\n      elm.removeEventListener(\"pointerup\", onPointerUp);\n    };\n  }, [reference.current]);\n}\n\n// node_modules/.pnpm/zustand@4.3.8_react@18.2.0/node_modules/zustand/esm/vanilla.mjs\nvar import_meta = {};\nvar createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\") ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if ((import_meta.env && import_meta.env.MODE) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, subscribe, destroy };\n  state = createState(setState, getState, api);\n  return api;\n};\nvar createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if ((import_meta.env && import_meta.env.MODE) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\n// node_modules/.pnpm/zustand@4.3.8_react@18.2.0/node_modules/zustand/esm/index.mjs\nvar import_react41 = require(\"react\");\nvar import_with_selector = __toESM(require_with_selector(), 1);\nvar import_meta2 = {};\nvar { useSyncExternalStoreWithSelector } = import_with_selector.default;\nfunction useStore(api, selector = api.getState, equalityFn) {\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getState,\n    selector,\n    equalityFn\n  );\n  (0, import_react41.useDebugValue)(slice);\n  return slice;\n}\nvar createImpl = (createState) => {\n  if ((import_meta2.env && import_meta2.env.MODE) !== \"production\" && typeof createState !== \"function\") {\n    console.warn(\n      \"[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.\"\n    );\n  }\n  const api = typeof createState === \"function\" ? createStore(createState) : createState;\n  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nvar create = (createState) => createState ? createImpl(createState) : createImpl;\nvar react = (createState) => {\n  if ((import_meta2.env && import_meta2.env.MODE) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`.\"\n    );\n  }\n  return create(createState);\n};\n\n// src/components/Tldraw/state/StateManager/StateManager.ts\nvar StateManager = class {\n  /**\n   * The initial state.\n   */\n  initialState;\n  /**\n   * A zustand store that also holds the state.\n   */\n  store;\n  /**\n   * The index of the current command.\n   */\n  pointer = -1;\n  /**\n   * The current state.\n   */\n  _state;\n  /**\n   * The state manager's current status, with regard to restoring persisted state.\n   */\n  _status = \"loading\";\n  /**\n   * A stack of commands used for history (undo and redo).\n   */\n  stack = [];\n  /**\n   * A snapshot of the current state.\n   */\n  _snapshot;\n  /**\n   * A React hook for accessing the zustand store.\n   */\n  useStore;\n  /**\n   * A promise that will resolve when the state manager has loaded any peristed state.\n   */\n  ready;\n  isPaused = false;\n  constructor(initialState, id, version, update) {\n    this._state = deepCopy(initialState);\n    this._snapshot = deepCopy(initialState);\n    this.initialState = deepCopy(initialState);\n    this.store = vanilla(() => this._state);\n    this.useStore = react(this.store);\n    this.ready = new Promise((resolve) => {\n      let message = \"none\";\n      this._status = \"ready\";\n      resolve(message);\n    }).then((message) => {\n      if (this.onReady)\n        this.onReady(message);\n      return message;\n    });\n  }\n  /**\n   * Save the current state to indexdb.\n   */\n  persist = (patch, id) => {\n    if (this._status !== \"ready\")\n      return;\n    if (this.onPersist) {\n      this.onPersist(this._state, patch, id);\n    }\n  };\n  /**\n   * Apply a patch to the current state.\n   * This does not effect the undo/redo stack.\n   * This does not persist the state.\n   * @param patch The patch to apply.\n   * @param id (optional) An id for the patch.\n   */\n  applyPatch = (patch, id) => {\n    const prev = this._state;\n    const next = C3.deepMerge(this._state, patch);\n    const final = this.cleanup(next, prev, patch, id);\n    if (this.onStateWillChange) {\n      this.onStateWillChange(final, id);\n    }\n    this._state = final;\n    this.store.setState(this._state, true);\n    if (this.onStateDidChange) {\n      this.onStateDidChange(this._state, id);\n    }\n    return this;\n  };\n  // Internal API ---------------------------------\n  migrate = (next) => {\n    return next;\n  };\n  /**\n   * Perform any last changes to the state before updating.\n   * Override this on your extending class.\n   * @param nextState The next state.\n   * @param prevState The previous state.\n   * @param patch The patch that was just applied.\n   * @param id (optional) An id for the just-applied patch.\n   * @returns The final new state to apply.\n   */\n  cleanup = (nextState, _prevState, _patch, _id) => nextState;\n  /**\n   * A life-cycle method called when the state is about to change.\n   * @param state The next state.\n   * @param id An id for the change.\n   */\n  onStateWillChange;\n  /**\n   * A life-cycle method called when the state has changed.\n   * @param state The next state.\n   * @param id An id for the change.\n   */\n  onStateDidChange;\n  /**\n   * Apply a patch to the current state.\n   * This does not effect the undo/redo stack.\n   * This does not persist the state.\n   * @param patch The patch to apply.\n   * @param id (optional) An id for this patch.\n   */\n  patchState = (patch, id) => {\n    this.applyPatch(patch, id);\n    if (this.onPatch) {\n      this.onPatch(this._state, patch, id);\n    }\n    return this;\n  };\n  /**\n   * Replace the current state.\n   * This does not effect the undo/redo stack.\n   * This does not persist the state.\n   * @param state The new state.\n   * @param id An id for this change.\n   */\n  replaceState = (state, id) => {\n    const final = this.cleanup(state, this._state, state, id);\n    if (this.onStateWillChange) {\n      this.onStateWillChange(final, \"replace\");\n    }\n    this._state = final;\n    this.store.setState(this._state, true);\n    if (this.onStateDidChange) {\n      this.onStateDidChange(this._state, \"replace\");\n    }\n    return this;\n  };\n  /**\n   * Update the state using a Command.\n   * This effects the undo/redo stack.\n   * This persists the state.\n   * @param command The command to apply and add to the undo/redo stack.\n   * @param id (optional) An id for this command.\n   */\n  setState = (command, id = command.id) => {\n    if (this.pointer < this.stack.length - 1) {\n      this.stack = this.stack.slice(0, this.pointer + 1);\n    }\n    this.stack.push({ ...command, id });\n    this.pointer = this.stack.length - 1;\n    this.applyPatch(command.after, id);\n    if (this.onCommand)\n      this.onCommand(this._state, command, id);\n    this.persist(command.after, id);\n    return this;\n  };\n  // Public API ---------------------------------\n  pause() {\n    this.isPaused = true;\n  }\n  resume() {\n    this.isPaused = false;\n  }\n  /**\n   * A callback fired when the constructor finishes loading any\n   * persisted data.\n   */\n  onReady;\n  /**\n   * A callback fired when a patch is applied.\n   */\n  onPatch;\n  /**\n   * A callback fired when a patch is applied.\n   */\n  onCommand;\n  /**\n   * A callback fired when the state is persisted.\n   */\n  onPersist;\n  /**\n   * A callback fired when the state is replaced.\n   */\n  onReplace;\n  /**\n   * A callback fired when the state is reset.\n   */\n  onReset;\n  /**\n   * A callback fired when the history is reset.\n   */\n  onResetHistory;\n  /**\n   * A callback fired when a command is undone.\n   */\n  onUndo;\n  /**\n   * A callback fired when a command is redone.\n   */\n  onRedo;\n  /**\n   * Reset the state to the initial state and reset history.\n   */\n  reset = () => {\n    if (this.onStateWillChange) {\n      this.onStateWillChange(this.initialState, \"reset\");\n    }\n    this._state = this.initialState;\n    this.store.setState(this._state, true);\n    this.resetHistory();\n    this.persist({}, \"reset\");\n    if (this.onStateDidChange) {\n      this.onStateDidChange(this._state, \"reset\");\n    }\n    if (this.onReset) {\n      this.onReset(this._state);\n    }\n    return this;\n  };\n  /**\n   * Force replace a new undo/redo history. It's your responsibility\n   * to make sure that this is compatible with the current state!\n   * @param history The new array of commands.\n   * @param pointer (optional) The new pointer position.\n   */\n  replaceHistory = (history, pointer = history.length - 1) => {\n    this.stack = history;\n    this.pointer = pointer;\n    if (this.onReplace) {\n      this.onReplace(this._state);\n    }\n    return this;\n  };\n  /**\n   * Reset the history stack (without resetting the state).\n   */\n  resetHistory = () => {\n    this.stack = [];\n    this.pointer = -1;\n    if (this.onResetHistory) {\n      this.onResetHistory(this._state);\n    }\n    return this;\n  };\n  /**\n   * Move backward in the undo/redo stack.\n   */\n  undo = () => {\n    if (!this.isPaused) {\n      if (!this.canUndo)\n        return this;\n      const command = this.stack[this.pointer];\n      this.pointer--;\n      this.applyPatch(command.before, `undo`);\n      this.persist(command.before, \"undo\");\n    }\n    if (this.onUndo)\n      this.onUndo(this._state);\n    return this;\n  };\n  /**\n   * Move forward in the undo/redo stack.\n   */\n  redo = () => {\n    if (!this.isPaused) {\n      if (!this.canRedo)\n        return this;\n      this.pointer++;\n      const command = this.stack[this.pointer];\n      this.applyPatch(command.after, \"redo\");\n      this.persist(command.after, \"undo\");\n    }\n    if (this.onRedo)\n      this.onRedo(this._state);\n    return this;\n  };\n  /**\n   * Save a snapshot of the current state, accessible at `this.snapshot`.\n   */\n  setSnapshot = () => {\n    this._snapshot = { ...this._state };\n    return this;\n  };\n  /**\n   * Force the zustand state to update.\n   */\n  forceUpdate = () => {\n    this.store.setState(this._state, true);\n  };\n  /**\n   * Get whether the state manager can undo.\n   */\n  get canUndo() {\n    return this.pointer > -1;\n  }\n  /**\n   * Get whether the state manager can redo.\n   */\n  get canRedo() {\n    return this.pointer < this.stack.length - 1;\n  }\n  /**\n   * The current state.\n   */\n  get state() {\n    return this._state;\n  }\n  /**\n   * The current status.\n   */\n  get status() {\n    return this._status;\n  }\n  /**\n   * The most-recent snapshot.\n   */\n  get snapshot() {\n    return this._snapshot;\n  }\n};\n\n// src/components/Tldraw/state/commands/alignShapes/alignShapes.ts\nfunction alignShapes(app, ids, type) {\n  const { currentPageId } = app;\n  const initialShapes = ids.map((id) => app.getShape(id));\n  const boundsForShapes = initialShapes.map((shape) => {\n    return {\n      id: shape.id,\n      point: [...shape.point],\n      bounds: TLDR.getBounds(shape)\n    };\n  });\n  const commonBounds = C3.getCommonBounds(boundsForShapes.map(({ bounds }) => bounds));\n  const midX = commonBounds.minX + commonBounds.width / 2;\n  const midY = commonBounds.minY + commonBounds.height / 2;\n  const deltaMap = Object.fromEntries(\n    boundsForShapes.map(({ id, point, bounds }) => {\n      return [\n        id,\n        {\n          prev: point,\n          next: {\n            [\"top\" /* Top */]: [point[0], commonBounds.minY],\n            [\"centerVertical\" /* CenterVertical */]: [point[0], midY - bounds.height / 2],\n            [\"bottom\" /* Bottom */]: [point[0], commonBounds.maxY - bounds.height],\n            [\"left\" /* Left */]: [commonBounds.minX, point[1]],\n            [\"centerHorizontal\" /* CenterHorizontal */]: [midX - bounds.width / 2, point[1]],\n            [\"right\" /* Right */]: [commonBounds.maxX - bounds.width, point[1]]\n          }[type]\n        }\n      ];\n    })\n  );\n  const { before, after } = TLDR.mutateShapes(\n    app.state,\n    ids,\n    (shape) => {\n      if (!deltaMap[shape.id])\n        return shape;\n      return { point: deltaMap[shape.id].next };\n    },\n    currentPageId,\n    false\n  );\n  initialShapes.forEach((shape) => {\n    if (shape.type === \"group\" /* Group */) {\n      const delta = e.sub(after[shape.id].point, before[shape.id].point);\n      shape.children.forEach((id) => {\n        const child = app.getShape(id);\n        before[child.id] = { point: child.point };\n        after[child.id] = { point: e.add(child.point, delta) };\n      });\n      delete before[shape.id];\n      delete after[shape.id];\n    }\n  });\n  return {\n    id: \"align\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: before\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: after\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/changePage/changePage.ts\nfunction changePage(app, pageId) {\n  return {\n    id: \"change_page\",\n    before: {\n      appState: {\n        currentPageId: app.currentPageId\n      }\n    },\n    after: {\n      appState: {\n        currentPageId: pageId\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/shared/getIncrementedName.ts\nfunction getIncrementedName(name, others) {\n  let result = name;\n  const set = new Set(others);\n  while (set.has(result)) {\n    result = /^.*(\\d+)$/.exec(result)?.[1] ? result.replace(/(\\d+)(?=\\D?)$/, (m6) => (+m6 + 1).toString()) : `${result} 1`;\n  }\n  return result;\n}\n\n// src/components/Tldraw/state/commands/shared/removeShapesFromPage.ts\nfunction removeShapesFromPage(data, ids, pageId) {\n  const before = {\n    shapes: {},\n    bindings: {}\n  };\n  const after = {\n    shapes: {},\n    bindings: {}\n  };\n  const parentsToUpdate = [];\n  const deletedIds = /* @__PURE__ */ new Set();\n  const assetsToRemove = /* @__PURE__ */ new Set();\n  ids.filter((id) => !TLDR.getShape(data, id, pageId).isLocked).forEach((id) => {\n    deletedIds.add(id);\n    const shape = TLDR.getShape(data, id, pageId);\n    before.shapes[id] = shape;\n    after.shapes[id] = void 0;\n    if (shape.children !== void 0) {\n      shape.children.forEach((childId) => {\n        deletedIds.add(childId);\n        const child = TLDR.getShape(data, childId, pageId);\n        before.shapes[childId] = child;\n        after.shapes[childId] = void 0;\n      });\n    }\n    if (shape.parentId !== pageId) {\n      parentsToUpdate.push(TLDR.getShape(data, shape.parentId, pageId));\n    }\n    if (shape.assetId) {\n      assetsToRemove.add(shape.assetId);\n    }\n  });\n  parentsToUpdate.forEach((parent) => {\n    if (ids.includes(parent.id))\n      return;\n    deletedIds.add(parent.id);\n    before.shapes[parent.id] = { children: parent.children };\n    after.shapes[parent.id] = { children: parent.children.filter((id) => !ids.includes(id)) };\n    if (after.shapes[parent.id]?.children.length === 0) {\n      after.shapes[parent.id] = void 0;\n      before.shapes[parent.id] = TLDR.getShape(data, parent.id, pageId);\n    }\n  });\n  const page = TLDR.getPage(data, pageId);\n  Object.values(page.bindings).filter((binding) => deletedIds.has(binding.fromId) || deletedIds.has(binding.toId)).forEach((binding) => {\n    for (const id of [binding.toId, binding.fromId]) {\n      if (after.shapes[id] === void 0) {\n        before.bindings[binding.id] = binding;\n        after.bindings[binding.id] = void 0;\n        const shape = page.shapes[id];\n        if (shape && shape.handles) {\n          Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {\n            before.shapes[id] = {\n              ...before.shapes[id],\n              handles: {\n                ...before.shapes[id]?.handles,\n                [handle.id]: {\n                  ...before.shapes[id]?.handles?.[handle.id],\n                  bindingId: binding.id\n                }\n              }\n            };\n            if (!deletedIds.has(id)) {\n              after.shapes[id] = {\n                ...after.shapes[id],\n                handles: {\n                  ...after.shapes[id]?.handles,\n                  [handle.id]: {\n                    ...after.shapes[id]?.handles?.[handle.id],\n                    bindingId: void 0\n                  }\n                }\n              };\n            }\n          });\n        }\n      }\n    }\n  });\n  Object.values(data.document.pages).flatMap((page2) => Object.values(page2.shapes)).forEach((shape) => {\n    if (\"assetId\" in shape && shape.assetId && !deletedIds.has(shape.id)) {\n      assetsToRemove.delete(shape.assetId);\n    }\n  });\n  return { before, after, assetsToRemove: [...assetsToRemove] };\n}\n\n// src/components/Tldraw/state/commands/createPage/createPage.ts\nfunction createPage(app, center, pageId = C3.uniqueId(), pageName = \"Page\") {\n  const { currentPageId } = app;\n  const pages = Object.values(app.state.document.pages).sort((a7, b6) => (a7.childIndex ?? 0) - (b6.childIndex ?? 0));\n  const topPage = pages[pages.length - 1];\n  const nextChildIndex = topPage?.childIndex ? topPage?.childIndex + 1 : 1;\n  const page = {\n    id: pageId,\n    name: getIncrementedName(\n      pageName,\n      pages.map((p6) => p6.name ?? \"\")\n    ),\n    childIndex: nextChildIndex,\n    shapes: {},\n    bindings: {}\n  };\n  const pageState = {\n    id: pageId,\n    selectedIds: [],\n    camera: { point: center, zoom: 1 },\n    editingId: void 0,\n    bindingId: void 0,\n    hoveredId: void 0,\n    pointedId: void 0\n  };\n  return {\n    id: \"create_page\",\n    before: {\n      appState: {\n        currentPageId\n      },\n      document: {\n        pages: {\n          [pageId]: void 0\n        },\n        pageStates: {\n          [pageId]: void 0\n        }\n      }\n    },\n    after: {\n      appState: {\n        currentPageId: page.id\n      },\n      document: {\n        pages: {\n          [pageId]: page\n        },\n        pageStates: {\n          [pageId]: pageState\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/createShapes/createShapes.ts\nfunction createShapes(app, shapes, bindings = []) {\n  const { currentPageId } = app;\n  const beforeShapes = {};\n  const afterShapes = {};\n  shapes.forEach((shape) => {\n    beforeShapes[shape.id] = void 0;\n    afterShapes[shape.id] = shape;\n  });\n  const beforeBindings = {};\n  const afterBindings = {};\n  bindings.forEach((binding) => {\n    beforeBindings[binding.id] = void 0;\n    afterBindings[binding.id] = binding;\n  });\n  return {\n    id: \"create\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: beforeShapes,\n            bindings: beforeBindings\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: [...app.selectedIds]\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: afterShapes,\n            bindings: afterBindings\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: shapes.map((shape) => shape.id)\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/deletePage/deletePage.ts\nfunction deletePage(app, pageId) {\n  const {\n    currentPageId,\n    document: { pages, pageStates }\n  } = app;\n  const pagesArr = Object.values(pages).sort((a7, b6) => (a7.childIndex || 0) - (b6.childIndex || 0));\n  const currentIndex = pagesArr.findIndex((page) => page.id === pageId);\n  let nextCurrentPageId;\n  if (pageId === currentPageId) {\n    if (currentIndex === pagesArr.length - 1) {\n      nextCurrentPageId = pagesArr[pagesArr.length - 2].id;\n    } else {\n      nextCurrentPageId = pagesArr[currentIndex + 1].id;\n    }\n  } else {\n    nextCurrentPageId = currentPageId;\n  }\n  return {\n    id: \"delete_page\",\n    before: {\n      appState: {\n        currentPageId: pageId\n      },\n      document: {\n        pages: {\n          [pageId]: { ...pages[pageId] }\n        },\n        pageStates: {\n          [pageId]: { ...pageStates[pageId] }\n        }\n      }\n    },\n    after: {\n      appState: {\n        currentPageId: nextCurrentPageId\n      },\n      document: {\n        pages: {\n          [pageId]: void 0\n        },\n        pageStates: {\n          [pageId]: void 0\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/deleteShapes/deleteShapes.ts\nvar removeAssetsFromDocument = (assets, idsToRemove) => {\n  const afterAssets = { ...assets };\n  idsToRemove.forEach((id) => afterAssets[id] = void 0);\n  return afterAssets;\n};\nfunction deleteShapes(app, ids, pageId = app.currentPageId) {\n  const {\n    pageState,\n    selectedIds,\n    document: { assets: beforeAssets }\n  } = app;\n  const { before, after, assetsToRemove } = removeShapesFromPage(app.state, ids, pageId);\n  const afterAssets = removeAssetsFromDocument(beforeAssets, assetsToRemove);\n  return {\n    id: \"delete\",\n    before: {\n      document: {\n        assets: beforeAssets,\n        pages: {\n          [pageId]: before\n        },\n        pageStates: {\n          [pageId]: { selectedIds: [...app.selectedIds] }\n        }\n      }\n    },\n    after: {\n      document: {\n        assets: afterAssets,\n        pages: {\n          [pageId]: after\n        },\n        pageStates: {\n          [pageId]: {\n            selectedIds: selectedIds.filter((id) => !ids.includes(id)),\n            hoveredId: pageState.hoveredId && ids.includes(pageState.hoveredId) ? void 0 : pageState.hoveredId\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/distributeShapes/distributeShapes.ts\nfunction distributeShapes(app, ids, type) {\n  const { currentPageId } = app;\n  const initialShapes = ids.map((id) => app.getShape(id));\n  const deltaMap = Object.fromEntries(getDistributions(initialShapes, type).map((d6) => [d6.id, d6]));\n  const { before, after } = TLDR.mutateShapes(\n    app.state,\n    ids.filter((id) => deltaMap[id] !== void 0),\n    (shape) => ({ point: deltaMap[shape.id]?.next }),\n    currentPageId\n  );\n  initialShapes.forEach((shape) => {\n    if (shape.type === \"group\" /* Group */) {\n      const delta = p.sub(after[shape.id].point, before[shape.id].point);\n      shape.children.forEach((id) => {\n        const child = app.getShape(id);\n        before[child.id] = { point: child.point };\n        after[child.id] = { point: p.add(child.point, delta) };\n      });\n      delete before[shape.id];\n      delete after[shape.id];\n    }\n  });\n  return {\n    id: \"distribute\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: before }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: after }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\nfunction getDistributions(initialShapes, type) {\n  const entries = initialShapes.map((shape) => {\n    const utils = TLDR.getShapeUtil(shape);\n    return {\n      id: shape.id,\n      point: [...shape.point],\n      bounds: utils.getBounds(shape),\n      center: utils.getCenter(shape)\n    };\n  });\n  const len = entries.length;\n  const commonBounds = C3.getCommonBounds(entries.map(({ bounds }) => bounds));\n  const results = [];\n  switch (type) {\n    case \"horizontal\" /* Horizontal */: {\n      const span = entries.reduce((a7, c5) => a7 + c5.bounds.width, 0);\n      if (span > commonBounds.width) {\n        const left = entries.sort((a7, b6) => a7.bounds.minX - b6.bounds.minX)[0];\n        const right = entries.sort((a7, b6) => b6.bounds.maxX - a7.bounds.maxX)[0];\n        const entriesToMove = entries.filter((a7) => a7 !== left && a7 !== right).sort((a7, b6) => a7.center[0] - b6.center[0]);\n        const step = (right.center[0] - left.center[0]) / (len - 1);\n        const x5 = left.center[0] + step;\n        entriesToMove.forEach(({ id, point, bounds }, i4) => {\n          results.push({\n            id,\n            prev: point,\n            next: [x5 + step * i4 - bounds.width / 2, bounds.minY]\n          });\n        });\n      } else {\n        const entriesToMove = entries.sort((a7, b6) => a7.center[0] - b6.center[0]);\n        let x5 = commonBounds.minX;\n        const step = (commonBounds.width - span) / (len - 1);\n        entriesToMove.forEach(({ id, point, bounds }) => {\n          results.push({ id, prev: point, next: [x5, bounds.minY] });\n          x5 += bounds.width + step;\n        });\n      }\n      break;\n    }\n    case \"vertical\" /* Vertical */: {\n      const span = entries.reduce((a7, c5) => a7 + c5.bounds.height, 0);\n      if (span > commonBounds.height) {\n        const top2 = entries.sort((a7, b6) => a7.bounds.minY - b6.bounds.minY)[0];\n        const bottom = entries.sort((a7, b6) => b6.bounds.maxY - a7.bounds.maxY)[0];\n        const entriesToMove = entries.filter((a7) => a7 !== top2 && a7 !== bottom).sort((a7, b6) => a7.center[1] - b6.center[1]);\n        const step = (bottom.center[1] - top2.center[1]) / (len - 1);\n        const y6 = top2.center[1] + step;\n        entriesToMove.forEach(({ id, point, bounds }, i4) => {\n          results.push({\n            id,\n            prev: point,\n            next: [bounds.minX, y6 + step * i4 - bounds.height / 2]\n          });\n        });\n      } else {\n        const entriesToMove = entries.sort((a7, b6) => a7.center[1] - b6.center[1]);\n        let y6 = commonBounds.minY;\n        const step = (commonBounds.height - span) / (len - 1);\n        entriesToMove.forEach(({ id, point, bounds }) => {\n          results.push({ id, prev: point, next: [bounds.minX, y6] });\n          y6 += bounds.height + step;\n        });\n      }\n      break;\n    }\n  }\n  return results;\n}\n\n// src/components/Tldraw/state/commands/duplicatePage/duplicatePage.ts\nfunction duplicatePage(app, pageId) {\n  const {\n    currentPageId,\n    pageState: { camera }\n  } = app;\n  const page = app.document.pages[pageId];\n  const newId = C3.uniqueId();\n  const nextPage = {\n    ...page,\n    id: newId,\n    name: page.name + \" Copy\",\n    shapes: Object.fromEntries(\n      Object.entries(page.shapes).map(([id, shape]) => {\n        return [\n          id,\n          {\n            ...shape,\n            parentId: shape.parentId === page.id ? newId : shape.parentId\n          }\n        ];\n      })\n    )\n  };\n  return {\n    id: \"duplicate_page\",\n    before: {\n      appState: {\n        currentPageId\n      },\n      document: {\n        pages: {\n          [newId]: void 0\n        },\n        pageStates: {\n          [newId]: void 0\n        }\n      }\n    },\n    after: {\n      appState: {\n        currentPageId: newId\n      },\n      document: {\n        pages: {\n          [newId]: nextPage\n        },\n        pageStates: {\n          [newId]: {\n            ...page,\n            id: newId,\n            selectedIds: [],\n            camera: { ...camera },\n            editingId: void 0,\n            bindingId: void 0,\n            hoveredId: void 0,\n            pointedId: void 0\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/duplicateShapes/duplicateShapes.ts\nfunction duplicateShapes(app, ids, point) {\n  const { selectedIds, currentPageId, page, shapes } = app;\n  const before = {\n    shapes: {},\n    bindings: {}\n  };\n  const after = {\n    shapes: {},\n    bindings: {}\n  };\n  const duplicateMap = {};\n  const shapesToDuplicate = ids.map((id) => app.getShape(id)).filter((shape) => !ids.includes(shape.parentId));\n  shapesToDuplicate.forEach((shape) => {\n    const duplicatedId = C3.uniqueId();\n    before.shapes[duplicatedId] = void 0;\n    after.shapes[duplicatedId] = {\n      ...C3.deepClone(shape),\n      id: duplicatedId,\n      childIndex: TLDR.getChildIndexAbove(app.state, shape.id, currentPageId)\n    };\n    if (shape.children) {\n      after.shapes[duplicatedId].children = [];\n    }\n    if (shape.parentId !== currentPageId) {\n      const parent = app.getShape(shape.parentId);\n      before.shapes[parent.id] = {\n        ...before.shapes[parent.id],\n        children: parent.children\n      };\n      after.shapes[parent.id] = {\n        ...after.shapes[parent.id],\n        children: [...(after.shapes[parent.id] || parent).children, duplicatedId]\n      };\n    }\n    duplicateMap[shape.id] = duplicatedId;\n  });\n  shapesToDuplicate.forEach((shape) => {\n    if (shape.children) {\n      shape.children.forEach((childId) => {\n        const child = app.getShape(childId);\n        const duplicatedId = C3.uniqueId();\n        const duplicatedParentId = duplicateMap[shape.id];\n        before.shapes[duplicatedId] = void 0;\n        after.shapes[duplicatedId] = {\n          ...C3.deepClone(child),\n          id: duplicatedId,\n          parentId: duplicatedParentId,\n          childIndex: TLDR.getChildIndexAbove(app.state, child.id, currentPageId)\n        };\n        duplicateMap[childId] = duplicatedId;\n        after.shapes[duplicateMap[shape.id]]?.children?.push(duplicatedId);\n      });\n    }\n  });\n  const dupedShapeIds = new Set(Object.keys(duplicateMap));\n  Object.values(page.bindings).filter((binding) => dupedShapeIds.has(binding.fromId) || dupedShapeIds.has(binding.toId)).forEach((binding) => {\n    if (dupedShapeIds.has(binding.fromId)) {\n      if (dupedShapeIds.has(binding.toId)) {\n        const duplicatedBindingId = C3.uniqueId();\n        const duplicatedBinding = {\n          ...C3.deepClone(binding),\n          id: duplicatedBindingId,\n          fromId: duplicateMap[binding.fromId],\n          toId: duplicateMap[binding.toId]\n        };\n        before.bindings[duplicatedBindingId] = void 0;\n        after.bindings[duplicatedBindingId] = duplicatedBinding;\n        const boundShape = after.shapes[duplicatedBinding.fromId];\n        Object.values(boundShape.handles).forEach((handle) => {\n          if (handle.bindingId === binding.id) {\n            handle.bindingId = duplicatedBindingId;\n          }\n        });\n      } else {\n        const boundShape = after.shapes[duplicateMap[binding.fromId]];\n        Object.values(boundShape.handles).forEach((handle) => {\n          if (handle.bindingId === binding.id) {\n            handle.bindingId = void 0;\n          }\n        });\n      }\n    }\n  });\n  const shapesToMove = Object.values(after.shapes);\n  if (point) {\n    const commonBounds = C3.getCommonBounds(shapesToMove.map((shape) => TLDR.getBounds(shape)));\n    const center = C3.getBoundsCenter(commonBounds);\n    shapesToMove.forEach((shape) => {\n      if (!shape.point)\n        return;\n      shape.point = e.sub(point, e.sub(center, shape.point));\n    });\n  } else {\n    const offset = [16, 16];\n    shapesToMove.forEach((shape) => {\n      if (!shape.point)\n        return;\n      shape.point = e.add(shape.point, offset);\n    });\n  }\n  shapesToMove.forEach((shape) => {\n    if (shape.isLocked) {\n      shape.isLocked = false;\n    }\n  });\n  return {\n    id: \"duplicate\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: before\n        },\n        pageStates: {\n          [currentPageId]: { selectedIds }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: after\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: [...dupedShapeIds.values()].map((id) => duplicateMap[id])\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/flipShapes/flipShapes.ts\nfunction flipShapes(app, ids, type) {\n  const {\n    selectedIds,\n    currentPageId,\n    page: { shapes }\n  } = app;\n  const boundsForShapes = ids.map((id) => TLDR.getBounds(shapes[id]));\n  const isSinglySelectedGroup = ids.length === 1 && shapes[ids[0]].type === \"group\";\n  const commonBounds = C3.getCommonBounds(boundsForShapes);\n  const { before, after } = TLDR.mutateShapes(\n    app.state,\n    ids,\n    (shape) => {\n      const shapeBounds = TLDR.getBounds(shape);\n      const isChildOfGroup = shape.parentId !== currentPageId;\n      switch (type) {\n        case \"horizontal\" /* Horizontal */: {\n          if (isChildOfGroup && !isSinglySelectedGroup) {\n            const groupBounds = TLDR.getBounds(shapes[shape.parentId]);\n            const newGroupBounds = C3.getRelativeTransformedBoundingBox(commonBounds, commonBounds, groupBounds, true, false);\n            const dx = newGroupBounds.minX - groupBounds.minX;\n            return TLDR.getShapeUtil(shape).transform(\n              shape,\n              { ...shapeBounds, minX: shapeBounds.minX + dx, maxX: shapeBounds.maxX + dx },\n              {\n                type: He.TopLeft,\n                scaleX: 1,\n                scaleY: 1,\n                initialShape: shape,\n                transformOrigin: [0.5, 0.5]\n              }\n            );\n          }\n          const newShapeBounds = C3.getRelativeTransformedBoundingBox(commonBounds, commonBounds, shapeBounds, true, false);\n          return TLDR.getShapeUtil(shape).transform(shape, newShapeBounds, {\n            type: He.TopLeft,\n            scaleX: -1,\n            scaleY: 1,\n            initialShape: shape,\n            transformOrigin: [0.5, 0.5]\n          });\n        }\n        case \"vertical\" /* Vertical */: {\n          if (isChildOfGroup && !isSinglySelectedGroup) {\n            const groupBounds = TLDR.getBounds(shapes[shape.parentId]);\n            const newGroupBounds = C3.getRelativeTransformedBoundingBox(commonBounds, commonBounds, groupBounds, false, true);\n            const dy = newGroupBounds.minY - groupBounds.minY;\n            return TLDR.getShapeUtil(shape).transform(\n              shape,\n              { ...shapeBounds, minY: shapeBounds.minY + dy, maxY: shapeBounds.maxY + dy },\n              {\n                type: He.TopLeft,\n                scaleX: 1,\n                scaleY: 1,\n                initialShape: shape,\n                transformOrigin: [0.5, 0.5]\n              }\n            );\n          }\n          const newShapeBounds = C3.getRelativeTransformedBoundingBox(commonBounds, commonBounds, shapeBounds, false, true);\n          return TLDR.getShapeUtil(shape).transform(shape, newShapeBounds, {\n            type: He.TopLeft,\n            scaleX: 1,\n            scaleY: -1,\n            initialShape: shape,\n            transformOrigin: [0.5, 0.5]\n          });\n        }\n      }\n    },\n    currentPageId,\n    true\n  );\n  return {\n    id: \"flip\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: before }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: after }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/groupShapes/groupShapes.ts\nfunction groupShapes(app, ids, groupId, pageId) {\n  if (ids.length < 2)\n    return;\n  const beforeShapes = {};\n  const afterShapes = {};\n  const beforeBindings = {};\n  const afterBindings = {};\n  const idsToGroup = [...ids];\n  const shapesToGroup = [];\n  const deletedGroupIds = [];\n  const otherEffectedGroups = [];\n  for (const id of ids) {\n    const shape = app.getShape(id);\n    if (shape.isLocked)\n      continue;\n    if (shape.children === void 0) {\n      shapesToGroup.push(shape);\n    } else {\n      const childIds = shape.children.filter((id2) => !app.getShape(id2).isLocked);\n      otherEffectedGroups.push(shape);\n      idsToGroup.push(...childIds);\n      shapesToGroup.push(...childIds.map((id2) => app.getShape(id2)).filter(Boolean));\n    }\n  }\n  if (shapesToGroup.every((shape) => shape.parentId === shapesToGroup[0].parentId) && // Is the common parent a shape (not the page)?\n  shapesToGroup[0].parentId !== pageId) {\n    const commonParent = app.getShape(shapesToGroup[0].parentId);\n    if (commonParent.children?.length === idsToGroup.length) {\n      return;\n    }\n  }\n  const flattenedShapes = TLDR.flattenPage(app.state, pageId);\n  const shapeIndexMap = Object.fromEntries(shapesToGroup.map((shape) => [shape.id, flattenedShapes.indexOf(shape)]));\n  const sortedShapes = shapesToGroup.sort((a7, b6) => shapeIndexMap[a7.id] - shapeIndexMap[b6.id]);\n  const groupParentId = pageId;\n  const groupChildIndex = (sortedShapes.find((shape) => shape.parentId === pageId) || sortedShapes[0]).childIndex;\n  const groupBounds = C3.getCommonBounds(shapesToGroup.map((shape) => TLDR.getBounds(shape)));\n  beforeShapes[groupId] = void 0;\n  afterShapes[groupId] = TLDR.getShapeUtil(\"group\" /* Group */).create({\n    id: groupId,\n    childIndex: groupChildIndex,\n    parentId: groupParentId,\n    point: [groupBounds.minX, groupBounds.minY],\n    size: [groupBounds.width, groupBounds.height],\n    children: sortedShapes.map((shape) => shape.id)\n  });\n  sortedShapes.forEach((shape, index2) => {\n    if (shape.parentId !== pageId) {\n      const parentShape = app.getShape(shape.parentId);\n      otherEffectedGroups.push(parentShape);\n    }\n    beforeShapes[shape.id] = {\n      ...beforeShapes[shape.id],\n      parentId: shape.parentId,\n      childIndex: shape.childIndex\n    };\n    afterShapes[shape.id] = {\n      ...afterShapes[shape.id],\n      parentId: groupId,\n      childIndex: index2 + 1\n    };\n  });\n  while (otherEffectedGroups.length > 0) {\n    const shape = otherEffectedGroups.pop();\n    if (!shape)\n      break;\n    const nextChildren = (beforeShapes[shape.id]?.children || shape.children).filter(\n      (childId) => childId && !(idsToGroup.includes(childId) || deletedGroupIds.includes(childId))\n    );\n    if (nextChildren.length === 0) {\n      beforeShapes[shape.id] = shape;\n      afterShapes[shape.id] = void 0;\n      if (shape.parentId !== pageId) {\n        deletedGroupIds.push(shape.id);\n        otherEffectedGroups.push(app.getShape(shape.parentId));\n      }\n    } else {\n      beforeShapes[shape.id] = {\n        ...beforeShapes[shape.id],\n        children: shape.children\n      };\n      afterShapes[shape.id] = {\n        ...afterShapes[shape.id],\n        children: nextChildren\n      };\n    }\n  }\n  const { bindings } = app;\n  const deletedGroupIdsSet = new Set(deletedGroupIds);\n  bindings.forEach((binding) => {\n    for (const id of [binding.toId, binding.fromId]) {\n      if (deletedGroupIdsSet.has(id)) {\n        beforeBindings[binding.id] = binding;\n        afterBindings[binding.id] = void 0;\n        const shape = app.getShape(id);\n        if (shape.handles) {\n          Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {\n            beforeShapes[id] = {\n              ...beforeShapes[id],\n              handles: {\n                ...beforeShapes[id]?.handles,\n                [handle.id]: { bindingId: binding.id }\n              }\n            };\n            if (!deletedGroupIds.includes(id)) {\n              afterShapes[id] = {\n                ...afterShapes[id],\n                handles: {\n                  ...afterShapes[id]?.handles,\n                  [handle.id]: { bindingId: void 0 }\n                }\n              };\n            }\n          });\n        }\n      }\n    }\n  });\n  return {\n    id: \"group\",\n    before: {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: beforeShapes,\n            bindings: beforeBindings\n          }\n        },\n        pageStates: {\n          [pageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: afterShapes,\n            bindings: beforeBindings\n          }\n        },\n        pageStates: {\n          [pageId]: {\n            selectedIds: [groupId]\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/moveShapesToPage/moveShapesToPage.ts\nfunction moveShapesToPage(app, ids, viewportBounds, fromPageId, toPageId) {\n  const { page } = app;\n  const fromPage = {\n    before: {\n      shapes: {},\n      bindings: {}\n    },\n    after: {\n      shapes: {},\n      bindings: {}\n    }\n  };\n  const toPage = {\n    before: {\n      shapes: {},\n      bindings: {}\n    },\n    after: {\n      shapes: {},\n      bindings: {}\n    }\n  };\n  const movingShapeIds = /* @__PURE__ */ new Set();\n  const shapesToMove = /* @__PURE__ */ new Set();\n  ids.map((id) => app.getShape(id, fromPageId)).filter((shape) => !shape.isLocked).forEach((shape) => {\n    movingShapeIds.add(shape.id);\n    shapesToMove.add(shape);\n    if (shape.children !== void 0) {\n      shape.children.forEach((childId) => {\n        movingShapeIds.add(childId);\n        shapesToMove.add(app.getShape(childId, fromPageId));\n      });\n    }\n  });\n  const startingChildIndex = TLDR.getTopChildIndex(app.state, toPageId);\n  const movingShapes = [...shapesToMove.values()];\n  movingShapes.forEach((shape, i4) => {\n    fromPage.before.shapes[shape.id] = shape;\n    fromPage.after.shapes[shape.id] = void 0;\n    toPage.before.shapes[shape.id] = void 0;\n    toPage.after.shapes[shape.id] = shape;\n    if (!movingShapeIds.has(shape.parentId)) {\n      toPage.after.shapes[shape.id] = {\n        ...shape,\n        parentId: toPageId,\n        childIndex: startingChildIndex + i4\n      };\n      if (shape.parentId !== fromPageId) {\n        const parent = app.getShape(shape.parentId, fromPageId);\n        fromPage.before.shapes[parent.id] = {\n          children: parent.children\n        };\n        fromPage.after.shapes[parent.id] = {\n          children: parent.children.filter((childId) => childId !== shape.id)\n        };\n      }\n    }\n  });\n  Object.values(page.bindings).filter((binding) => movingShapeIds.has(binding.fromId) || movingShapeIds.has(binding.toId)).forEach((binding) => {\n    fromPage.before.bindings[binding.id] = binding;\n    fromPage.after.bindings[binding.id] = void 0;\n    const fromBoundShape = app.getShape(binding.fromId, fromPageId);\n    const shouldCopy = movingShapeIds.has(binding.fromId) && movingShapeIds.has(binding.toId);\n    if (shouldCopy) {\n      toPage.before.bindings[binding.id] = void 0;\n      toPage.after.bindings[binding.id] = binding;\n    } else {\n      if (movingShapeIds.has(binding.fromId)) {\n        const fromShape = app.getShape(binding.fromId, fromPageId);\n        const handle = Object.values(fromBoundShape.handles).find((handle2) => handle2.bindingId === binding.id);\n        const handleId = handle.id;\n        const toPageShape = toPage.after.shapes[fromShape.id];\n        toPageShape.handles = {\n          ...toPageShape.handles,\n          [handleId]: {\n            ...toPageShape.handles[handleId],\n            bindingId: void 0\n          }\n        };\n      } else {\n        const fromShape = app.getShape(binding.fromId, fromPageId);\n        const handle = Object.values(fromBoundShape.handles).find((handle2) => handle2.bindingId === binding.id);\n        fromPage.before.shapes[fromShape.id] = {\n          handles: { [handle.id]: { bindingId: binding.id } }\n        };\n        fromPage.after.shapes[fromShape.id] = {\n          handles: { [handle.id]: { bindingId: void 0 } }\n        };\n      }\n    }\n  });\n  const toPageState = app.state.document.pageStates[toPageId];\n  const bounds = C3.getCommonBounds(movingShapes.map((shape) => TLDR.getBounds(shape)));\n  const zoom = TLDR.getCameraZoom(\n    viewportBounds.width < viewportBounds.height ? (viewportBounds.width - 128) / bounds.width : (viewportBounds.height - 128) / bounds.height\n  );\n  const mx = (viewportBounds.width - bounds.width * zoom) / 2 / zoom;\n  const my = (viewportBounds.height - bounds.height * zoom) / 2 / zoom;\n  const point = e.toFixed(e.add([-bounds.minX, -bounds.minY], [mx, my]));\n  return {\n    id: \"move_to_page\",\n    before: {\n      appState: {\n        currentPageId: fromPageId\n      },\n      document: {\n        pages: {\n          [fromPageId]: fromPage.before,\n          [toPageId]: toPage.before\n        },\n        pageStates: {\n          [fromPageId]: { selectedIds: ids },\n          [toPageId]: {\n            selectedIds: toPageState.selectedIds,\n            camera: toPageState.camera\n          }\n        }\n      }\n    },\n    after: {\n      appState: {\n        currentPageId: toPageId\n      },\n      document: {\n        pages: {\n          [fromPageId]: fromPage.after,\n          [toPageId]: toPage.after\n        },\n        pageStates: {\n          [fromPageId]: { selectedIds: [] },\n          [toPageId]: {\n            selectedIds: ids,\n            camera: {\n              zoom,\n              point\n            }\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/movePage/movePage.ts\nfunction movePage(app, pageId, index2) {\n  const { pages } = app.document;\n  const movingPage = pages[pageId];\n  const beforePages = Object.values(pages).sort((a7, b6) => (a7.childIndex ?? 0) - (b6.childIndex ?? 0));\n  const fromIndex = beforePages.indexOf(movingPage);\n  const afterPages = [...beforePages];\n  afterPages.splice(fromIndex, 1);\n  afterPages.splice(index2 > fromIndex ? index2 - 1 : index2, 0, movingPage);\n  return {\n    id: \"move_page\",\n    before: {\n      document: {\n        pages: Object.fromEntries(beforePages.map((p6) => [p6.id, { childIndex: p6.childIndex }]))\n      }\n    },\n    after: {\n      document: {\n        pages: Object.fromEntries(afterPages.map((p6, childIndex) => [p6.id, { childIndex }]))\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/reorderShapes/reorderShapes.ts\nfunction reorderShapes(app, ids, type) {\n  const { currentPageId, page } = app;\n  const parentIds = new Set(ids.map((id) => app.getShape(id).parentId));\n  let result = { before: {}, after: {} };\n  let startIndex;\n  let startChildIndex;\n  let step;\n  [...parentIds.values()].forEach((parentId) => {\n    let sortedChildren = [];\n    if (parentId === page.id) {\n      sortedChildren = Object.values(page.shapes).sort((a7, b6) => a7.childIndex - b6.childIndex);\n    } else {\n      const parent = app.getShape(parentId);\n      if (!parent.children)\n        throw new Error(\"No children in parent!\");\n      sortedChildren = parent.children.map((childId) => app.getShape(childId)).sort((a7, b6) => a7.childIndex - b6.childIndex);\n    }\n    const sortedChildIds = sortedChildren.map((shape) => shape.id);\n    const sortedIndicesToMove = ids.filter((id) => sortedChildIds.includes(id)).map((id) => sortedChildIds.indexOf(id)).sort((a7, b6) => a7 - b6);\n    if (sortedIndicesToMove.length === sortedChildIds.length)\n      return;\n    switch (type) {\n      case \"toBack\" /* ToBack */: {\n        for (let i4 = 0; i4 < sortedChildIds.length; i4++) {\n          if (sortedIndicesToMove.includes(i4))\n            continue;\n          startIndex = i4;\n          break;\n        }\n        startChildIndex = sortedChildren[startIndex].childIndex;\n        step = startChildIndex / (sortedIndicesToMove.length + 1);\n        result = TLDR.mutateShapes(\n          app.state,\n          sortedIndicesToMove.map((i4) => sortedChildren[i4].id).reverse(),\n          (_shape, i4) => ({\n            childIndex: startChildIndex - (i4 + 1) * step\n          }),\n          currentPageId\n        );\n        break;\n      }\n      case \"toFront\" /* ToFront */: {\n        for (let i4 = sortedChildIds.length - 1; i4 >= 0; i4--) {\n          if (sortedIndicesToMove.includes(i4))\n            continue;\n          startIndex = i4;\n          break;\n        }\n        startChildIndex = sortedChildren[startIndex].childIndex;\n        step = 1;\n        result = TLDR.mutateShapes(\n          app.state,\n          sortedIndicesToMove.map((i4) => sortedChildren[i4].id),\n          (_shape, i4) => ({\n            childIndex: startChildIndex + (i4 + 1)\n          }),\n          currentPageId\n        );\n        break;\n      }\n      case \"backward\" /* Backward */: {\n        const indexMap = {};\n        for (let i4 = sortedChildIds.length - 1; i4 >= 0; i4--) {\n          if (sortedIndicesToMove.includes(i4)) {\n            for (let j4 = i4; j4 >= 0; j4--) {\n              if (!sortedIndicesToMove.includes(j4)) {\n                const endChildIndex = sortedChildren[j4].childIndex;\n                let startChildIndex2;\n                let step2;\n                if (j4 === 0) {\n                  startChildIndex2 = endChildIndex / 2;\n                  step2 = endChildIndex / 2 / (i4 - j4 + 1);\n                } else {\n                  startChildIndex2 = sortedChildren[j4 - 1].childIndex;\n                  step2 = (endChildIndex - startChildIndex2) / (i4 - j4 + 1);\n                  startChildIndex2 += step2;\n                }\n                for (let k7 = 0; k7 < i4 - j4; k7++) {\n                  indexMap[sortedChildren[j4 + k7 + 1].id] = startChildIndex2 + step2 * k7;\n                }\n                break;\n              }\n            }\n          }\n        }\n        if (Object.values(indexMap).length > 0) {\n          result = TLDR.mutateShapes(\n            app.state,\n            sortedIndicesToMove.map((i4) => sortedChildren[i4].id),\n            (shape) => ({\n              childIndex: indexMap[shape.id]\n            }),\n            currentPageId\n          );\n        }\n        break;\n      }\n      case \"forward\" /* Forward */: {\n        const indexMap = {};\n        for (let i4 = 0; i4 < sortedChildIds.length; i4++) {\n          if (sortedIndicesToMove.includes(i4)) {\n            for (let j4 = i4; j4 < sortedChildIds.length; j4++) {\n              if (!sortedIndicesToMove.includes(j4)) {\n                startChildIndex = sortedChildren[j4].childIndex;\n                const step2 = j4 === sortedChildIds.length - 1 ? 1 : (sortedChildren[j4 + 1].childIndex - startChildIndex) / (j4 - i4 + 1);\n                for (let k7 = 0; k7 < j4 - i4; k7++) {\n                  indexMap[sortedChildren[i4 + k7].id] = startChildIndex + step2 * (k7 + 1);\n                }\n                break;\n              }\n            }\n          }\n        }\n        if (Object.values(indexMap).length > 0) {\n          result = TLDR.mutateShapes(\n            app.state,\n            sortedIndicesToMove.map((i4) => sortedChildren[i4].id),\n            (shape) => ({\n              childIndex: indexMap[shape.id]\n            }),\n            currentPageId\n          );\n        }\n        break;\n      }\n    }\n  });\n  return {\n    id: \"move\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: result.before }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: result.after }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/renamePage/renamePage.ts\nfunction renamePage(app, pageId, name) {\n  const { page } = app;\n  return {\n    id: \"rename_page\",\n    before: {\n      document: {\n        pages: {\n          [pageId]: { name: page.name }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [pageId]: { name }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/resetBounds/resetBounds.ts\nfunction resetBounds(app, ids, pageId) {\n  const { currentPageId } = app;\n  const { before, after } = TLDR.mutateShapes(app.state, ids, (shape) => app.getShapeUtil(shape).onDoubleClickBoundsHandle?.(shape), pageId);\n  return {\n    id: \"reset_bounds\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: before }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: after }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/rotateShapes/rotateShapes.ts\nvar PI23 = Math.PI * 2;\nfunction rotateShapes(app, ids, delta = -PI23 / 4) {\n  const { currentPageId } = app;\n  const before = {};\n  const after = {};\n  const shapesToRotate = ids.flatMap((id) => {\n    const shape = app.getShape(id);\n    return shape.children ? shape.children.map((childId) => app.getShape(childId)) : shape;\n  }).filter((shape) => !shape.isLocked);\n  const origin = C3.getBoundsCenter(C3.getCommonBounds(shapesToRotate.map((shape) => TLDR.getBounds(shape))));\n  shapesToRotate.forEach((shape) => {\n    const change = TLDR.getRotatedShapeMutation(shape, TLDR.getCenter(shape), origin, delta);\n    if (!change)\n      return;\n    before[shape.id] = TLDR.getBeforeShape(shape, change);\n    after[shape.id] = change;\n  });\n  return {\n    id: \"rotate\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: before }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: after }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/stretchShapes/stretchShapes.ts\nfunction stretchShapes(app, ids, type) {\n  const { currentPageId, selectedIds } = app;\n  const initialShapes = ids.map((id) => app.getShape(id));\n  const boundsForShapes = initialShapes.map((shape) => TLDR.getBounds(shape));\n  const commonBounds = C3.getCommonBounds(boundsForShapes);\n  const idsToMutate = ids.flatMap((id) => {\n    const shape = app.getShape(id);\n    return shape.children ? shape.children : shape.id;\n  }).filter((id) => !app.getShape(id).isLocked);\n  const { before, after } = TLDR.mutateShapes(\n    app.state,\n    idsToMutate,\n    (shape) => {\n      const bounds = TLDR.getBounds(shape);\n      switch (type) {\n        case \"horizontal\" /* Horizontal */: {\n          const newBounds = {\n            ...bounds,\n            minX: commonBounds.minX,\n            maxX: commonBounds.maxX,\n            width: commonBounds.width\n          };\n          return TLDR.getShapeUtil(shape).transformSingle(shape, newBounds, {\n            type: He.TopLeft,\n            scaleX: newBounds.width / bounds.width,\n            scaleY: 1,\n            initialShape: shape,\n            transformOrigin: [0.5, 0.5]\n          });\n        }\n        case \"vertical\" /* Vertical */: {\n          const newBounds = {\n            ...bounds,\n            minY: commonBounds.minY,\n            maxY: commonBounds.maxY,\n            height: commonBounds.height\n          };\n          return TLDR.getShapeUtil(shape).transformSingle(shape, newBounds, {\n            type: He.TopLeft,\n            scaleX: 1,\n            scaleY: newBounds.height / bounds.height,\n            initialShape: shape,\n            transformOrigin: [0.5, 0.5]\n          });\n        }\n      }\n    },\n    currentPageId\n  );\n  initialShapes.forEach((shape) => {\n    if (shape.type === \"group\" /* Group */) {\n      delete before[shape.id];\n      delete after[shape.id];\n    }\n  });\n  return {\n    id: \"stretch\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: before }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: after }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/styleShapes/styleShapes.ts\nfunction styleShapes(app, ids, changes) {\n  const { currentPageId, selectedIds } = app;\n  const shapeIdsToMutate = ids.flatMap((id) => TLDR.getDocumentBranch(app.state, id, currentPageId)).filter((id) => !app.getShape(id).isLocked);\n  const beforeShapes = {};\n  const afterShapes = {};\n  shapeIdsToMutate.map((id) => app.getShape(id)).filter((shape) => !shape.isLocked).forEach((shape) => {\n    beforeShapes[shape.id] = {\n      style: {\n        ...Object.fromEntries(Object.keys(changes).map((key) => [key, shape.style[key]]))\n      }\n    };\n    afterShapes[shape.id] = {\n      style: changes\n    };\n    if (shape.type === \"text\" /* Text */) {\n      beforeShapes[shape.id].point = shape.point;\n      afterShapes[shape.id].point = e.toFixed(\n        e.add(\n          shape.point,\n          e.sub(\n            app.getShapeUtil(shape).getCenter(shape),\n            app.getShapeUtil(shape).getCenter({\n              ...shape,\n              style: { ...shape.style, ...changes }\n            })\n          )\n        )\n      );\n    }\n  });\n  return {\n    id: \"style\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: beforeShapes\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds\n          }\n        }\n      },\n      appState: {\n        currentStyle: { ...app.appState.currentStyle }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: afterShapes\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      },\n      appState: {\n        currentStyle: changes\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/toggleShapesDecoration/toggleShapesDecoration.ts\nfunction toggleShapesDecoration(app, ids, decorationId) {\n  const { currentPageId, selectedIds } = app;\n  const beforeShapes = Object.fromEntries(\n    ids.map((id) => [\n      id,\n      {\n        decorations: {\n          [decorationId]: app.getShape(id).decorations?.[decorationId]\n        }\n      }\n    ])\n  );\n  const afterShapes = Object.fromEntries(\n    ids.filter((id) => !app.getShape(id).isLocked).map((id) => [\n      id,\n      {\n        decorations: {\n          [decorationId]: app.getShape(id).decorations?.[decorationId] ? void 0 : \"arrow\" /* Arrow */\n        }\n      }\n    ])\n  );\n  return {\n    id: \"toggle_decorations\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: beforeShapes }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: { shapes: afterShapes }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/toggleShapesProp/toggleShapesProp.ts\nfunction toggleShapeProp(app, ids, prop) {\n  const { currentPageId } = app;\n  const initialShapes = ids.map((id) => app.getShape(id)).filter((shape) => prop === \"isLocked\" ? true : !shape.isLocked);\n  const isAllToggled = initialShapes.every((shape) => shape[prop]);\n  const before = {};\n  const after = {};\n  initialShapes.forEach((shape) => {\n    before[shape.id] = { [prop]: shape[prop] };\n    after[shape.id] = { [prop]: !isAllToggled };\n  });\n  return {\n    id: \"toggle\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: before\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: after\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/translateShapes/translateShapes.ts\nfunction translateShapes(app, ids, delta) {\n  const { currentPageId, selectedIds } = app;\n  app.rotationInfo.selectedIds = [...selectedIds];\n  const before = {\n    shapes: {},\n    bindings: {}\n  };\n  const after = {\n    shapes: {},\n    bindings: {}\n  };\n  const idsToMutate = ids.flatMap((id) => {\n    const shape = app.getShape(id);\n    return shape.children ? shape.children : shape.id;\n  }).filter((id) => !app.getShape(id).isLocked);\n  const change = TLDR.mutateShapes(\n    app.state,\n    idsToMutate,\n    (shape) => ({\n      point: e.toFixed(e.add(shape.point, delta))\n    }),\n    currentPageId\n  );\n  before.shapes = change.before;\n  after.shapes = change.after;\n  const bindingsToDelete = TLDR.getBindings(app.state, currentPageId).filter((binding) => ids.includes(binding.fromId) && !ids.includes(binding.toId));\n  bindingsToDelete.forEach((binding) => {\n    before.bindings[binding.id] = binding;\n    after.bindings[binding.id] = void 0;\n    for (const id of [binding.toId, binding.fromId]) {\n      const shape = app.getShape(id);\n      if (!shape.handles)\n        continue;\n      Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {\n        before.shapes[id] = {\n          ...before.shapes[id],\n          handles: {\n            ...before.shapes[id]?.handles,\n            [handle.id]: { bindingId: binding.id }\n          }\n        };\n        after.shapes[id] = {\n          ...after.shapes[id],\n          handles: { ...after.shapes[id]?.handles, [handle.id]: { bindingId: void 0 } }\n        };\n      });\n    }\n  });\n  return {\n    id: \"translate\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: before\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: after\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: ids\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/ungroupShapes/ungroupShapes.ts\nfunction ungroupShapes(app, selectedIds, groupShapes2, pageId) {\n  const { bindings } = app;\n  const beforeShapes = {};\n  const afterShapes = {};\n  const beforeBindings = {};\n  const afterBindings = {};\n  const beforeSelectedIds = selectedIds;\n  const afterSelectedIds = selectedIds.filter((id) => !groupShapes2.find((shape) => shape.id === id));\n  groupShapes2.filter((shape) => !shape.isLocked).forEach((groupShape) => {\n    const shapesToReparent = [];\n    const deletedGroupIds = [];\n    beforeShapes[groupShape.id] = groupShape;\n    afterShapes[groupShape.id] = void 0;\n    groupShape.children.forEach((id) => {\n      afterSelectedIds.push(id);\n      const shape = app.getShape(id, pageId);\n      shapesToReparent.push(shape);\n    });\n    const startingChildIndex = groupShape.childIndex;\n    const endingChildIndex = TLDR.getChildIndexAbove(app.state, groupShape.id, pageId);\n    const step = (endingChildIndex - startingChildIndex) / shapesToReparent.length;\n    const sortedShapes = shapesToReparent.sort((a7, b6) => a7.childIndex - b6.childIndex);\n    sortedShapes.forEach((shape, index2) => {\n      beforeShapes[shape.id] = {\n        parentId: shape.parentId,\n        childIndex: shape.childIndex\n      };\n      afterShapes[shape.id] = {\n        parentId: pageId,\n        childIndex: startingChildIndex + step * index2\n      };\n    });\n    bindings.filter((binding) => binding.toId === groupShape.id || binding.fromId === groupShape.id).forEach((binding) => {\n      for (const id of [binding.toId, binding.fromId]) {\n        if (afterShapes[id] === void 0) {\n          beforeBindings[binding.id] = binding;\n          afterBindings[binding.id] = void 0;\n          const shape = app.getShape(id, pageId);\n          if (shape.handles) {\n            Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {\n              beforeShapes[id] = {\n                ...beforeShapes[id],\n                handles: {\n                  ...beforeShapes[id]?.handles,\n                  [handle.id]: { bindingId: binding.id }\n                }\n              };\n              if (!deletedGroupIds.includes(id)) {\n                afterShapes[id] = {\n                  ...afterShapes[id],\n                  handles: {\n                    ...afterShapes[id]?.handles,\n                    [handle.id]: { bindingId: void 0 }\n                  }\n                };\n              }\n            });\n          }\n        }\n      }\n    });\n  });\n  return {\n    id: \"ungroup\",\n    before: {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: beforeShapes,\n            bindings: beforeBindings\n          }\n        },\n        pageStates: {\n          [pageId]: {\n            selectedIds: beforeSelectedIds\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: afterShapes,\n            bindings: beforeBindings\n          }\n        },\n        pageStates: {\n          [pageId]: {\n            selectedIds: afterSelectedIds\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/updateShapes/updateShapes.ts\nfunction updateShapes(app, updates, pageId) {\n  const ids = updates.map((update) => update.id);\n  const change = TLDR.mutateShapes(\n    app.state,\n    ids.filter((id) => !app.getShape(id, pageId).isLocked),\n    (_shape, i4) => updates[i4],\n    pageId\n  );\n  return {\n    id: \"update\",\n    before: {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: change.before\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: change.after\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/setShapesProps/setShapesProps.ts\nfunction setShapesProps(app, ids, partial) {\n  const { currentPageId, selectedIds } = app;\n  const initialShapes = ids.map((id) => app.getShape(id)).filter((shape) => partial.isLocked ? true : !shape.isLocked);\n  const before = {};\n  const after = {};\n  const keys = Object.keys(partial);\n  initialShapes.forEach((shape) => {\n    before[shape.id] = Object.fromEntries(keys.map((key) => [key, shape[key]]));\n    after[shape.id] = partial;\n  });\n  return {\n    id: \"set_props\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: before\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds\n          }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: after\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/commands/insertContent/insertContent.ts\nfunction insertContent(app, content, opts = {}) {\n  const { currentPageId } = app;\n  const { point, select, overwrite } = opts;\n  const page = app.document.pages[currentPageId];\n  const before = {\n    shapes: {},\n    bindings: {}\n  };\n  const afterAssets = {};\n  const after = {\n    shapes: {},\n    bindings: {}\n  };\n  if (overwrite) {\n    for (const shape of content.shapes) {\n      before.shapes[shape.id] = page.shapes[shape.id];\n      after.shapes[shape.id] = shape;\n    }\n    if (content.bindings) {\n      for (const binding of content.bindings) {\n        before.bindings[binding.id] = page.bindings[binding.id];\n        after.bindings[binding.id] = binding;\n      }\n    }\n    if (content.assets) {\n      for (const asset of content.assets) {\n        afterAssets[asset.id] = asset;\n      }\n    }\n  } else {\n    const oldToNewIds = {};\n    let nextIndex = TLDR.getTopChildIndex(app.state, currentPageId);\n    const shapesToInsert = content.shapes.sort((a7, b6) => a7.childIndex - b6.childIndex).map((shape) => {\n      const newShapeId = C3.uniqueId();\n      oldToNewIds[shape.id] = newShapeId;\n      return {\n        ...C3.deepClone(shape),\n        id: newShapeId\n      };\n    });\n    const visited = /* @__PURE__ */ new Set();\n    while (shapesToInsert.length > 0) {\n      const shape = shapesToInsert.shift();\n      if (!shape)\n        break;\n      visited.add(shape.id);\n      if (shape.parentId === \"currentPageId\") {\n        shape.parentId = currentPageId;\n        shape.childIndex = nextIndex++;\n      } else {\n        shape.parentId = oldToNewIds[shape.parentId];\n        const parent = after.shapes[shape.parentId];\n        if (!parent) {\n          if (visited.has(shape.id)) {\n            shape.parentId = \"currentPageId\";\n          }\n          shapesToInsert.push(shape);\n          continue;\n        }\n        parent.children.push(shape.id);\n      }\n      if (shape.children) {\n        shape.children = [];\n      }\n      before.shapes[shape.id] = void 0;\n      after.shapes[shape.id] = shape;\n    }\n    Object.values(after.shapes).forEach((shape) => {\n      if (shape.children && shape.children.length === 0) {\n        delete before.shapes[shape.id];\n        delete after.shapes[shape.id];\n      }\n    });\n    if (content.bindings) {\n      content.bindings.forEach((binding) => {\n        const newBindingId = C3.uniqueId();\n        oldToNewIds[binding.id] = newBindingId;\n        const toId = oldToNewIds[binding.toId];\n        const fromId = oldToNewIds[binding.fromId];\n        if (!toId || !fromId) {\n          if (fromId) {\n            const handles = after.shapes[fromId].handles;\n            if (handles) {\n              Object.values(handles).forEach((handle) => {\n                if (handle.bindingId === binding.id) {\n                  handle.bindingId = void 0;\n                }\n              });\n            }\n          }\n          if (toId) {\n            const handles = after.shapes[toId].handles;\n            if (handles) {\n              Object.values(handles).forEach((handle) => {\n                if (handle.bindingId === binding.id) {\n                  handle.bindingId = void 0;\n                }\n              });\n            }\n          }\n          return;\n        }\n        const fromHandles = after.shapes[fromId].handles;\n        if (fromHandles) {\n          Object.values(fromHandles).forEach((handle) => {\n            if (handle.bindingId === binding.id) {\n              handle.bindingId = newBindingId;\n            }\n          });\n        }\n        const toHandles = after.shapes[toId].handles;\n        if (toHandles) {\n          Object.values(after.shapes[toId].handles).forEach((handle) => {\n            if (handle.bindingId === binding.id) {\n              handle.bindingId = newBindingId;\n            }\n          });\n        }\n        const newBinding = {\n          ...C3.deepClone(binding),\n          id: newBindingId,\n          toId,\n          fromId\n        };\n        before.bindings[newBinding.id] = void 0;\n        after.bindings[newBinding.id] = newBinding;\n      });\n    }\n    const shapesToMove = Object.values(after.shapes);\n    if (shapesToMove.length > 0) {\n      if (point) {\n        const commonBounds = C3.getCommonBounds(shapesToMove.map((shape) => TLDR.getBounds(shape)));\n        const center = C3.getBoundsCenter(commonBounds);\n        shapesToMove.forEach((shape) => {\n          if (!shape.point)\n            return;\n          shape.point = e.sub(point, e.sub(center, shape.point));\n        });\n      } else {\n        const commonBounds = C3.getCommonBounds(shapesToMove.map(TLDR.getBounds));\n        if (!(C3.boundsContain(app.viewport, commonBounds) || C3.boundsCollide(app.viewport, commonBounds))) {\n          const center = e.toFixed(app.getPagePoint(app.centerPoint));\n          const centeredBounds = C3.centerBounds(commonBounds, center);\n          const delta = e.sub(C3.getBoundsCenter(centeredBounds), C3.getBoundsCenter(commonBounds));\n          shapesToMove.forEach((shape) => {\n            shape.point = e.toFixed(e.add(shape.point, delta));\n          });\n        }\n      }\n    }\n    if (content.assets) {\n      for (const asset of content.assets) {\n        afterAssets[asset.id] = asset;\n      }\n    }\n  }\n  const elm = document.createElement(\"textarea\");\n  Object.values(after.shapes).forEach((shape) => {\n    if (\"text\" in shape) {\n      elm.innerHTML = shape.text;\n      shape.text = elm.value;\n    }\n    if (\"label\" in shape) {\n      elm.innerHTML = shape.label;\n      shape.label = elm.value;\n    }\n  });\n  elm.remove();\n  return {\n    id: \"insert\",\n    before: {\n      document: {\n        pages: {\n          [currentPageId]: before\n        },\n        pageStates: {\n          [currentPageId]: { selectedIds: [...app.selectedIds] }\n        }\n      }\n    },\n    after: {\n      document: {\n        pages: {\n          [currentPageId]: after\n        },\n        assets: afterAssets,\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: select ? Object.keys(after.shapes) : [...app.selectedIds]\n          }\n        }\n      }\n    }\n  };\n}\n\n// src/components/Tldraw/state/data/migrate.ts\nfunction migrate(state, newVersion) {\n  const { document: document2, settings } = state;\n  const { version = 0 } = document2;\n  if (!(\"assets\" in document2)) {\n    document2.assets = {};\n  }\n  const assetIdsInUse = /* @__PURE__ */ new Set();\n  Object.values(document2.pages).forEach(\n    (page) => Object.values(page.shapes).forEach((shape) => {\n      const { parentId, children, assetId } = shape;\n      if (assetId) {\n        assetIdsInUse.add(assetId);\n      }\n      if (parentId !== page.id && !page.shapes[parentId]) {\n        console.warn(\"Encountered a shape with a missing parent!\");\n        shape.parentId = page.id;\n      }\n      if (shape.type === \"group\" /* Group */ && children) {\n        children.forEach((childId) => {\n          if (!page.shapes[childId]) {\n            console.warn(\"Encountered a parent with a missing child!\", shape.id, childId);\n            children?.splice(children.indexOf(childId), 1);\n          }\n        });\n      }\n    })\n  );\n  Object.keys(document2.assets).forEach((assetId) => {\n    if (!assetIdsInUse.has(assetId)) {\n      delete document2.assets[assetId];\n    }\n  });\n  if (version !== newVersion) {\n    if (version < 14) {\n      Object.values(document2.pages).forEach((page) => {\n        Object.values(page.shapes).filter((shape) => shape.type === \"text\" /* Text */).forEach((shape) => shape.style.font === \"script\" /* Script */);\n      });\n    }\n    if (version <= 13) {\n      Object.values(document2.pages).forEach((page) => {\n        Object.values(page.bindings).forEach((binding) => {\n          Object.assign(binding, binding.meta);\n        });\n        Object.values(page.shapes).forEach((shape) => {\n          Object.entries(shape.style).forEach(([id, style]) => {\n            if (typeof style === \"string\") {\n              shape.style[id] = style.toLowerCase();\n            }\n          });\n          if (shape.type === \"arrow\" /* Arrow */ && shape.decorations) {\n            Object.entries(shape.decorations).forEach(([id, decoration]) => {\n              if (decoration === \"Arrow\") {\n                shape.decorations = {\n                  ...shape.decorations,\n                  [id]: \"arrow\" /* Arrow */\n                };\n              }\n            });\n          }\n        });\n      });\n    }\n    if (version <= 13.1) {\n      document2.name = \"New Document\";\n    }\n    if (version < 15) {\n      document2.assets = {};\n    }\n    Object.values(document2.pages).forEach((page) => {\n      Object.values(page.shapes).forEach((shape) => {\n        if (version < 15.2 && shape.type === \"image\" /* Image */) {\n          shape.style.isFilled = true;\n        }\n        if (version < 15.3 && (shape.type === \"rectangle\" /* Rectangle */ || shape.type === \"triangle\" /* Triangle */ || shape.type === \"ellipse\" /* Ellipse */ || shape.type === \"arrow\" /* Arrow */)) {\n          shape.label = shape.text || \"\";\n          shape.labelPoint = [0.5, 0.5];\n        }\n      });\n    });\n    if (version < 15.4) {\n      settings.dockPosition = \"bottom\";\n    }\n    if (version < 15.5) {\n      settings.exportBackground = \"transparent\" /* Transparent */;\n    }\n  }\n  Object.values(document2.pageStates).forEach((pageState) => {\n    pageState.selectedIds = pageState.selectedIds.filter((id) => {\n      return document2.pages[pageState.id].shapes[id] !== void 0;\n    });\n    pageState.bindingId = void 0;\n    pageState.editingId = void 0;\n    pageState.hoveredId = void 0;\n    pageState.pointedId = void 0;\n  });\n  document2.version = newVersion;\n  return state;\n}\n\n// node_modules/.pnpm/browser-fs-access@0.34.1/node_modules/browser-fs-access/dist/index.modern.js\nvar e4 = (() => {\n  if (\"undefined\" == typeof self)\n    return false;\n  if (\"top\" in self && self !== top)\n    try {\n      top;\n    } catch (e5) {\n      return false;\n    }\n  return \"showOpenFilePicker\" in self;\n})();\nvar t4 = e4 ? Promise.resolve().then(function() {\n  return l6;\n}) : Promise.resolve().then(function() {\n  return v5;\n});\nasync function n4(...e5) {\n  return (await t4).default(...e5);\n}\nvar r4 = e4 ? Promise.resolve().then(function() {\n  return y5;\n}) : Promise.resolve().then(function() {\n  return b5;\n});\nvar a6 = e4 ? Promise.resolve().then(function() {\n  return m5;\n}) : Promise.resolve().then(function() {\n  return k6;\n});\nvar s4 = async (e5) => {\n  const t5 = await e5.getFile();\n  return t5.handle = e5, t5;\n};\nvar c4 = async (e5 = [{}]) => {\n  Array.isArray(e5) || (e5 = [e5]);\n  const t5 = [];\n  e5.forEach((e6, n6) => {\n    t5[n6] = { description: e6.description || \"Files\", accept: {} }, e6.mimeTypes ? e6.mimeTypes.map((r6) => {\n      t5[n6].accept[r6] = e6.extensions || [];\n    }) : t5[n6].accept[\"*/*\"] = e6.extensions || [];\n  });\n  const n5 = await window.showOpenFilePicker({ id: e5[0].id, startIn: e5[0].startIn, types: t5, multiple: e5[0].multiple || false, excludeAcceptAllOption: e5[0].excludeAcceptAllOption || false }), r5 = await Promise.all(n5.map(s4));\n  return e5[0].multiple ? r5 : r5[0];\n};\nvar l6 = { __proto__: null, default: c4 };\nfunction u4(e5) {\n  function t5(e6) {\n    if (Object(e6) !== e6)\n      return Promise.reject(new TypeError(e6 + \" is not an object.\"));\n    var t6 = e6.done;\n    return Promise.resolve(e6.value).then(function(e7) {\n      return { value: e7, done: t6 };\n    });\n  }\n  return u4 = function(e6) {\n    this.s = e6, this.n = e6.next;\n  }, u4.prototype = { s: null, n: null, next: function() {\n    return t5(this.n.apply(this.s, arguments));\n  }, return: function(e6) {\n    var n5 = this.s.return;\n    return void 0 === n5 ? Promise.resolve({ value: e6, done: true }) : t5(n5.apply(this.s, arguments));\n  }, throw: function(e6) {\n    var n5 = this.s.return;\n    return void 0 === n5 ? Promise.reject(e6) : t5(n5.apply(this.s, arguments));\n  } }, new u4(e5);\n}\nvar p5 = async (e5, t5, n5 = e5.name, r5) => {\n  const i4 = [], a7 = [];\n  var o5, s5 = false, c5 = false;\n  try {\n    for (var l7, d6 = function(e6) {\n      var t6, n6, r6, i5 = 2;\n      for (\"undefined\" != typeof Symbol && (n6 = Symbol.asyncIterator, r6 = Symbol.iterator); i5--; ) {\n        if (n6 && null != (t6 = e6[n6]))\n          return t6.call(e6);\n        if (r6 && null != (t6 = e6[r6]))\n          return new u4(t6.call(e6));\n        n6 = \"@@asyncIterator\", r6 = \"@@iterator\";\n      }\n      throw new TypeError(\"Object is not async iterable\");\n    }(e5.values()); s5 = !(l7 = await d6.next()).done; s5 = false) {\n      const o6 = l7.value, s6 = `${n5}/${o6.name}`;\n      \"file\" === o6.kind ? a7.push(o6.getFile().then((t6) => (t6.directoryHandle = e5, t6.handle = o6, Object.defineProperty(t6, \"webkitRelativePath\", { configurable: true, enumerable: true, get: () => s6 })))) : \"directory\" !== o6.kind || !t5 || r5 && r5(o6) || i4.push(p5(o6, t5, s6, r5));\n    }\n  } catch (e6) {\n    c5 = true, o5 = e6;\n  } finally {\n    try {\n      s5 && null != d6.return && await d6.return();\n    } finally {\n      if (c5)\n        throw o5;\n    }\n  }\n  return [...(await Promise.all(i4)).flat(), ...await Promise.all(a7)];\n};\nvar d5 = async (e5 = {}) => {\n  e5.recursive = e5.recursive || false, e5.mode = e5.mode || \"read\";\n  const t5 = await window.showDirectoryPicker({ id: e5.id, startIn: e5.startIn, mode: e5.mode });\n  return (await (await t5.values()).next()).done ? [t5] : p5(t5, e5.recursive, void 0, e5.skipDirectory);\n};\nvar y5 = { __proto__: null, default: d5 };\nvar f4 = async (e5, t5 = [{}], n5 = null, r5 = false, i4 = null) => {\n  Array.isArray(t5) || (t5 = [t5]), t5[0].fileName = t5[0].fileName || \"Untitled\";\n  const a7 = [];\n  let o5 = null;\n  if (e5 instanceof Blob && e5.type ? o5 = e5.type : e5.headers && e5.headers.get(\"content-type\") && (o5 = e5.headers.get(\"content-type\")), t5.forEach((e6, t6) => {\n    a7[t6] = { description: e6.description || \"Files\", accept: {} }, e6.mimeTypes ? (0 === t6 && o5 && e6.mimeTypes.push(o5), e6.mimeTypes.map((n6) => {\n      a7[t6].accept[n6] = e6.extensions || [];\n    })) : o5 ? a7[t6].accept[o5] = e6.extensions || [] : a7[t6].accept[\"*/*\"] = e6.extensions || [];\n  }), n5)\n    try {\n      await n5.getFile();\n    } catch (e6) {\n      if (n5 = null, r5)\n        throw e6;\n    }\n  const s5 = n5 || await window.showSaveFilePicker({ suggestedName: t5[0].fileName, id: t5[0].id, startIn: t5[0].startIn, types: a7, excludeAcceptAllOption: t5[0].excludeAcceptAllOption || false });\n  !n5 && i4 && i4(s5);\n  const c5 = await s5.createWritable();\n  if (\"stream\" in e5) {\n    const t6 = e5.stream();\n    return await t6.pipeTo(c5), s5;\n  }\n  return \"body\" in e5 ? (await e5.body.pipeTo(c5), s5) : (await c5.write(await e5), await c5.close(), s5);\n};\nvar m5 = { __proto__: null, default: f4 };\nvar w6 = async (e5 = [{}]) => (Array.isArray(e5) || (e5 = [e5]), new Promise((t5, n5) => {\n  const r5 = document.createElement(\"input\");\n  r5.type = \"file\";\n  const i4 = [...e5.map((e6) => e6.mimeTypes || []), ...e5.map((e6) => e6.extensions || [])].join();\n  r5.multiple = e5[0].multiple || false, r5.accept = i4 || \"\", r5.style.display = \"none\", document.body.append(r5);\n  const a7 = (e6) => {\n    \"function\" == typeof o5 && o5(), t5(e6);\n  }, o5 = e5[0].legacySetup && e5[0].legacySetup(a7, () => o5(n5), r5), s5 = () => {\n    window.removeEventListener(\"focus\", s5), r5.remove();\n  };\n  r5.addEventListener(\"click\", () => {\n    window.addEventListener(\"focus\", s5);\n  }), r5.addEventListener(\"change\", () => {\n    window.removeEventListener(\"focus\", s5), r5.remove(), a7(r5.multiple ? Array.from(r5.files) : r5.files[0]);\n  }), \"showPicker\" in HTMLInputElement.prototype ? r5.showPicker() : r5.click();\n}));\nvar v5 = { __proto__: null, default: w6 };\nvar h5 = async (e5 = [{}]) => (Array.isArray(e5) || (e5 = [e5]), e5[0].recursive = e5[0].recursive || false, new Promise((t5, n5) => {\n  const r5 = document.createElement(\"input\");\n  r5.type = \"file\", r5.webkitdirectory = true;\n  const i4 = (e6) => {\n    \"function\" == typeof a7 && a7(), t5(e6);\n  }, a7 = e5[0].legacySetup && e5[0].legacySetup(i4, () => a7(n5), r5);\n  r5.addEventListener(\"change\", () => {\n    let t6 = Array.from(r5.files);\n    e5[0].recursive ? e5[0].recursive && e5[0].skipDirectory && (t6 = t6.filter((t7) => t7.webkitRelativePath.split(\"/\").every((t8) => !e5[0].skipDirectory({ name: t8, kind: \"directory\" })))) : t6 = t6.filter((e6) => 2 === e6.webkitRelativePath.split(\"/\").length), i4(t6);\n  }), \"showPicker\" in HTMLInputElement.prototype ? r5.showPicker() : r5.click();\n}));\nvar b5 = { __proto__: null, default: h5 };\nvar P4 = async (e5, t5 = {}) => {\n  Array.isArray(t5) && (t5 = t5[0]);\n  const n5 = document.createElement(\"a\");\n  let r5 = e5;\n  \"body\" in e5 && (r5 = await async function(e6, t6) {\n    const n6 = e6.getReader(), r6 = new ReadableStream({ start: (e7) => async function t7() {\n      return n6.read().then(({ done: n7, value: r7 }) => {\n        if (!n7)\n          return e7.enqueue(r7), t7();\n        e7.close();\n      });\n    }() }), i5 = new Response(r6), a8 = await i5.blob();\n    return n6.releaseLock(), new Blob([a8], { type: t6 });\n  }(e5.body, e5.headers.get(\"content-type\"))), n5.download = t5.fileName || \"Untitled\", n5.href = URL.createObjectURL(await r5);\n  const i4 = () => {\n    \"function\" == typeof a7 && a7();\n  }, a7 = t5.legacySetup && t5.legacySetup(i4, () => a7(), n5);\n  return n5.addEventListener(\"click\", () => {\n    setTimeout(() => URL.revokeObjectURL(n5.href), 3e4), i4();\n  }), n5.click(), null;\n};\nvar k6 = { __proto__: null, default: P4 };\n\n// src/components/Tldraw/state/data/filesystem.ts\nasync function openAssetsFromFileSystem() {\n  return await n4({\n    description: \"Image\",\n    extensions: [...IMAGE_EXTENSIONS],\n    multiple: true\n  });\n}\nasync function fileToBase64(file) {\n  return await new Promise((resolve, reject) => {\n    if (file) {\n      const reader = new FileReader();\n      reader.readAsDataURL(file);\n      reader.onload = () => resolve(reader.result);\n      reader.onerror = (error) => reject(error);\n      reader.onabort = (error) => reject(error);\n    }\n  });\n}\nasync function fileToText(file) {\n  return await new Promise((resolve, reject) => {\n    if (file) {\n      const reader = new FileReader();\n      reader.readAsText(file);\n      reader.onload = () => resolve(reader.result);\n      reader.onerror = (error) => reject(error);\n      reader.onabort = (error) => reject(error);\n    }\n  });\n}\nasync function getImageSizeFromSrc(src) {\n  return await new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve([img.width, img.height]);\n    img.onerror = () => reject(new Error(\"Could not get image size\"));\n    img.src = src;\n  });\n}\n\n// src/components/Tldraw/state/sessions/BaseSession.ts\nvar BaseSession = class {\n  constructor(app) {\n    this.app = app;\n  }\n};\n\n// src/components/Tldraw/state/sessions/ArrowSession/ArrowSession.ts\nvar ArrowSession = class extends BaseSession {\n  type = \"arrow\" /* Arrow */;\n  performanceMode = void 0;\n  status = \"translatingHandle\" /* TranslatingHandle */;\n  newStartBindingId = C3.uniqueId();\n  draggedBindingId = C3.uniqueId();\n  didBind = false;\n  initialShape;\n  handleId;\n  bindableShapeIds;\n  initialBinding;\n  startBindingShapeId;\n  isCreate;\n  constructor(app, shapeId, handleId, isCreate = false) {\n    super(app);\n    this.isCreate = isCreate;\n    const { currentPageId } = app.state.appState;\n    const page = app.state.document.pages[currentPageId];\n    this.handleId = handleId;\n    this.initialShape = deepCopy(page.shapes[shapeId]);\n    this.bindableShapeIds = TLDR.getBindableShapeIds(app.state).filter((id) => !(id === this.initialShape.id || id === this.initialShape.parentId));\n    const oppositeHandleBindingId = this.initialShape.handles[handleId === \"start\" ? \"end\" : \"start\"]?.bindingId;\n    if (oppositeHandleBindingId) {\n      const oppositeToId = page.bindings[oppositeHandleBindingId]?.toId;\n      if (oppositeToId) {\n        this.bindableShapeIds = this.bindableShapeIds.filter((id) => id !== oppositeToId);\n      }\n    }\n    const { originPoint } = this.app;\n    if (this.isCreate) {\n      this.startBindingShapeId = this.bindableShapeIds.map((id) => page.shapes[id]).filter((shape) => !shape.isLocked && C3.pointInBounds(originPoint, TLDR.getShapeUtil(shape).getBounds(shape))).sort((a7, b6) => {\n        return b6.childIndex - a7.childIndex;\n      })[0]?.id;\n      if (this.startBindingShapeId) {\n        this.bindableShapeIds.splice(this.bindableShapeIds.indexOf(this.startBindingShapeId), 1);\n      }\n    } else {\n      const initialBindingId = this.initialShape.handles[this.handleId].bindingId;\n      if (initialBindingId) {\n        this.initialBinding = page.bindings[initialBindingId];\n      } else {\n        this.initialShape.handles[this.handleId].bindingId = void 0;\n      }\n    }\n  }\n  start = () => void 0;\n  update = () => {\n    const { initialShape } = this;\n    const {\n      currentPoint,\n      shiftKey,\n      altKey,\n      metaKey,\n      currentGrid,\n      settings: { showGrid }\n    } = this.app;\n    const shape = this.app.getShape(initialShape.id);\n    if (shape.isLocked)\n      return;\n    const { handles } = initialShape;\n    const handleId = this.handleId;\n    if (!handles[handleId].canBind)\n      return;\n    let delta = e.sub(currentPoint, e.add(handles[handleId].point, initialShape.point));\n    if (shiftKey) {\n      const A6 = altKey ? e.med(handles.start.point, handles.end.point) : handles[handleId === \"start\" ? \"end\" : \"start\"].point;\n      const B5 = handles[handleId].point;\n      const C6 = e.add(B5, delta);\n      const angle = e.angle(A6, C6);\n      const adjusted = e.rotWith(C6, A6, C3.snapAngleToSegments(angle, 24) - angle);\n      delta = e.add(delta, e.sub(adjusted, C6));\n    }\n    const nextPoint = e.add(handles[handleId].point, delta);\n    const handleChanges = {\n      [handleId]: {\n        ...handles[handleId],\n        point: showGrid ? e.snap(nextPoint, currentGrid) : e.toFixed(nextPoint),\n        bindingId: void 0\n      }\n    };\n    const utils = shapeUtils[\"arrow\" /* Arrow */];\n    const handleChange = utils.onHandleChange?.(initialShape, handleChanges);\n    if (!handleChange)\n      return;\n    const next = {\n      shape: C3.deepMerge(shape, handleChange),\n      bindings: {}\n    };\n    let draggedBinding;\n    const draggingHandle = next.shape.handles[this.handleId];\n    const oppositeHandle = next.shape.handles[this.handleId === \"start\" ? \"end\" : \"start\"];\n    if (this.startBindingShapeId) {\n      let nextStartBinding;\n      const startTarget = this.app.page.shapes[this.startBindingShapeId];\n      const startTargetUtils = TLDR.getShapeUtil(startTarget);\n      const center = startTargetUtils.getCenter(startTarget);\n      const startHandle = next.shape.handles.start;\n      const endHandle = next.shape.handles.end;\n      const rayPoint = e.add(startHandle.point, next.shape.point);\n      if (e.isEqual(rayPoint, center))\n        rayPoint[1]++;\n      const rayOrigin = center;\n      const isInsideShape = startTargetUtils.hitTestPoint(startTarget, currentPoint);\n      const rayDirection = e.uni(e.sub(rayPoint, rayOrigin));\n      const hasStartBinding = this.app.getBinding(this.newStartBindingId) !== void 0;\n      if (!metaKey && !startTargetUtils.hitTestPoint(startTarget, e.add(next.shape.point, endHandle.point))) {\n        nextStartBinding = this.findBindingPoint(shape, startTarget, \"start\", this.newStartBindingId, center, rayOrigin, rayDirection, isInsideShape);\n      }\n      if (nextStartBinding && !hasStartBinding) {\n        this.didBind = true;\n        next.bindings[this.newStartBindingId] = nextStartBinding;\n        next.shape = C3.deepMerge(next.shape, {\n          handles: {\n            start: {\n              bindingId: nextStartBinding.id\n            }\n          }\n        });\n      } else if (!nextStartBinding && hasStartBinding) {\n        this.didBind = false;\n        next.bindings[this.newStartBindingId] = void 0;\n        next.shape = C3.deepMerge(initialShape, {\n          handles: {\n            start: {\n              bindingId: void 0\n            }\n          }\n        });\n      }\n    }\n    if (!metaKey) {\n      const rayOrigin = e.add(oppositeHandle.point, next.shape.point);\n      const rayPoint = e.add(draggingHandle.point, next.shape.point);\n      const rayDirection = e.uni(e.sub(rayPoint, rayOrigin));\n      const startPoint = e.add(next.shape.point, next.shape.handles.start.point);\n      const endPoint = e.add(next.shape.point, next.shape.handles.end.point);\n      const targets = this.bindableShapeIds.map((id) => this.app.page.shapes[id]).sort((a7, b6) => b6.childIndex - a7.childIndex).filter((shape2) => {\n        if (shape2.isLocked)\n          return false;\n        const utils2 = TLDR.getShapeUtil(shape2);\n        return ![startPoint, endPoint].every((point) => utils2.hitTestPoint(shape2, point));\n      });\n      for (const target of targets) {\n        draggedBinding = this.findBindingPoint(shape, target, this.handleId, this.draggedBindingId, rayPoint, rayOrigin, rayDirection, altKey);\n        if (draggedBinding)\n          break;\n      }\n    }\n    if (draggedBinding) {\n      this.didBind = true;\n      next.bindings[this.draggedBindingId] = draggedBinding;\n      next.shape = C3.deepMerge(next.shape, {\n        handles: {\n          [this.handleId]: {\n            bindingId: this.draggedBindingId\n          }\n        }\n      });\n    } else {\n      this.didBind = this.didBind || false;\n      const currentBindingId = shape.handles[this.handleId].bindingId;\n      if (currentBindingId !== void 0) {\n        next.bindings[currentBindingId] = void 0;\n        next.shape = C3.deepMerge(next.shape, {\n          handles: {\n            [this.handleId]: {\n              bindingId: void 0\n            }\n          }\n        });\n      }\n    }\n    const change = TLDR.getShapeUtil(next.shape).onHandleChange?.(next.shape, next.shape.handles);\n    return {\n      document: {\n        pages: {\n          [this.app.currentPageId]: {\n            shapes: {\n              [shape.id]: { ...next.shape, ...change }\n            },\n            bindings: next.bindings\n          }\n        },\n        pageStates: {\n          [this.app.currentPageId]: {\n            bindingId: next.shape.handles[handleId].bindingId\n          }\n        }\n      }\n    };\n  };\n  cancel = () => {\n    const { initialShape, initialBinding, newStartBindingId, draggedBindingId } = this;\n    const currentShape = TLDR.onSessionComplete(this.app.page.shapes[initialShape.id]);\n    const isDeleting = this.isCreate || e.dist(currentShape.handles.start.point, currentShape.handles.end.point) < 4;\n    const afterBindings = {};\n    afterBindings[draggedBindingId] = void 0;\n    if (initialBinding) {\n      afterBindings[initialBinding.id] = isDeleting ? void 0 : initialBinding;\n    }\n    if (newStartBindingId) {\n      afterBindings[newStartBindingId] = void 0;\n    }\n    return {\n      document: {\n        pages: {\n          [this.app.currentPageId]: {\n            shapes: {\n              [initialShape.id]: isDeleting ? void 0 : initialShape\n            },\n            bindings: afterBindings\n          }\n        },\n        pageStates: {\n          [this.app.currentPageId]: {\n            selectedIds: isDeleting ? [] : [initialShape.id],\n            bindingId: void 0,\n            hoveredId: void 0,\n            editingId: void 0\n          }\n        }\n      }\n    };\n  };\n  complete = () => {\n    const { initialShape, initialBinding, newStartBindingId, startBindingShapeId, handleId } = this;\n    const currentShape = TLDR.onSessionComplete(this.app.page.shapes[initialShape.id]);\n    const currentBindingId = currentShape.handles[handleId].bindingId;\n    const length = e.dist(currentShape.handles.start.point, currentShape.handles.end.point);\n    if (!(currentBindingId || initialBinding) && length < 4)\n      return this.cancel();\n    const beforeBindings = {};\n    const afterBindings = {};\n    if (initialBinding) {\n      beforeBindings[initialBinding.id] = this.isCreate ? void 0 : initialBinding;\n      afterBindings[initialBinding.id] = void 0;\n    }\n    if (currentBindingId) {\n      beforeBindings[currentBindingId] = void 0;\n      afterBindings[currentBindingId] = this.app.page.bindings[currentBindingId];\n    }\n    if (startBindingShapeId) {\n      beforeBindings[newStartBindingId] = void 0;\n      afterBindings[newStartBindingId] = this.app.page.bindings[newStartBindingId];\n    }\n    return {\n      id: \"arrow\",\n      before: {\n        document: {\n          pages: {\n            [this.app.currentPageId]: {\n              shapes: {\n                [initialShape.id]: this.isCreate ? void 0 : initialShape\n              },\n              bindings: beforeBindings\n            }\n          },\n          pageStates: {\n            [this.app.currentPageId]: {\n              selectedIds: this.isCreate ? [] : [initialShape.id],\n              bindingId: void 0,\n              hoveredId: void 0,\n              editingId: void 0\n            }\n          }\n        }\n      },\n      after: {\n        document: {\n          pages: {\n            [this.app.currentPageId]: {\n              shapes: {\n                [initialShape.id]: currentShape\n              },\n              bindings: afterBindings\n            }\n          },\n          pageStates: {\n            [this.app.currentPageId]: {\n              selectedIds: [initialShape.id],\n              bindingId: void 0,\n              hoveredId: void 0,\n              editingId: void 0\n            }\n          }\n        }\n      }\n    };\n  };\n  findBindingPoint = (shape, target, handleId, bindingId, point, origin, direction, bindAnywhere) => {\n    const util = TLDR.getShapeUtil(target.type);\n    const bindingPoint = util.getBindingPoint(\n      target,\n      shape,\n      point,\n      // fix dead center bug\n      origin,\n      direction,\n      bindAnywhere\n    );\n    if (!bindingPoint)\n      return;\n    return {\n      id: bindingId,\n      type: \"arrow\",\n      fromId: shape.id,\n      toId: target.id,\n      handleId,\n      point: e.toFixed(bindingPoint.point),\n      distance: bindingPoint.distance\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/BrushSession/BrushSession.ts\nvar BrushSession = class extends BaseSession {\n  type = \"brush\" /* Brush */;\n  performanceMode = void 0;\n  status = \"brushing\" /* Brushing */;\n  initialSelectedIds;\n  shapesToTest;\n  constructor(app) {\n    super(app);\n    const { currentPageId } = app;\n    this.initialSelectedIds = new Set(this.app.selectedIds);\n    this.shapesToTest = this.app.shapes.filter(\n      (shape) => !(shape.isLocked || shape.isHidden || shape.parentId !== currentPageId || this.initialSelectedIds.has(shape.id) || this.initialSelectedIds.has(shape.parentId))\n    ).map((shape) => ({\n      id: shape.id,\n      bounds: this.app.getShapeUtil(shape).getBounds(shape),\n      selectId: shape.id\n      // TLDR.getTopParentId(data, shape.id, currentPageId),\n    }));\n    this.update();\n  }\n  start = () => void 0;\n  update = () => {\n    const {\n      initialSelectedIds,\n      shapesToTest,\n      app: { metaKey, settings, originPoint, currentPoint }\n    } = this;\n    const brush = C3.getBoundsFromPoints([originPoint, currentPoint]);\n    const selectByContain = settings.isCadSelectMode ? !metaKey && originPoint[0] < currentPoint[0] : metaKey;\n    const hits = /* @__PURE__ */ new Set();\n    const selectedIds = new Set(initialSelectedIds);\n    shapesToTest.forEach(({ id, selectId }) => {\n      const shape = this.app.getShape(id);\n      if (!hits.has(selectId)) {\n        const util = this.app.getShapeUtil(shape);\n        if (selectByContain ? C3.boundsContain(brush, util.getBounds(shape)) : util.hitTestBounds(shape, brush)) {\n          hits.add(selectId);\n          if (!selectedIds.has(selectId)) {\n            selectedIds.add(selectId);\n          }\n        } else if (selectedIds.has(selectId)) {\n          selectedIds.delete(selectId);\n        }\n      }\n    });\n    const currentSelectedIds = this.app.selectedIds;\n    const didChange = selectedIds.size !== currentSelectedIds.length || currentSelectedIds.some((id) => !selectedIds.has(id));\n    const afterSelectedIds = didChange ? [...selectedIds.values()] : currentSelectedIds;\n    if (!didChange)\n      return {\n        appState: {\n          selectByContain\n        },\n        document: {\n          pageStates: {\n            [this.app.currentPageId]: {\n              brush\n            }\n          }\n        }\n      };\n    return {\n      appState: {\n        selectByContain\n      },\n      document: {\n        pageStates: {\n          [this.app.currentPageId]: {\n            brush,\n            selectedIds: afterSelectedIds\n          }\n        }\n      }\n    };\n  };\n  cancel = () => {\n    return {\n      appState: {\n        selectByContain: false\n      },\n      document: {\n        pageStates: {\n          [this.app.currentPageId]: {\n            brush: null,\n            selectedIds: [...this.initialSelectedIds.values()]\n          }\n        }\n      }\n    };\n  };\n  complete = () => {\n    return {\n      appState: {\n        selectByContain: false\n      },\n      document: {\n        pageStates: {\n          [this.app.currentPageId]: {\n            brush: null,\n            selectedIds: [...this.app.selectedIds]\n          }\n        }\n      }\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/DrawSession/DrawSession.ts\nvar DrawSession = class extends BaseSession {\n  type = \"draw\" /* Draw */;\n  performanceMode = void 0;\n  status = \"creating\" /* Creating */;\n  topLeft;\n  points;\n  initialShape;\n  lastAdjustedPoint;\n  shiftedPoints = [];\n  shapeId;\n  isLocked;\n  isExtending;\n  lockedDirection;\n  constructor(app, id) {\n    super(app);\n    const { originPoint } = this.app;\n    this.shapeId = id;\n    this.initialShape = this.app.getShape(id);\n    this.topLeft = [...this.initialShape.point];\n    const currentPoint = [0, 0, originPoint[2] ?? 0.5];\n    const delta = e.sub(originPoint, this.topLeft);\n    const initialPoints = this.initialShape.points.map((pt2) => e.sub(pt2, delta).concat(pt2[2]));\n    this.isExtending = initialPoints.length > 0;\n    const newPoints = [];\n    if (this.isExtending) {\n      const prevPoint = initialPoints[initialPoints.length - 1];\n      if (prevPoint) {\n        newPoints.push(prevPoint, prevPoint);\n        const len = Math.floor(e.dist(prevPoint, currentPoint) / 16);\n        if (len > 1) {\n          for (let i4 = 0; i4 < len; i4++) {\n            const t5 = i4 / (len - 1);\n            newPoints.push(e.lrp(prevPoint, currentPoint, t5).concat(prevPoint[2]));\n          }\n        } else {\n          newPoints.push(currentPoint, currentPoint);\n        }\n      }\n    } else {\n      newPoints.push(currentPoint);\n    }\n    this.points = [...initialPoints, ...newPoints];\n    this.shiftedPoints = this.points.map((pt2) => e.add(pt2, delta).concat(pt2[2]));\n    this.lastAdjustedPoint = this.points[this.points.length - 1];\n  }\n  start = () => {\n    const currentPoint = this.app.originPoint;\n    const newAdjustedPoint = [0, 0, currentPoint[2] ?? 0.5];\n    this.points.push(newAdjustedPoint);\n    const topLeft = [Math.min(this.topLeft[0], currentPoint[0]), Math.min(this.topLeft[1], currentPoint[1])];\n    const delta = e.sub(topLeft, currentPoint);\n    this.topLeft = topLeft;\n    this.shiftedPoints = this.points.map((pt2) => e.toFixed(e.sub(pt2, delta)).concat(pt2[2]));\n    return {\n      document: {\n        pages: {\n          [this.app.currentPageId]: {\n            shapes: {\n              [this.shapeId]: {\n                point: this.topLeft,\n                points: this.shiftedPoints\n              }\n            }\n          }\n        },\n        pageStates: {\n          [this.app.currentPageId]: {\n            selectedIds: [this.shapeId]\n          }\n        }\n      }\n    };\n  };\n  update = () => {\n    const { shapeId } = this;\n    const { currentPoint, originPoint, shiftKey, zoom } = this.app;\n    if (!this.lockedDirection && this.points.length > 1) {\n      const delta = e.sub(currentPoint, originPoint);\n      if (e.len(delta) > 3 / zoom) {\n        this.lockedDirection = Math.abs(delta[0]) > Math.abs(delta[1]) ? \"horizontal\" : \"vertical\";\n      }\n    }\n    if (shiftKey) {\n      if (!this.isLocked && this.points.length > 2) {\n        if (!this.lockedDirection) {\n          const delta = e.sub(currentPoint, originPoint);\n          if (e.len(delta) > 3 / zoom) {\n            this.lockedDirection = Math.abs(delta[0]) > Math.abs(delta[1]) ? \"horizontal\" : \"vertical\";\n          }\n        }\n        this.isLocked = true;\n        const returning = [...this.lastAdjustedPoint];\n        if (this.lockedDirection === \"vertical\") {\n          returning[0] = 0;\n        } else {\n          returning[1] = 0;\n        }\n        this.points.push(returning.concat(currentPoint[2]));\n      }\n    } else if (this.isLocked) {\n      this.isLocked = false;\n    }\n    if (this.isLocked) {\n      if (this.lockedDirection === \"vertical\") {\n        currentPoint[0] = originPoint[0];\n      } else {\n        currentPoint[1] = originPoint[1];\n      }\n    }\n    const change = this.addPoint(currentPoint);\n    if (!change)\n      return;\n    return {\n      document: {\n        pages: {\n          [this.app.currentPageId]: {\n            shapes: {\n              [shapeId]: change\n            }\n          }\n        },\n        pageStates: {\n          [this.app.currentPageId]: {\n            selectedIds: [shapeId]\n          }\n        }\n      }\n    };\n  };\n  cancel = () => {\n    const { shapeId } = this;\n    const pageId = this.app.currentPageId;\n    return {\n      document: {\n        pages: {\n          [pageId]: {\n            shapes: {\n              [shapeId]: this.isExtending ? this.initialShape : void 0\n            }\n          }\n        },\n        pageStates: {\n          [pageId]: {\n            selectedIds: []\n          }\n        }\n      }\n    };\n  };\n  complete = () => {\n    const { shapeId } = this;\n    const pageId = this.app.currentPageId;\n    const shape = this.app.getShape(shapeId);\n    return {\n      id: \"create_draw\",\n      before: {\n        document: {\n          pages: {\n            [pageId]: {\n              shapes: {\n                [shapeId]: this.isExtending ? this.initialShape : void 0\n              }\n            }\n          },\n          pageStates: {\n            [pageId]: {\n              selectedIds: []\n            }\n          }\n        }\n      },\n      after: {\n        document: {\n          pages: {\n            [pageId]: {\n              shapes: {\n                [shapeId]: {\n                  ...shape,\n                  point: e.toFixed(shape.point),\n                  points: shape.points.map((pt2) => e.toFixed(pt2)),\n                  isComplete: true\n                }\n              }\n            }\n          },\n          pageStates: {\n            [this.app.currentPageId]: {\n              selectedIds: []\n            }\n          }\n        }\n      }\n    };\n  };\n  addPoint = (currentPoint) => {\n    const { originPoint } = this.app;\n    const newAdjustedPoint = e.toFixed(e.sub(currentPoint, originPoint)).concat(currentPoint[2]);\n    if (e.isEqual(this.lastAdjustedPoint, newAdjustedPoint))\n      return;\n    this.points.push(newAdjustedPoint);\n    this.lastAdjustedPoint = newAdjustedPoint;\n    const prevTopLeft = [...this.topLeft];\n    const topLeft = [Math.min(this.topLeft[0], currentPoint[0]), Math.min(this.topLeft[1], currentPoint[1])];\n    const delta = e.sub(topLeft, originPoint);\n    let points;\n    if (prevTopLeft[0] !== topLeft[0] || prevTopLeft[1] !== topLeft[1]) {\n      this.topLeft = topLeft;\n      points = this.points.map((pt2) => e.toFixed(e.sub(pt2, delta)).concat(pt2[2]));\n    } else {\n      points = [...this.shiftedPoints, e.sub(newAdjustedPoint, delta).concat(newAdjustedPoint[2])];\n    }\n    this.shiftedPoints = points;\n    return {\n      point: this.topLeft,\n      points\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/EditSession/EditSession.ts\nvar EditSession = class extends BaseSession {\n  type = \"edit\" /* Edit */;\n  performanceMode = void 0;\n  initialShape;\n  initialSelectedIds;\n  currentPageId;\n  isCreating;\n  constructor(app, id, isCreating) {\n    super(app);\n    this.initialShape = app.getShape(id, app.currentPageId);\n    this.currentPageId = app.currentPageId;\n    this.isCreating = isCreating;\n    this.initialSelectedIds = [...app.selectedIds];\n  }\n  start = () => void 0;\n  update = () => void 0;\n  cancel = () => {\n    return {\n      document: {\n        pages: {\n          [this.currentPageId]: {\n            shapes: {\n              [this.initialShape.id]: this.isCreating ? void 0 : this.initialShape\n            }\n          }\n        },\n        pageStates: {\n          [this.currentPageId]: {\n            selectedIds: this.isCreating ? [] : this.initialSelectedIds,\n            editingId: void 0\n          }\n        }\n      }\n    };\n  };\n  complete = () => {\n    const shape = this.app.getShape(this.initialShape.id);\n    return {\n      id: \"edit\",\n      before: {\n        document: {\n          pages: {\n            [this.currentPageId]: {\n              shapes: {\n                [this.initialShape.id]: this.isCreating ? void 0 : this.initialShape\n              }\n            }\n          },\n          pageStates: {\n            [this.currentPageId]: {\n              selectedIds: this.isCreating ? [] : this.initialSelectedIds,\n              editingId: void 0\n            }\n          }\n        }\n      },\n      after: {\n        document: {\n          pages: {\n            [this.currentPageId]: {\n              shapes: {\n                [this.initialShape.id]: shape\n              }\n            }\n          },\n          pageStates: {\n            [this.currentPageId]: {\n              selectedIds: [shape.id],\n              editingId: void 0\n            }\n          }\n        }\n      }\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/EraseSession/EraseSession.ts\nvar EraseSession = class extends BaseSession {\n  type = \"draw\" /* Draw */;\n  performanceMode = void 0;\n  status = \"creating\" /* Creating */;\n  isLocked;\n  lockedDirection;\n  erasedShapes = /* @__PURE__ */ new Set();\n  erasedBindings = /* @__PURE__ */ new Set();\n  initialSelectedShapes;\n  erasableShapes;\n  prevPoint;\n  prevEraseShapesSize = 0;\n  constructor(app) {\n    super(app);\n    this.prevPoint = [...app.originPoint];\n    this.initialSelectedShapes = this.app.selectedIds.map((id) => this.app.getShape(id));\n    this.erasableShapes = new Set(this.app.shapes.filter((shape) => !shape.isLocked));\n    this.interval = this.loop();\n  }\n  interval;\n  timestamp1 = 0;\n  timestamp2 = 0;\n  prevErasePoint = [];\n  loop = () => {\n    const now = Date.now();\n    const elapsed1 = now - this.timestamp1;\n    const elapsed2 = now - this.timestamp2;\n    const { eraseLine } = this.app.appState;\n    let next = [...eraseLine];\n    let didUpdate = false;\n    if (elapsed1 > 16 && this.prevErasePoint !== this.prevPoint) {\n      didUpdate = true;\n      next = [...eraseLine, this.prevPoint];\n      this.prevErasePoint = this.prevPoint;\n    }\n    if (elapsed2 > 32 && next.length > 1) {\n      didUpdate = true;\n      next.splice(0, Math.ceil(next.length * 0.1));\n      this.timestamp2 = now;\n    }\n    if (didUpdate) {\n      this.app.patchState(\n        {\n          appState: {\n            eraseLine: next\n          }\n        },\n        \"eraseline\"\n      );\n    }\n    this.interval = requestAnimationFrame(this.loop);\n  };\n  start = () => void 0;\n  update = () => {\n    const { page, shiftKey, originPoint, currentPoint, zoom } = this.app;\n    if (shiftKey) {\n      const delta = e.sub(currentPoint, originPoint);\n      if (!this.isLocked && e.len(delta) > 3 / zoom) {\n        if (!this.lockedDirection) {\n          const delta2 = e.sub(currentPoint, originPoint);\n          this.lockedDirection = Math.abs(delta2[0]) > Math.abs(delta2[1]) ? \"horizontal\" : \"vertical\";\n        }\n        this.isLocked = true;\n      }\n    } else if (this.isLocked) {\n      this.isLocked = false;\n    }\n    if (this.isLocked) {\n      if (this.lockedDirection === \"vertical\") {\n        currentPoint[0] = originPoint[0];\n      } else {\n        currentPoint[1] = originPoint[1];\n      }\n    }\n    const newPoint = e.toFixed(e.add(originPoint, e.sub(currentPoint, originPoint)));\n    const deletedShapeIds = /* @__PURE__ */ new Set([]);\n    this.erasableShapes.forEach((shape) => {\n      if (this.erasedShapes.has(shape))\n        return;\n      if (this.app.getShapeUtil(shape).hitTestLineSegment(shape, this.prevPoint, newPoint)) {\n        this.erasedShapes.add(shape);\n        deletedShapeIds.add(shape.id);\n        if (shape.children !== void 0) {\n          for (const childId of shape.children) {\n            this.erasedShapes.add(this.app.getShape(childId));\n            deletedShapeIds.add(childId);\n          }\n        }\n      }\n    });\n    Object.values(page.bindings).forEach((binding) => {\n      for (const id of [binding.toId, binding.fromId]) {\n        if (deletedShapeIds.has(id)) {\n          this.erasedBindings.add(binding);\n        }\n      }\n    });\n    this.erasedShapes.forEach((shape) => {\n      if (!this.app.getShape(shape.id)) {\n        this.erasedShapes.delete(shape);\n        this.erasableShapes.delete(shape);\n        deletedShapeIds.delete(shape.id);\n      }\n    });\n    const erasedShapes = [...this.erasedShapes.values()];\n    this.prevPoint = newPoint;\n    if (erasedShapes.length === this.prevEraseShapesSize) {\n      return;\n    }\n    this.prevEraseShapesSize = erasedShapes.length;\n    return {\n      document: {\n        pages: {\n          [page.id]: {\n            shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, { isGhost: true }]))\n          }\n        }\n      }\n    };\n  };\n  cancel = () => {\n    const { page } = this.app;\n    cancelAnimationFrame(this.interval);\n    this.erasedShapes.forEach((shape) => {\n      if (!this.app.getShape(shape.id)) {\n        this.erasedShapes.delete(shape);\n        this.erasableShapes.delete(shape);\n      }\n    });\n    const erasedShapes = [...this.erasedShapes.values()];\n    return {\n      document: {\n        pages: {\n          [page.id]: {\n            shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, { isGhost: false }]))\n          }\n        },\n        pageStates: {\n          [page.id]: {\n            selectedIds: this.initialSelectedShapes.map((shape) => shape.id)\n          }\n        }\n      },\n      appState: {\n        eraseLine: []\n      }\n    };\n  };\n  complete = () => {\n    const { page } = this.app;\n    cancelAnimationFrame(this.interval);\n    this.erasedShapes.forEach((shape) => {\n      if (!this.app.getShape(shape.id)) {\n        this.erasedShapes.delete(shape);\n        this.erasableShapes.delete(shape);\n      }\n    });\n    this.erasedBindings.forEach((binding) => {\n      if (!this.app.getBinding(binding.id)) {\n        this.erasedBindings.delete(binding);\n      }\n    });\n    const erasedShapes = [...this.erasedShapes.values()];\n    const erasedBindings = [...this.erasedBindings.values()];\n    const erasedShapeIds = new Set(erasedShapes.map((shape) => shape.id));\n    const erasedBindingIds = new Set(erasedBindings.map((binding) => binding.id));\n    const before = {\n      shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, shape])),\n      bindings: Object.fromEntries(erasedBindings.map((binding) => [binding.id, binding]))\n    };\n    const after = {\n      shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, void 0])),\n      bindings: Object.fromEntries(erasedBindings.map((binding) => [binding.id, void 0]))\n    };\n    this.app.shapes.forEach((shape) => {\n      if (shape.handles && !after.shapes[shape.id]) {\n        Object.values(shape.handles).forEach((handle) => {\n          if (handle.bindingId && erasedBindingIds.has(handle.bindingId)) {\n            before.shapes[shape.id] = {\n              ...before.shapes[shape.id],\n              handles: {\n                ...before.shapes[shape.id]?.handles,\n                [handle.id]: handle\n              }\n            };\n            if (!erasedShapeIds.has(shape.id)) {\n              after.shapes[shape.id] = {\n                ...after.shapes[shape.id],\n                handles: {\n                  ...after.shapes[shape.id]?.handles,\n                  [handle.id]: {\n                    ...handle,\n                    bindingId: void 0\n                  }\n                }\n              };\n            }\n          }\n        });\n      }\n    });\n    return {\n      id: \"erase\",\n      before: {\n        document: {\n          pages: {\n            [page.id]: before\n          },\n          pageStates: {\n            [page.id]: {\n              selectedIds: this.initialSelectedShapes.filter((shape) => !!this.app.getShape(shape.id)).map((shape) => shape.id)\n            }\n          }\n        },\n        appState: {\n          eraseLine: []\n        }\n      },\n      after: {\n        document: {\n          pages: {\n            [page.id]: after\n          },\n          pageStates: {\n            [page.id]: {\n              selectedIds: this.initialSelectedShapes.filter((shape) => !!this.app.getShape(shape.id)).filter((shape) => !erasedShapeIds.has(shape.id)).map((shape) => shape.id)\n            }\n          }\n        },\n        appState: {\n          eraseLine: []\n        }\n      }\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/GridSession/GridSession.ts\nvar GridSession = class extends BaseSession {\n  type = \"grid\" /* Grid */;\n  performanceMode = void 0;\n  status = \"translating\" /* Translating */;\n  shape;\n  bounds;\n  initialSelectedIds;\n  initialSiblings;\n  grid = {};\n  columns = 1;\n  rows = 1;\n  isCopying = false;\n  constructor(app, id) {\n    super(app);\n    this.shape = this.app.getShape(id);\n    this.grid[\"0_0\"] = this.shape.id;\n    this.bounds = this.app.getShapeBounds(id);\n    this.initialSelectedIds = [...this.app.selectedIds];\n    if (this.shape.parentId !== this.app.currentPageId) {\n      this.initialSiblings = this.app.getShape(this.shape.parentId).children?.filter((id2) => id2 !== this.shape.id);\n    }\n  }\n  start = () => void 0;\n  update = () => {\n    const { currentPageId, altKey, shiftKey, currentPoint } = this.app;\n    const nextShapes = {};\n    const nextPageState = {};\n    const center = C3.getBoundsCenter(this.bounds);\n    const offset = e.sub(currentPoint, center);\n    if (shiftKey) {\n      if (Math.abs(offset[0]) < Math.abs(offset[1])) {\n        offset[0] = 0;\n      } else {\n        offset[1] = 0;\n      }\n    }\n    const gapX = this.bounds.width + 32;\n    const gapY = this.bounds.height + 32;\n    const columns = Math.ceil(offset[0] / gapX);\n    const rows = Math.ceil(offset[1] / gapY);\n    const minX = Math.min(columns, 0);\n    const minY = Math.min(rows, 0);\n    const maxX = Math.max(columns, 1);\n    const maxY = Math.max(rows, 1);\n    const inGrid = /* @__PURE__ */ new Set();\n    const isCopying = altKey;\n    if (isCopying !== this.isCopying) {\n      Object.values(this.grid).filter((id) => id !== this.shape.id).forEach((id) => nextShapes[id] = void 0);\n      this.grid = { \"0_0\": this.shape.id };\n      this.isCopying = isCopying;\n    }\n    for (let x5 = minX; x5 < maxX; x5++) {\n      for (let y6 = minY; y6 < maxY; y6++) {\n        const position = `${x5}_${y6}`;\n        inGrid.add(position);\n        if (this.grid[position])\n          continue;\n        if (x5 === 0 && y6 === 0)\n          continue;\n        const clone = this.getClone(e.add(this.shape.point, [x5 * gapX, y6 * gapY]), isCopying);\n        nextShapes[clone.id] = clone;\n        this.grid[position] = clone.id;\n      }\n    }\n    Object.entries(this.grid).forEach(([position, id]) => {\n      if (!inGrid.has(position)) {\n        nextShapes[id] = void 0;\n        delete this.grid[position];\n      }\n    });\n    if (Object.values(nextShapes).length === 0)\n      return;\n    if (this.initialSiblings) {\n      nextShapes[this.shape.parentId] = {\n        children: [...this.initialSiblings, ...Object.values(this.grid)]\n      };\n    }\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: nextShapes\n          }\n        },\n        pageStates: {\n          [currentPageId]: nextPageState\n        }\n      }\n    };\n  };\n  cancel = () => {\n    const { currentPageId } = this.app;\n    const nextShapes = {};\n    Object.values(this.grid).forEach((id) => {\n      nextShapes[id] = void 0;\n    });\n    nextShapes[this.shape.id] = { ...nextShapes[this.shape.id], point: this.shape.point };\n    if (this.initialSiblings) {\n      nextShapes[this.shape.parentId] = {\n        children: [...this.initialSiblings, this.shape.id]\n      };\n    }\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: nextShapes\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: [this.shape.id]\n          }\n        }\n      }\n    };\n  };\n  complete = () => {\n    const { currentPageId } = this.app;\n    const beforeShapes = {};\n    const afterShapes = {};\n    const afterSelectedIds = [];\n    Object.values(this.grid).forEach((id) => {\n      beforeShapes[id] = void 0;\n      afterShapes[id] = this.app.getShape(id);\n      afterSelectedIds.push(id);\n    });\n    beforeShapes[this.shape.id] = this.shape;\n    if (this.initialSiblings) {\n      beforeShapes[this.shape.parentId] = {\n        children: [...this.initialSiblings, this.shape.id]\n      };\n      afterShapes[this.shape.parentId] = {\n        children: [...this.initialSiblings, ...Object.values(this.grid)]\n      };\n    }\n    if (afterSelectedIds.length === 1)\n      return;\n    return {\n      id: \"grid\",\n      before: {\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: beforeShapes\n            }\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: [],\n              hoveredId: void 0\n            }\n          }\n        }\n      },\n      after: {\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: afterShapes\n            }\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: afterSelectedIds,\n              hoveredId: void 0\n            }\n          }\n        }\n      }\n    };\n  };\n  getClone = (point, copy) => {\n    const clone = {\n      ...this.shape,\n      id: C3.uniqueId(),\n      point\n    };\n    if (!copy && clone.type === \"sticky\" /* Sticky */) {\n      clone.text = \"\";\n    }\n    return clone;\n  };\n};\n\n// src/components/Tldraw/state/sessions/HandleSession/HandleSession.ts\nvar HandleSession = class extends BaseSession {\n  type = \"handle\" /* Handle */;\n  performanceMode = void 0;\n  status = \"translatingHandle\" /* TranslatingHandle */;\n  commandId;\n  topLeft;\n  shiftKey = false;\n  initialShape;\n  handleId;\n  constructor(app, shapeId, handleId, commandId = \"move_handle\") {\n    super(app);\n    const { originPoint } = app;\n    this.topLeft = [...originPoint];\n    this.handleId = handleId;\n    this.initialShape = this.app.getShape(shapeId);\n    this.commandId = commandId;\n  }\n  start = () => void 0;\n  update = () => {\n    const {\n      initialShape,\n      app: { currentPageId, currentPoint }\n    } = this;\n    const shape = this.app.getShape(initialShape.id);\n    if (shape.isLocked)\n      return void 0;\n    const handles = shape.handles;\n    const handleId = this.handleId;\n    const delta = e.sub(currentPoint, handles[handleId].point);\n    const handleChanges = {\n      [handleId]: {\n        ...handles[handleId],\n        point: e.sub(e.add(handles[handleId].point, delta), shape.point)\n      }\n    };\n    const change = TLDR.getShapeUtil(shape).onHandleChange?.(shape, handleChanges);\n    if (!change)\n      return;\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: {\n              [shape.id]: change\n            }\n          }\n        }\n      }\n    };\n  };\n  cancel = () => {\n    const {\n      initialShape,\n      app: { currentPageId }\n    } = this;\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: {\n              [initialShape.id]: initialShape\n            }\n          }\n        }\n      }\n    };\n  };\n  complete = () => {\n    const {\n      initialShape,\n      app: { currentPageId }\n    } = this;\n    return {\n      id: this.commandId,\n      before: {\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: {\n                [initialShape.id]: initialShape\n              }\n            }\n          }\n        }\n      },\n      after: {\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: {\n                [initialShape.id]: TLDR.onSessionComplete(this.app.getShape(this.initialShape.id))\n              }\n            }\n          }\n        }\n      }\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/RotateSession/RotateSession.ts\nvar RotateSession = class extends BaseSession {\n  type = \"rotate\" /* Rotate */;\n  status = \"transforming\" /* Transforming */;\n  performanceMode = void 0;\n  delta = [0, 0];\n  commonBoundsCenter;\n  initialAngle;\n  initialShapes;\n  changes = {};\n  constructor(app) {\n    super(app);\n    const {\n      app: { currentPageId, pageState, originPoint }\n    } = this;\n    const initialShapes = TLDR.getSelectedBranchSnapshot(app.state, currentPageId).filter((shape) => !shape.isLocked);\n    if (initialShapes.length === 0) {\n      throw new Error(\"No selected shapes!\");\n    }\n    if (app.rotationInfo.selectedIds === pageState.selectedIds) {\n      if (app.rotationInfo.center === void 0) {\n        throw new Error(\"We should have a center for rotation!\");\n      }\n      this.commonBoundsCenter = app.rotationInfo.center;\n    } else {\n      this.commonBoundsCenter = C3.getBoundsCenter(C3.getCommonBounds(initialShapes.map(TLDR.getBounds)));\n      app.rotationInfo.selectedIds = pageState.selectedIds;\n      app.rotationInfo.center = this.commonBoundsCenter;\n    }\n    this.initialShapes = initialShapes.filter((shape) => shape.children === void 0).map((shape) => {\n      return {\n        shape,\n        center: this.app.getShapeUtil(shape).getCenter(shape)\n      };\n    });\n    this.initialAngle = e.angle(this.commonBoundsCenter, originPoint);\n  }\n  start = () => void 0;\n  update = () => {\n    const {\n      commonBoundsCenter,\n      initialShapes,\n      app: { currentPageId, currentPoint, shiftKey }\n    } = this;\n    const shapes = {};\n    let directionDelta = e.angle(commonBoundsCenter, currentPoint) - this.initialAngle;\n    if (shiftKey) {\n      directionDelta = C3.snapAngleToSegments(directionDelta, 24);\n    }\n    initialShapes.forEach(({ center, shape }) => {\n      const { rotation = 0 } = shape;\n      let shapeDelta = 0;\n      if (shiftKey) {\n        const snappedRotation = C3.snapAngleToSegments(rotation, 24);\n        shapeDelta = snappedRotation - rotation;\n      }\n      const change = TLDR.getRotatedShapeMutation(shape, center, commonBoundsCenter, shiftKey ? directionDelta + shapeDelta : directionDelta);\n      if (change) {\n        shapes[shape.id] = change;\n      }\n    });\n    this.changes = shapes;\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes\n          }\n        }\n      }\n    };\n  };\n  cancel = () => {\n    const {\n      initialShapes,\n      app: { currentPageId }\n    } = this;\n    const shapes = {};\n    initialShapes.forEach(({ shape }) => shapes[shape.id] = shape);\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes\n          }\n        }\n      }\n    };\n  };\n  complete = () => {\n    const {\n      initialShapes,\n      app: { currentPageId }\n    } = this;\n    const beforeShapes = {};\n    const afterShapes = this.changes;\n    initialShapes.forEach(({ shape: { id, point, rotation, handles } }) => {\n      beforeShapes[id] = { point, rotation, handles };\n    });\n    return {\n      id: \"rotate\",\n      before: {\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: beforeShapes\n            }\n          }\n        }\n      },\n      after: {\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: afterShapes\n            }\n          }\n        }\n      }\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/TransformSession/TransformSession.ts\nvar TransformSession = class extends BaseSession {\n  constructor(app, transformType = He.BottomRight, isCreate = false) {\n    super(app);\n    this.transformType = transformType;\n    this.isCreate = isCreate;\n    this.initialSelectedIds = [...this.app.selectedIds];\n    this.app.rotationInfo.selectedIds = [...this.initialSelectedIds];\n    this.initialShapes = TLDR.getSelectedBranchSnapshot(this.app.state, this.app.currentPageId).filter((shape) => !shape.isLocked);\n    this.initialShapeIds = this.initialShapes.map((shape) => shape.id);\n    this.hasUnlockedShapes = this.initialShapes.length > 0;\n    this.isAllAspectRatioLocked = this.initialShapes.every((shape) => shape.isAspectRatioLocked || TLDR.getShapeUtil(shape).isAspectRatioLocked);\n    const shapesBounds = Object.fromEntries(this.initialShapes.map((shape) => [shape.id, TLDR.getBounds(shape)]));\n    const boundsArr = Object.values(shapesBounds);\n    this.initialCommonBounds = C3.getCommonBounds(boundsArr);\n    const initialInnerBounds = C3.getBoundsFromPoints(boundsArr.map(C3.getBoundsCenter));\n    this.shapeBounds = this.initialShapes.map((shape) => {\n      const initialShapeBounds = shapesBounds[shape.id];\n      const ic = C3.getBoundsCenter(initialShapeBounds);\n      const ix = (ic[0] - initialInnerBounds.minX) / initialInnerBounds.width;\n      const iy = (ic[1] - initialInnerBounds.minY) / initialInnerBounds.height;\n      return {\n        initialShape: shape,\n        initialShapeBounds,\n        transformOrigin: [ix, iy]\n      };\n    });\n  }\n  type = \"transform\" /* Transform */;\n  performanceMode = void 0;\n  status = \"transforming\" /* Transforming */;\n  scaleX = 1;\n  scaleY = 1;\n  initialShapes;\n  initialShapeIds;\n  initialSelectedIds;\n  shapeBounds;\n  hasUnlockedShapes;\n  isAllAspectRatioLocked;\n  initialCommonBounds;\n  snapInfo = { state: \"empty\" };\n  prevPoint = [0, 0];\n  speed = 1;\n  start = () => {\n    this.snapInfo = {\n      state: \"ready\",\n      bounds: this.app.shapes.filter((shape) => !this.initialShapeIds.includes(shape.id)).map((shape) => C3.getBoundsWithCenter(TLDR.getRotatedBounds(shape)))\n    };\n    return void 0;\n  };\n  update = () => {\n    const {\n      transformType,\n      shapeBounds,\n      initialCommonBounds,\n      isAllAspectRatioLocked,\n      app: {\n        currentPageId,\n        pageState: { camera },\n        viewport,\n        currentPoint,\n        previousPoint,\n        originPoint,\n        shiftKey,\n        altKey,\n        metaKey,\n        currentGrid,\n        settings: { isSnapping, showGrid }\n      }\n    } = this;\n    const shapes = {};\n    const delta = altKey ? e.mul(e.sub(currentPoint, originPoint), 2) : e.sub(currentPoint, originPoint);\n    let newBounds = C3.getTransformedBoundingBox(initialCommonBounds, transformType, delta, 0, shiftKey || isAllAspectRatioLocked);\n    if (altKey) {\n      newBounds = {\n        ...newBounds,\n        ...C3.centerBounds(newBounds, C3.getBoundsCenter(initialCommonBounds))\n      };\n    }\n    if (showGrid) {\n      newBounds = {\n        ...newBounds,\n        ...C3.snapBoundsToGrid(newBounds, currentGrid)\n      };\n    }\n    const speed = e.dist(currentPoint, previousPoint);\n    const speedChange = speed - this.speed;\n    this.speed = this.speed + speedChange * (speedChange > 1 ? 0.5 : 0.15);\n    let snapLines = [];\n    if ((isSnapping && !metaKey || !isSnapping && metaKey) && this.speed * camera.zoom < SLOW_SPEED && this.snapInfo.state === \"ready\") {\n      const snapResult = C3.getSnapPoints(\n        C3.getBoundsWithCenter(newBounds),\n        this.snapInfo.bounds.filter((bounds) => C3.boundsContain(viewport, bounds) || C3.boundsCollide(viewport, bounds)),\n        SNAP_DISTANCE / camera.zoom\n      );\n      if (snapResult) {\n        snapLines = snapResult.snapLines;\n        newBounds = C3.getTransformedBoundingBox(\n          initialCommonBounds,\n          transformType,\n          e.sub(delta, snapResult.offset),\n          0,\n          shiftKey || isAllAspectRatioLocked\n        );\n      }\n    }\n    this.scaleX = newBounds.scaleX;\n    this.scaleY = newBounds.scaleY;\n    shapeBounds.forEach(({ initialShape, initialShapeBounds, transformOrigin }) => {\n      let newShapeBounds = C3.getRelativeTransformedBoundingBox(newBounds, initialCommonBounds, initialShapeBounds, this.scaleX < 0, this.scaleY < 0);\n      if (showGrid) {\n        newShapeBounds = C3.snapBoundsToGrid(newShapeBounds, currentGrid);\n      }\n      const afterShape = TLDR.transform(this.app.getShape(initialShape.id), newShapeBounds, {\n        type: this.transformType,\n        initialShape,\n        scaleX: this.scaleX,\n        scaleY: this.scaleY,\n        transformOrigin\n      });\n      shapes[initialShape.id] = afterShape;\n    });\n    return {\n      appState: {\n        snapLines\n      },\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes\n          }\n        }\n      }\n    };\n  };\n  cancel = () => {\n    const {\n      shapeBounds,\n      app: { currentPageId }\n    } = this;\n    const shapes = {};\n    if (this.isCreate) {\n      shapeBounds.forEach((shape) => shapes[shape.initialShape.id] = void 0);\n    } else {\n      shapeBounds.forEach((shape) => shapes[shape.initialShape.id] = shape.initialShape);\n    }\n    return {\n      appState: {\n        snapLines: []\n      },\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: this.isCreate ? [] : shapeBounds.map((shape) => shape.initialShape.id)\n          }\n        }\n      }\n    };\n  };\n  complete = () => {\n    const {\n      isCreate,\n      shapeBounds,\n      hasUnlockedShapes,\n      app: { currentPageId }\n    } = this;\n    if (!hasUnlockedShapes)\n      return;\n    if (this.isCreate && e.dist(this.app.originPoint, this.app.currentPoint) < 2) {\n      return this.cancel();\n    }\n    const beforeShapes = {};\n    const afterShapes = {};\n    let beforeSelectedIds;\n    let afterSelectedIds;\n    if (isCreate) {\n      beforeSelectedIds = [];\n      afterSelectedIds = [];\n      shapeBounds.forEach(({ initialShape }) => {\n        beforeShapes[initialShape.id] = void 0;\n        afterShapes[initialShape.id] = this.app.getShape(initialShape.id);\n      });\n    } else {\n      beforeSelectedIds = this.initialSelectedIds;\n      afterSelectedIds = this.initialSelectedIds;\n      shapeBounds.forEach(({ initialShape }) => {\n        beforeShapes[initialShape.id] = initialShape;\n        afterShapes[initialShape.id] = this.app.getShape(initialShape.id);\n      });\n    }\n    return {\n      id: \"transform\",\n      before: {\n        appState: {\n          snapLines: []\n        },\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: beforeShapes\n            }\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: beforeSelectedIds,\n              hoveredId: void 0,\n              editingId: void 0\n            }\n          }\n        }\n      },\n      after: {\n        appState: {\n          snapLines: []\n        },\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: afterShapes\n            }\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: afterSelectedIds,\n              hoveredId: void 0,\n              editingId: void 0\n            }\n          }\n        }\n      }\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/TransformSingleSession/TransformSingleSession.ts\nvar TransformSingleSession = class extends BaseSession {\n  type = \"transformSingle\" /* TransformSingle */;\n  status = \"transforming\" /* Transforming */;\n  performanceMode = void 0;\n  transformType;\n  scaleX = 1;\n  scaleY = 1;\n  isCreate;\n  initialShape;\n  initialShapeBounds;\n  initialCommonBounds;\n  snapInfo = { state: \"empty\" };\n  prevPoint = [0, 0];\n  speed = 1;\n  constructor(app, id, transformType, isCreate = false) {\n    super(app);\n    this.isCreate = isCreate;\n    this.transformType = transformType;\n    const shape = this.app.getShape(id);\n    this.initialShape = shape;\n    this.initialShapeBounds = TLDR.getBounds(shape);\n    this.initialCommonBounds = TLDR.getRotatedBounds(shape);\n    this.app.rotationInfo.selectedIds = [shape.id];\n  }\n  start = () => {\n    this.snapInfo = {\n      state: \"ready\",\n      bounds: this.app.shapes.filter((shape) => shape.id !== this.initialShape.id).map((shape) => C3.getBoundsWithCenter(TLDR.getRotatedBounds(shape)))\n    };\n    return void 0;\n  };\n  update = () => {\n    const {\n      transformType,\n      initialShape,\n      initialShapeBounds,\n      app: {\n        settings: { isSnapping, showGrid },\n        currentPageId,\n        pageState: { camera },\n        viewport,\n        currentPoint,\n        previousPoint,\n        originPoint,\n        currentGrid,\n        shiftKey,\n        altKey,\n        metaKey\n      }\n    } = this;\n    if (initialShape.isLocked)\n      return void 0;\n    const shapes = {};\n    const delta = altKey ? e.mul(e.sub(currentPoint, originPoint), 2) : e.sub(currentPoint, originPoint);\n    const shape = this.app.getShape(initialShape.id);\n    const utils = TLDR.getShapeUtil(shape);\n    let newBounds = C3.getTransformedBoundingBox(\n      initialShapeBounds,\n      transformType,\n      delta,\n      shape.rotation,\n      shiftKey || shape.isAspectRatioLocked || utils.isAspectRatioLocked\n    );\n    if (altKey) {\n      newBounds = {\n        ...newBounds,\n        ...C3.centerBounds(newBounds, C3.getBoundsCenter(initialShapeBounds))\n      };\n    }\n    if (showGrid) {\n      newBounds = {\n        ...newBounds,\n        ...C3.snapBoundsToGrid(newBounds, currentGrid)\n      };\n    }\n    const speed = e.dist(currentPoint, previousPoint);\n    const speedChange = speed - this.speed;\n    this.speed = this.speed + speedChange * (speedChange > 1 ? 0.5 : 0.15);\n    let snapLines = [];\n    if ((isSnapping && !metaKey || !isSnapping && metaKey) && !initialShape.rotation && // not now anyway\n    this.speed * camera.zoom < SLOW_SPEED && this.snapInfo.state === \"ready\") {\n      const snapResult = C3.getSnapPoints(\n        C3.getBoundsWithCenter(newBounds),\n        this.snapInfo.bounds.filter((bounds) => C3.boundsContain(viewport, bounds) || C3.boundsCollide(viewport, bounds)),\n        SNAP_DISTANCE / camera.zoom\n      );\n      if (snapResult) {\n        snapLines = snapResult.snapLines;\n        newBounds = C3.getTransformedBoundingBox(\n          initialShapeBounds,\n          transformType,\n          e.sub(delta, snapResult.offset),\n          shape.rotation,\n          shiftKey || shape.isAspectRatioLocked || utils.isAspectRatioLocked\n        );\n      }\n    }\n    const afterShape = TLDR.getShapeUtil(shape).transformSingle(shape, newBounds, {\n      initialShape,\n      type: this.transformType,\n      scaleX: newBounds.scaleX,\n      scaleY: newBounds.scaleY,\n      transformOrigin: [0.5, 0.5]\n    });\n    if (afterShape) {\n      shapes[shape.id] = afterShape;\n    }\n    if (showGrid && afterShape && afterShape.point) {\n      afterShape.point = e.snap(afterShape.point, currentGrid);\n    }\n    return {\n      appState: {\n        snapLines\n      },\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes\n          }\n        }\n      }\n    };\n  };\n  cancel = () => {\n    const {\n      initialShape,\n      app: { currentPageId }\n    } = this;\n    const shapes = {};\n    if (this.isCreate) {\n      shapes[initialShape.id] = void 0;\n    } else {\n      shapes[initialShape.id] = initialShape;\n    }\n    return {\n      appState: {\n        snapLines: []\n      },\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes\n          }\n        },\n        pageStates: {\n          [currentPageId]: {\n            selectedIds: this.isCreate ? [] : [initialShape.id]\n          }\n        }\n      }\n    };\n  };\n  complete = () => {\n    const {\n      initialShape,\n      app: { currentPageId }\n    } = this;\n    if (initialShape.isLocked)\n      return;\n    if (this.isCreate && e.dist(this.app.originPoint, this.app.currentPoint) < 2) {\n      return this.cancel();\n    }\n    const beforeShapes = {};\n    const afterShapes = {};\n    beforeShapes[initialShape.id] = this.isCreate ? void 0 : initialShape;\n    afterShapes[initialShape.id] = TLDR.onSessionComplete(this.app.getShape(initialShape.id));\n    return {\n      id: \"transform_single\",\n      before: {\n        appState: {\n          snapLines: []\n        },\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: beforeShapes\n            }\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: this.isCreate ? [] : [initialShape.id],\n              editingId: void 0,\n              hoveredId: void 0\n            }\n          }\n        }\n      },\n      after: {\n        appState: {\n          snapLines: []\n        },\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: afterShapes\n            }\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: [initialShape.id],\n              editingId: void 0,\n              hoveredId: void 0\n            }\n          }\n        }\n      }\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/TranslateSession/TranslateSession.ts\nvar TranslateSession = class extends BaseSession {\n  performanceMode = void 0;\n  type = \"translate\" /* Translate */;\n  status = \"translating\" /* Translating */;\n  delta = [0, 0];\n  prev = [0, 0];\n  prevPoint = [0, 0];\n  speed = 1;\n  cloneInfo = {\n    state: \"empty\"\n  };\n  snapInfo = {\n    state: \"empty\"\n  };\n  snapLines = [];\n  isCloning = false;\n  isCreate;\n  link;\n  initialIds;\n  hasUnlockedShapes;\n  initialSelectedIds;\n  initialCommonBounds;\n  initialShapes;\n  initialParentChildren;\n  bindingsToDelete;\n  constructor(app, isCreate = false, link = false) {\n    super(app);\n    this.isCreate = isCreate;\n    this.link = link;\n    const { currentPageId, selectedIds, page } = this.app;\n    this.initialSelectedIds = [...selectedIds];\n    const selectedShapes = (link ? TLDR.getLinkedShapeIds(this.app.state, currentPageId, link, false) : selectedIds).map((id) => this.app.getShape(id)).filter((shape) => !shape.isLocked);\n    const selectedShapeIds = new Set(selectedShapes.map((shape) => shape.id));\n    this.hasUnlockedShapes = selectedShapes.length > 0;\n    this.initialShapes = [\n      ...new Set(\n        selectedShapes.filter((shape) => !selectedShapeIds.has(shape.parentId)).flatMap((shape) => {\n          return shape.children ? [shape, ...shape.children.map((childId) => this.app.getShape(childId))] : [shape];\n        })\n      ).values()\n    ];\n    this.initialIds = new Set(this.initialShapes.map((shape) => shape.id));\n    this.bindingsToDelete = [];\n    Object.values(page.bindings).filter((binding) => this.initialIds.has(binding.fromId) || this.initialIds.has(binding.toId)).forEach((binding) => {\n      if (this.initialIds.has(binding.fromId) && !this.initialIds.has(binding.toId)) {\n        this.bindingsToDelete.push(binding);\n      }\n    });\n    this.initialParentChildren = {};\n    this.initialShapes.map((s5) => s5.parentId).filter((id) => id !== page.id).forEach((id) => {\n      this.initialParentChildren[id] = this.app.getShape(id).children;\n    });\n    this.initialCommonBounds = C3.getCommonBounds(this.initialShapes.map(TLDR.getRotatedBounds));\n    this.app.rotationInfo.selectedIds = [...this.app.selectedIds];\n  }\n  start = () => {\n    const {\n      bindingsToDelete,\n      initialIds,\n      app: { currentPageId, page }\n    } = this;\n    const allBounds = [];\n    const otherBounds = [];\n    Object.values(page.shapes).forEach((shape) => {\n      const bounds = C3.getBoundsWithCenter(TLDR.getRotatedBounds(shape));\n      allBounds.push(bounds);\n      if (!initialIds.has(shape.id)) {\n        otherBounds.push(bounds);\n      }\n    });\n    this.snapInfo = {\n      state: \"ready\",\n      bounds: allBounds,\n      others: otherBounds\n    };\n    if (bindingsToDelete.length === 0)\n      return;\n    const nextBindings = {};\n    const nextShapes = {};\n    bindingsToDelete.forEach((binding) => {\n      nextBindings[binding.id] = void 0;\n      const fromShape = this.app.getShape(binding.fromId);\n      nextShapes[binding.fromId] = {\n        handles: {\n          ...fromShape.handles,\n          [binding.handleId]: {\n            // @ts-expect-error\n            ...fromShape.handles[binding.handleId],\n            bindingId: void 0\n          }\n        }\n      };\n    });\n    return {\n      document: {\n        pages: {\n          [currentPageId]: {\n            bindings: nextBindings,\n            shapes: nextShapes\n          }\n        }\n      }\n    };\n  };\n  update = () => {\n    const {\n      initialParentChildren,\n      initialShapes,\n      initialCommonBounds,\n      bindingsToDelete,\n      app: {\n        pageState: { camera },\n        settings: { isSnapping, showGrid },\n        currentPageId,\n        viewport,\n        selectedIds,\n        currentPoint,\n        previousPoint,\n        originPoint,\n        altKey,\n        shiftKey,\n        metaKey,\n        currentGrid\n      }\n    } = this;\n    const nextBindings = {};\n    const nextShapes = {};\n    const nextPageState = {};\n    let delta = e.sub(currentPoint, originPoint);\n    let didChangeCloning = false;\n    if (!this.isCreate) {\n      if (altKey && !this.isCloning) {\n        this.isCloning = true;\n        didChangeCloning = true;\n      } else if (!altKey && this.isCloning) {\n        this.isCloning = false;\n        didChangeCloning = true;\n      }\n    }\n    if (shiftKey) {\n      if (Math.abs(delta[0]) < Math.abs(delta[1])) {\n        delta[0] = 0;\n      } else {\n        delta[1] = 0;\n      }\n    }\n    const speed = e.dist(currentPoint, previousPoint);\n    const change = speed - this.speed;\n    this.speed = this.speed + change * (change > 1 ? 0.5 : 0.15);\n    this.snapLines = [];\n    if ((isSnapping && !metaKey || !isSnapping && metaKey) && this.speed * camera.zoom < SLOW_SPEED && this.snapInfo.state === \"ready\") {\n      const snapResult = C3.getSnapPoints(\n        C3.getBoundsWithCenter(\n          showGrid ? C3.snapBoundsToGrid(C3.translateBounds(initialCommonBounds, delta), currentGrid) : C3.translateBounds(initialCommonBounds, delta)\n        ),\n        (this.isCloning ? this.snapInfo.bounds : this.snapInfo.others).filter((bounds) => {\n          return C3.boundsContain(viewport, bounds) || C3.boundsCollide(viewport, bounds);\n        }),\n        SNAP_DISTANCE / camera.zoom\n      );\n      if (snapResult) {\n        this.snapLines = snapResult.snapLines;\n        delta = e.sub(delta, snapResult.offset);\n      }\n    }\n    this.prev = delta;\n    if (this.isCloning) {\n      if (didChangeCloning) {\n        if (this.cloneInfo.state === \"empty\") {\n          this.createCloneInfo();\n        }\n        if (this.cloneInfo.state === \"empty\") {\n          throw Error;\n        }\n        const { clones, clonedBindings } = this.cloneInfo;\n        this.isCloning = true;\n        bindingsToDelete.forEach((binding) => nextBindings[binding.id] = binding);\n        initialShapes.forEach((shape) => nextShapes[shape.id] = { point: shape.point });\n        clones.forEach((clone) => {\n          nextShapes[clone.id] = { ...clone };\n          if (clone.parentId !== currentPageId && !selectedIds.includes(clone.parentId)) {\n            const children = nextShapes[clone.parentId]?.children || initialParentChildren[clone.parentId];\n            if (!children.includes(clone.id)) {\n              nextShapes[clone.parentId] = {\n                ...nextShapes[clone.parentId],\n                children: [...children, clone.id]\n              };\n            }\n          }\n        });\n        for (const binding of clonedBindings) {\n          nextBindings[binding.id] = binding;\n        }\n        nextPageState.selectedIds = clones.map((clone) => clone.id);\n        clones.forEach((clone) => {\n          nextShapes[clone.id] = {\n            ...clone,\n            point: showGrid ? e.snap(e.toFixed(e.add(clone.point, delta)), currentGrid) : e.toFixed(e.add(clone.point, delta))\n          };\n        });\n      } else {\n        if (this.cloneInfo.state === \"empty\")\n          throw Error;\n        const { clones } = this.cloneInfo;\n        clones.forEach((clone) => {\n          nextShapes[clone.id] = {\n            point: showGrid ? e.snap(e.toFixed(e.add(clone.point, delta)), currentGrid) : e.toFixed(e.add(clone.point, delta))\n          };\n        });\n      }\n    } else {\n      if (didChangeCloning) {\n        if (this.cloneInfo.state === \"empty\")\n          throw Error;\n        const { clones, clonedBindings } = this.cloneInfo;\n        this.isCloning = false;\n        bindingsToDelete.forEach((binding) => nextBindings[binding.id] = void 0);\n        clones.forEach((clone) => {\n          if (clone.parentId !== currentPageId) {\n            nextShapes[clone.parentId] = {\n              ...nextShapes[clone.parentId],\n              children: initialParentChildren[clone.parentId]\n            };\n          }\n        });\n        clones.forEach((clone) => nextShapes[clone.id] = void 0);\n        initialShapes.forEach((shape) => {\n          nextShapes[shape.id] = {\n            point: showGrid ? e.snap(e.toFixed(e.add(shape.point, delta)), currentGrid) : e.toFixed(e.add(shape.point, delta))\n          };\n        });\n        for (const binding of clonedBindings) {\n          nextBindings[binding.id] = void 0;\n        }\n        nextPageState.selectedIds = initialShapes.map((shape) => shape.id);\n      } else {\n        initialShapes.forEach((shape) => {\n          nextShapes[shape.id] = {\n            point: showGrid ? e.snap(e.toFixed(e.add(shape.point, delta)), currentGrid) : e.toFixed(e.add(shape.point, delta))\n          };\n        });\n      }\n    }\n    return {\n      appState: {\n        snapLines: this.snapLines\n      },\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: nextShapes,\n            bindings: nextBindings\n          }\n        },\n        pageStates: {\n          [currentPageId]: nextPageState\n        }\n      }\n    };\n  };\n  cancel = () => {\n    const {\n      initialShapes,\n      initialSelectedIds,\n      bindingsToDelete,\n      app: { currentPageId }\n    } = this;\n    const nextBindings = {};\n    const nextShapes = {};\n    const nextPageState = {\n      editingId: void 0,\n      hoveredId: void 0\n    };\n    if (this.isCreate) {\n      initialShapes.forEach(({ id }) => nextShapes[id] = void 0);\n      nextPageState.selectedIds = [];\n    } else {\n      initialShapes.forEach(\n        ({ id, point, handles }) => nextShapes[id] = handles ? { ...nextShapes[id], point, handles } : { ...nextShapes[id], point }\n      );\n      nextPageState.selectedIds = initialSelectedIds;\n      bindingsToDelete.forEach((binding) => {\n        nextBindings[binding.id] = binding;\n      });\n    }\n    if (this.cloneInfo.state === \"ready\") {\n      const { clones, clonedBindings } = this.cloneInfo;\n      clones.forEach((clone) => nextShapes[clone.id] = void 0);\n      clonedBindings.forEach((binding) => nextBindings[binding.id] = void 0);\n    }\n    return {\n      appState: {\n        snapLines: []\n      },\n      document: {\n        pages: {\n          [currentPageId]: {\n            shapes: nextShapes,\n            bindings: nextBindings\n          }\n        },\n        pageStates: {\n          [currentPageId]: nextPageState\n        }\n      }\n    };\n  };\n  complete = () => {\n    const {\n      initialShapes,\n      initialParentChildren,\n      bindingsToDelete,\n      app: { currentPageId }\n    } = this;\n    const beforeBindings = {};\n    const beforeShapes = {};\n    const afterBindings = {};\n    const afterShapes = {};\n    if (this.isCloning) {\n      if (this.cloneInfo.state === \"empty\") {\n        this.createCloneInfo();\n      }\n      if (this.cloneInfo.state !== \"ready\")\n        throw Error;\n      const { clones, clonedBindings } = this.cloneInfo;\n      clones.forEach((clone) => {\n        beforeShapes[clone.id] = void 0;\n        afterShapes[clone.id] = this.app.getShape(clone.id);\n        if (clone.parentId !== currentPageId) {\n          beforeShapes[clone.parentId] = {\n            ...beforeShapes[clone.parentId],\n            children: initialParentChildren[clone.parentId]\n          };\n          afterShapes[clone.parentId] = {\n            ...afterShapes[clone.parentId],\n            children: this.app.getShape(clone.parentId).children\n          };\n        }\n      });\n      clonedBindings.forEach((binding) => {\n        beforeBindings[binding.id] = void 0;\n        afterBindings[binding.id] = this.app.getBinding(binding.id);\n      });\n    } else {\n      initialShapes.forEach((shape) => {\n        beforeShapes[shape.id] = this.isCreate ? void 0 : {\n          ...beforeShapes[shape.id],\n          point: shape.point\n        };\n        afterShapes[shape.id] = {\n          ...afterShapes[shape.id],\n          ...this.isCreate ? this.app.getShape(shape.id) : { point: this.app.getShape(shape.id).point }\n        };\n      });\n    }\n    bindingsToDelete.forEach((binding) => {\n      beforeBindings[binding.id] = binding;\n      beforeShapes[binding.fromId] = {\n        ...beforeShapes[binding.fromId],\n        id: binding.fromId,\n        handles: {\n          ...beforeShapes[binding.fromId]?.handles,\n          [binding.handleId]: {\n            ...beforeShapes[binding.fromId]?.handles?.[binding.handleId],\n            bindingId: binding.id\n          }\n        }\n      };\n      afterShapes[binding.fromId] = {\n        ...afterShapes[binding.fromId],\n        id: binding.fromId,\n        handles: {\n          // @ts-expect-error\n          ...afterShapes[binding.fromId].handles,\n          [binding.handleId]: {\n            ...afterShapes[binding.fromId]?.handles?.[binding.handleId],\n            bindingId: void 0\n          }\n        }\n      };\n    });\n    bindingsToDelete.forEach((binding) => afterBindings[binding.id] = void 0);\n    return {\n      id: \"translate\",\n      before: {\n        appState: {\n          snapLines: []\n        },\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: beforeShapes,\n              bindings: beforeBindings\n            }\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: this.isCreate ? [] : [...this.initialSelectedIds]\n            }\n          }\n        }\n      },\n      after: {\n        appState: {\n          snapLines: []\n        },\n        document: {\n          pages: {\n            [currentPageId]: {\n              shapes: afterShapes,\n              bindings: afterBindings\n            }\n          },\n          pageStates: {\n            [currentPageId]: {\n              selectedIds: [...this.app.selectedIds]\n            }\n          }\n        }\n      }\n    };\n  };\n  createCloneInfo = () => {\n    const {\n      initialShapes,\n      initialParentChildren,\n      app: { selectedIds, currentPageId, page }\n    } = this;\n    const cloneMap = {};\n    const clonedBindingsMap = {};\n    const clonedBindings = [];\n    const clones = [];\n    initialShapes.forEach((shape) => {\n      const newId = C3.uniqueId();\n      initialParentChildren[newId] = initialParentChildren[shape.id];\n      cloneMap[shape.id] = newId;\n      const clone = {\n        ...C3.deepClone(shape),\n        id: newId,\n        parentId: shape.parentId,\n        childIndex: TLDR.getChildIndexAbove(this.app.state, shape.id, currentPageId)\n      };\n      clones.push(clone);\n    });\n    clones.forEach((clone) => {\n      if (clone.children !== void 0) {\n        clone.children = clone.children.map((childId) => cloneMap[childId]);\n      }\n    });\n    clones.forEach((clone) => {\n      if (selectedIds.includes(clone.parentId)) {\n        clone.parentId = cloneMap[clone.parentId];\n      }\n    });\n    const clonedShapeIds = new Set(Object.keys(cloneMap));\n    Object.values(page.bindings).filter((binding) => clonedShapeIds.has(binding.fromId) || clonedShapeIds.has(binding.toId)).forEach((binding) => {\n      if (clonedShapeIds.has(binding.fromId) && clonedShapeIds.has(binding.toId)) {\n        const cloneId = C3.uniqueId();\n        const cloneBinding = {\n          ...C3.deepClone(binding),\n          id: cloneId,\n          fromId: cloneMap[binding.fromId] || binding.fromId,\n          toId: cloneMap[binding.toId] || binding.toId\n        };\n        clonedBindingsMap[binding.id] = cloneId;\n        clonedBindings.push(cloneBinding);\n      }\n    });\n    clones.forEach((clone) => {\n      if (clone.handles && clone.handles) {\n        for (const id in clone.handles) {\n          const handle = clone.handles[id];\n          handle.bindingId = handle.bindingId ? clonedBindingsMap[handle.bindingId] : void 0;\n        }\n      }\n    });\n    clones.forEach((clone) => {\n      if (page.shapes[clone.id]) {\n        throw new Error(\"uh oh, we didn't clone correctly\");\n      }\n    });\n    this.cloneInfo = {\n      state: \"ready\",\n      clones,\n      cloneMap,\n      clonedBindings\n    };\n  };\n};\n\n// src/components/Tldraw/state/sessions/index.ts\nvar sessions = {\n  [\"arrow\" /* Arrow */]: ArrowSession,\n  [\"brush\" /* Brush */]: BrushSession,\n  [\"draw\" /* Draw */]: DrawSession,\n  [\"erase\" /* Erase */]: EraseSession,\n  [\"handle\" /* Handle */]: HandleSession,\n  [\"rotate\" /* Rotate */]: RotateSession,\n  [\"transform\" /* Transform */]: TransformSession,\n  [\"transformSingle\" /* TransformSingle */]: TransformSingleSession,\n  [\"translate\" /* Translate */]: TranslateSession,\n  [\"grid\" /* Grid */]: GridSession,\n  [\"edit\" /* Edit */]: EditSession\n};\nvar getSession = (type) => {\n  return sessions[type];\n};\n\n// src/components/Tldraw/state/tools/BaseTool.ts\nvar BaseTool = class extends TDEventHandler {\n  constructor(app) {\n    super();\n    this.app = app;\n  }\n  type = \"select\";\n  previous;\n  status = \"idle\" /* Idle */;\n  setStatus = (status) => {\n    this.status = status;\n    this.app.setStatus(this.status);\n  };\n  onEnter = () => {\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  onExit = () => {\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  onCancel = () => {\n    if (this.status === \"idle\" /* Idle */) {\n      this.app.selectTool(\"select\");\n    } else {\n      this.setStatus(\"idle\" /* Idle */);\n    }\n    this.app.cancelSession();\n  };\n  getNextChildIndex = () => {\n    const {\n      shapes,\n      appState: { currentPageId }\n    } = this.app;\n    return shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === currentPageId).sort((a7, b6) => b6.childIndex - a7.childIndex)[0].childIndex + 1;\n  };\n  /* --------------------- Camera --------------------- */\n  onPinchStart = () => {\n    this.app.cancelSession();\n    this.setStatus(\"pinching\" /* Pinching */);\n  };\n  onPinchEnd = () => {\n    if (C3.isMobileSafari()) {\n      this.app.undoSelect();\n    }\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  onPinch = (info, e5) => {\n    if (this.status !== \"pinching\")\n      return;\n    if (isNaN(info.delta[0]) || isNaN(info.delta[1]))\n      return;\n    this.app.pinchZoom(info.point, info.delta, info.delta[2]);\n    this.onPointerMove?.(info, e5);\n  };\n  /* ---------------------- Keys ---------------------- */\n  onKeyDown = (key) => {\n    if (key === \"Escape\") {\n      this.onCancel();\n      return;\n    }\n    if (key === \"Meta\" || key === \"Control\" || key === \"Alt\") {\n      this.app.updateSession();\n    }\n  };\n  onKeyUp = (key) => {\n    if (key === \"Meta\" || key === \"Control\" || key === \"Alt\") {\n      this.app.updateSession();\n    }\n  };\n  /* --------------------- Pointer -------------------- */\n  onPointerMove = () => {\n    if (this.status === \"creating\" /* Creating */) {\n      this.app.updateSession();\n    }\n  };\n  onPointerUp = () => {\n    if (this.status === \"creating\" /* Creating */) {\n      this.app.completeSession();\n      const { isToolLocked } = this.app.appState;\n      if (!isToolLocked) {\n        this.app.selectTool(\"select\");\n      }\n    }\n    this.setStatus(\"idle\" /* Idle */);\n  };\n};\n\n// src/components/Tldraw/state/tools/ArrowTool/ArrowTool.ts\nvar ArrowTool = class extends BaseTool {\n  type = \"arrow\" /* Arrow */;\n  /* ----------------- Event Handlers ----------------- */\n  onPointerDown = () => {\n    if (this.status !== \"idle\" /* Idle */)\n      return;\n    const {\n      currentPoint,\n      currentGrid,\n      settings: { showGrid },\n      appState: { currentPageId, currentStyle }\n    } = this.app;\n    const childIndex = this.getNextChildIndex();\n    const id = C3.uniqueId();\n    const newShape = Arrow.create({\n      id,\n      parentId: currentPageId,\n      childIndex,\n      point: showGrid ? p.snap(currentPoint, currentGrid) : currentPoint,\n      style: { ...currentStyle }\n    });\n    this.app.patchCreate([newShape]);\n    this.app.startSession(\"arrow\" /* Arrow */, newShape.id, \"end\", true);\n    this.setStatus(\"creating\" /* Creating */);\n  };\n};\n\n// src/components/Tldraw/state/tools/DrawTool/DrawTool.ts\nvar DrawTool = class extends BaseTool {\n  type = \"draw\" /* Draw */;\n  lastShapeId;\n  onEnter = () => {\n    this.lastShapeId = void 0;\n  };\n  onCancel = () => {\n    switch (this.status) {\n      case \"idle\" /* Idle */: {\n        this.app.selectTool(\"select\");\n        break;\n      }\n      default: {\n        this.setStatus(\"idle\" /* Idle */);\n        break;\n      }\n    }\n    this.app.cancelSession();\n  };\n  /* ----------------- Event Handlers ----------------- */\n  onPointerDown = (info) => {\n    if (this.status !== \"idle\" /* Idle */)\n      return;\n    if (this.app.readOnly)\n      return;\n    const {\n      currentPoint,\n      appState: { currentPageId, currentStyle }\n    } = this.app;\n    const previous = this.lastShapeId && this.app.getShape(this.lastShapeId);\n    if (info.shiftKey && previous) {\n      this.app.startSession(\"draw\" /* Draw */, previous.id);\n      this.setStatus(\"extending\" /* Extending */);\n    } else {\n      const childIndex = this.getNextChildIndex();\n      const id = C3.uniqueId();\n      const newShape = Draw.create({\n        id,\n        parentId: currentPageId,\n        childIndex,\n        point: currentPoint,\n        style: { ...currentStyle }\n      });\n      this.lastShapeId = id;\n      this.app.patchCreate([newShape]);\n      this.app.startSession(\"draw\" /* Draw */, id);\n      this.setStatus(\"creating\" /* Creating */);\n    }\n  };\n  onPointerMove = () => {\n    if (this.app.readOnly)\n      return;\n    switch (this.status) {\n      case \"extending\" /* Extending */:\n      case \"creating\" /* Creating */: {\n        this.app.updateSession();\n      }\n    }\n  };\n  onPointerUp = () => {\n    this.app.completeSession();\n    this.setStatus(\"idle\" /* Idle */);\n  };\n};\n\n// src/components/Tldraw/state/tools/EllipseTool/EllipseTool.ts\nvar EllipseTool = class extends BaseTool {\n  type = \"ellipse\" /* Ellipse */;\n  /* ----------------- Event Handlers ----------------- */\n  onPointerDown = () => {\n    if (this.app.readOnly)\n      return;\n    if (this.status !== \"idle\" /* Idle */)\n      return;\n    const {\n      currentPoint,\n      currentGrid,\n      settings: { showGrid },\n      appState: { currentPageId, currentStyle }\n    } = this.app;\n    const childIndex = this.getNextChildIndex();\n    const id = C3.uniqueId();\n    const newShape = Ellipse.create({\n      id,\n      parentId: currentPageId,\n      childIndex,\n      point: showGrid ? p.snap(currentPoint, currentGrid) : currentPoint,\n      style: { ...currentStyle }\n    });\n    this.app.patchCreate([newShape]);\n    this.app.startSession(\"transformSingle\" /* TransformSingle */, newShape.id, He.BottomRight, true);\n    this.setStatus(\"creating\" /* Creating */);\n  };\n};\n\n// src/components/Tldraw/state/tools/EraseTool/EraseTool.ts\nvar EraseTool = class extends BaseTool {\n  type = \"erase\";\n  status = \"idle\" /* Idle */;\n  /* ----------------- Event Handlers ----------------- */\n  onPointerDown = () => {\n    if (this.app.readOnly)\n      return;\n    if (this.status !== \"idle\" /* Idle */)\n      return;\n    this.setStatus(\"pointing\" /* Pointing */);\n  };\n  onPointerMove = (info) => {\n    if (this.app.readOnly)\n      return;\n    switch (this.status) {\n      case \"pointing\" /* Pointing */: {\n        if (p.dist(info.origin, info.point) > DEAD_ZONE) {\n          this.app.startSession(\"erase\" /* Erase */);\n          this.app.updateSession();\n          this.setStatus(\"erasing\" /* Erasing */);\n        }\n        break;\n      }\n      case \"erasing\" /* Erasing */: {\n        this.app.updateSession();\n      }\n    }\n  };\n  onPointerUp = () => {\n    if (this.app.readOnly)\n      return;\n    switch (this.status) {\n      case \"pointing\" /* Pointing */: {\n        const shapeIdsAtPoint = this.app.shapes.filter((shape) => !shape.isLocked).filter((shape) => this.app.getShapeUtil(shape).hitTestPoint(shape, this.app.currentPoint)).flatMap((shape) => shape.children ? [shape.id, ...shape.children] : shape.id);\n        this.app.delete(shapeIdsAtPoint);\n        break;\n      }\n      case \"erasing\" /* Erasing */: {\n        this.app.completeSession();\n      }\n    }\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  onCancel = () => {\n    if (this.status === \"idle\" /* Idle */) {\n      if (this.previous) {\n        this.app.selectTool(this.previous);\n      } else {\n        this.app.selectTool(\"select\");\n      }\n    } else {\n      this.setStatus(\"idle\" /* Idle */);\n    }\n    this.app.cancelSession();\n  };\n};\n\n// src/components/Tldraw/state/tools/LineTool/LineTool.ts\nvar LineTool = class extends BaseTool {\n  type = \"line\" /* Line */;\n  /* ----------------- Event Handlers ----------------- */\n  onPointerDown = () => {\n    if (this.app.readOnly)\n      return;\n    if (this.status !== \"idle\" /* Idle */)\n      return;\n    const {\n      currentPoint,\n      currentGrid,\n      settings: { showGrid },\n      appState: { currentPageId, currentStyle }\n    } = this.app;\n    const childIndex = this.getNextChildIndex();\n    const id = C3.uniqueId();\n    const newShape = Arrow.create({\n      id,\n      parentId: currentPageId,\n      childIndex,\n      point: showGrid ? p.snap(currentPoint, currentGrid) : currentPoint,\n      decorations: {\n        start: void 0,\n        end: void 0\n      },\n      style: { ...currentStyle }\n    });\n    this.app.patchCreate([newShape]);\n    this.app.startSession(\"arrow\" /* Arrow */, newShape.id, \"end\", true);\n    this.setStatus(\"creating\" /* Creating */);\n  };\n};\n\n// src/components/Tldraw/state/tools/RectangleTool/RectangleTool.ts\nvar RectangleTool = class extends BaseTool {\n  type = \"rectangle\" /* Rectangle */;\n  /* ----------------- Event Handlers ----------------- */\n  onPointerDown = () => {\n    if (this.app.readOnly)\n      return;\n    if (this.status !== \"idle\" /* Idle */)\n      return;\n    const {\n      currentPoint,\n      currentGrid,\n      settings: { showGrid },\n      appState: { currentPageId, currentStyle }\n    } = this.app;\n    const childIndex = this.getNextChildIndex();\n    const id = C3.uniqueId();\n    const newShape = Rectangle.create({\n      id,\n      parentId: currentPageId,\n      childIndex,\n      point: showGrid ? p.snap(currentPoint, currentGrid) : currentPoint,\n      style: { ...currentStyle }\n    });\n    this.app.patchCreate([newShape]);\n    this.app.startSession(\"transformSingle\" /* TransformSingle */, newShape.id, He.BottomRight, true);\n    this.setStatus(\"creating\" /* Creating */);\n  };\n};\n\n// src/components/Tldraw/state/tools/SelectTool/SelectTool.ts\nvar SelectTool = class extends BaseTool {\n  type = \"select\";\n  pointedId;\n  selectedGroupId;\n  pointedHandleId;\n  pointedBoundsHandle;\n  pointedLinkHandleId;\n  /* --------------------- Methods -------------------- */\n  deselect(id) {\n    this.app.select(...this.app.selectedIds.filter((oid) => oid !== id));\n  }\n  select(id) {\n    this.app.select(id);\n  }\n  pushSelect(id) {\n    const shape = this.app.getShape(id);\n    this.app.select(...this.app.selectedIds.filter((oid) => oid !== shape.parentId), id);\n  }\n  selectNone() {\n    this.app.selectNone();\n  }\n  onEnter = () => {\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  onExit = () => {\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  clonePaint = (point) => {\n    if (this.app.selectedIds.length === 0)\n      return;\n    const shapes = this.app.selectedIds.map((id) => this.app.getShape(id));\n    const bounds = C3.expandBounds(C3.getCommonBounds(shapes.map(TLDR.getBounds)), 16);\n    const center = C3.getBoundsCenter(bounds);\n    const size = [bounds.width, bounds.height];\n    const gridPoint = [\n      center[0] + size[0] * Math.floor((point[0] + size[0] / 2 - center[0]) / size[0]),\n      center[1] + size[1] * Math.floor((point[1] + size[1] / 2 - center[1]) / size[1])\n    ];\n    const centeredBounds = C3.centerBounds(bounds, gridPoint);\n    const hit = this.app.shapes.some((shape) => TLDR.getShapeUtil(shape).hitTestBounds(shape, centeredBounds));\n    if (!hit) {\n      this.app.duplicate(this.app.selectedIds, gridPoint);\n    }\n  };\n  getShapeClone = (id, side) => {\n    const shape = this.app.getShape(id);\n    const utils = TLDR.getShapeUtil(shape);\n    if (utils.canClone) {\n      const bounds = utils.getBounds(shape);\n      const center = utils.getCenter(shape);\n      let point = {\n        top: [bounds.minX, bounds.minY - (bounds.height + CLONING_DISTANCE)],\n        right: [bounds.maxX + CLONING_DISTANCE, bounds.minY],\n        bottom: [bounds.minX, bounds.maxY + CLONING_DISTANCE],\n        left: [bounds.minX - (bounds.width + CLONING_DISTANCE), bounds.minY],\n        topLeft: [bounds.minX - (bounds.width + CLONING_DISTANCE), bounds.minY - (bounds.height + CLONING_DISTANCE)],\n        topRight: [bounds.maxX + CLONING_DISTANCE, bounds.minY - (bounds.height + CLONING_DISTANCE)],\n        bottomLeft: [bounds.minX - (bounds.width + CLONING_DISTANCE), bounds.maxY + CLONING_DISTANCE],\n        bottomRight: [bounds.maxX + CLONING_DISTANCE, bounds.maxY + CLONING_DISTANCE]\n      }[side];\n      if (shape.rotation !== 0) {\n        const newCenter = p.add(point, [bounds.width / 2, bounds.height / 2]);\n        const rotatedCenter = p.rotWith(newCenter, center, shape.rotation || 0);\n        point = p.sub(rotatedCenter, [bounds.width / 2, bounds.height / 2]);\n      }\n      const id2 = C3.uniqueId();\n      const clone = {\n        ...shape,\n        id: id2,\n        point\n      };\n      if (clone.type === \"sticky\" /* Sticky */) {\n        clone.text = \"\";\n      }\n      return clone;\n    }\n  };\n  /* ----------------- Event Handlers ----------------- */\n  onCancel = () => {\n    if (this.app.session) {\n      this.app.cancelSession();\n    } else {\n      this.selectNone();\n    }\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  onKeyDown = (key, info, e5) => {\n    switch (key) {\n      case \"Escape\": {\n        this.onCancel();\n        break;\n      }\n      case \"Tab\": {\n        if (this.app.readOnly)\n          return;\n        if (!this.app.pageState.editingId && this.status === \"idle\" /* Idle */ && this.app.selectedIds.length === 1) {\n          const [selectedId] = this.app.selectedIds;\n          const clonedShape = this.getShapeClone(selectedId, \"right\");\n          if (clonedShape) {\n            this.app.createShapes(clonedShape);\n            this.setStatus(\"idle\" /* Idle */);\n            if (clonedShape.type === \"sticky\" /* Sticky */) {\n              this.app.select(clonedShape.id);\n              this.app.setEditingId(clonedShape.id);\n            }\n          }\n        }\n        break;\n      }\n      case \"Meta\":\n      case \"Control\":\n      case \"Alt\": {\n        this.app.updateSession();\n        break;\n      }\n      case \"Enter\": {\n        if (this.app.readOnly)\n          return;\n        const { pageState } = this.app;\n        if (pageState.selectedIds.length === 1 && !pageState.editingId) {\n          this.app.setEditingId(pageState.selectedIds[0]);\n          e5.preventDefault();\n        }\n      }\n    }\n  };\n  onKeyUp = (key, info) => {\n    if (this.status === \"clonePainting\" /* ClonePainting */ && !(info.altKey && info.shiftKey)) {\n      this.setStatus(\"idle\" /* Idle */);\n      return;\n    }\n    if (key === \"Meta\" || key === \"Control\" || key === \"Alt\") {\n      this.app.updateSession();\n    }\n  };\n  // Keyup is handled on BaseTool\n  // Pointer Events (generic)\n  onPointerMove = () => {\n    const { originPoint, currentPoint } = this.app;\n    if (this.app.readOnly && this.app.isPointing) {\n      if (this.app.session) {\n        this.app.updateSession();\n      } else {\n        if (p.dist(originPoint, currentPoint) > DEAD_ZONE) {\n          this.app.startSession(\"brush\" /* Brush */);\n          this.setStatus(\"brushing\" /* Brushing */);\n        }\n      }\n      return;\n    }\n    switch (this.status) {\n      case \"pointingBoundsHandle\" /* PointingBoundsHandle */: {\n        if (!this.pointedBoundsHandle)\n          throw new Error(\"No pointed bounds handle\");\n        if (p.dist(originPoint, currentPoint) > DEAD_ZONE) {\n          if (this.pointedBoundsHandle === \"rotate\") {\n            this.setStatus(\"rotating\" /* Rotating */);\n            this.app.startSession(\"rotate\" /* Rotate */);\n          } else if (this.pointedBoundsHandle === \"center\" || this.pointedBoundsHandle === \"left\" || this.pointedBoundsHandle === \"right\") {\n            this.setStatus(\"translating\" /* Translating */);\n            this.app.startSession(\"translate\" /* Translate */, false, this.pointedBoundsHandle);\n          } else {\n            this.setStatus(\"transforming\" /* Transforming */);\n            const idsToTransform = this.app.selectedIds.flatMap((id) => TLDR.getDocumentBranch(this.app.state, id, this.app.currentPageId));\n            if (idsToTransform.length === 1) {\n              this.app.startSession(\"transformSingle\" /* TransformSingle */, idsToTransform[0], this.pointedBoundsHandle);\n            } else {\n              this.app.startSession(\"transform\" /* Transform */, this.pointedBoundsHandle);\n            }\n          }\n          this.app.updateSession();\n        }\n        break;\n      }\n      case \"pointingCanvas\" /* PointingCanvas */: {\n        if (p.dist(originPoint, currentPoint) > DEAD_ZONE) {\n          this.app.startSession(\"brush\" /* Brush */);\n          this.setStatus(\"brushing\" /* Brushing */);\n        }\n        break;\n      }\n      case \"pointingClone\" /* PointingClone */: {\n        if (p.dist(originPoint, currentPoint) > DEAD_ZONE) {\n          this.setStatus(\"translatingClone\" /* TranslatingClone */);\n          this.app.startSession(\"translate\" /* Translate */);\n          this.app.updateSession();\n        }\n        break;\n      }\n      case \"pointingBounds\" /* PointingBounds */: {\n        if (p.dist(originPoint, currentPoint) > DEAD_ZONE) {\n          this.setStatus(\"translating\" /* Translating */);\n          this.app.startSession(\"translate\" /* Translate */);\n          this.app.updateSession();\n        }\n        break;\n      }\n      case \"pointingHandle\" /* PointingHandle */: {\n        if (!this.pointedHandleId)\n          throw new Error(\"No pointed handle\");\n        if (p.dist(originPoint, currentPoint) > DEAD_ZONE) {\n          this.setStatus(\"translatingHandle\" /* TranslatingHandle */);\n          const selectedShape = this.app.getShape(this.app.selectedIds[0]);\n          if (selectedShape) {\n            if (this.pointedHandleId === \"bend\") {\n              this.app.startSession(\"handle\" /* Handle */, selectedShape.id, this.pointedHandleId);\n              this.app.updateSession();\n            } else {\n              this.app.startSession(\"arrow\" /* Arrow */, selectedShape.id, this.pointedHandleId, false);\n              this.app.updateSession();\n            }\n          }\n        }\n        break;\n      }\n      case \"clonePainting\" /* ClonePainting */: {\n        this.clonePaint(currentPoint);\n        break;\n      }\n      default: {\n        if (this.app.session) {\n          this.app.updateSession();\n          break;\n        }\n      }\n    }\n  };\n  onPointerDown = (info, e5) => {\n    if (info.target === \"canvas\" && this.status === \"idle\" /* Idle */) {\n      const { currentPoint } = this.app;\n      if (info.spaceKey && e5.buttons === 1)\n        return;\n      if (this.status === \"idle\" /* Idle */ && info.altKey && info.shiftKey) {\n        this.setStatus(\"clonePainting\" /* ClonePainting */);\n        this.clonePaint(currentPoint);\n        return;\n      }\n      if (!info.shiftKey) {\n        this.app.onShapeBlur();\n        if (info.altKey && this.app.selectedIds.length > 0) {\n          this.app.duplicate(this.app.selectedIds, currentPoint);\n          return;\n        }\n        this.selectNone();\n      }\n      this.setStatus(\"pointingCanvas\" /* PointingCanvas */);\n    }\n  };\n  onPointerUp = (info) => {\n    if (this.status === \"translatingClone\" /* TranslatingClone */ || this.status === \"pointingClone\" /* PointingClone */) {\n      if (this.pointedId) {\n        this.app.completeSession();\n        this.app.setEditingId(this.pointedId);\n      }\n      this.setStatus(\"idle\" /* Idle */);\n      this.pointedId = void 0;\n      return;\n    }\n    if (this.status === \"pointingBounds\" /* PointingBounds */) {\n      if (info.target === \"bounds\") {\n        this.selectNone();\n      } else if (this.app.isSelected(info.target)) {\n        if (info.shiftKey) {\n          if (this.pointedId !== info.target) {\n            this.deselect(info.target);\n          }\n        } else {\n          if (this.pointedId !== info.target && this.app.selectedIds.length > 1) {\n            this.select(info.target);\n          }\n        }\n      } else if (this.pointedId === info.target) {\n        if (this.app.getShape(info.target).isLocked)\n          return;\n        if (info.shiftKey) {\n          this.pushSelect(info.target);\n        } else {\n          this.select(info.target);\n        }\n      }\n    }\n    this.setStatus(\"idle\" /* Idle */);\n    this.pointedBoundsHandle = void 0;\n    this.pointedHandleId = void 0;\n    this.pointedId = void 0;\n    if (this.app.session?.type === \"edit\" /* Edit */) {\n      return;\n    }\n    this.app.completeSession();\n  };\n  // Canvas\n  onDoubleClickCanvas = () => {\n    if (this.app.readOnly)\n      return;\n  };\n  // Shape\n  onPointShape = (info, e5) => {\n    if (info.spaceKey && e5.buttons === 1)\n      return;\n    if (this.app.getShape(info.target).isLocked)\n      return;\n    const { editingId, hoveredId } = this.app.pageState;\n    if (editingId && info.target !== editingId) {\n      this.app.onShapeBlur();\n    }\n    if ((this.status === \"idle\" /* Idle */ || this.status === \"pointingBounds\" /* PointingBounds */) && info.metaKey && info.shiftKey && hoveredId) {\n      this.pointedId = hoveredId;\n      if (this.app.isSelected(hoveredId)) {\n        this.deselect(hoveredId);\n      } else {\n        this.pushSelect(hoveredId);\n        this.setStatus(\"pointingBounds\" /* PointingBounds */);\n      }\n      return;\n    }\n    if (this.status === \"pointingBounds\" /* PointingBounds */) {\n      const { parentId } = this.app.getShape(info.target);\n      this.pointedId = parentId === this.app.currentPageId ? info.target : parentId;\n      return;\n    }\n    if (this.status === \"idle\" /* Idle */) {\n      this.setStatus(\"pointingBounds\" /* PointingBounds */);\n      if (info.metaKey) {\n        if (!info.shiftKey) {\n          this.selectNone();\n        }\n        this.app.startSession(\"brush\" /* Brush */);\n        this.setStatus(\"brushing\" /* Brushing */);\n        return;\n      }\n      let shapeIdToSelect;\n      const { parentId } = this.app.getShape(info.target);\n      if (parentId === this.app.currentPageId) {\n        shapeIdToSelect = info.target;\n        this.selectedGroupId = void 0;\n      } else {\n        if (parentId === this.selectedGroupId) {\n          shapeIdToSelect = info.target;\n        } else {\n          shapeIdToSelect = parentId;\n          this.selectedGroupId = void 0;\n        }\n      }\n      if (!this.app.isSelected(shapeIdToSelect)) {\n        this.pointedId = shapeIdToSelect;\n        if (info.shiftKey) {\n          this.pushSelect(shapeIdToSelect);\n        } else {\n          this.select(shapeIdToSelect);\n        }\n      }\n    }\n  };\n  onDoubleClickShape = (info) => {\n    if (this.app.readOnly)\n      return;\n    const shape = this.app.getShape(info.target);\n    if (shape.isLocked) {\n      this.app.select(info.target);\n      return;\n    }\n    if (TLDR.getShapeUtil(shape.type).canEdit && (shape.parentId === this.app.currentPageId || shape.parentId === this.selectedGroupId)) {\n      this.app.setEditingId(info.target);\n    }\n    if (shape.parentId !== this.app.currentPageId) {\n      this.selectedGroupId = shape.parentId;\n    }\n    this.app.select(info.target);\n  };\n  onRightPointShape = (info) => {\n    if (!this.app.isSelected(info.target)) {\n      this.app.select(info.target);\n    }\n  };\n  onHoverShape = (info) => {\n    this.app.setHoveredId(info.target);\n  };\n  onUnhoverShape = (info) => {\n    const { currentPageId: oldCurrentPageId } = this.app;\n    requestAnimationFrame(() => {\n      if (oldCurrentPageId === this.app.currentPageId && this.app.pageState.hoveredId === info.target) {\n        this.app.setHoveredId();\n      }\n    });\n  };\n  /* --------------------- Bounds --------------------- */\n  onPointBounds = (info) => {\n    if (info.metaKey) {\n      if (!info.shiftKey) {\n        this.selectNone();\n      }\n      this.app.startSession(\"brush\" /* Brush */);\n      this.setStatus(\"brushing\" /* Brushing */);\n      return;\n    }\n    this.setStatus(\"pointingBounds\" /* PointingBounds */);\n  };\n  onRightPointBounds = (info, e5) => {\n    e5.stopPropagation();\n  };\n  onReleaseBounds = () => {\n    if (this.status === \"translating\" /* Translating */ || this.status === \"brushing\" /* Brushing */) {\n      this.app.completeSession();\n    }\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  /* ----------------- Bounds Handles ----------------- */\n  onPointBoundsHandle = (info) => {\n    this.pointedBoundsHandle = info.target;\n    this.setStatus(\"pointingBoundsHandle\" /* PointingBoundsHandle */);\n  };\n  onDoubleClickBoundsHandle = (info) => {\n    switch (info.target) {\n      case \"center\":\n      case \"left\":\n      case \"right\": {\n        this.app.select(...TLDR.getLinkedShapeIds(this.app.state, this.app.currentPageId, info.target, info.shiftKey));\n        break;\n      }\n      default: {\n        if (this.app.selectedIds.length === 1) {\n          this.app.resetBounds(this.app.selectedIds);\n          const shape = this.app.getShape(this.app.selectedIds[0]);\n          if (\"label\" in shape) {\n            this.app.setEditingId(shape.id);\n          }\n        }\n      }\n    }\n  };\n  onReleaseBoundsHandle = () => {\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  /* --------------------- Handles -------------------- */\n  onPointHandle = (info) => {\n    this.pointedHandleId = info.target;\n    this.setStatus(\"pointingHandle\" /* PointingHandle */);\n  };\n  onDoubleClickHandle = (info) => {\n    if (info.target === \"bend\") {\n      const { selectedIds } = this.app;\n      if (selectedIds.length !== 1)\n        return;\n      const shape = this.app.getShape(selectedIds[0]);\n      if (TLDR.getShapeUtil(shape.type).canEdit && (shape.parentId === this.app.currentPageId || shape.parentId === this.selectedGroupId)) {\n        this.app.setEditingId(shape.id);\n      }\n      return;\n    }\n    this.app.toggleDecoration(info.target);\n  };\n  onReleaseHandle = () => {\n    this.setStatus(\"idle\" /* Idle */);\n  };\n  /* ---------------------- Misc ---------------------- */\n  onShapeClone = (info) => {\n    const selectedShapeId = this.app.selectedIds[0];\n    const clonedShape = this.getShapeClone(selectedShapeId, info.target);\n    if (info.target === \"left\" || info.target === \"right\" || info.target === \"top\" || info.target === \"bottom\") {\n      if (clonedShape) {\n        this.app.createShapes(clonedShape);\n        this.pointedId = clonedShape.id;\n        this.setStatus(\"pointingClone\" /* PointingClone */);\n      }\n    } else {\n      this.setStatus(\"gridCloning\" /* GridCloning */);\n      this.app.startSession(\"grid\" /* Grid */, selectedShapeId);\n    }\n  };\n};\n\n// src/components/Tldraw/state/tools/StickyTool/StickyTool.ts\nvar StickyTool = class extends BaseTool {\n  type = \"sticky\" /* Sticky */;\n  shapeId;\n  /* ----------------- Event Handlers ----------------- */\n  onPointerDown = () => {\n    if (this.app.readOnly)\n      return;\n    if (this.status === \"creating\" /* Creating */) {\n      this.setStatus(\"idle\" /* Idle */);\n      if (!this.app.appState.isToolLocked) {\n        this.app.selectTool(\"select\");\n      }\n      return;\n    }\n    if (this.status === \"idle\" /* Idle */) {\n      const {\n        currentPoint,\n        currentGrid,\n        settings: { showGrid },\n        appState: { currentPageId, currentStyle }\n      } = this.app;\n      const childIndex = this.getNextChildIndex();\n      const id = C3.uniqueId();\n      this.shapeId = id;\n      const newShape = Sticky.create({\n        id,\n        parentId: currentPageId,\n        childIndex,\n        point: showGrid ? p.snap(currentPoint, currentGrid) : currentPoint,\n        style: { ...currentStyle }\n      });\n      const bounds = Sticky.getBounds(newShape);\n      newShape.point = p.sub(newShape.point, [bounds.width / 2, bounds.height / 2]);\n      this.app.patchCreate([newShape]);\n      this.app.startSession(\"translate\" /* Translate */);\n      this.setStatus(\"creating\" /* Creating */);\n    }\n  };\n  onPointerUp = () => {\n    if (this.app.readOnly)\n      return;\n    if (this.status === \"creating\" /* Creating */) {\n      this.setStatus(\"idle\" /* Idle */);\n      this.app.completeSession();\n      this.app.selectTool(\"select\");\n      this.app.setEditingId(this.shapeId);\n    }\n  };\n};\n\n// src/components/Tldraw/state/tools/TextTool/TextTool.ts\nvar TextTool = class extends BaseTool {\n  type = \"text\" /* Text */;\n  /* --------------------- Methods -------------------- */\n  stopEditingShape = () => {\n    this.setStatus(\"idle\" /* Idle */);\n    if (!this.app.appState.isToolLocked) {\n      this.app.selectTool(\"select\");\n    }\n  };\n  /* ----------------- Event Handlers ----------------- */\n  onKeyUp = () => {\n  };\n  onKeyDown = () => {\n  };\n  onPointerDown = () => {\n    if (this.status === \"creating\" /* Creating */) {\n      this.stopEditingShape();\n      return;\n    }\n    if (this.status === \"idle\" /* Idle */) {\n      const {\n        currentPoint,\n        currentGrid,\n        settings: { showGrid }\n      } = this.app;\n      this.app.createTextShapeAtPoint(showGrid ? p.snap(currentPoint, currentGrid) : currentPoint, void 0, true);\n      this.setStatus(\"creating\" /* Creating */);\n    }\n  };\n  onPointerUp = () => {\n  };\n  onPointShape = (info) => {\n    if (this.app.readOnly)\n      return;\n    const shape = this.app.getShape(info.target);\n    if (shape.type === \"text\" /* Text */) {\n      this.setStatus(\"idle\" /* Idle */);\n      this.app.setEditingId(shape.id);\n    }\n  };\n  onShapeBlur = () => {\n    if (this.app.readOnly)\n      return;\n    this.stopEditingShape();\n  };\n};\n\n// src/components/Tldraw/state/tools/TriangleTool/TriangleTool.ts\nvar TriangleTool = class extends BaseTool {\n  type = \"triangle\" /* Triangle */;\n  /* ----------------- Event Handlers ----------------- */\n  onPointerDown = () => {\n    if (this.app.readOnly)\n      return;\n    if (this.status !== \"idle\" /* Idle */)\n      return;\n    const {\n      currentPoint,\n      currentGrid,\n      settings: { showGrid },\n      appState: { currentPageId, currentStyle }\n    } = this.app;\n    const childIndex = this.getNextChildIndex();\n    const id = C3.uniqueId();\n    const newShape = Triangle.create({\n      id,\n      parentId: currentPageId,\n      childIndex,\n      point: showGrid ? p.snap(currentPoint, currentGrid) : currentPoint,\n      style: { ...currentStyle }\n    });\n    this.app.patchCreate([newShape]);\n    this.app.startSession(\"transformSingle\" /* TransformSingle */, newShape.id, He.BottomRight, true);\n    this.setStatus(\"creating\" /* Creating */);\n  };\n};\n\n// src/components/Tldraw/state/TldrawApp.ts\nvar uuid = C3.uniqueId();\nvar _TldrawApp = class extends StateManager {\n  callbacks = {};\n  tools = {\n    select: new SelectTool(this),\n    erase: new EraseTool(this),\n    [\"text\" /* Text */]: new TextTool(this),\n    [\"draw\" /* Draw */]: new DrawTool(this),\n    [\"ellipse\" /* Ellipse */]: new EllipseTool(this),\n    [\"rectangle\" /* Rectangle */]: new RectangleTool(this),\n    [\"triangle\" /* Triangle */]: new TriangleTool(this),\n    [\"line\" /* Line */]: new LineTool(this),\n    [\"arrow\" /* Arrow */]: new ArrowTool(this),\n    [\"sticky\" /* Sticky */]: new StickyTool(this)\n  };\n  currentTool = this.tools.select;\n  session;\n  readOnly = false;\n  isDirty = false;\n  isCreating = false;\n  originPoint = [0, 0];\n  currentPoint = [0, 0];\n  previousPoint = [0, 0];\n  shiftKey = false;\n  altKey = false;\n  metaKey = false;\n  ctrlKey = false;\n  spaceKey = false;\n  isPointing = false;\n  isForcePanning = false;\n  isErasingWithPen = false;\n  isPastePrevented = false;\n  editingStartTime = -1;\n  fileSystemHandle = null;\n  viewport = C3.getBoundsFromPoints([\n    [0, 0],\n    [100, 100]\n  ]);\n  rendererBounds = C3.getBoundsFromPoints([\n    [0, 0],\n    [100, 100]\n  ]);\n  selectHistory = {\n    stack: [[]],\n    pointer: 0\n  };\n  clipboard;\n  rotationInfo = {\n    selectedIds: [],\n    center: [0, 0]\n  };\n  constructor(id, callbacks = {}) {\n    super(_TldrawApp.defaultState, id, _TldrawApp.version, (prev, next, prevVersion) => {\n      return migrate(\n        {\n          ...next,\n          document: { ...next.document, ...prev.document, version: prevVersion }\n        },\n        _TldrawApp.version\n      );\n    });\n    this.callbacks = callbacks;\n  }\n  /* -------------------- Internal -------------------- */\n  migrate = (state) => {\n    return migrate(state, _TldrawApp.version);\n  };\n  onReady = () => {\n    this.loadDocument(this.document);\n    try {\n      this.patchState({\n        ...migrate(this.state, _TldrawApp.version),\n        appState: {\n          status: \"idle\" /* Idle */\n        }\n      });\n    } catch (error) {\n      console.error(\"The data appears to be corrupted. Resetting!\", error);\n      localStorage.setItem(this.document.id + \"_corrupted\", JSON.stringify(this.document));\n      this.patchState({\n        ..._TldrawApp.defaultState,\n        appState: {\n          ..._TldrawApp.defaultState.appState,\n          status: \"idle\" /* Idle */\n        }\n      });\n    }\n    this.callbacks.onMount?.(this);\n  };\n  /**\n   * Cleanup the state after each state change.\n   * @param state The new state\n   * @param prev The previous state\n   * @protected\n   * @returns The final state\n   */\n  cleanup = (state, prev) => {\n    const next = { ...state };\n    if (next.document !== prev.document) {\n      Object.entries(next.document.pages).forEach(([pageId, page]) => {\n        if (page === void 0) {\n          delete next.document.pages[pageId];\n          delete next.document.pageStates[pageId];\n          return;\n        }\n        const prevPage = prev.document.pages[pageId];\n        const changedShapes = {};\n        if (!prevPage || page.shapes !== prevPage.shapes || page.bindings !== prevPage.bindings) {\n          page.shapes = { ...page.shapes };\n          page.bindings = { ...page.bindings };\n          const groupsToUpdate = /* @__PURE__ */ new Set();\n          Object.entries(page.shapes).forEach(([id, shape]) => {\n            let parentId;\n            if (shape) {\n              parentId = shape.parentId;\n            } else {\n              parentId = prevPage?.shapes[id]?.parentId;\n              delete page.shapes[id];\n            }\n            if (page.id === next.appState.currentPageId && prevPage?.shapes[id] !== shape) {\n              changedShapes[id] = shape;\n            }\n            if (parentId && parentId !== pageId) {\n              const group = page.shapes[parentId];\n              if (group !== void 0) {\n                groupsToUpdate.add(page.shapes[parentId]);\n              }\n            }\n          });\n          Object.keys(page.bindings).forEach((id) => {\n            if (!page.bindings[id]) {\n              delete page.bindings[id];\n            }\n          });\n          next.document.pages[pageId] = page;\n          const bindingsToUpdate = TLDR.getRelatedBindings(next, Object.keys(changedShapes), pageId);\n          const visitedShapes = /* @__PURE__ */ new Set();\n          bindingsToUpdate.forEach((binding) => {\n            if (!page.bindings[binding.id]) {\n              return;\n            }\n            const toShape = page.shapes[binding.toId];\n            const fromShape = page.shapes[binding.fromId];\n            if (!(toShape && fromShape)) {\n              delete next.document.pages[pageId].bindings[binding.id];\n              return;\n            }\n            if (visitedShapes.has(fromShape)) {\n              return;\n            }\n            const fromDelta = TLDR.updateArrowBindings(page, fromShape);\n            visitedShapes.add(fromShape);\n            if (fromDelta) {\n              const nextShape = {\n                ...fromShape,\n                ...fromDelta\n              };\n              page.shapes[fromShape.id] = nextShape;\n            }\n          });\n          groupsToUpdate.forEach((group) => {\n            if (!group)\n              throw new Error(\"no group!\");\n            const children = group.children.filter((id) => page.shapes[id] !== void 0);\n            const commonBounds = C3.getCommonBounds(\n              children.map((id) => page.shapes[id]).filter(Boolean).map((shape) => TLDR.getRotatedBounds(shape))\n            );\n            page.shapes[group.id] = {\n              ...group,\n              point: [commonBounds.minX, commonBounds.minY],\n              size: [commonBounds.width, commonBounds.height],\n              children\n            };\n          });\n        }\n        const nextPageState = {\n          ...next.document.pageStates[pageId]\n        };\n        if (!nextPageState.brush) {\n          delete nextPageState.brush;\n        }\n        if (nextPageState.hoveredId && !page.shapes[nextPageState.hoveredId]) {\n          delete nextPageState.hoveredId;\n        }\n        if (nextPageState.bindingId && !page.bindings[nextPageState.bindingId]) {\n          TLDR.warn(`Could not find the binding of ${pageId}`);\n          delete nextPageState.bindingId;\n        }\n        if (nextPageState.editingId && !page.shapes[nextPageState.editingId]) {\n          TLDR.warn(\"Could not find the editing shape!\");\n          delete nextPageState.editingId;\n        }\n        next.document.pageStates[pageId] = nextPageState;\n      });\n    }\n    Object.keys(next.document.assets ?? {}).forEach((id) => {\n      if (!next.document.assets?.[id]) {\n        delete next.document.assets?.[id];\n      }\n    });\n    if (this.readOnly) {\n      next.document.pages = prev.document.pages;\n    }\n    return next;\n  };\n  onPatch = (state, patch, id) => {\n    this.callbacks.onPatch?.(this, patch, id);\n  };\n  onCommand = (state, command, id) => {\n    this.clearSelectHistory();\n    this.isDirty = true;\n    this.callbacks.onCommand?.(this, command, id);\n  };\n  onReplace = () => {\n    this.clearSelectHistory();\n    this.isDirty = false;\n  };\n  onUndo = () => {\n    this.rotationInfo.selectedIds = [...this.selectedIds];\n    this.callbacks.onUndo?.(this);\n  };\n  onRedo = () => {\n    this.rotationInfo.selectedIds = [...this.selectedIds];\n    this.callbacks.onRedo?.(this);\n  };\n  onPersist = (state, patch) => {\n    this.callbacks.onPersist?.(this);\n  };\n  prevSelectedIds = this.selectedIds;\n  /**\n   * Clear the selection history after each new command, undo or redo.\n   * @param state\n   * @param id\n   */\n  onStateDidChange = (_state, id) => {\n    this.callbacks.onChange?.(this, id);\n  };\n  preventPaste = () => {\n    if (this.isPastePrevented)\n      return;\n    const prevent = (event) => event.stopImmediatePropagation();\n    const enable = () => {\n      setTimeout(() => {\n        document.removeEventListener(\"paste\", prevent, { capture: true });\n        this.isPastePrevented = false;\n      }, 50);\n    };\n    document.addEventListener(\"paste\", prevent, { capture: true });\n    window.addEventListener(\"pointerup\", enable, { once: true });\n    this.isPastePrevented = true;\n  };\n  /**\n   * Set the current status.\n   * @param status The new status to set.\n   * @private\n   * @returns\n   */\n  setStatus(status) {\n    return this.patchState(\n      {\n        appState: { status }\n      },\n      `set_status:${status}`\n    );\n  }\n  /**\n   * Update the bounding box when the renderer's bounds change.\n   * @param bounds\n   */\n  updateBounds = (bounds) => {\n    this.rendererBounds = bounds;\n    const { point, zoom } = this.camera;\n    this.updateViewport(point, zoom);\n    if (!this.readOnly && this.session) {\n      this.session.update();\n    }\n  };\n  updateViewport = (point, zoom) => {\n    const { width, height } = this.rendererBounds;\n    const [minX, minY] = e.sub(e.div([0, 0], zoom), point);\n    const [maxX, maxY] = e.sub(e.div([width, height], zoom), point);\n    this.viewport = {\n      minX,\n      minY,\n      maxX,\n      maxY,\n      height: maxX - minX,\n      width: maxY - minY\n    };\n  };\n  /**\n   * Set or clear the editing id\n   * @param id [string]\n   */\n  setEditingId = (id, isCreating = false) => {\n    if (this.readOnly)\n      return;\n    if (id) {\n      this.startSession(\"edit\" /* Edit */, id, isCreating);\n    } else {\n      if (!this.pageState.editingId)\n        return;\n      this.completeSession();\n    }\n    this.editingStartTime = performance.now();\n    this.patchState(\n      {\n        document: {\n          pageStates: {\n            [this.currentPageId]: {\n              editingId: id\n            }\n          }\n        }\n      },\n      `set_editing_id`\n    );\n  };\n  /**\n   * Set or clear the hovered id\n   * @param id [string]\n   */\n  setHoveredId = (id) => {\n    this.patchState(\n      {\n        document: {\n          pageStates: {\n            [this.currentPageId]: {\n              hoveredId: id\n            }\n          }\n        }\n      },\n      `set_hovered_id`\n    );\n  };\n  /* -------------------------------------------------- */\n  /*                    Settings & UI                   */\n  /* -------------------------------------------------- */\n  /**\n   * Set a setting.\n   */\n  setSetting = (name, value) => {\n    if (this.session)\n      return this;\n    const patch = {\n      settings: {\n        [name]: typeof value === \"function\" ? value(this.settings[name]) : value\n      }\n    };\n    this.patchState(patch, `settings:${name}`);\n    this.persist(patch);\n    return this;\n  };\n  /**\n   * Toggle pen mode.\n   */\n  toggleFocusMode = () => {\n    if (this.session)\n      return this;\n    const patch = {\n      settings: {\n        isFocusMode: !this.settings.isFocusMode\n      }\n    };\n    this.patchState(patch, `settings:toggled_focus_mode`);\n    this.persist(patch);\n    return this;\n  };\n  /**\n   * Toggle pen mode.\n   */\n  togglePenMode = () => {\n    if (this.session)\n      return this;\n    const patch = {\n      settings: {\n        isPenMode: !this.settings.isPenMode\n      }\n    };\n    this.patchState(patch, `settings:toggled_pen_mode`);\n    this.persist(patch);\n    return this;\n  };\n  /**\n   * Toggle zoom snap.\n   */\n  toggleZoomSnap = () => {\n    if (this.session)\n      return this;\n    const patch = { settings: { isZoomSnap: !this.settings.isZoomSnap } };\n    this.patchState(patch, `settings:toggled_zoom_snap`);\n    this.persist(patch);\n    return this;\n  };\n  /**\n   * Toggle debug mode.\n   */\n  toggleDebugMode = () => {\n    if (this.session)\n      return this;\n    const patch = { settings: { isDebugMode: !this.settings.isDebugMode } };\n    this.patchState(patch, `settings:toggled_debug`);\n    this.persist(patch);\n    return this;\n  };\n  /**\n   * Toggles the state if menu is opened\n   */\n  setMenuOpen = (isOpen) => {\n    const patch = { appState: { isMenuOpen: isOpen } };\n    this.patchState(patch, \"ui:toggled_menu_opened\");\n    this.persist(patch);\n    return this;\n  };\n  /**\n   * Toggles the state if something is loading\n   */\n  setIsLoading = (isLoading) => {\n    const patch = { appState: { isLoading } };\n    this.patchState(patch, \"ui:toggled_is_loading\");\n    this.persist(patch);\n    return this;\n  };\n  /**\n   * Toggles the state if mouse move into/out-of the edit area\n   */\n  setMouseInBound = (mouseInBound) => {\n    const patch = { appState: { mouseInBound } };\n    this.patchState(patch, \"ui:toggled_mouse_in_bound\");\n    return this;\n  };\n  setDisableAssets = (disableAssets) => {\n    this.patchState({ appState: { disableAssets } }, \"ui:toggled_disable_images\");\n    return this;\n  };\n  get isMenuOpen() {\n    return this.appState.isMenuOpen;\n  }\n  get isMouseInBound() {\n    return this.appState.mouseInBound;\n  }\n  get isLoading() {\n    return this.appState.isLoading;\n  }\n  get disableAssets() {\n    return this.appState.disableAssets;\n  }\n  /**\n   * Toggle grids.\n   */\n  toggleGrid = () => {\n    if (this.session)\n      return this;\n    const patch = { settings: { showGrid: !this.settings.showGrid } };\n    this.patchState(patch, \"settings:toggled_grid\");\n    this.persist(patch);\n    return this;\n  };\n  /**\n   * Select a tool.\n   * @param tool The tool to select, or \"select\".\n   */\n  selectTool = (type) => {\n    if (this.readOnly || this.session)\n      return this;\n    this.isPointing = false;\n    const tool = this.tools[type];\n    if (tool === this.currentTool) {\n      this.patchState({\n        appState: {\n          isToolLocked: false\n        }\n      });\n      return this;\n    }\n    this.currentTool.onExit();\n    tool.previous = this.currentTool.type;\n    this.currentTool = tool;\n    this.currentTool.onEnter();\n    return this.patchState(\n      {\n        appState: {\n          activeTool: type,\n          isToolLocked: false\n        }\n      },\n      `selected_tool:${type}`\n    );\n  };\n  /**\n   * Toggle the tool lock option.\n   */\n  toggleToolLock = () => {\n    if (this.session)\n      return this;\n    return this.patchState(\n      {\n        appState: {\n          isToolLocked: !this.appState.isToolLocked\n        }\n      },\n      `toggled_tool_lock`\n    );\n  };\n  /* -------------------------------------------------- */\n  /*                      Document                      */\n  /* -------------------------------------------------- */\n  /**\n   * Reset the document to a blank state.\n   */\n  resetDocument = () => {\n    if (this.session)\n      return this;\n    this.session = void 0;\n    this.currentTool = this.tools.select;\n    const doc = _TldrawApp.defaultDocument;\n    doc.pages.page.name = \"Page 1\";\n    this.resetHistory().clearSelectHistory().loadDocument(_TldrawApp.defaultDocument).persist({});\n    return this;\n  };\n  /**\n   * Update the current document.\n   * @param document\n   */\n  updateDocument = (document2, reason = \"updated_document\") => {\n    const prevState = this.state;\n    const nextState = {\n      ...prevState,\n      document: {\n        ...prevState.document,\n        assets: document2.assets\n      }\n    };\n    if (!document2.pages[this.currentPageId]) {\n      nextState.appState = {\n        ...prevState.appState,\n        currentPageId: Object.keys(document2.pages)[0]\n      };\n    }\n    let i4 = 1;\n    for (const nextPage of Object.values(document2.pages)) {\n      if (nextPage !== prevState.document.pages[nextPage.id]) {\n        nextState.document.pages[nextPage.id] = nextPage;\n        if (!nextPage.name) {\n          nextState.document.pages[nextPage.id].name = `Page ${i4 + 1}`;\n          i4++;\n        }\n      }\n    }\n    for (const nextPageState of Object.values(document2.pageStates)) {\n      if (nextPageState !== prevState.document.pageStates[nextPageState.id]) {\n        nextState.document.pageStates[nextPageState.id] = nextPageState;\n        const nextPage = document2.pages[nextPageState.id];\n        const keysToCheck = [\"bindingId\", \"editingId\", \"hoveredId\", \"pointedId\"];\n        for (const key of keysToCheck) {\n          if (!nextPage.shapes[key]) {\n            nextPageState[key] = void 0;\n          }\n        }\n        nextPageState.selectedIds = nextPageState.selectedIds.filter((id) => !!document2.pages[nextPage.id].shapes[id]);\n      }\n    }\n    return this.replaceState(migrate(nextState, nextState.document.version || 0), `${reason}:${document2.id}`);\n  };\n  /**\n   * Load a new document.\n   * @param document The document to load\n   */\n  loadDocument = (document2) => {\n    this.setIsLoading(true);\n    this.selectNone();\n    this.resetHistory();\n    this.clearSelectHistory();\n    this.session = void 0;\n    const state = {\n      ..._TldrawApp.defaultState,\n      settings: {\n        ...this.state.settings\n      },\n      document: document2,\n      appState: {\n        ..._TldrawApp.defaultState.appState,\n        ...this.state.appState,\n        currentPageId: Object.keys(document2.pages)[0],\n        disableAssets: this.disableAssets\n      }\n    };\n    this.replaceState(migrate(state, _TldrawApp.version), \"loaded_document\");\n    const { point, zoom } = this.camera;\n    this.updateViewport(point, zoom);\n    this.setIsLoading(false);\n    return this;\n  };\n  /**\n   * Upload media from file\n   */\n  openAsset = async () => {\n    if (!this.disableAssets)\n      try {\n        const file = await openAssetsFromFileSystem();\n        if (Array.isArray(file)) {\n          await this.addMediaFromFiles(file, this.centerPoint);\n        } else {\n          if (!file)\n            return;\n          await this.addMediaFromFiles([file]);\n        }\n      } catch (error) {\n        console.error(error);\n      } finally {\n        await this.persist({});\n      }\n  };\n  /* -------------------- Getters --------------------- */\n  /**\n   * Get the current app state.\n   */\n  getAppState = () => {\n    return this.appState;\n  };\n  /**\n   * Get a page.\n   * @param pageId (optional) The page's id.\n   */\n  getPage = (pageId = this.currentPageId) => {\n    return TLDR.getPage(this.state, pageId || this.currentPageId);\n  };\n  /**\n   * Get the shapes (as an array) from a given page.\n   * @param pageId (optional) The page's id.\n   */\n  getShapes = (pageId = this.currentPageId) => {\n    return TLDR.getShapes(this.state, pageId || this.currentPageId);\n  };\n  /**\n   * Get the bindings from a given page.\n   * @param pageId (optional) The page's id.\n   */\n  getBindings = (pageId = this.currentPageId) => {\n    return TLDR.getBindings(this.state, pageId || this.currentPageId);\n  };\n  /**\n   * Get a shape from a given page.\n   * @param id The shape's id.\n   * @param pageId (optional) The page's id.\n   */\n  getShape = (id, pageId = this.currentPageId) => {\n    return TLDR.getShape(this.state, id, pageId);\n  };\n  /**\n   * Get the bounds of a shape on a given page.\n   * @param id The shape's id.\n   * @param pageId (optional) The page's id.\n   */\n  getShapeBounds = (id, pageId = this.currentPageId) => {\n    return TLDR.getBounds(this.getShape(id, pageId));\n  };\n  /**\n   * Get a binding from a given page.\n   * @param id The binding's id.\n   * @param pageId (optional) The page's id.\n   */\n  getBinding = (id, pageId = this.currentPageId) => {\n    return TLDR.getBinding(this.state, id, pageId);\n  };\n  /**\n   * Get the page state for a given page.\n   * @param pageId (optional) The page's id.\n   */\n  getPageState = (pageId = this.currentPageId) => {\n    return TLDR.getPageState(this.state, pageId || this.currentPageId);\n  };\n  /**\n   * Turn a screen point into a point on the page.\n   * @param point The screen point\n   * @param pageId (optional) The page to use\n   */\n  getPagePoint = (point, pageId = this.currentPageId) => {\n    const { camera } = this.getPageState(pageId);\n    return e.sub(e.div(point, camera.zoom), camera.point);\n  };\n  /**\n   * Get the current undo/redo stack.\n   */\n  get history() {\n    return this.stack.slice(0, this.pointer + 1);\n  }\n  /**\n   * Replace the current history stack.\n   */\n  set history(commands) {\n    this.replaceHistory(commands);\n  }\n  /**\n   * The current document.\n   */\n  get document() {\n    return this.state.document;\n  }\n  /**\n   * The current app state.\n   */\n  get settings() {\n    return this.state.settings;\n  }\n  /**\n   * The current app state.\n   */\n  get appState() {\n    return this.state.appState;\n  }\n  /**\n   * The current page id.\n   */\n  get currentPageId() {\n    return this.state.appState.currentPageId;\n  }\n  /**\n   * The current page.\n   */\n  get page() {\n    return this.state.document.pages[this.currentPageId];\n  }\n  /**\n   * The current page's shapes (as an array).\n   */\n  get shapes() {\n    return Object.values(this.page.shapes);\n  }\n  /**\n   * The current page's bindings.\n   */\n  get bindings() {\n    return Object.values(this.page.bindings);\n  }\n  /**\n   * The document's assets (as an array).\n   */\n  get assets() {\n    return Object.values(this.document.assets);\n  }\n  /**\n   * The current page's state.\n   */\n  get pageState() {\n    return this.state.document.pageStates[this.currentPageId];\n  }\n  get camera() {\n    return this.pageState.camera;\n  }\n  get zoom() {\n    return this.pageState.camera.zoom;\n  }\n  /**\n   * The page's current selected ids.\n   */\n  get selectedIds() {\n    return this.pageState.selectedIds;\n  }\n  /* -------------------------------------------------- */\n  /*                        Pages                       */\n  /* -------------------------------------------------- */\n  /**\n   * Create a new page.\n   * @param pageId (optional) The new page's id.\n   */\n  createPage = (id, name) => {\n    if (this.readOnly)\n      return this;\n    const { width, height } = this.rendererBounds;\n    return this.setState(createPage(this, [-width / 2, -height / 2], id, name));\n  };\n  /**\n   * Change the current page.\n   * @param pageId The new current page's id.\n   */\n  changePage = (pageId) => {\n    return this.setState(changePage(this, pageId));\n  };\n  /**\n   * Move a page above another.\n   * @param pageId The page to move.\n   * @param index The page above which to move.\n   */\n  movePage = (pageId, index2) => {\n    if (this.readOnly)\n      return this;\n    return this.setState(movePage(this, pageId, index2));\n  };\n  /**\n   * Rename a page.\n   * @param pageId The id of the page to rename.\n   * @param name The page's new name\n   */\n  renamePage = (pageId, name) => {\n    if (this.readOnly)\n      return this;\n    return this.setState(renamePage(this, pageId, name));\n  };\n  /**\n   * Duplicate a page.\n   * @param pageId The id of the page to duplicate.\n   */\n  duplicatePage = (pageId) => {\n    if (this.readOnly)\n      return this;\n    return this.setState(duplicatePage(this, pageId));\n  };\n  /**\n   * Delete a page.\n   * @param pageId The id of the page to delete.\n   */\n  deletePage = (pageId) => {\n    if (this.readOnly)\n      return this;\n    if (Object.values(this.document.pages).length <= 1)\n      return this;\n    return this.setState(deletePage(this, pageId || this.currentPageId));\n  };\n  /* -------------------------------------------------- */\n  /*                      Clipboard                     */\n  /* -------------------------------------------------- */\n  /**\n   * Cut (copy and delete) one or more shapes to the clipboard.\n   * @param ids The ids of the shapes to cut.\n   */\n  cut = (ids = this.selectedIds, event) => {\n    event?.preventDefault();\n    this.copy(ids, event);\n    if (!this.readOnly) {\n      this.delete(ids);\n    }\n    return this;\n  };\n  /**\n   * Copy one or more shapes to the clipboard.\n   * @param ids The ids of the shapes to copy.\n   */\n  copy = (ids = this.selectedIds, event) => {\n    event?.preventDefault();\n    event?.stopPropagation();\n    this.clipboard = this.getContent(ids);\n    const jsonString = JSON.stringify({\n      type: \"tldr/clipboard\",\n      ...this.clipboard\n    });\n    const tldrawString = `<tldraw>${jsonString}</tldraw>`;\n    if (event) {\n      event.clipboardData?.setData(\"text/html\", tldrawString);\n    }\n    if (navigator.clipboard && window.ClipboardItem) {\n      void navigator.clipboard.write([\n        new ClipboardItem({\n          \"text/html\": new Blob([tldrawString], { type: \"text/html\" })\n        })\n      ]);\n    }\n    return this;\n  };\n  /**\n   * Paste shapes (or text) from clipboard to a certain point.\n   * @param point\n   */\n  paste = async (point, event) => {\n    event?.preventDefault();\n    event?.stopPropagation();\n    if (this.readOnly)\n      return;\n    const filesToPaste = [];\n    const shapesToCreate = [];\n    let clipboardData;\n    const getSvgFromText = async (text) => {\n      const div = document.createElement(\"div\");\n      div.innerHTML = text;\n      const svg = div.firstChild;\n      svg.style.setProperty(\"background-color\", \"transparent\");\n      const imageBlob = await TLDR.getImageForSvg(svg, \"svg\" /* SVG */, {\n        scale: 1,\n        quality: 1\n      });\n      if (imageBlob) {\n        const file = new File([imageBlob], \"image.svg\");\n        filesToPaste.push(file);\n      } else {\n        getShapeFromText(text);\n      }\n    };\n    const getShapeFromText = (text) => {\n      const pagePoint = this.getPagePoint(point ?? this.centerPoint, this.currentPageId);\n      const isMultiline = text.includes(\"\\n\");\n      shapesToCreate.push(\n        TLDR.getShapeUtil(\"text\" /* Text */).getShape({\n          id: C3.uniqueId(),\n          type: \"text\" /* Text */,\n          parentId: this.appState.currentPageId,\n          text: TLDR.normalizeText(text.trim()),\n          point: pagePoint,\n          style: {\n            ...this.appState.currentStyle,\n            textAlign: isMultiline ? \"start\" /* Start */ : this.appState.currentStyle.textAlign\n          }\n        })\n      );\n    };\n    const getShapeFromHtml = (html) => {\n      try {\n        const maybeJson = html.match(/<tldraw>(.*)<\\/tldraw>/)?.[1];\n        if (!maybeJson)\n          return;\n        const json = JSON.parse(maybeJson);\n        if (json.type === \"tldr/clipboard\") {\n          clipboardData = json;\n          return;\n        } else {\n          throw new Error(\"Not tldraw data!\");\n        }\n      } catch {\n        getShapeFromText(html);\n      }\n    };\n    if (event !== void 0) {\n      const items = [...event.clipboardData?.items ?? []];\n      await Promise.all(\n        items.map(async (item) => {\n          const { type, kind } = item;\n          switch (kind) {\n            case \"string\": {\n              const str = await new Promise((resolve) => item.getAsString(resolve));\n              switch (type) {\n                case \"text/html\": {\n                  if (str.match(/<tldraw>(.*)<\\/tldraw>/)?.[1]) {\n                    getShapeFromHtml(str);\n                  }\n                  break;\n                }\n                case \"text/plain\": {\n                  if (str.startsWith(\"<svg\")) {\n                    await getSvgFromText(str);\n                  } else {\n                    getShapeFromText(str);\n                  }\n                  break;\n                }\n              }\n              break;\n            }\n            case \"file\": {\n              const file = item.getAsFile();\n              if (file)\n                filesToPaste.push(file);\n              break;\n            }\n          }\n        })\n      );\n    }\n    if (clipboardData) {\n      this.insertContent(clipboardData, { point, select: true });\n      return this;\n    }\n    if (filesToPaste.length > 0) {\n      this.addMediaFromFiles(filesToPaste, point);\n      return this;\n    }\n    if (shapesToCreate.length > 0) {\n      const pagePoint = this.getPagePoint(point ?? this.centerPoint, this.currentPageId);\n      const currentPoint = e.add(pagePoint, [0, 0]);\n      shapesToCreate.forEach((shape, i4) => {\n        const bounds = TLDR.getBounds(shape);\n        if (i4 === 0) {\n          currentPoint[0] -= bounds.width / 2;\n          currentPoint[1] -= bounds.height / 2;\n        }\n        shape.point = [...currentPoint];\n        currentPoint[0] += bounds.width;\n      });\n      this.createShapes(...shapesToCreate);\n      return this;\n    }\n    if (this.clipboard) {\n      this.insertContent(this.clipboard);\n    }\n    return this;\n  };\n  getSvg = async (ids = this.selectedIds.length > 0 ? this.selectedIds : Object.keys(this.page.shapes)) => {\n    if (ids.length === 0)\n      return;\n    const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    const defs = document.createElementNS(\"http://www.w3.org/2000/svg\", \"defs\");\n    const style = document.createElementNS(\"http://www.w3.org/2000/svg\", \"style\");\n    if (typeof window !== \"undefined\") {\n      window.focus();\n    }\n    defs.append(style);\n    svg.append(defs);\n    const shapes = ids.map((id) => this.getShape(id, this.currentPageId)).sort((a7, b6) => a7.childIndex - b6.childIndex);\n    const commonBounds = C3.getCommonBounds(shapes.map(TLDR.getRotatedBounds));\n    const getSvgElementForShape = (shape) => {\n      const util = TLDR.getShapeUtil(shape);\n      const bounds = util.getBounds(shape);\n      const elm = util.getSvgElement(shape);\n      if (!elm)\n        return;\n      if (shape.type === \"image\" /* Image */) {\n        elm.setAttribute(\"xlink:href\", this.document.assets[shape.assetId].src);\n      }\n      elm.setAttribute(\n        \"transform\",\n        `translate(${(SVG_EXPORT_PADDING + shape.point[0] - commonBounds.minX).toFixed(2)}, ${(SVG_EXPORT_PADDING + shape.point[1] - commonBounds.minY).toFixed(\n          2\n        )}) rotate(${((shape.rotation || 0) * 180 / Math.PI).toFixed(2)}, ${(bounds.width / 2).toFixed(2)}, ${(bounds.height / 2).toFixed(2)})`\n      );\n      return elm;\n    };\n    shapes.forEach((shape) => {\n      if (shape.children?.length) {\n        const g6 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n        shape.children.forEach((childId) => {\n          const shape2 = this.getShape(childId, this.currentPageId);\n          const elm2 = getSvgElementForShape(shape2);\n          if (elm2) {\n            g6.append(elm2);\n          }\n        });\n        svg.append(g6);\n        return;\n      }\n      const elm = getSvgElementForShape(shape);\n      if (elm) {\n        svg.append(elm);\n      }\n    });\n    svg.setAttribute(\"viewBox\", [0, 0, commonBounds.width + SVG_EXPORT_PADDING * 2, commonBounds.height + SVG_EXPORT_PADDING * 2].join(\" \"));\n    svg.setAttribute(\"width\", (commonBounds.width + SVG_EXPORT_PADDING * 2).toString());\n    svg.setAttribute(\"height\", (commonBounds.height + SVG_EXPORT_PADDING * 2).toString());\n    const exportBackground = this.settings.exportBackground;\n    const darkBackground = \"#212529\";\n    const lightBackground = \"rgb(248, 249, 250)\";\n    switch (exportBackground) {\n      case \"dark\" /* Dark */: {\n        svg.style.setProperty(\"background-color\", darkBackground);\n        break;\n      }\n      case \"auto\" /* Auto */:\n      case \"light\" /* Light */: {\n        svg.style.setProperty(\"background-color\", lightBackground);\n        break;\n      }\n      case \"transparent\" /* Transparent */:\n      default: {\n        svg.style.setProperty(\"background-color\", \"transparent\");\n        break;\n      }\n    }\n    svg.querySelectorAll(\".tl-fill-hitarea, .tl-stroke-hitarea, .tl-binding-indicator\").forEach((elm) => elm.remove());\n    return svg;\n  };\n  /**\n   * Copy one or more shapes as SVG.\n   * @param ids The ids of the shapes to copy.\n   * @returns A string containing the JSON.\n   */\n  copySvg = async (ids = this.selectedIds.length > 0 ? this.selectedIds : Object.keys(this.page.shapes)) => {\n    if (ids.length === 0)\n      return;\n    const svg = await this.getSvg(ids);\n    if (!svg)\n      return;\n    const svgString = TLDR.getSvgString(svg, 1);\n    this.clipboard = this.getContent(ids);\n    const tldrawString = JSON.stringify({\n      type: \"tldr/clipboard\",\n      ...this.clipboard\n    });\n    if (navigator.clipboard && window.ClipboardItem) {\n      navigator.clipboard.write([\n        new ClipboardItem({\n          \"text/html\": new Blob([tldrawString], { type: \"text/html\" }),\n          \"text/plain\": new Blob([svgString], { type: \"text/plain\" })\n        })\n      ]);\n    }\n    return svgString;\n  };\n  /**\n   * Get the shapes and bindings for the current selection, if any, or else the current page.\n   *\n   * @param ids The ids of the shapes to get content for.\n   */\n  getContent = (ids) => {\n    const page = this.getPage(this.currentPageId);\n    if (ids && ids.length === 0)\n      return;\n    if (!ids)\n      ids = this.selectedIds;\n    if (ids.length === 0)\n      ids = Object.keys(page.shapes);\n    if (ids.length === 0)\n      return;\n    const shapes = ids.map((id) => page.shapes[id]).flatMap((shape) => [shape, ...(shape.children ?? []).map((childId) => page.shapes[childId])]).map(deepCopy);\n    const idsSet = new Set(shapes.map((s5) => s5.id));\n    shapes.forEach((shape) => {\n      if (shape.parentId === this.currentPageId) {\n        shape.parentId = \"currentPageId\";\n      }\n    });\n    const bindings = Object.values(page.bindings).filter((binding) => {\n      if (idsSet.has(binding.fromId) || idsSet.has(binding.toId)) {\n        return true;\n      }\n      if (idsSet.has(binding.fromId)) {\n        const shape = shapes.find((s5) => s5.id === binding.fromId);\n        const handles = shape.handles;\n        if (handles) {\n          Object.values(handles).forEach((handle) => {\n            if (handle.bindingId === binding.id) {\n              handle.bindingId = void 0;\n            }\n          });\n        }\n      }\n      if (idsSet.has(binding.toId)) {\n        const shape = shapes.find((s5) => s5.id === binding.toId);\n        const handles = shape.handles;\n        if (handles) {\n          Object.values(handles).forEach((handle) => {\n            if (handle.bindingId === binding.id) {\n              handle.bindingId = void 0;\n            }\n          });\n        }\n      }\n      return false;\n    }).map(deepCopy);\n    const assets = [\n      ...new Set(\n        shapes.map((shape) => {\n          if (!shape.assetId)\n            return;\n          return this.document.assets[shape.assetId];\n        }).filter(Boolean).map(deepCopy)\n      )\n    ];\n    return { shapes, bindings, assets };\n  };\n  /**\n   * Copy one or more shapes as JSON.\n   * @param ids The ids of the shapes to copy.\n   * @returns A string containing the JSON.\n   */\n  copyJson = (ids = this.selectedIds) => {\n    const content = this.getContent(ids);\n    if (content) {\n      TLDR.copyStringToClipboard(JSON.stringify(content));\n    }\n    return this;\n  };\n  /**\n   * Export one or more shapes as JSON.\n   * @param ids The ids of the shapes to copy from the current page.\n   * @returns A string containing the JSON.\n   */\n  exportJson = (ids = this.selectedIds) => {\n    const content = this.getContent(ids);\n    if (content) {\n      const blob = new Blob([JSON.stringify(content)], { type: \"application/json\" });\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement(\"a\");\n      link.href = url;\n      link.download = `export.json`;\n      link.click();\n    }\n    return this;\n  };\n  /**\n   * Insert content.\n   *\n   * @param content The content to insert.\n   * @param content.shapes An array of TDShape objects.\n   * @param content.bindings (optional) An array of TDBinding objects.\n   * @param content.assets (optional) An array of TDAsset objects.\n   * @param opts (optional) An options object\n   * @param opts.point (optional) A point at which to paste the content.\n   * @param opts.select (optional) When true, the inserted shapes will be selected. Defaults to false.\n   * @param opts.overwrite (optional) When true, the inserted shapes and bindings will overwrite any existing shapes and bindings. Defaults to false.\n   */\n  insertContent = (content, opts = {}) => {\n    return this.setState(insertContent(this, content, opts), \"insert_content\");\n  };\n  /**\n   * Get an image of the selected shapes.\n   *\n   * @param format The format to export the image as.\n   * @param opts (optional) An object containing options for the image.\n   * @param opts.ids (optional) The ids of the shapes (on the current page) to get an image for.\n   * @param opts.scale (optional) The id of the page from which to get an image.\n   * @param opts.quality (optional) The quality (between 0 and 1) for the image if lossy format.\n   */\n  getImage = async (format = \"png\" /* PNG */, opts = {}) => {\n    const { ids = this.selectedIds.length > 0 ? this.selectedIds : Object.keys(this.page.shapes) } = opts;\n    const svg = await this.getSvg(ids);\n    if (!svg)\n      return;\n    if (format === \"svg\" /* SVG */) {\n      const svgString = TLDR.getSvgString(svg, 1);\n      const blob = new Blob([svgString], { type: \"image/svg+xml\" });\n      return blob;\n    }\n    const imageBlob = await TLDR.getImageForSvg(svg, format, opts);\n    if (!imageBlob)\n      return;\n    return imageBlob;\n  };\n  /**\n   * Copy an image of the selected shapes.\n   *\n   * @param format The format to export the image as.\n   * @param opts (optional) An object containing options for the image.\n   * @param opts.ids (optional) The ids of the shapes (on the current page) to get an image for.\n   * @param opts.scale (optional) The id of the page from which to get an image.\n   * @param opts.quality (optional) The quality (between 0 and 1) for the image if lossy format.\n   */\n  copyImage = async (format = \"png\" /* PNG */, opts = {}) => {\n    if (format === \"svg\" /* SVG */) {\n      await this.copySvg(opts.ids);\n      return;\n    }\n    if (!(navigator.clipboard && window.ClipboardItem)) {\n      console.warn(\"Sorry, your browser does not support copying images.\");\n      return;\n    }\n    const blob = await this.getImage(format, opts);\n    if (!blob)\n      return;\n    await navigator.clipboard.write([\n      new ClipboardItem({\n        [blob.type]: blob\n      })\n    ]);\n  };\n  exportImage = async (format = \"png\" /* PNG */, opts = {}) => {\n    const { pageId = this.currentPageId } = opts;\n    const blob = await this.getImage(format, opts);\n    if (!blob)\n      return;\n    const name = this.document.pages[pageId].name ?? \"export\";\n    if (this.callbacks.onExport) {\n      await this.callbacks.onExport(this, {\n        name,\n        type: format,\n        blob\n      });\n    } else {\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement(\"a\");\n      link.href = url;\n      link.download = `${name}.${format}`;\n      link.click();\n    }\n  };\n  /* -------------------------------------------------- */\n  /*                       Camera                       */\n  /* -------------------------------------------------- */\n  /**\n   * Set the camera to a specific point and zoom.\n   * @param point The camera point (top left of the viewport).\n   * @param zoom The zoom level.\n   * @param reason Why did the camera change?\n   */\n  setCamera = (point, zoom, reason) => {\n    this.updateViewport(point, zoom);\n    this.patchState(\n      {\n        document: {\n          pageStates: {\n            [this.currentPageId]: { camera: { point, zoom } }\n          }\n        }\n      },\n      reason\n    );\n    return this;\n  };\n  /**\n   * Reset the camera to the default position\n   */\n  resetCamera = () => {\n    return this.setCamera(this.centerPoint, 1, `reset_camera`);\n  };\n  /**\n   * Pan the camera\n   * @param delta\n   */\n  pan = (delta) => {\n    const { camera } = this.pageState;\n    return this.setCamera(e.toFixed(e.sub(camera.point, delta)), camera.zoom, `panned`);\n  };\n  /**\n   * Pinch to a new zoom level, possibly together with a pan.\n   * @param point The current point under the cursor.\n   * @param delta The movement delta.\n   * @param zoomDelta The zoom detal\n   */\n  pinchZoom = (point, delta, zoom) => {\n    const { camera } = this.pageState;\n    const nextPoint = e.sub(camera.point, e.div(delta, camera.zoom));\n    const nextZoom = zoom;\n    const p0 = e.sub(e.div(point, camera.zoom), nextPoint);\n    const p1 = e.sub(e.div(point, nextZoom), nextPoint);\n    return this.setCamera(e.toFixed(e.add(nextPoint, e.sub(p1, p0))), nextZoom, `pinch_zoomed`);\n  };\n  /**\n   * Zoom to a new zoom level, keeping the point under the cursor in the same position\n   * @param next The new zoom level.\n   * @param center The point to zoom towards (defaults to screen center).\n   */\n  zoomTo = (next, center = this.centerPoint) => {\n    const { zoom, point } = this.camera;\n    const p0 = e.sub(e.div(center, zoom), point);\n    const p1 = e.sub(e.div(center, next), point);\n    return this.setCamera(e.toFixed(e.add(point, e.sub(p1, p0))), next, `zoomed_camera`);\n  };\n  /**\n   * Zoom out by 25%\n   */\n  zoomIn = () => {\n    const i4 = Math.round(this.camera.zoom * 100 / 25);\n    const nextZoom = TLDR.getCameraZoom((i4 + 1) * 0.25);\n    return this.zoomTo(nextZoom);\n  };\n  /**\n   * Zoom in by 25%.\n   */\n  zoomOut = () => {\n    const i4 = Math.round(this.camera.zoom * 100 / 25);\n    const nextZoom = TLDR.getCameraZoom((i4 - 1) * 0.25);\n    return this.zoomTo(nextZoom);\n  };\n  /**\n   * Zoom to fit the page's shapes.\n   */\n  zoomToFit = () => {\n    const {\n      shapes,\n      pageState: { camera }\n    } = this;\n    if (shapes.length === 0)\n      return this;\n    const { rendererBounds } = this;\n    const commonBounds = C3.getCommonBounds(shapes.map(TLDR.getBounds));\n    let zoom = TLDR.getCameraZoom(\n      Math.min((rendererBounds.width - FIT_TO_SCREEN_PADDING) / commonBounds.width, (rendererBounds.height - FIT_TO_SCREEN_PADDING) / commonBounds.height)\n    );\n    zoom = camera.zoom === zoom || camera.zoom < 1 ? Math.min(1, zoom) : zoom;\n    const mx = (rendererBounds.width - commonBounds.width * zoom) / 2 / zoom;\n    const my = (rendererBounds.height - commonBounds.height * zoom) / 2 / zoom;\n    return this.setCamera(e.toFixed(e.sub([mx, my], [commonBounds.minX, commonBounds.minY])), zoom, `zoomed_to_fit`);\n  };\n  /**\n   * Zoom to the selected shapes.\n   */\n  zoomToSelection = () => {\n    if (this.selectedIds.length === 0)\n      return this;\n    const { rendererBounds } = this;\n    const selectedBounds = TLDR.getSelectedBounds(this.state);\n    let zoom = TLDR.getCameraZoom(\n      Math.min((rendererBounds.width - FIT_TO_SCREEN_PADDING) / selectedBounds.width, (rendererBounds.height - FIT_TO_SCREEN_PADDING) / selectedBounds.height)\n    );\n    zoom = this.camera.zoom === zoom || this.camera.zoom < 1 ? Math.min(1, zoom) : zoom;\n    const mx = (rendererBounds.width - selectedBounds.width * zoom) / 2 / zoom;\n    const my = (rendererBounds.height - selectedBounds.height * zoom) / 2 / zoom;\n    return this.setCamera(e.toFixed(e.sub([mx, my], [selectedBounds.minX, selectedBounds.minY])), zoom, `zoomed_to_selection`);\n  };\n  /**\n   * Zoom back to content when the canvas is empty.\n   */\n  zoomToContent = () => {\n    const shapes = this.shapes;\n    const pageState = this.pageState;\n    if (shapes.length === 0)\n      return this;\n    const { rendererBounds } = this;\n    const { zoom } = pageState.camera;\n    const commonBounds = C3.getCommonBounds(shapes.map(TLDR.getBounds));\n    const mx = (rendererBounds.width - commonBounds.width * zoom) / 2 / zoom;\n    const my = (rendererBounds.height - commonBounds.height * zoom) / 2 / zoom;\n    return this.setCamera(e.toFixed(e.sub([mx, my], [commonBounds.minX, commonBounds.minY])), this.camera.zoom, `zoomed_to_content`);\n  };\n  /**\n   * Zoom the camera to 100%.\n   */\n  resetZoom = () => {\n    return this.zoomTo(1);\n  };\n  /**\n   * Zoom the camera by a certain delta.\n   * @param delta The zoom delta.\n   * @param center The point to zoom toward.\n   */\n  zoomBy = C3.throttle((delta, center) => {\n    const { zoom } = this.camera;\n    const nextZoom = TLDR.getCameraZoom(zoom - delta * zoom);\n    return this.zoomTo(nextZoom, center);\n  }, 16);\n  /* -------------------------------------------------- */\n  /*                      Selection                     */\n  /* -------------------------------------------------- */\n  /**\n   * Clear the selection history (undo/redo stack for selection).\n   */\n  clearSelectHistory = () => {\n    this.selectHistory.pointer = 0;\n    this.selectHistory.stack = [this.selectedIds];\n    return this;\n  };\n  /**\n   * Adds a selection to the selection history (undo/redo stack for selection).\n   */\n  addToSelectHistory = (ids) => {\n    if (this.selectHistory.pointer < this.selectHistory.stack.length) {\n      this.selectHistory.stack = this.selectHistory.stack.slice(0, this.selectHistory.pointer + 1);\n    }\n    this.selectHistory.pointer++;\n    this.selectHistory.stack.push(ids);\n    return this;\n  };\n  /**\n   * Set the current selection.\n   * @param ids The ids to select\n   * @param push Whether to add the ids to the current selection instead.\n   */\n  setSelectedIds = (ids, push = false) => {\n    const nextIds = push ? [...this.pageState.selectedIds, ...ids] : [...ids];\n    return this.patchState(\n      {\n        appState: {\n          activeTool: \"select\"\n        },\n        document: {\n          pageStates: {\n            [this.currentPageId]: {\n              selectedIds: nextIds\n            }\n          }\n        }\n      },\n      `selected`\n    );\n  };\n  /**\n   * Undo the most recent selection.\n   */\n  undoSelect = () => {\n    if (this.selectHistory.pointer > 0) {\n      this.selectHistory.pointer--;\n      this.setSelectedIds(this.selectHistory.stack[this.selectHistory.pointer]);\n    }\n    return this;\n  };\n  /**\n   * Redo the previous selection.\n   */\n  redoSelect = () => {\n    if (this.selectHistory.pointer < this.selectHistory.stack.length - 1) {\n      this.selectHistory.pointer++;\n      this.setSelectedIds(this.selectHistory.stack[this.selectHistory.pointer]);\n    }\n    return this;\n  };\n  /**\n   * Select one or more shapes.\n   * @param ids The shape ids to select.\n   */\n  select = (...ids) => {\n    ids.forEach((id) => {\n      if (!this.page.shapes[id]) {\n        throw new Error(`That shape does not exist on page ${this.currentPageId}`);\n      }\n    });\n    this.setSelectedIds(ids);\n    this.addToSelectHistory(ids);\n    return this;\n  };\n  /**\n   * Select all shapes on the page.\n   */\n  selectAll = (pageId = this.currentPageId) => {\n    if (this.session)\n      return this;\n    this.setSelectedIds(\n      Object.values(this.document.pages[pageId].shapes).filter((shape) => shape.parentId === pageId).map((shape) => shape.id)\n    );\n    this.addToSelectHistory(this.selectedIds);\n    this.selectTool(\"select\");\n    return this;\n  };\n  /**\n   * Deselect any selected shapes.\n   */\n  selectNone = () => {\n    this.setSelectedIds([]);\n    this.addToSelectHistory(this.selectedIds);\n    return this;\n  };\n  /* -------------------------------------------------- */\n  /*                      Sessions                 p      */\n  /* -------------------------------------------------- */\n  /**\n   * Start a new session.\n   * @param type The session type\n   * @param args arguments of the session's start method.\n   */\n  startSession = (type, ...args) => {\n    if (this.readOnly && type !== \"brush\" /* Brush */)\n      return this;\n    if (this.session) {\n      TLDR.warn(`Already in a session! (${this.session.constructor.name})`);\n      this.cancelSession();\n    }\n    const Session = getSession(type);\n    this.session = new Session(this, ...args);\n    const result = this.session.start();\n    if (result) {\n      this.patchState(result, `session:start_${this.session.constructor.name}`);\n    }\n    this.callbacks.onSessionStart?.(this, this.session.constructor.name);\n    return this;\n  };\n  /**\n   * updateSession.\n   * @param args The arguments of the current session's update method.\n   */\n  updateSession = () => {\n    const { session } = this;\n    if (!session)\n      return this;\n    const patch = session.update();\n    if (!patch)\n      return this;\n    return this.patchState(patch, `session:${session?.constructor.name}`);\n  };\n  /**\n   * Cancel the current session.\n   * @param args The arguments of the current session's cancel method.\n   */\n  cancelSession = () => {\n    const { session } = this;\n    if (!session)\n      return this;\n    this.session = void 0;\n    const result = session.cancel();\n    if (result) {\n      this.patchState(result, `session:cancel:${session.constructor.name}`);\n    }\n    this.setEditingId();\n    this.callbacks.onSessionEnd?.(this, session.constructor.name);\n    return this;\n  };\n  /**\n   * Complete the current session.\n   * @param args The arguments of the current session's complete method.\n   */\n  completeSession = () => {\n    const { session } = this;\n    if (!session)\n      return this;\n    this.session = void 0;\n    const result = session.complete();\n    if (result === void 0) {\n      this.isCreating = false;\n      this.patchState(\n        {\n          appState: {\n            status: \"idle\" /* Idle */\n          },\n          document: {\n            pageStates: {\n              [this.currentPageId]: {\n                editingId: void 0,\n                bindingId: void 0,\n                hoveredId: void 0\n              }\n            }\n          }\n        },\n        `session:complete:${session.constructor.name}`\n      );\n    } else if (\"after\" in result) {\n      if (this.isCreating) {\n        result.before = {\n          appState: {\n            ...result.before.appState,\n            status: \"idle\" /* Idle */\n          },\n          document: {\n            pages: {\n              [this.currentPageId]: {\n                shapes: Object.fromEntries(this.selectedIds.map((id) => [id, void 0]))\n              }\n            },\n            pageStates: {\n              [this.currentPageId]: {\n                selectedIds: [],\n                editingId: null,\n                bindingId: null,\n                hoveredId: null\n              }\n            }\n          }\n        };\n        if (this.appState.isToolLocked) {\n          const pageState = result.after?.document?.pageStates?.[this.currentPageId] || {};\n          pageState.selectedIds = [];\n        }\n        this.isCreating = false;\n      }\n      result.after.appState = {\n        ...result.after.appState,\n        status: \"idle\" /* Idle */\n      };\n      result.after.document = {\n        ...result.after.document,\n        pageStates: {\n          ...result.after.document?.pageStates,\n          [this.currentPageId]: {\n            ...(result.after.document?.pageStates || {})[this.currentPageId],\n            editingId: null\n          }\n        }\n      };\n      this.setState(result, `session:complete:${session.constructor.name}`);\n    } else {\n      this.patchState(\n        {\n          ...result,\n          appState: {\n            ...result.appState,\n            status: \"idle\" /* Idle */\n          },\n          document: {\n            ...result.document,\n            pageStates: {\n              [this.currentPageId]: {\n                ...result.document?.pageStates?.[this.currentPageId],\n                editingId: null\n              }\n            }\n          }\n        },\n        `session:complete:${session.constructor.name}`\n      );\n    }\n    this.callbacks.onSessionEnd?.(this, session.constructor.name);\n    return this;\n  };\n  /* -------------------------------------------------- */\n  /*                   Shape Functions                  */\n  /* -------------------------------------------------- */\n  /**\n   * Manually create shapes on the page.\n   * @param shapes An array of shape partials, containing the initial props for the shapes.\n   * @command\n   */\n  createShapes = (...shapes) => {\n    if (shapes.length === 0)\n      return this;\n    return this.create(\n      shapes.map((shape) => {\n        return TLDR.getShapeUtil(shape.type).create({\n          parentId: this.currentPageId,\n          ...shape\n        });\n      })\n    );\n  };\n  /**\n   * Manually update a set of shapes.\n   * @param shapes An array of shape partials, containing the changes to be made to each shape.\n   * @command\n   */\n  updateShapes = (...shapes) => {\n    const pageShapes = this.document.pages[this.currentPageId].shapes;\n    const shapesToUpdate = shapes.filter((shape) => pageShapes[shape.id]);\n    if (shapesToUpdate.length === 0)\n      return this;\n    return this.setState(updateShapes(this, shapesToUpdate, this.currentPageId), \"updated_shapes\");\n  };\n  createTextShapeAtPoint(point, id, patch) {\n    const {\n      shapes,\n      appState: { currentPageId, currentStyle }\n    } = this;\n    const childIndex = shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === currentPageId).sort((a7, b6) => b6.childIndex - a7.childIndex)[0].childIndex + 1;\n    const Text2 = shapeUtils[\"text\" /* Text */];\n    const newShape = Text2.create({\n      id: id || C3.uniqueId(),\n      parentId: currentPageId,\n      childIndex,\n      point,\n      style: { ...currentStyle }\n    });\n    const bounds = Text2.getBounds(newShape);\n    newShape.point = e.sub(newShape.point, [bounds.width / 2, bounds.height / 2]);\n    if (patch) {\n      this.patchCreate([TLDR.getShapeUtil(newShape.type).create(newShape)]);\n    } else {\n      this.createShapes(newShape);\n    }\n    this.setEditingId(newShape.id, true);\n    return this;\n  }\n  getImageShapeAtPoint(id, type, point, size, assetId) {\n    const {\n      shapes,\n      appState: { currentPageId, currentStyle }\n    } = this;\n    const childIndex = shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === currentPageId).sort((a7, b6) => b6.childIndex - a7.childIndex)[0].childIndex + 1;\n    const Shape = shapeUtils[type];\n    if (size[0] > this.viewport.width) {\n      const r5 = size[1] / size[0];\n      size[0] = this.viewport.width - FIT_TO_SCREEN_PADDING / this.camera.zoom * 2;\n      size[1] = size[0] * r5;\n      if (size[1] < 32 || size[1] < 32) {\n        size[1] = 32;\n        size[0] = size[1] / r5;\n      }\n    } else if (size[1] > this.viewport.height) {\n      const r5 = size[0] / size[1];\n      size[1] = this.viewport.height - FIT_TO_SCREEN_PADDING / this.camera.zoom * 2;\n      size[0] = size[1] * r5;\n      if (size[1] < 32 || size[1] < 32) {\n        size[0] = 32;\n        size[1] = size[0] / r5;\n      }\n    }\n    const newShape = Shape.create({\n      id,\n      parentId: currentPageId,\n      childIndex,\n      point,\n      size,\n      style: { ...currentStyle },\n      assetId\n    });\n    return newShape;\n  }\n  /**\n   * Create one or more shapes.\n   * @param shapes An array of shapes.\n   * @command\n   */\n  create = (shapes = [], bindings = []) => {\n    if (shapes.length === 0)\n      return this;\n    return this.setState(createShapes(this, shapes, bindings));\n  };\n  /**\n   * Patch in a new set of shapes\n   * @param shapes\n   * @param bindings\n   */\n  patchCreate = (shapes = [], bindings = []) => {\n    if (shapes.length === 0)\n      return this;\n    return this.patchState(createShapes(this, shapes, bindings).after);\n  };\n  /**\n   * Delete one or more shapes.\n   * @param ids The ids of the shapes to delete.\n   * @command\n   */\n  delete = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    if (this.session)\n      return this;\n    const drawCommand = deleteShapes(this, ids);\n    if (this.callbacks.onAssetDelete && drawCommand.before.document?.assets && drawCommand.after.document?.assets) {\n      const beforeAssetIds = Object.keys(drawCommand.before.document.assets).filter((k7) => !!drawCommand.before.document.assets[k7]);\n      const afterAssetIds = new Set(Object.keys(drawCommand.after.document.assets).filter((k7) => !!drawCommand.after.document.assets[k7]));\n      const intersection = beforeAssetIds.filter((x5) => !afterAssetIds.has(x5));\n      intersection.forEach((id) => this.callbacks.onAssetDelete(this, id));\n    }\n    return this.setState(drawCommand);\n  };\n  /**\n   * Delete all shapes on the page.\n   */\n  deleteAll = () => {\n    this.selectAll();\n    this.delete();\n    return this;\n  };\n  /**\n   * Change the style for one or more shapes.\n   * @param style A style partial to apply to the shapes.\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  style = (style, ids = this.selectedIds) => {\n    return this.setState(styleShapes(this, ids, style));\n  };\n  /**\n   * Align one or more shapes.\n   * @param direction Whether to align horizontally or vertically.\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  align = (type, ids = this.selectedIds) => {\n    if (ids.length < 2)\n      return this;\n    return this.setState(alignShapes(this, ids, type));\n  };\n  /**\n   * Distribute one or more shapes.\n   * @param direction Whether to distribute horizontally or vertically..\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  distribute = (direction, ids = this.selectedIds) => {\n    if (ids.length < 3)\n      return this;\n    return this.setState(distributeShapes(this, ids, direction));\n  };\n  /**\n   * Stretch one or more shapes to their common bounds.\n   * @param direction Whether to stretch horizontally or vertically.\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  stretch = (direction, ids = this.selectedIds) => {\n    if (ids.length < 2)\n      return this;\n    return this.setState(stretchShapes(this, ids, direction));\n  };\n  /**\n   * Flip one or more shapes horizontally.\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  flipHorizontal = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    return this.setState(flipShapes(this, ids, \"horizontal\" /* Horizontal */));\n  };\n  /**\n   * Flip one or more shapes vertically.\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  flipVertical = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    return this.setState(flipShapes(this, ids, \"vertical\" /* Vertical */));\n  };\n  /**\n   * Move one or more shapes to a new page. Will also break or move bindings.\n   * @param toPageId The id of the page to move the shapes to.\n   * @param fromPageId The id of the page to move the shapes from (defaults to current page).\n   * @param ids The ids of the shapes to move (defaults to selection).\n   */\n  moveToPage = (toPageId, fromPageId = this.currentPageId, ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    const { rendererBounds } = this;\n    this.setState(moveShapesToPage(this, ids, rendererBounds, fromPageId, toPageId));\n    return this;\n  };\n  /**\n   * Move one or more shapes to the back of the page.\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  moveToBack = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    return this.setState(reorderShapes(this, ids, \"toBack\" /* ToBack */));\n  };\n  /**\n   * Move one or more shapes backward on of the page.\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  moveBackward = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    return this.setState(reorderShapes(this, ids, \"backward\" /* Backward */));\n  };\n  /**\n   * Move one or more shapes forward on the page.\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  moveForward = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    return this.setState(reorderShapes(this, ids, \"forward\" /* Forward */));\n  };\n  /**\n   * Move one or more shapes to the front of the page.\n   * @param ids The ids of the shapes to change (defaults to selection).\n   */\n  moveToFront = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    return this.setState(reorderShapes(this, ids, \"toFront\" /* ToFront */));\n  };\n  /**\n   * Nudge one or more shapes in a direction.\n   * @param delta The direction to nudge the shapes.\n   * @param isMajor Whether this is a major (i.e. shift) nudge.\n   * @param ids The ids to change (defaults to selection).\n   */\n  nudge = (delta, isMajor = false, ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    const size = isMajor ? this.settings.showGrid ? this.currentGrid * 4 : 10 : this.settings.showGrid ? this.currentGrid : 1;\n    return this.setState(translateShapes(this, ids, e.mul(delta, size)));\n  };\n  /**\n   * Duplicate one or more shapes.\n   * @param ids The ids to duplicate (defaults to selection).\n   */\n  duplicate = (ids = this.selectedIds, point) => {\n    if (this.readOnly)\n      return this;\n    if (ids.length === 0)\n      return this;\n    return this.setState(duplicateShapes(this, ids, point));\n  };\n  /**\n   * Reset the bounds for one or more shapes. Usually when the\n   * bounding box of a shape is double-clicked. Different shapes may\n   * handle this differently.\n   * @param ids The ids to change (defaults to selection).\n   */\n  resetBounds = (ids = this.selectedIds) => {\n    const command = resetBounds(this, ids, this.currentPageId);\n    return this.setState(resetBounds(this, ids, this.currentPageId), command.id);\n  };\n  /**\n   * Toggle the hidden property of one or more shapes.\n   * @param ids The ids to change (defaults to selection).\n   */\n  toggleHidden = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    return this.setState(toggleShapeProp(this, ids, \"isHidden\"));\n  };\n  /**\n   * Toggle the locked property of one or more shapes.\n   * @param ids The ids to change (defaults to selection).\n   */\n  toggleLocked = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    return this.setState(toggleShapeProp(this, ids, \"isLocked\"));\n  };\n  /**\n   * Toggle the fixed-aspect-ratio property of one or more shapes.\n   * @param ids The ids to change (defaults to selection).\n   */\n  toggleAspectRatioLocked = (ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    return this.setState(toggleShapeProp(this, ids, \"isAspectRatioLocked\"));\n  };\n  /**\n   * Toggle the decoration at a handle of one or more shapes.\n   * @param handleId The handle to toggle.\n   * @param ids The ids of the shapes to toggle the decoration on.\n   */\n  toggleDecoration = (handleId, ids = this.selectedIds) => {\n    if (ids.length === 0 || !(handleId === \"start\" || handleId === \"end\"))\n      return this;\n    return this.setState(toggleShapesDecoration(this, ids, handleId));\n  };\n  /**\n   * Set the props of one or more shapes\n   * @param props The props to set on the shapes.\n   * @param ids The ids of the shapes to set props on.\n   */\n  setShapeProps = (props, ids = this.selectedIds) => {\n    return this.setState(setShapesProps(this, ids, props));\n  };\n  /**\n   * Rotate one or more shapes by a delta.\n   * @param delta The delta in radians.\n   * @param ids The ids to rotate (defaults to selection).\n   */\n  rotate = (delta = Math.PI * -0.5, ids = this.selectedIds) => {\n    if (ids.length === 0)\n      return this;\n    const change = rotateShapes(this, ids, delta);\n    if (!change)\n      return this;\n    return this.setState(change);\n  };\n  /**\n   * Group the selected shapes.\n   * @param ids The ids to group (defaults to selection).\n   * @param groupId The new group's id.\n   */\n  group = (ids = this.selectedIds, groupId = C3.uniqueId(), pageId = this.currentPageId) => {\n    if (this.readOnly)\n      return this;\n    if (ids.length === 1 && this.getShape(ids[0], pageId).type === \"group\" /* Group */) {\n      return this.ungroup(ids, pageId);\n    }\n    if (ids.length < 2)\n      return this;\n    const command = groupShapes(this, ids, groupId, pageId);\n    if (!command)\n      return this;\n    return this.setState(command);\n  };\n  /**\n   * Ungroup the selected groups.\n   * @todo\n   */\n  ungroup = (ids = this.selectedIds, pageId = this.currentPageId) => {\n    if (this.readOnly)\n      return this;\n    const groups = ids.map((id) => this.getShape(id, pageId)).filter((shape) => shape.type === \"group\" /* Group */);\n    if (groups.length === 0)\n      return this;\n    const command = ungroupShapes(this, ids, groups, pageId);\n    if (!command) {\n      return this;\n    }\n    return this.setState(command);\n  };\n  /**\n   * Cancel the current session.\n   */\n  cancel = () => {\n    this.currentTool.onCancel?.();\n    return this;\n  };\n  addMediaFromFiles = async (files, point = this.centerPoint) => {\n    this.setIsLoading(true);\n    const shapesToCreate = [];\n    const pagePoint = this.getPagePoint(point);\n    for (const file of files) {\n      const id = C3.uniqueId();\n      const extension = file.name.match(/\\.[\\da-z]+$/i);\n      if (!extension)\n        throw new Error(\"No extension\");\n      const isImage = IMAGE_EXTENSIONS.includes(extension[0].toLowerCase());\n      if (!isImage)\n        throw new Error(\"Wrong extension\");\n      const shapeType = \"image\" /* Image */;\n      const assetType = \"image\" /* Image */;\n      let src;\n      try {\n        if (this.callbacks.onAssetCreate) {\n          const result = await this.callbacks.onAssetCreate(this, file, id);\n          if (!result)\n            throw new Error(\"Asset creation callback returned false\");\n          src = result;\n        } else {\n          src = await fileToBase64(file);\n        }\n        if (typeof src === \"string\") {\n          let size = [0, 0];\n          if (isImage) {\n            if (extension[0] == \".svg\") {\n              let viewBox;\n              const svgString = await fileToText(file);\n              const viewBoxAttribute = this.getViewboxFromSVG(svgString);\n              if (viewBoxAttribute) {\n                viewBox = viewBoxAttribute.split(\" \");\n                size[0] = Number.parseFloat(viewBox[2]);\n                size[1] = Number.parseFloat(viewBox[3]);\n              }\n            }\n            if (e.isEqual(size, [0, 0])) {\n              size = await getImageSizeFromSrc(src);\n            }\n          }\n          const match = Object.values(this.document.assets).find((asset) => asset.type === assetType && asset.src === src);\n          let assetId;\n          if (match) {\n            assetId = match.id;\n          } else {\n            assetId = id;\n            const asset = {\n              id: assetId,\n              type: assetType,\n              name: file.name,\n              src,\n              size\n            };\n            this.patchState({\n              document: {\n                assets: {\n                  [assetId]: asset\n                }\n              }\n            });\n          }\n          shapesToCreate.push(this.getImageShapeAtPoint(id, shapeType, point, size, assetId));\n        }\n      } catch (error) {\n        console.warn(error);\n      }\n    }\n    if (shapesToCreate.length > 0) {\n      const currentPoint = e.add(pagePoint, [0, 0]);\n      shapesToCreate.forEach((shape, i4) => {\n        const bounds = TLDR.getBounds(shape);\n        if (i4 === 0) {\n          currentPoint[0] -= bounds.width / 2;\n          currentPoint[1] -= bounds.height / 2;\n        }\n        shape.point = [...currentPoint];\n        currentPoint[0] += bounds.width;\n      });\n      const commonBounds = C3.getCommonBounds(shapesToCreate.map(TLDR.getBounds));\n      this.createShapes(...shapesToCreate);\n      if (!C3.boundsContain(this.viewport, commonBounds)) {\n        this.zoomToSelection();\n        if (this.zoom > 1) {\n          this.resetZoom();\n        }\n      }\n    }\n    this.setIsLoading(false);\n    return this;\n  };\n  getViewboxFromSVG = (svgStr) => {\n    const viewBoxRegex = /.*?viewBox=[\"'](-?[\\d.]+[ ,]+-?(?:[\\d.]+[ ,]){2}[\\d.]+)[\"']/;\n    if (typeof svgStr === \"string\") {\n      const matches = svgStr.match(viewBoxRegex);\n      return matches && matches.length >= 2 ? matches[1] : null;\n    }\n    this.setIsLoading(false);\n    return null;\n  };\n  /* -------------------------------------------------- */\n  /*                   Event Handlers                   */\n  /* -------------------------------------------------- */\n  /* ----------------- Keyboard Events ---------------- */\n  onKeyDown = (key, info, e5) => {\n    switch (e5.key) {\n      case \"/\": {\n        if (this.status === \"idle\" && !this.pageState.editingId) {\n          const { shiftKey, metaKey, altKey, ctrlKey, spaceKey } = this;\n          this.onPointerDown(\n            {\n              target: \"canvas\",\n              pointerId: 0,\n              origin: info.point,\n              point: info.point,\n              delta: [0, 0],\n              pressure: 0.5,\n              shiftKey,\n              ctrlKey,\n              metaKey,\n              altKey,\n              spaceKey\n            },\n            {\n              shiftKey,\n              altKey,\n              ctrlKey,\n              pointerId: 0,\n              clientX: info.point[0],\n              clientY: info.point[1]\n            }\n          );\n        }\n        break;\n      }\n      case \"Escape\": {\n        this.cancel();\n        break;\n      }\n      case \"Meta\": {\n        this.metaKey = true;\n        break;\n      }\n      case \"Alt\": {\n        this.altKey = true;\n        break;\n      }\n      case \"Control\": {\n        this.ctrlKey = true;\n        break;\n      }\n      case \" \": {\n        this.isForcePanning = true;\n        this.spaceKey = true;\n        break;\n      }\n    }\n    this.currentTool.onKeyDown?.(key, info, e5);\n    return this;\n  };\n  onKeyUp = (key, info, e5) => {\n    if (!info)\n      return;\n    switch (e5.key) {\n      case \"/\": {\n        const { currentPoint, shiftKey, metaKey, altKey, ctrlKey, spaceKey } = this;\n        this.onPointerUp(\n          {\n            target: \"canvas\",\n            pointerId: 0,\n            origin: currentPoint,\n            point: currentPoint,\n            delta: [0, 0],\n            pressure: 0.5,\n            shiftKey,\n            ctrlKey,\n            metaKey,\n            altKey,\n            spaceKey\n          },\n          {\n            shiftKey,\n            altKey,\n            ctrlKey,\n            pointerId: 0,\n            clientX: currentPoint[0],\n            clientY: currentPoint[1]\n          }\n        );\n        break;\n      }\n      case \"Meta\": {\n        this.metaKey = false;\n        break;\n      }\n      case \"Alt\": {\n        this.altKey = false;\n        break;\n      }\n      case \"Control\": {\n        this.ctrlKey = false;\n        break;\n      }\n      case \" \": {\n        this.isForcePanning = false;\n        this.spaceKey = false;\n        break;\n      }\n    }\n    this.currentTool.onKeyUp?.(key, info, e5);\n  };\n  /** Force bounding boxes to reset when the document loads. */\n  refreshBoundingBoxes = () => {\n    const force = this.shapes.map((shape) => {\n      return [\n        shape.id,\n        {\n          point: [...shape.point],\n          ...\"label\" in shape && { label: \"\" }\n        }\n      ];\n    });\n    const restore = this.shapes.map((shape) => {\n      return [\n        shape.id,\n        {\n          point: [...shape.point],\n          ...\"label\" in shape && { label: shape.label }\n        }\n      ];\n    });\n    clearPrevSize();\n    this.patchState({\n      document: {\n        pages: {\n          [this.currentPageId]: {\n            shapes: Object.fromEntries(force)\n          }\n        }\n      }\n    });\n    this.patchState({\n      document: {\n        pages: {\n          [this.currentPageId]: {\n            shapes: Object.fromEntries(restore)\n          }\n        }\n      }\n    });\n  };\n  /* ------------- Renderer Event Handlers ------------ */\n  onDragOver = (e5) => {\n    e5.preventDefault();\n  };\n  onDrop = async (e5) => {\n    e5.preventDefault();\n    if (this.disableAssets)\n      return this;\n    if (e5.dataTransfer.files?.length) {\n      this.addMediaFromFiles(Object.values(e5.dataTransfer.files), [e5.clientX, e5.clientY]);\n    }\n    return this;\n  };\n  onPinchStart = (info, e5) => {\n    this.currentTool.onPinchStart?.(info, e5);\n  };\n  onPinchEnd = (info, e5) => this.currentTool.onPinchEnd?.(info, e5);\n  onPinch = (info, e5) => this.currentTool.onPinch?.(info, e5);\n  onPan = (info, e5) => {\n    if (this.appState.status === \"pinching\")\n      return;\n    const delta = e.div(info.delta, this.camera.zoom);\n    const prev = this.camera.point;\n    const next = e.sub(prev, delta);\n    if (e.isEqual(next, prev))\n      return;\n    this.pan(delta);\n    if (!this.isForcePanning)\n      this.onPointerMove(info, e5);\n    if (isLinux && this.isForcePanning)\n      this.preventPaste();\n  };\n  onZoom = (info, e5) => {\n    if (this.state.appState.status !== \"idle\" /* Idle */)\n      return;\n    const delta = info.delta[2] / 50;\n    this.zoomBy(delta, info.point);\n    this.onPointerMove(info, e5);\n  };\n  /* ----------------- Pointer Events ----------------- */\n  updateInputs = (info) => {\n    this.currentPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.shiftKey = info.shiftKey;\n    this.altKey = info.altKey;\n    this.ctrlKey = info.ctrlKey;\n    this.metaKey = info.metaKey;\n  };\n  onPointerMove = (info, e5) => {\n    this.previousPoint = this.currentPoint;\n    this.updateInputs(info, e5);\n    if (this.isForcePanning && this.isPointing) {\n      this.onPan?.({ ...info, delta: e.neg(info.delta) }, e5);\n      return;\n    }\n    this.currentTool.onPointerMove?.(info, e5);\n  };\n  onPointerDown = (info, e5) => {\n    if (e5.buttons === 4) {\n      this.isForcePanning = true;\n    } else if (this.isPointing) {\n      return;\n    }\n    this.isPointing = true;\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    if (this.isForcePanning)\n      return;\n    if (this.currentTool.type === \"draw\" /* Draw */ && e5.pointerType === \"pen\" && e5.button === 5) {\n      this.selectTool(\"erase\");\n      this.isErasingWithPen = true;\n    }\n    this.currentTool.onPointerDown?.(info, e5);\n  };\n  onPointerUp = (info, e5) => {\n    this.isPointing = false;\n    if (!this.shiftKey)\n      this.isForcePanning = false;\n    this.updateInputs(info, e5);\n    this.currentTool.onPointerUp?.(info, e5);\n    if (this.isErasingWithPen && e5.pointerType === \"pen\" && e5.button === 5) {\n      this.selectTool(\"draw\" /* Draw */);\n      this.isErasingWithPen = false;\n    }\n  };\n  // Canvas (background)\n  onPointCanvas = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onPointCanvas?.(info, e5);\n  };\n  onDoubleClickCanvas = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onDoubleClickCanvas?.(info, e5);\n  };\n  onRightPointCanvas = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onRightPointCanvas?.(info, e5);\n  };\n  onDragCanvas = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onDragCanvas?.(info, e5);\n  };\n  onReleaseCanvas = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onReleaseCanvas?.(info, e5);\n  };\n  // Shape\n  onPointShape = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onPointShape?.(info, e5);\n  };\n  onReleaseShape = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onReleaseShape?.(info, e5);\n  };\n  onDoubleClickShape = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onDoubleClickShape?.(info, e5);\n  };\n  onRightPointShape = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onRightPointShape?.(info, e5);\n  };\n  onDragShape = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onDragShape?.(info, e5);\n  };\n  onHoverShape = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onHoverShape?.(info, e5);\n  };\n  onUnhoverShape = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onUnhoverShape?.(info, e5);\n  };\n  // Bounds (bounding box background)\n  onPointBounds = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onPointBounds?.(info, e5);\n  };\n  onDoubleClickBounds = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onDoubleClickBounds?.(info, e5);\n  };\n  onRightPointBounds = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onRightPointBounds?.(info, e5);\n  };\n  onDragBounds = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onDragBounds?.(info, e5);\n  };\n  onHoverBounds = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onHoverBounds?.(info, e5);\n  };\n  onUnhoverBounds = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onUnhoverBounds?.(info, e5);\n  };\n  onReleaseBounds = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onReleaseBounds?.(info, e5);\n  };\n  // Bounds handles (corners, edges)\n  onPointBoundsHandle = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onPointBoundsHandle?.(info, e5);\n  };\n  onDoubleClickBoundsHandle = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onDoubleClickBoundsHandle?.(info, e5);\n    if (this.selectedIds.length !== 1)\n      return;\n    const shape = this.getShape(this.selectedIds[0]);\n    if (shape.type === \"image\" /* Image */) {\n      const asset = this.document.assets[shape.assetId];\n      const util = TLDR.getShapeUtil(shape);\n      const centerA = util.getCenter(shape);\n      const centerB = util.getCenter({ ...shape, size: asset.size });\n      const delta = e.sub(centerB, centerA);\n      this.updateShapes({\n        id: shape.id,\n        point: e.sub(shape.point, delta),\n        size: asset.size\n      });\n    }\n  };\n  onRightPointBoundsHandle = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onRightPointBoundsHandle?.(info, e5);\n  };\n  onDragBoundsHandle = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onDragBoundsHandle?.(info, e5);\n  };\n  onHoverBoundsHandle = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onHoverBoundsHandle?.(info, e5);\n  };\n  onUnhoverBoundsHandle = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onUnhoverBoundsHandle?.(info, e5);\n  };\n  onReleaseBoundsHandle = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onReleaseBoundsHandle?.(info, e5);\n  };\n  // Handles (ie the handles of a selected arrow)\n  onPointHandle = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onPointHandle?.(info, e5);\n  };\n  onDoubleClickHandle = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onDoubleClickHandle?.(info, e5);\n  };\n  onRightPointHandle = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onRightPointHandle?.(info, e5);\n  };\n  onDragHandle = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onDragHandle?.(info, e5);\n  };\n  onHoverHandle = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onHoverHandle?.(info, e5);\n  };\n  onUnhoverHandle = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onUnhoverHandle?.(info, e5);\n  };\n  onReleaseHandle = (info, e5) => {\n    this.updateInputs(info, e5);\n    this.currentTool.onReleaseHandle?.(info, e5);\n  };\n  onShapeChange = (shape) => {\n    const pageShapes = this.document.pages[this.currentPageId].shapes;\n    const shapeToUpdate = { ...pageShapes[shape.id], ...shape };\n    const patch = updateShapes(this, [shapeToUpdate], this.currentPageId).after;\n    return this.patchState(patch, \"patched_shapes\");\n  };\n  onShapeBlur = () => {\n    if (performance.now() - this.editingStartTime < 50)\n      return;\n    const { editingId } = this.pageState;\n    const { isToolLocked } = this.getAppState();\n    if (editingId) {\n      const shape = this.getShape(editingId);\n      this.setEditingId();\n      if (shape.type === \"text\" /* Text */) {\n        if (shape.text.trim().length <= 0) {\n          this.patchState(deleteShapes(this, [editingId]).after, \"delete_empty_text\");\n        } else if (!isToolLocked) {\n          this.select(editingId);\n        }\n      }\n    }\n    this.currentTool.onShapeBlur?.();\n  };\n  onShapeClone = (info, e5) => {\n    this.originPoint = this.getPagePoint(info.point).concat(info.pressure);\n    this.updateInputs(info, e5);\n    this.currentTool.onShapeClone?.(info, e5);\n  };\n  onRenderCountChange = (ids) => {\n    const appState = this.getAppState();\n    if (appState.isEmptyCanvas && ids.length > 0) {\n      this.patchState(\n        {\n          appState: {\n            isEmptyCanvas: false\n          }\n        },\n        \"empty_canvas:false\"\n      );\n    } else if (!appState.isEmptyCanvas && ids.length <= 0) {\n      this.patchState(\n        {\n          appState: {\n            isEmptyCanvas: true\n          }\n        },\n        \"empty_canvas:true\"\n      );\n    }\n  };\n  onError = () => {\n  };\n  isSelected(id) {\n    return this.selectedIds.includes(id);\n  }\n  /* ----------------- Export ----------------- */\n  /**\n   * Get a snapshot of a image (e.g. a GIF) as base64 encoded image\n   * @param id ID of image shape\n   * @returns base64 encoded frame\n   * @throws Error if image shape with given ID does not exist\n   */\n  serializeImage(id) {\n    const image = document.getElementById(id + \"_image\");\n    if (image) {\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = image.width;\n      canvas.height = image.height;\n      canvas.getContext(\"2d\").drawImage(image, 0, 0);\n      return canvas.toDataURL(\"image/png\");\n    } else\n      throw new Error(\"Image with id \" + id + \" not found\");\n  }\n  patchAssets(assets) {\n    this.document.assets = {\n      ...this.document.assets,\n      ...assets\n    };\n  }\n  get status() {\n    return this.appState.status;\n  }\n  // The center of the component (in screen space)\n  get centerPoint() {\n    const { width, height } = this.rendererBounds;\n    return e.toFixed([width / 2, height / 2]);\n  }\n  get currentGrid() {\n    const { zoom } = this.camera;\n    if (zoom < 0.15) {\n      return GRID_SIZE * 16;\n    } else if (zoom < 1) {\n      return GRID_SIZE * 4;\n    } else {\n      return GRID_SIZE * 1;\n    }\n  }\n  getShapeUtil = TLDR.getShapeUtil;\n};\nvar TldrawApp = _TldrawApp;\n__publicField(TldrawApp, \"version\", 15.5);\n__publicField(TldrawApp, \"defaultDocument\", {\n  id: \"doc\",\n  name: \"New Document\",\n  version: _TldrawApp.version,\n  pages: {\n    page: {\n      id: \"page\",\n      name: \"Page 1\",\n      childIndex: 1,\n      shapes: {},\n      bindings: {}\n    }\n  },\n  pageStates: {\n    page: {\n      id: \"page\",\n      selectedIds: [],\n      camera: {\n        point: [0, 0],\n        zoom: 1\n      }\n    }\n  },\n  assets: {}\n});\n__publicField(TldrawApp, \"defaultState\", {\n  settings: {\n    isCadSelectMode: false,\n    isPenMode: false,\n    isZoomSnap: false,\n    isFocusMode: false,\n    isSnapping: false,\n    isDebugMode: false,\n    isReadonlyMode: false,\n    keepStyleMenuOpen: false,\n    nudgeDistanceLarge: 16,\n    nudgeDistanceSmall: 1,\n    showRotateHandles: true,\n    showBindingHandles: true,\n    showCloneHandles: false,\n    showGrid: false,\n    language: \"en\",\n    dockPosition: \"bottom\",\n    exportBackground: \"transparent\" /* Transparent */\n  },\n  appState: {\n    activeTool: \"select\",\n    currentPageId: \"page\",\n    currentStyle: defaultStyle,\n    disableAssets: false,\n    eraseLine: [],\n    hoveredId: void 0,\n    isEmptyCanvas: false,\n    isLoading: false,\n    isMenuOpen: false,\n    isToolLocked: false,\n    mouseInBound: false,\n    snapLines: [],\n    status: \"idle\" /* Idle */\n  },\n  document: _TldrawApp.defaultDocument\n});\n__publicField(TldrawApp, \"assetSrc\", \"tldraw-assets.json\");\n\n// src/components/Tldraw/state/tools/index.ts\nvar tools = {\n  select: SelectTool,\n  erase: EraseTool,\n  [\"text\" /* Text */]: TextTool,\n  [\"draw\" /* Draw */]: DrawTool,\n  [\"ellipse\" /* Ellipse */]: EllipseTool,\n  [\"rectangle\" /* Rectangle */]: RectangleTool,\n  [\"triangle\" /* Triangle */]: TriangleTool,\n  [\"line\" /* Line */]: LineTool,\n  [\"arrow\" /* Arrow */]: ArrowTool,\n  [\"sticky\" /* Sticky */]: StickyTool\n};\n\n// src/components/Tldraw/Tldraw.tsx\nvar import_jsx_runtime67 = require(\"react/jsx-runtime\");\nfunction Tldraw({\n  id,\n  document: document2,\n  currentPageId,\n  autofocus = true,\n  showMenu = true,\n  showPages = true,\n  showTools = true,\n  showZoom = true,\n  showStyles = true,\n  showUI = true,\n  readOnly = false,\n  disableAssets = false,\n  components,\n  onMount,\n  onChange,\n  onOpenMedia,\n  onUndo,\n  onRedo,\n  onPersist,\n  onPatch,\n  onCommand,\n  onChangePage,\n  onAssetCreate,\n  onAssetDelete,\n  onAssetUpload,\n  onSessionStart,\n  onSessionEnd,\n  onExport,\n  hideCursors,\n  onLoaded\n}) {\n  const [sId, setSId] = React49.useState(id);\n  const [app, setApp] = React49.useState(() => {\n    const app2 = new TldrawApp(id, {\n      onMount,\n      onChange,\n      onOpenMedia,\n      onUndo,\n      onRedo,\n      onPersist,\n      onPatch,\n      onCommand,\n      onChangePage,\n      onAssetDelete,\n      onAssetCreate,\n      onAssetUpload,\n      onSessionStart,\n      onSessionEnd\n    });\n    return app2;\n  });\n  const [onCancel, setOnCancel] = React49.useState(null);\n  const [onYes, setOnYes] = React49.useState(null);\n  const [onNo, setOnNo] = React49.useState(null);\n  const [dialogState, setDialogState] = React49.useState(null);\n  const openDialog = React49.useCallback((dialogState2, onYes2, onNo2, onCancel2) => {\n    setDialogState(() => dialogState2);\n    setOnCancel(() => onCancel2);\n    setOnYes(() => onYes2);\n    setOnNo(() => onNo2);\n  }, []);\n  React49.useLayoutEffect(() => {\n    if (id === sId)\n      return;\n    const newApp = new TldrawApp(id, {\n      onMount,\n      onChange,\n      onOpenMedia,\n      onUndo,\n      onRedo,\n      onPersist,\n      onPatch,\n      onCommand,\n      onChangePage,\n      onAssetDelete,\n      onAssetCreate,\n      onAssetUpload,\n      onExport,\n      onSessionStart,\n      onSessionEnd\n    });\n    setSId(id);\n    setApp(newApp);\n  }, [sId, id]);\n  React49.useEffect(() => {\n    if (document2 == void 0)\n      return;\n    if (document2.id === app.document.id) {\n      app.updateDocument(document2);\n    } else {\n      app.loadDocument(document2);\n    }\n  }, [document2, app]);\n  React49.useEffect(() => {\n    app.setDisableAssets(disableAssets);\n  }, [app, disableAssets]);\n  React49.useEffect(() => {\n    if (!currentPageId)\n      return;\n    app.changePage(currentPageId);\n  }, [currentPageId, app]);\n  React49.useEffect(() => {\n    app.readOnly = readOnly;\n    if (!readOnly) {\n      app.selectNone();\n      app.cancelSession();\n      app.setEditingId();\n    }\n  }, [app, readOnly]);\n  React49.useEffect(() => {\n    app.callbacks = {\n      onMount,\n      onChange,\n      onOpenMedia,\n      onUndo,\n      onRedo,\n      onPersist,\n      onPatch,\n      onCommand,\n      onChangePage,\n      onAssetDelete,\n      onAssetCreate,\n      onAssetUpload,\n      onExport,\n      onSessionStart,\n      onSessionEnd\n    };\n  }, [\n    onMount,\n    onChange,\n    onOpenMedia,\n    onUndo,\n    onRedo,\n    onPersist,\n    onPatch,\n    onCommand,\n    onChangePage,\n    onAssetDelete,\n    onAssetCreate,\n    onAssetUpload,\n    onExport,\n    onSessionStart,\n    onSessionEnd\n  ]);\n  React49.useLayoutEffect(() => {\n    if (typeof window === \"undefined\")\n      return;\n    if (!window.document?.fonts)\n      return;\n    function refreshBoundingBoxes() {\n      app.refreshBoundingBoxes();\n    }\n    window.document.fonts.addEventListener(\"loadingdone\", refreshBoundingBoxes);\n    return () => {\n      window.document.fonts.removeEventListener(\"loadingdone\", refreshBoundingBoxes);\n    };\n  }, [app]);\n  React49.useEffect(() => {\n    onLoaded?.(app);\n  }, [app, onLoaded]);\n  return /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(TldrawContext.Provider, { value: app, children: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(AlertDialogContext.Provider, { value: { onYes, onCancel, onNo, dialogState, setDialogState, openDialog }, children: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(\n    InnerTldraw,\n    {\n      id: sId,\n      autofocus,\n      showPages,\n      showMenu,\n      showStyles,\n      showZoom,\n      showTools,\n      showUI,\n      readOnly,\n      components,\n      hideCursors\n    },\n    sId || \"Tldraw\"\n  ) }) });\n}\nvar InnerTldraw = React49.memo(function InnerTldraw2({\n  id,\n  autofocus,\n  showPages,\n  showMenu,\n  showZoom,\n  showStyles,\n  showTools,\n  readOnly,\n  showUI,\n  components,\n  hideCursors\n}) {\n  const app = useTldrawApp();\n  const [dialogContainer, setDialogContainer] = React49.useState(null);\n  const rWrapper = React49.useRef(null);\n  const state = app.useStore();\n  const { document: document2, settings, appState } = state;\n  const isSelecting = state.appState.activeTool === \"select\";\n  const page = document2.pages[appState.currentPageId];\n  const pageState = document2.pageStates[page.id];\n  const assets = document2.assets;\n  const { selectedIds } = pageState;\n  const isHideBoundsShape = selectedIds.length === 1 && page.shapes[selectedIds[0]] && TLDR.getShapeUtil(page.shapes[selectedIds[0]].type).hideBounds;\n  const isHideResizeHandlesShape = selectedIds.length === 1 && page.shapes[selectedIds[0]] && TLDR.getShapeUtil(page.shapes[selectedIds[0]].type).hideResizeHandles;\n  const showDashedBrush = settings.isCadSelectMode ? !appState.selectByContain : appState.selectByContain;\n  const theme = React49.useMemo(() => {\n    const { selectByContain } = appState;\n    const { isCadSelectMode } = settings;\n    const brushBase = isCadSelectMode ? selectByContain ? \"0, 89, 242\" : \"51, 163, 23\" : \"0,0,0\";\n    return {\n      brushFill: `rgba(${brushBase}, ${isCadSelectMode ? 0.08 : 0.05})`,\n      brushStroke: `rgba(${brushBase}, ${isCadSelectMode ? 0.4 : 0.25})`,\n      brushDashStroke: `rgba(${brushBase}, .6)`\n    };\n  }, [settings.isCadSelectMode, appState.selectByContain]);\n  const isInSession = app.session !== void 0;\n  const hideBounds = isInSession && app.session?.constructor.name !== \"BrushSession\" || !isSelecting || isHideBoundsShape || !!pageState.editingId;\n  const hideHandles = isInSession || !isSelecting;\n  const hideIndicators = isInSession && state.appState.status !== \"brushing\" /* Brushing */ || !isSelecting;\n  const hideCloneHandles = isInSession || !isSelecting || pageState.camera.zoom < 0.2;\n  useCursor(rWrapper);\n  const onMouseEnter = React49.useCallback(() => {\n    app.setMouseInBound(true);\n  }, [app]);\n  const onMouseLeave = React49.useCallback(() => {\n    app.setMouseInBound(false);\n  }, [app]);\n  return /* @__PURE__ */ (0, import_jsx_runtime67.jsxs)(ContainerContext.Provider, { value: rWrapper, children: [\n    /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(AlertDialog, { container: dialogContainer }),\n    /* @__PURE__ */ (0, import_jsx_runtime67.jsxs)(StyledLayout, { ref: rWrapper, tabIndex: -1, onMouseEnter, onMouseLeave, children: [\n      /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(Loading, {}),\n      /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(OneOff, { focusableRef: rWrapper, autofocus }),\n      /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(ContextMenu, { children: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(\n        ks,\n        {\n          id,\n          containerRef: rWrapper,\n          shapeUtils,\n          page,\n          pageState,\n          assets,\n          snapLines: appState.snapLines,\n          eraseLine: appState.eraseLine,\n          grid: GRID_SIZE,\n          theme,\n          components,\n          hideCursors,\n          hideBounds,\n          hideHandles,\n          hideResizeHandles: isHideResizeHandlesShape,\n          hideIndicators,\n          hideBindingHandles: !settings.showBindingHandles,\n          hideCloneHandles,\n          hideRotateHandles: !settings.showRotateHandles,\n          hideGrid: !settings.showGrid,\n          showDashedBrush,\n          performanceMode: app.session?.performanceMode,\n          onPinchStart: app.onPinchStart,\n          onPinchEnd: app.onPinchEnd,\n          onPinch: app.onPinch,\n          onPan: app.onPan,\n          onZoom: app.onZoom,\n          onPointerDown: app.onPointerDown,\n          onPointerMove: app.onPointerMove,\n          onPointerUp: app.onPointerUp,\n          onPointCanvas: app.onPointCanvas,\n          onDoubleClickCanvas: app.onDoubleClickCanvas,\n          onRightPointCanvas: app.onRightPointCanvas,\n          onDragCanvas: app.onDragCanvas,\n          onReleaseCanvas: app.onReleaseCanvas,\n          onPointShape: app.onPointShape,\n          onDoubleClickShape: app.onDoubleClickShape,\n          onRightPointShape: app.onRightPointShape,\n          onDragShape: app.onDragShape,\n          onHoverShape: app.onHoverShape,\n          onUnhoverShape: app.onUnhoverShape,\n          onReleaseShape: app.onReleaseShape,\n          onPointBounds: app.onPointBounds,\n          onDoubleClickBounds: app.onDoubleClickBounds,\n          onRightPointBounds: app.onRightPointBounds,\n          onDragBounds: app.onDragBounds,\n          onHoverBounds: app.onHoverBounds,\n          onUnhoverBounds: app.onUnhoverBounds,\n          onReleaseBounds: app.onReleaseBounds,\n          onPointBoundsHandle: app.onPointBoundsHandle,\n          onDoubleClickBoundsHandle: app.onDoubleClickBoundsHandle,\n          onRightPointBoundsHandle: app.onRightPointBoundsHandle,\n          onDragBoundsHandle: app.onDragBoundsHandle,\n          onHoverBoundsHandle: app.onHoverBoundsHandle,\n          onUnhoverBoundsHandle: app.onUnhoverBoundsHandle,\n          onReleaseBoundsHandle: app.onReleaseBoundsHandle,\n          onPointHandle: app.onPointHandle,\n          onDoubleClickHandle: app.onDoubleClickHandle,\n          onRightPointHandle: app.onRightPointHandle,\n          onDragHandle: app.onDragHandle,\n          onHoverHandle: app.onHoverHandle,\n          onUnhoverHandle: app.onUnhoverHandle,\n          onReleaseHandle: app.onReleaseHandle,\n          onError: app.onError,\n          onRenderCountChange: app.onRenderCountChange,\n          onShapeChange: app.onShapeChange,\n          onShapeBlur: app.onShapeBlur,\n          onShapeClone: app.onShapeClone,\n          onBoundsChange: app.updateBounds,\n          onKeyDown: app.onKeyDown,\n          onKeyUp: app.onKeyUp,\n          onDragOver: app.onDragOver,\n          onDrop: app.onDrop\n        }\n      ) }),\n      showUI && /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(StyledUI, { ref: setDialogContainer, children: settings.isFocusMode ? /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(FocusButton, { onSelect: app.toggleFocusMode }) : /* @__PURE__ */ (0, import_jsx_runtime67.jsxs)(import_jsx_runtime67.Fragment, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(TopPanel, { readOnly, showPages, showMenu, showStyles, showZoom }),\n        /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(StyledSpacer2, {}),\n        showTools && !readOnly && /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(ToolsPanel, {})\n      ] }) })\n    ] })\n  ] });\n});\nvar OneOff = React49.memo(function OneOff2({ focusableRef, autofocus }) {\n  useKeyboardShortcuts(focusableRef);\n  React49.useEffect(() => {\n    if (autofocus) {\n      focusableRef.current?.focus();\n    }\n  }, [autofocus]);\n  return null;\n});\nvar StyledLayout = styled(\"div\", {\n  position: \"absolute\",\n  height: \"100%\",\n  width: \"100%\",\n  minHeight: 0,\n  minWidth: 0,\n  maxHeight: \"100%\",\n  maxWidth: \"100%\",\n  overflow: \"hidden\",\n  boxSizing: \"border-box\",\n  outline: \"none\",\n  \"& .tl-container\": {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    height: \"100%\",\n    width: \"100%\",\n    zIndex: 1\n  },\n  \"& input, textarea, button, select, label, button\": {\n    webkitTouchCallout: \"none\",\n    webkitUserSelect: \"none\",\n    \"-webkit-tap-highlight-color\": \"transparent\",\n    \"tap-highlight-color\": \"transparent\"\n  }\n});\nvar StyledUI = styled(\"div\", {\n  position: \"absolute\",\n  top: 0,\n  left: 0,\n  height: \"100%\",\n  width: \"100%\",\n  padding: \"8px 8px 0 8px\",\n  display: \"flex\",\n  alignItems: \"flex-start\",\n  justifyContent: \"flex-start\",\n  pointerEvents: \"none\",\n  zIndex: 2,\n  \"& > *\": {\n    pointerEvents: \"all\"\n  }\n});\nvar StyledSpacer2 = styled(\"div\", {\n  flexGrow: 2\n});\n\n// src/components/App.tsx\nvar import_jsx_runtime68 = require(\"react/jsx-runtime\");\nvar debounceSaveTime = 500;\nfunction App(props) {\n  const {\n    height,\n    width,\n    currentTiddler,\n    initialTiddlerText,\n    isDraft,\n    readonly,\n    zoomToFit,\n    zoom,\n    saver: { onSave, lock },\n    parentWidget\n  } = props;\n  const updatedCountReference = (0, import_react42.useRef)(0);\n  const getTiddlerJSONContent = (0, import_react42.useCallback)(() => {\n    if (initialTiddlerText) {\n      try {\n        const data = JSON.parse(initialTiddlerText);\n        updatedCountReference.current = data.updatedCount ?? 0;\n        return data.document;\n      } catch (error) {\n        console.error(`$:/plugins/linonetwo/tw-whiteboard load tiddler ${currentTiddler} failed, text:\n${initialTiddlerText}\n${error.message}`);\n      }\n    }\n  }, [initialTiddlerText, currentTiddler]);\n  const initialTiddlerJSONContent = (0, import_react42.useMemo)(getTiddlerJSONContent, []);\n  (0, import_react42.useEffect)(() => {\n    const latestUpdatedDocument = getTiddlerJSONContent();\n    if (latestUpdatedDocument !== void 0) {\n      tldrawDocumentSetter(latestUpdatedDocument);\n    }\n  }, [getTiddlerJSONContent]);\n  const [tldrawDocument, tldrawDocumentSetterRaw] = (0, import_react42.useState)(initialTiddlerJSONContent);\n  const tldrawDocumentReference = (0, import_react42.useRef)(tldrawDocument);\n  const tldrawDocumentSetter = (newDocument) => {\n    tldrawDocumentSetterRaw(newDocument);\n    tldrawDocumentReference.current = newDocument;\n  };\n  const deferSave = (0, import_react42.useCallback)(\n    (app) => {\n      const saveCallback = () => {\n        const exportedTldrJSON = { document: app.document, updatedCount: ++updatedCountReference.current };\n        const newTiddlerText = JSON.stringify(exportedTldrJSON);\n        lock();\n        onSave(newTiddlerText);\n      };\n      if (typeof requestIdleCallback !== \"undefined\") {\n        requestIdleCallback(saveCallback, { timeout: 60 });\n      } else if (typeof requestAnimationFrame === \"undefined\") {\n        setTimeout(saveCallback, 16.66);\n      } else {\n        requestAnimationFrame(saveCallback);\n      }\n    },\n    [onSave, lock]\n  );\n  const debouncedSaveOnChange = useDebouncedCallback_default(\n    (app) => {\n      deferSave(app);\n    },\n    [deferSave],\n    debounceSaveTime\n  );\n  const onChange = (app) => {\n    app.document.name = currentTiddler;\n    tldrawDocumentSetter(app.document);\n    if (!isDraft && !readonly) {\n      debouncedSaveOnChange(app);\n    }\n  };\n  (0, import_react42.useEffect)(() => {\n    return () => {\n      if (readonly)\n        return;\n      const exportedTldrJSON = { document: tldrawDocumentReference.current, updatedCount: ++updatedCountReference.current };\n      onSave(JSON.stringify(exportedTldrJSON));\n    };\n  }, []);\n  const onMount = (0, import_react42.useCallback)((app) => {\n    if (typeof zoom === \"string\") {\n      app.zoomTo(Number(zoom));\n    } else if (zoomToFit === true) {\n      app.zoomToFit();\n    }\n  }, [zoom, zoomToFit]);\n  return /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(import_tw_react2.ParentWidgetContext.Provider, { value: parentWidget, children: /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(\"div\", { className: \"tw-whiteboard-tldraw-container\", style: { height, width }, children: /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(Tldraw, { onPersist: onChange, onLoaded: onMount, document: tldrawDocument, autofocus: false, readOnly: readonly }) }) });\n}\n\n// src/widget.ts\nvar Widget = require(\"$:/plugins/linonetwo/tw-react/widget.js\").widget;\nvar SAVE_DEBOUNCE_INTERVAL = 1e3;\nvar TldrawWhiteBoardWidget = class extends Widget {\n  reactComponent = App;\n  getProps = () => {\n    return {\n      currentTiddler: this.editTitle ?? this.getVariable(\"currentTiddler\"),\n      initialTiddlerText: this.editTitle === void 0 ? \"\" : $tw.wiki.getTiddlerText(this.editTitle),\n      height: this.getAttribute(\"height\"),\n      width: this.getAttribute(\"width\"),\n      readonly: this.getAttribute(\"readonly\") === \"yes\" || this.getAttribute(\"readonly\") === \"true\",\n      zoomToFit: this.getAttribute(\"zoomToFit\") === \"yes\" || this.getAttribute(\"zoomToFit\") === \"true\",\n      zoom: this.getAttribute(\"zoom\"),\n      isDraft: this.editTitle === void 0 ? false : Boolean(this.getAttribute(\"draftTitle\")),\n      saver: {\n        lock: this.lock,\n        onSave: this.onSave,\n        interval: SAVE_DEBOUNCE_INTERVAL\n      }\n    };\n  };\n  refresh(changedTiddlers) {\n    if (this.editTitle === void 0)\n      return false;\n    if (changedTiddlers[this.editTitle]?.deleted === true) {\n      this.lock();\n      return false;\n    }\n    if (this.isUpdatingByUserInput) {\n      return false;\n    }\n    const changedAttributes = this.computeAttributes();\n    if ($tw.utils.count(changedAttributes) > 0 || changedTiddlers[this.editTitle]?.modified === true) {\n      this.refreshSelf();\n      return true;\n    }\n    return false;\n  }\n  editorOperations = {};\n  editTitle;\n  execute() {\n    this.editTitle = this.getAttribute(\"tiddler\");\n    this.makeChildWidgets();\n  }\n  onSave = (newText) => {\n    if (this.editTitle === \"\" || this.editTitle === void 0) {\n      return;\n    }\n    const previousText = $tw.wiki.getTiddlerText(this.editTitle, \"{}\") || \"{}\";\n    if (previousText !== newText) {\n      let isSavingNewVersion = false;\n      try {\n        const newTextVersion = JSON.parse(newText).updatedCount ?? 0;\n        const previousTextVersion = JSON.parse(previousText).updatedCount ?? 0;\n        if (newTextVersion > previousTextVersion) {\n          isSavingNewVersion = true;\n        }\n      } catch (error) {\n        console.error(error);\n      }\n      if (isSavingNewVersion) {\n        $tw.wiki.setText(this.editTitle, void 0, void 0, newText);\n        $tw.wiki.setText(this.editTitle, \"type\", void 0, \"application/tldr\");\n      }\n    }\n    window.requestIdleCallback(\n      () => {\n        this.parentWidget?.dispatchEvent({\n          type: \"tm-save-tiddler\",\n          // param: param,\n          paramObject: { suppressNavigation: \"yes\" },\n          // event: parameters.event,\n          tiddlerTitle: this.editTitle\n        });\n        this.parentWidget?.dispatchEvent({ type: \"tm-auto-save-wiki\" });\n      },\n      { timeout: 2e3 }\n    );\n    this.unlock();\n  };\n  /** a lock to prevent update from tiddler to slate, when update of tiddler is trigger by slate. */\n  isUpdatingByUserInput = false;\n  updatingLockTimeoutHandle;\n  get editIconElement() {\n    const element = this.parentDomNode.closest(\".tc-tiddler-exists\")?.querySelector(\".tc-image-wysiwyg-edit-button\");\n    return element;\n  }\n  lock = () => {\n    this.isUpdatingByUserInput = true;\n    if (this.updatingLockTimeoutHandle !== void 0) {\n      clearTimeout(this.updatingLockTimeoutHandle);\n    }\n  };\n  unlock = () => {\n    this.updatingLockTimeoutHandle = setTimeout(() => {\n      this.isUpdatingByUserInput = false;\n    }, SAVE_DEBOUNCE_INTERVAL);\n  };\n};\nexports.whiteboard = TldrawWhiteBoardWidget;\n/*! Bundled license information:\n\nuse-sync-external-store/cjs/use-sync-external-store-shim.development.js:\n  (**\n   * @license React\n   * use-sync-external-store-shim.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n\nuse-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:\n  (**\n   * @license React\n   * use-sync-external-store-shim/with-selector.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n\n@tldraw/core/dist/index.mjs:\n  (**\n   * String.prototype.replaceAll() polyfill\n   * https://gomakethings.com/how-to-replace-a-section-of-a-string-with-another-one-with-vanilla-js/\n   * @author Chris Ferdinandi\n   * @license MIT\n   *)\n*/\n","type":"application/javascript","module-type":"library","hide-body":"yes"}}}